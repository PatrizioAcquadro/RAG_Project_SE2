[
  "def is_running_virtual_env():\n    return sys.prefix != sys.base_prefix",
  "class BasiliskConan(ConanFile):\n    name = \"Basilisk\"\n    homepage = \"http://hanspeterschaub.info/basilisk\"\n    f = open('docs/source/bskVersion.txt', 'r')\n    version = f.read()\n    f.close()\n    generators = \"cmake_find_package_multi\"\n    requires = \"eigen/3.3.9\"\n    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n    build_policy = \"missing\"\n    license = \"ISC\"\n\n    options = {\"generator\": \"ANY\"}\n    default_options = {\"generator\": \"\"}\n\n    # ensure latest pip is installed\n    if is_running_virtual_env() or platform.system() == \"Windows\":\n        cmakeCmdString = 'python -m pip install --upgrade pip'\n    else:\n        cmakeCmdString = 'python3 -m pip install --upgrade pip'\n    print(statusColor + \"Updating pip:\" + endColor)\n    print(cmakeCmdString)\n    os.system(cmakeCmdString)\n\n    for opt, value in bskModuleOptionsBool.items():\n        options.update({opt: [True, False]})\n        default_options.update({opt: value})\n    for opt, value in bskModuleOptionsString.items():\n        options.update({opt: \"ANY\"})\n        default_options.update({opt: value})\n    for opt, value in bskModuleOptionsFlag.items():\n        options.update({opt: [True, False]})\n        default_options.update({opt: value})\n\n    # set cmake generator default\n    generator = None\n\n    # make sure conan is configured to use the libstdc++11 by default\n    if platform.system() != \"Darwin\":\n        try:\n            subprocess.check_output([\"conan\", \"profile\", \"new\", \"default\", \"--detect\"], stdout=subprocess.DEVNULL)\n        except:\n            pass\n\n        if platform.system() == \"Linux\":\n            try:\n                subprocess.check_output([\"conan\", \"profile\", \"update\",\n                                         \"settings.compiler.libcxx=libstdc++11\", \"default\"])\n                print(\"\\nConfiguring: \" + statusColor + \"use libstdc++11 by default\" + endColor)\n\n            except:\n                pass\n\n    print(statusColor + \"Checking conan configuration:\" + endColor + \" Done\")\n\n    try:\n        # enable this flag for access revised conan modules.\n        subprocess.check_output([\"conan\", \"config\", \"set\", \"general.revisions_enabled=1\"])\n    except:\n        pass\n\n    def system_requirements(self):\n        reqFile = open('docs/source/bskPkgRequired.txt', 'r')\n        required = reqFile.read().replace(\"`\", \"\").split('\\n')\n        reqFile.close()\n        pkgList = [x.lower() for x in required]\n\n        checkStr = \"Required\"\n        if self.options.allOptPkg:\n            optFile = open('docs/source/bskPkgOptions.txt', 'r')\n            optionalPkgs = optFile.read().replace(\"`\", \"\").split('\\n')\n            optFile.close()\n            optionalPkgs = [x.lower() for x in optionalPkgs]\n            pkgList += optionalPkgs\n            checkStr += \" and All Optional\"\n\n        print(\"\\nChecking \" + checkStr + \" Python packages:\")\n        for elem in pkgList:\n            try:\n                pkg_resources.require(elem)\n                print(\"Found: \" + statusColor + elem + endColor)\n            except (pkg_resources.DistributionNotFound, pkg_resources.VersionConflict):\n                installCmd = [sys.executable, \"-m\", \"pip\", \"install\"]\n\n                if not is_running_virtual_env():\n                    if self.options.autoKey:\n                        choice = self.options.autoKey\n                    else:\n                        choice = input(warningColor + \"Required python package \" + elem + \" is missing\" + endColor +\n                                       \"\\nInstall for user (u), system (s) or cancel(c)? \")\n                    if choice == 'c':\n                        print(warningColor + \"Skipping installing \" + elem + endColor)\n                        continue\n                    elif choice == 'u':\n                        installCmd.append(\"--user\")\n                installCmd.append(elem)\n                try:\n                    subprocess.check_call(installCmd)\n                except subprocess.CalledProcessError:\n                    print(failColor + \"Was not able to install \" + elem + endColor)\n\n        # check the version of Python\n        print(\"\\nChecking Python version:\")\n        if not (sys.version_info.major == 3 and sys.version_info.minor >= 7):\n            print(warningColor + \"Python 3.7 or newer should be used with Basilisk.\" + endColor)\n            print(\"You are using Python {}.{}.{}\".format(sys.version_info.major,\n                                                         sys.version_info.minor, sys.version_info.micro))\n        else:\n            print(statusColor + \"Python {}.{}.{}\".format(sys.version_info.major,\n                                                         sys.version_info.minor, sys.version_info.micro)\n                  + \" is acceptable for Basilisk\" + endColor)\n\n        print(\"\\n\")\n\n    def requirements(self):\n        if self.options.opNav:\n            self.requires.add(\"pcre/8.45\")\n            self.requires.add(\"opencv/4.1.2#b610ad323f67adc1b51e402cb5d68d70\")\n            self.options['opencv'].with_ffmpeg = False  # video frame encoding lib\n            self.options['opencv'].with_ade = False  # graph manipulations framework\n            self.options['opencv'].with_tiff = False  # generate image in TIFF format\n            self.options['opencv'].with_openexr = False  # generate image in EXR format\n            self.options['opencv'].with_quirc = False  # QR code lib\n            self.requires.add(\"zlib/1.2.13\")\n            self.requires.add(\"xz_utils/5.4.0\")\n\n        if self.options.vizInterface or self.options.opNav:\n            self.requires.add(\"protobuf/3.17.1\")\n            self.options['zeromq'].encryption = False  # Basilisk does not use data streaming encryption.\n            self.requires.add(\"cppzmq/4.5.0\")\n\n    def configure(self):\n        if self.options.clean:\n            # clean the distribution folder to start fresh\n            self.options.clean = False\n            root = os.path.abspath(os.path.curdir)\n            distPath = os.path.join(root, \"dist3\")\n            if os.path.exists(distPath):\n                shutil.rmtree(distPath, ignore_errors=True)\n        if self.settings.build_type == \"Debug\":\n            print(warningColor + \"Build type is set to Debug. Performance will be significantly lower.\" + endColor)\n\n        # Install additional opencv methods\n        if self.options.opNav:\n            self.options['opencv'].contrib = True\n            # Raise an issue to conan-center to fix this bug. Using workaround to disable freetype for windows\n            # Issue link: https://github.com/conan-community/community/issues/341\n            #TODO Remove this once they fix this issue.\n            if self.settings.os == \"Windows\":\n                self.options['opencv'].freetype = False\n\n        if self.options.generator == \"\":\n            # Select default generator supplied to cmake based on os\n            if self.settings.os == \"Macos\":\n                self.generator = \"Xcode\"\n            elif self.settings.os == \"Windows\":\n                self.generator = \"Visual Studio 16 2019\"\n                self.options[\"*\"].shared = True\n            else:\n                print(\"Creating a make file for project. \")\n                print(\"Specify your own using the -o generator='Name' flag during conan install\")\n        else:\n            self.generator = str(self.options.generator)\n            if self.settings.os == \"Windows\":\n                self.options[\"*\"].shared = True\n        print(\"cmake generator set to: \" + statusColor + str(self.generator) + endColor)\n    \n    def package_id(self):\n        if self.settings.compiler == \"Visual Studio\":\n            if \"MD\" in self.settings.compiler.runtime:\n                self.info.settings.compiler.runtime = \"MD/MDd\"\n            else:\n                self.info.settings.compiler.runtime = \"MT/MTd\"\n\n    def imports(self):\n        if self.settings.os == \"Windows\":\n            self.keep_imports = True\n            self.copy(\"*.dll\", \"../Basilisk\", \"bin\")\n\n    def generateMessageModules(self, originalWorkingDirectory):\n        cmdString = [sys.executable, \"GenCMessages.py\"]\n        if self.options.pathToExternalModules:\n            cmdString.extend([\"--pathToExternalModules\", str(self.options.pathToExternalModules)])\n        subprocess.check_call(cmdString)\n        os.chdir(originalWorkingDirectory)\n        print(\"Done\")\n\n    def build(self):\n        # auto-generate C message definition files\n        print(statusColor + \"Auto-generating message definitions:\" + endColor, end=\" \")\n        bskPath = os.getcwd()\n        os.chdir(os.path.join(bskPath, \"src/architecture/messaging/msgAutoSource\"))\n        self.generateMessageModules(bskPath)\n\n        if self.options.pathToExternalModules:\n            print(statusColor + \"Including External Folder: \" + endColor + str(self.options.pathToExternalModules))\n\n        root = os.path.abspath(os.path.curdir)\n\n        self.folders.source = os.path.join(root, \"src\")\n        self.folders.build = os.path.join(root, \"dist3\")\n\n        cmake = CMake(self, set_cmake_flags=True, generator=self.generator)\n        if self.settings.compiler == \"Visual Studio\":\n            cmake.definitions[\"CONAN_LINK_RUNTIME_MULTI\"] = cmake.definitions[\"CONAN_LINK_RUNTIME\"]\n            cmake.definitions[\"CONAN_LINK_RUNTIME\"] = False\n        cmake.definitions[\"BUILD_OPNAV\"] = self.options.opNav\n        cmake.definitions[\"BUILD_VIZINTERFACE\"] = self.options.vizInterface\n        cmake.definitions[\"EXTERNAL_MODULES_PATH\"] = self.options.pathToExternalModules\n        cmake.definitions[\"PYTHON_VERSION\"] = sys.version_info.major + 0.1*sys.version_info.minor\n        cmake.parallel = True\n        print(statusColor + \"Configuring cmake...\" + endColor)\n        cmake.configure()\n        self.add_basilisk_to_sys_path()\n        if self.options.buildProject:\n            print(statusColor + \"\\nCompiling Basilisk...\" + endColor)\n            start = datetime.now()\n            if self.generator == \"Xcode\":\n                # Xcode multi-threaded needs specialized arguments\n                cmake.build(['--', '-jobs', str(tools.cpu_count()), '-parallelizeTargets'])\n            else:\n                cmake.build()\n            print(\"Total Build Time: \" + str(datetime.now() - start))\n            print(f\"{statusColor}The Basilisk build is successful and the scripts are ready to run{endColor}\")\n        else:\n            print(f\"{statusColor}Finished configuring the Basilisk project.{endColor}\")\n            if self.settings.os != \"Linux\":\n                print(f\"{statusColor}Please open project file inside dist3 with {self.generator} IDE \"\n                      f\"and build the project for {self.settings.build_type}{endColor}\")\n            else:\n                print(f\"{statusColor}Please go to dist3 folder and run command \"\n                      f\"`make -j <number of threads to use>`{endColor}\")\n        return\n\n    def add_basilisk_to_sys_path(self):\n        print(\"Adding Basilisk module to python\\n\")\n        add_basilisk_module_command = [sys.executable, \"-m\", \"pip\", \"install\", \"-e\", \".\"]\n        if not is_running_virtual_env() and self.options.autoKey != 's':\n            add_basilisk_module_command.append(\"--user\")\n\n        process = subprocess.Popen(add_basilisk_module_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        output, err = process.communicate()\n        if err:\n            print(\"Error %s while running %s\" % (err.decode(), add_basilisk_module_command))\n            sys.exit(1)\n        else:\n            print(\"This resulted in the output: \\n%s\" % output.decode())",
  "def system_requirements(self):\n        reqFile = open('docs/source/bskPkgRequired.txt', 'r')\n        required = reqFile.read().replace(\"`\", \"\").split('\\n')\n        reqFile.close()\n        pkgList = [x.lower() for x in required]\n\n        checkStr = \"Required\"\n        if self.options.allOptPkg:\n            optFile = open('docs/source/bskPkgOptions.txt', 'r')\n            optionalPkgs = optFile.read().replace(\"`\", \"\").split('\\n')\n            optFile.close()\n            optionalPkgs = [x.lower() for x in optionalPkgs]\n            pkgList += optionalPkgs\n            checkStr += \" and All Optional\"\n\n        print(\"\\nChecking \" + checkStr + \" Python packages:\")\n        for elem in pkgList:\n            try:\n                pkg_resources.require(elem)\n                print(\"Found: \" + statusColor + elem + endColor)\n            except (pkg_resources.DistributionNotFound, pkg_resources.VersionConflict):\n                installCmd = [sys.executable, \"-m\", \"pip\", \"install\"]\n\n                if not is_running_virtual_env():\n                    if self.options.autoKey:\n                        choice = self.options.autoKey\n                    else:\n                        choice = input(warningColor + \"Required python package \" + elem + \" is missing\" + endColor +\n                                       \"\\nInstall for user (u), system (s) or cancel(c)? \")\n                    if choice == 'c':\n                        print(warningColor + \"Skipping installing \" + elem + endColor)\n                        continue\n                    elif choice == 'u':\n                        installCmd.append(\"--user\")\n                installCmd.append(elem)\n                try:\n                    subprocess.check_call(installCmd)\n                except subprocess.CalledProcessError:\n                    print(failColor + \"Was not able to install \" + elem + endColor)\n\n        # check the version of Python\n        print(\"\\nChecking Python version:\")\n        if not (sys.version_info.major == 3 and sys.version_info.minor >= 7):\n            print(warningColor + \"Python 3.7 or newer should be used with Basilisk.\" + endColor)\n            print(\"You are using Python {}.{}.{}\".format(sys.version_info.major,\n                                                         sys.version_info.minor, sys.version_info.micro))\n        else:\n            print(statusColor + \"Python {}.{}.{}\".format(sys.version_info.major,\n                                                         sys.version_info.minor, sys.version_info.micro)\n                  + \" is acceptable for Basilisk\" + endColor)\n\n        print(\"\\n\")",
  "def requirements(self):\n        if self.options.opNav:\n            self.requires.add(\"pcre/8.45\")\n            self.requires.add(\"opencv/4.1.2#b610ad323f67adc1b51e402cb5d68d70\")\n            self.options['opencv'].with_ffmpeg = False  # video frame encoding lib\n            self.options['opencv'].with_ade = False  # graph manipulations framework\n            self.options['opencv'].with_tiff = False  # generate image in TIFF format\n            self.options['opencv'].with_openexr = False  # generate image in EXR format\n            self.options['opencv'].with_quirc = False  # QR code lib\n            self.requires.add(\"zlib/1.2.13\")\n            self.requires.add(\"xz_utils/5.4.0\")\n\n        if self.options.vizInterface or self.options.opNav:\n            self.requires.add(\"protobuf/3.17.1\")\n            self.options['zeromq'].encryption = False  # Basilisk does not use data streaming encryption.\n            self.requires.add(\"cppzmq/4.5.0\")",
  "def configure(self):\n        if self.options.clean:\n            # clean the distribution folder to start fresh\n            self.options.clean = False\n            root = os.path.abspath(os.path.curdir)\n            distPath = os.path.join(root, \"dist3\")\n            if os.path.exists(distPath):\n                shutil.rmtree(distPath, ignore_errors=True)\n        if self.settings.build_type == \"Debug\":\n            print(warningColor + \"Build type is set to Debug. Performance will be significantly lower.\" + endColor)\n\n        # Install additional opencv methods\n        if self.options.opNav:\n            self.options['opencv'].contrib = True\n            # Raise an issue to conan-center to fix this bug. Using workaround to disable freetype for windows\n            # Issue link: https://github.com/conan-community/community/issues/341\n            #TODO Remove this once they fix this issue.\n            if self.settings.os == \"Windows\":\n                self.options['opencv'].freetype = False\n\n        if self.options.generator == \"\":\n            # Select default generator supplied to cmake based on os\n            if self.settings.os == \"Macos\":\n                self.generator = \"Xcode\"\n            elif self.settings.os == \"Windows\":\n                self.generator = \"Visual Studio 16 2019\"\n                self.options[\"*\"].shared = True\n            else:\n                print(\"Creating a make file for project. \")\n                print(\"Specify your own using the -o generator='Name' flag during conan install\")\n        else:\n            self.generator = str(self.options.generator)\n            if self.settings.os == \"Windows\":\n                self.options[\"*\"].shared = True\n        print(\"cmake generator set to: \" + statusColor + str(self.generator) + endColor)",
  "def package_id(self):\n        if self.settings.compiler == \"Visual Studio\":\n            if \"MD\" in self.settings.compiler.runtime:\n                self.info.settings.compiler.runtime = \"MD/MDd\"\n            else:\n                self.info.settings.compiler.runtime = \"MT/MTd\"",
  "def imports(self):\n        if self.settings.os == \"Windows\":\n            self.keep_imports = True\n            self.copy(\"*.dll\", \"../Basilisk\", \"bin\")",
  "def generateMessageModules(self, originalWorkingDirectory):\n        cmdString = [sys.executable, \"GenCMessages.py\"]\n        if self.options.pathToExternalModules:\n            cmdString.extend([\"--pathToExternalModules\", str(self.options.pathToExternalModules)])\n        subprocess.check_call(cmdString)\n        os.chdir(originalWorkingDirectory)\n        print(\"Done\")",
  "def build(self):\n        # auto-generate C message definition files\n        print(statusColor + \"Auto-generating message definitions:\" + endColor, end=\" \")\n        bskPath = os.getcwd()\n        os.chdir(os.path.join(bskPath, \"src/architecture/messaging/msgAutoSource\"))\n        self.generateMessageModules(bskPath)\n\n        if self.options.pathToExternalModules:\n            print(statusColor + \"Including External Folder: \" + endColor + str(self.options.pathToExternalModules))\n\n        root = os.path.abspath(os.path.curdir)\n\n        self.folders.source = os.path.join(root, \"src\")\n        self.folders.build = os.path.join(root, \"dist3\")\n\n        cmake = CMake(self, set_cmake_flags=True, generator=self.generator)\n        if self.settings.compiler == \"Visual Studio\":\n            cmake.definitions[\"CONAN_LINK_RUNTIME_MULTI\"] = cmake.definitions[\"CONAN_LINK_RUNTIME\"]\n            cmake.definitions[\"CONAN_LINK_RUNTIME\"] = False\n        cmake.definitions[\"BUILD_OPNAV\"] = self.options.opNav\n        cmake.definitions[\"BUILD_VIZINTERFACE\"] = self.options.vizInterface\n        cmake.definitions[\"EXTERNAL_MODULES_PATH\"] = self.options.pathToExternalModules\n        cmake.definitions[\"PYTHON_VERSION\"] = sys.version_info.major + 0.1*sys.version_info.minor\n        cmake.parallel = True\n        print(statusColor + \"Configuring cmake...\" + endColor)\n        cmake.configure()\n        self.add_basilisk_to_sys_path()\n        if self.options.buildProject:\n            print(statusColor + \"\\nCompiling Basilisk...\" + endColor)\n            start = datetime.now()\n            if self.generator == \"Xcode\":\n                # Xcode multi-threaded needs specialized arguments\n                cmake.build(['--', '-jobs', str(tools.cpu_count()), '-parallelizeTargets'])\n            else:\n                cmake.build()\n            print(\"Total Build Time: \" + str(datetime.now() - start))\n            print(f\"{statusColor}The Basilisk build is successful and the scripts are ready to run{endColor}\")\n        else:\n            print(f\"{statusColor}Finished configuring the Basilisk project.{endColor}\")\n            if self.settings.os != \"Linux\":\n                print(f\"{statusColor}Please open project file inside dist3 with {self.generator} IDE \"\n                      f\"and build the project for {self.settings.build_type}{endColor}\")\n            else:\n                print(f\"{statusColor}Please go to dist3 folder and run command \"\n                      f\"`make -j <number of threads to use>`{endColor}\")\n        return",
  "def add_basilisk_to_sys_path(self):\n        print(\"Adding Basilisk module to python\\n\")\n        add_basilisk_module_command = [sys.executable, \"-m\", \"pip\", \"install\", \"-e\", \".\"]\n        if not is_running_virtual_env() and self.options.autoKey != 's':\n            add_basilisk_module_command.append(\"--user\")\n\n        process = subprocess.Popen(add_basilisk_module_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        output, err = process.communicate()\n        if err:\n            print(\"Error %s while running %s\" % (err.decode(), add_basilisk_module_command))\n            sys.exit(1)\n        else:\n            print(\"This resulted in the output: \\n%s\" % output.decode())",
  "def runCommand(cmd, dir=None):\n    if not verbose:\n        cmd += \"> /dev/null\"\n    print(\"Running command:\", cmd)\n\n    originalDir = os.getcwd()\n    if dir is not None:\n        os.chdir(dir)\n        os.system(cmd)\n        os.chdir(originalDir)\n    else:\n        os.system(cmd)",
  "class PyTestCommand(TestCommand):\n    # Here we define a command to use for testing installed Basilisk\n    # Taken from pytest documentation found https://docs.pytest.org/en/latest/goodpractices.html\n    description = \"Custom test command that runs pytest\"\n    user_options = [('pytest-args=', 'a', \"Arguments to pass to pytest\")]\n\n    def initialize_options(self):\n        TestCommand.initialize_options(self)\n        self.pytest_args = ''\n\n    def run_tests(self):\n        import shlex\n        # import here, cause outside the eggs aren't loaded\n        import pytest\n        errno = pytest.main(['src'] + shlex.split(self.pytest_args))\n        sys.exit(errno)",
  "class CleanCommand(Command):\n    # Custom command to clean up\n    description = \"Custom clean command that removes dist3/build and artifacts\"\n    user_options = []\n\n    def initialize_options(self):\n        self.cwd = None\n\n    def finalize_options(self):\n        self.cwd = os.getcwd()\n\n    def run(self):\n        to_delete = [\n            \"dist3/\",\n            \"docs/build\",\n            \"docs/source/_images/Scenarios\"\n        ]\n        assert os.getcwd() == self.cwd, 'Must be in package root: %s' % self.cwd\n        runCommand('rm -rf ' + \" \".join(to_delete))",
  "class CMakeBuildCommand(Command):\n    # Custom command to build with cmake and xcode\n    description = \"Custom build command that runs CMake\"\n    user_options = []\n\n    def initialize_options(self):\n        self.cwd = None\n\n    def finalize_options(self):\n        self.cwd = os.getcwd()\n\n    def run(self):\n        assert os.getcwd() == self.cwd, 'Must be in package root: %s' % self.cwd\n        print(\"Making distribution directory\")\n        runCommand(\"mkdir dist3/\")\n        print(\"Executing CMake build into dist3/ directory\")\n        # if we switch to using mostly setup.py for the build, install will not be done by CMake\n        print(\"This also will install Basilisk locally...\")\n        runCommand(\"cmake -G Xcode ../src/\", \"dist3/\")",
  "class XCodeBuildCommand(Command):\n    description = \"Custom build command that runs XCode\"\n    user_options = []\n\n    def initialize_options(self):\n        self.cwd = None\n\n    def finalize_options(self):\n        self.cwd = os.getcwd()\n\n    def run(self):\n        assert os.getcwd() == self.cwd, 'Must be in package root: %s' % self.cwd\n        print(\"Executing XCode build into dist3/ directory\")\n        runCommand(\"xcodebuild -project dist3/basilisk.xcodeproj -target ALL_BUILD\")",
  "class LintCommand(Command):\n    description = \"Custom lint command that displays pep8 violations\"\n    user_options = []\n\n    def initialize_options(self):\n        self.cwd = None\n\n    def finalize_options(self):\n        self.cwd = os.getcwd()\n\n    def run(self):\n        assert os.getcwd() == self.cwd, 'Must be in package root: %s' % self.cwd\n        print(\"Executing linter\")\n        runCommand(\"flake8 src/\")",
  "class BuildDocsCommand(Command):\n    # Custom command to build with cmake and xcode\n\n    description = \"Custom build command to build the documentation with doxygen\"\n    user_options = []\n\n    def initialize_options(self):\n        self.cwd = None\n\n    def finalize_options(self):\n        self.cwd = os.getcwd()\n\n    def run(self):\n        assert os.getcwd() == self.cwd, 'Must be in package root: %s' % self.cwd\n        print(\"Building documentation\")\n        runCommand(\"make html\", \"docs/source\")",
  "def initialize_options(self):\n        TestCommand.initialize_options(self)\n        self.pytest_args = ''",
  "def run_tests(self):\n        import shlex\n        # import here, cause outside the eggs aren't loaded\n        import pytest\n        errno = pytest.main(['src'] + shlex.split(self.pytest_args))\n        sys.exit(errno)",
  "def initialize_options(self):\n        self.cwd = None",
  "def finalize_options(self):\n        self.cwd = os.getcwd()",
  "def run(self):\n        to_delete = [\n            \"dist3/\",\n            \"docs/build\",\n            \"docs/source/_images/Scenarios\"\n        ]\n        assert os.getcwd() == self.cwd, 'Must be in package root: %s' % self.cwd\n        runCommand('rm -rf ' + \" \".join(to_delete))",
  "def initialize_options(self):\n        self.cwd = None",
  "def finalize_options(self):\n        self.cwd = os.getcwd()",
  "def run(self):\n        assert os.getcwd() == self.cwd, 'Must be in package root: %s' % self.cwd\n        print(\"Making distribution directory\")\n        runCommand(\"mkdir dist3/\")\n        print(\"Executing CMake build into dist3/ directory\")\n        # if we switch to using mostly setup.py for the build, install will not be done by CMake\n        print(\"This also will install Basilisk locally...\")\n        runCommand(\"cmake -G Xcode ../src/\", \"dist3/\")",
  "def initialize_options(self):\n        self.cwd = None",
  "def finalize_options(self):\n        self.cwd = os.getcwd()",
  "def run(self):\n        assert os.getcwd() == self.cwd, 'Must be in package root: %s' % self.cwd\n        print(\"Executing XCode build into dist3/ directory\")\n        runCommand(\"xcodebuild -project dist3/basilisk.xcodeproj -target ALL_BUILD\")",
  "def initialize_options(self):\n        self.cwd = None",
  "def finalize_options(self):\n        self.cwd = os.getcwd()",
  "def run(self):\n        assert os.getcwd() == self.cwd, 'Must be in package root: %s' % self.cwd\n        print(\"Executing linter\")\n        runCommand(\"flake8 src/\")",
  "def initialize_options(self):\n        self.cwd = None",
  "def finalize_options(self):\n        self.cwd = os.getcwd()",
  "def run(self):\n        assert os.getcwd() == self.cwd, 'Must be in package root: %s' % self.cwd\n        print(\"Building documentation\")\n        runCommand(\"make html\", \"docs/source\")",
  "def pytest_addoption(parser):\n    parser.addoption(\"--show_plots\", action=\"store_true\",\n                     help=\"test(s) shall display plots\")\n    parser.addoption(\"--report\", action=\"store_true\",  # --report is easier, more controlled than --html=<pathToReport>\n                         help=\"whether or not to gen a pytest-html report. The report is saved in ./tests/report\")",
  "def show_plots(request):\n    return request.config.getoption(\"--show_plots\")",
  "def get_test_name(item):  # just get the name of the test from the item function\n    return str(item.function).split(' ')[1]",
  "def get_docstring(item):\n    if item.function.__doc__:\n        return '<span style=\"font-family:monospace;white-space:pre-wrap;word-wrap: break-word;\">' \\\n               + textwrap.dedent(str(item.function.__doc__)).replace('``', '') + '</span>'\n    else:\n        return '<span style=\"font-family:monospace;white-space:pre-wrap;word-wrap: break-word;\"> ' \\\n               'This test does not have a docstring </br></span>'",
  "def pytest_runtest_makereport(item, call):\n    \"\"\"\n        We (Basilisk) use this function to do two things:\n        1) append the docstrings to the test log extras\n        2) print test plots to the test log extras\n\n        This is kept neat by inserting a table into the extras to separate the two things.\n    \"\"\"\n    pytest_html = item.config.pluginmanager.getplugin('html')\n    outcome = yield\n    if item.config.option.htmlpath:  # don't save pictures etc. if not making a report\n\n        report = outcome.get_result()\n        extra = getattr(report, 'extra', [])\n\n        # add the doc string\n        extra.append(pytest_html.extras.html(get_docstring(item)))\n\n        # save the figures\n        dir_name = testFigsDir + get_test_name(item)\n        i = 0\n        if len(plt.get_fignums()) > 0:\n            while i > -1:  # this loops makes a numbered directory per run of the same test to avoid overwrite\n                dir_name_num = dir_name + '_' + str(i) + '/'\n                if not os.path.exists(dir_name_num):\n                    os.makedirs(dir_name_num)\n                    break\n                else:\n                    i += 1\n                    continue\n\n            for f in plt.get_fignums():\n                if not os.path.exists(dir_name_num):\n                    time.sleep(0.02)\n                filename = dir_name_num + 'figure_' + str(f) + '.svg'\n                plt.figure(f).savefig(filename, transparent=True)\n                plt.close(f)  # prevents saving same image multiple times\n                img_src = 'assets' + filename.split('assets')[1]  # just want a relative (to report) path here\n                extra.append(pytest_html.extras.html('<a href=\"' + img_src +'\"><img src=\"' + img_src +\n                                                     '\" style=\"width:30em;float:left;\"></a>'))\n        else:\n            extra.append(pytest_html.extras.html('<tt> This test has no images.<br></tt>'))\n        extra.append(pytest_html.extras.html('<br style=\"clear:left;\">'))\n        report.extra = extra",
  "def pytest_html_results_table_header(cells):\n    # remove the \"links\" column from the report\n    cells.pop()",
  "def pytest_html_results_table_row(report, cells):\n    # remove the \"links column from the report\n    cells.pop()",
  "def test_hingedBodyLinearProfiler(show_plots, startTime, endTime, startTheta, endTheta):\n    r\"\"\"\n    **Validation Test Description**\n\n    For a given deployment, checks that the theta before, during, and after deployment are correct.\n\n    **Test Parameters**\n\n    Discuss the test parameters used.\n\n    Args:\n        startTime (uint64_t): starting time in nanoseconds\n        endTime (uint64_t): ending time in nanoseconds\n        startTheta (double): starting angle of deployment in radians\n        endTheta (double): ending angle of deployment in radians\n\n    **Description of Variables Being Tested**\n    \n    For a deployment from 0 to 1 degree, starting at 1 second and ending at 2 seconds into the simulation, checks that the angle and angle rates are as expected before, during, and after deployment.\n    \n    Before deployment, theta should be 0 and ``thetaDot`` 0. During deployment, ``thetaDot`` should be 1 degree per second, with theta varying linearly. After deployment, theta should be 1 degree and ``thetaDot`` 0.\n\n    \"\"\"\n    [testResults, testMessage] = hingedBodyLinearProfilerTestFunction(show_plots, startTime, endTime, startTheta, endTheta)\n    assert testResults < 1, testMessage",
  "def hingedBodyLinearProfilerTestFunction(show_plots, startTime, endTime, startTheta, endTheta):\n    \"\"\"Test method\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n    \n    # accuracy to which double values compared\n    accuracy = 1e-12\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(0.5)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    module = hingedBodyLinearProfiler.HingedBodyLinearProfiler()\n    module.ModelTag = \"hingedBodyLinearProfilerTag\"\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    module.startTime = startTime\n    module.endTime = endTime\n    module.startTheta = startTheta\n    module.endTheta = endTheta\n\n    # set up output message recorder objects\n    dataLog = module.hingedRigidBodyReferenceOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(3))\n    unitTestSim.ExecuteSimulation()\n\n    # pull module data and make sure it is correct\n    trueTheta = np.array([0, 0, 0, pi/360, pi/180, pi/180, pi/180]);\n    trueThetaDot = np.array([0, 0, pi/180, pi/180, pi/180, 0, 0])\n    \n    testFailCount, testMessages = unitTestSupport.compareVector(trueTheta, dataLog.theta, accuracy, \"theta\", testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareVector(trueThetaDot, dataLog.thetaDot, accuracy, \"thetaDot\", testFailCount, testMessages)\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, \"\".join(testMessages)]",
  "def addTimeColumn(time, data):\n    return np.transpose(np.vstack([[time], np.transpose(data)]))",
  "def test_module(show_plots, voltage):\n    r\"\"\"\n    **Test Parameters**\n\n    Three base voltages are tested where :math:`V_0\\in(5.0,-7.5,0.0)`. The input voltages are then setup as\n\n    .. math::\n\n        {\\bf V}=V_0 \\begin{bmatrix}\n        1\\\\\n        1\\\\\n        1\n        \\end{bmatrix} + \\begin{bmatrix}\n        0.0\\\\\n        1.0\\\\\n        1.5\n        \\end{bmatrix}\n\n    Other inputs to the module are:\n\n    .. code-block:: python\n        :linenos:\n\n        testModule.voltage2TorqueGain =[ 1.32, 0.99, 1.31] # [Nm/V] conversion gain\n        testModule.scaleFactor =[ 1.01, 1.00, 1.02] #[unitless] scale factor\n        testModule.bias =[0.01, 0.02, 0.04] # [Nm] bias\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(show_plots, voltage)\n    assert testResults < 1, testMessage",
  "def run(show_plots, voltage):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    testModule = motorVoltageInterface.MotorVoltageInterface()\n    testModule.ModelTag = \"motorVoltageInterface\"\n\n    # set module parameters(s)\n    testModule.setGains(np.array([1.32, 0.99, 1.31]))      # [Nm/V] conversion gain\n    testModule.setScaleFactors(np.array([1.01, 1.00, 1.02]))               # [ul] error scale factor\n    testModule.setBiases(np.array([0.01, 0.02, 0.04]))                      # [Nm] Torque bias from converter output\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    voltageData = messaging.ArrayMotorVoltageMsgPayload()\n    voltageData.voltage = [voltage, voltage+1.0, voltage+1.5]\n    voltageMsg = messaging.ArrayMotorVoltageMsg().write(voltageData)\n    testModule.motorVoltageInMsg.subscribeTo(voltageMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = testModule.motorTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n\n    # This pulls the actual data log from the simulation run.\n    moduleOutput = dataLog.motorTorque[:, :3]\n\n    # set truth states\n    voltageTrue = np.array([1.0, 1.0, 1.0])*voltage + np.array([0.0, 1.0, 1.5])\n    trueVector = [\n          voltageTrue[0] * testModule.voltage2TorqueGain[0][0]*testModule.scaleFactor[0][0] + testModule.bias[0][0],\n          voltageTrue[1] * testModule.voltage2TorqueGain[1][0]*testModule.scaleFactor[1][0] + testModule.bias[1][0],\n          voltageTrue[2] * testModule.voltage2TorqueGain[2][0]*testModule.scaleFactor[2][0] + testModule.bias[2][0]\n    ]\n    trueVector = np.array([trueVector, trueVector, trueVector])\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput,\n                                                               accuracy, \"Output Vector\",\n                                                               testFailCount, testMessages)\n    moduleOutput = addTimeColumn(dataLog.times(), moduleOutput)\n    resultTable = moduleOutput\n    resultTable[:, 0] = macros.NANO2SEC * resultTable[:, 0]\n    diff = np.delete(moduleOutput, 0, 1) - trueVector\n    resultTable = np.insert(resultTable, list(range(2, 2 + len(diff.transpose()))), diff, axis=1)\n\n    tableName = \"baseVoltage\" + str(voltage)\n    tableHeaders = [\"time [s]\", \"$u_{s,1}$ (Nm)\", \"Error\", \"$u_{s,2}$ (Nm)\", \"Error\", \"$u_{u,3}$ (Nm)\", \"Error\"]\n    caption = 'RW motoor torque output for Base Voltaget = ' + str(voltage) + 'V.'\n    unitTestSupport.writeTableLaTeX(\n        tableName,\n        tableHeaders,\n        caption,\n        resultTable,\n        path)\n\n\n    #   print out success message if no error were found\n    snippetName = \"passFail\" + '{:1.1f}'.format(voltage)\n    if testFailCount == 0:\n        colorText = \"ForestGreen\"\n        print(\"PASSED: \" + testModule.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = \"Red\"\n        passedText = r'\\textcolor{' + colorText + '}{' + \"FAILED\" + '}'\n    unitTestSupport.writeTeXSnippet(snippetName, passedText, path)\n\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_sensorThermalFault(tempFault):\n    '''This function is called by the py.test environment.'''\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(tempFault)\n    assert testResults < 1, testMessage\n    __tracebackhide__ = True",
  "def run(tempFault):\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    # Create simulation variable names\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # set the simulation time variable used later on\n    simulationTime = macros.sec2nano(100.)\n\n    #\n    #  create the simulation process\n    #\n\n    testProcessRate = macros.sec2nano(1.0)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    #\n    #   set up the simulation tasks/objects\n    #\n\n    #  set device status message\n    sensorStatusMsgPayload = messaging.DeviceStatusMsgPayload()\n    sensorStatusMsgPayload.deviceStatus = 1\n    sensorStatusMsg = messaging.DeviceStatusMsg().write(sensorStatusMsgPayload)\n\n    #  set the spacecraft message\n    scStateMsgPayload = messaging.SCStatesMsgPayload()\n    scStateMsgPayload.r_BN_N = [6378*1000., 0., 0.]\n    scStateMsgPayload.sigma_BN = [0., 0., 0.]\n    scStateMsg = messaging.SCStatesMsg().write(scStateMsgPayload)\n\n    #  set the sun message\n    sunMsgPayload = messaging.SpicePlanetStateMsgPayload()\n    sunMsgPayload.PositionVector = [astroFunctions.AU*1000., 0., 0.]\n    sunMsg = messaging.SpicePlanetStateMsg().write(sunMsgPayload)\n\n\n    #\n    #   set up the truth value temperature modeling\n    #\n    sensorThermalModel = sensorThermal.SensorThermal()\n    sensorThermalModel.ModelTag = 'sensorThermalModel'\n    sensorThermalModel.nHat_B = [0, 0, 1]\n    sensorThermalModel.sensorArea = 1.0  # m^2\n    sensorThermalModel.sensorAbsorptivity = 0.25\n    sensorThermalModel.sensorEmissivity = 0.34\n    sensorThermalModel.sensorMass = 2.0  # kg\n    sensorThermalModel.sensorSpecificHeat = 890\n    sensorThermalModel.sensorPowerDraw = 30.0  # W\n    sensorThermalModel.T_0 = 0  # [\u00baC]\n    sensorThermalModel.sunInMsg.subscribeTo(sunMsg)\n    sensorThermalModel.stateInMsg.subscribeTo(scStateMsg)\n    sensorThermalModel.sensorStatusInMsg.subscribeTo(sensorStatusMsg)\n    unitTestSim.AddModelToTask(unitTaskName, sensorThermalModel)\n\n    #\n    # set up the tempMeasurement module\n    #\n    tempMeasurementModel = tempMeasurement.TempMeasurement()\n    tempMeasurementModel.tempInMsg.subscribeTo(sensorThermalModel.temperatureOutMsg)\n    unitTestSim.AddModelToTask(unitTaskName, tempMeasurementModel)\n\n    #\n    # log data\n    #\n\n    # log the RW temperature\n    tempLog = tempMeasurementModel.tempOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, tempLog)\n\n    #\n    #   initialize Simulation\n    #\n    # Truth Values\n    if tempFault == \"TEMP_FAULT_NOMINAL\":\n        truthValue = -4.251289338192501\n        unitTestSim.InitializeSimulation()\n        unitTestSim.ConfigureStopTime(simulationTime)\n        unitTestSim.ExecuteSimulation()\n\n    elif tempFault == \"TEMP_FAULT_STUCK_CURRENT\":\n        truthValue = -2.1722164230619447\n        unitTestSim.InitializeSimulation()\n        unitTestSim.ConfigureStopTime(round(simulationTime/2.0))\n        unitTestSim.ExecuteSimulation()\n        tempMeasurementModel.faultState = tempMeasurement.TEMP_FAULT_STUCK_CURRENT\n        unitTestSim.ConfigureStopTime(simulationTime)\n        unitTestSim.ExecuteSimulation()\n\n    elif tempFault == \"TEMP_FAULT_STUCK_VALUE\":\n        truthValue = 10.0\n        tempMeasurementModel.stuckValue = 10.0\n        unitTestSim.InitializeSimulation()\n        unitTestSim.ConfigureStopTime(round(simulationTime/2.0))\n        unitTestSim.ExecuteSimulation()\n        tempMeasurementModel.faultState = tempMeasurement.TEMP_FAULT_STUCK_VALUE\n        unitTestSim.ConfigureStopTime(simulationTime)\n        unitTestSim.ExecuteSimulation()\n    elif tempFault == \"TEMP_FAULT_SPIKING\":\n        tempMeasurementModel.faultState = tempMeasurement.TEMP_FAULT_SPIKING\n        truthValue = 0.1\n        unitTestSim.InitializeSimulation()\n        unitTestSim.ConfigureStopTime(simulationTime)\n        unitTestSim.ExecuteSimulation()\n        nominals = np.array([ 0.,         -0.04439869, -0.08875756, -0.13307667, \n            -0.17735608, -0.22159584, -0.265796,   -0.30995662, -0.35407775, \n            -0.39815946, -0.44220178, -0.48620479, -0.53016852, -0.57409304, \n            -0.6179784,  -0.66182465, -0.70563184, -0.74940004, -0.79312929, \n            -0.83681965, -0.88047117, -0.9240839,  -0.9676579,  -1.01119321, \n            -1.0546899,  -1.09814802, -1.14156761, -1.18494873, -1.22829144, \n            -1.27159578, -1.31486181, -1.35808958, -1.40127914, -1.44443055, \n            -1.48754385, -1.5306191, -1.57365634, -1.61665564, -1.65961704, \n            -1.7025406,  -1.74542636, -1.78827437, -1.83108469, -1.87385737, \n            -1.91659246, -1.95929001, -2.00195007, -2.04457269, -2.08715792, \n            -2.12970582, -2.17221642, -2.21468979, -2.25712597, -2.29952502, \n            -2.34188697, -2.38421189, -2.42649982, -2.46875082, -2.51096492, \n            -2.55314219, -2.59528266, -2.6373864,  -2.67945344, -2.72148384, \n            -2.76347765, -2.80543491, -2.84735568, -2.88924,    -2.93108792, \n            -2.9728995 , -3.01467477, -3.05641378, -3.0981166,  -3.13978325, \n            -3.1814138,  -3.22300829, -3.26456677, -3.30608928, -3.34757587, \n            -3.38902659, -3.43044149, -3.47182062, -3.51316402, -3.55447174, \n            -3.59574383, -3.63698033, -3.67818129, -3.71934677, -3.76047679, \n            -3.80157142, -3.8426307,  -3.88365467, -3.92464338, -3.96559689, \n            -4.00651522, -4.04739844, -4.08824658, -4.1290597,  -4.16983783, \n            -4.21058103, -4.25128934])\n\n        testValue = 0\n        sensorTemp = np.array(tempLog.temperature)\n        for ii in range(len(nominals)):\n            if abs(nominals[ii]) > 0.0001:\n                if abs(nominals[ii] - sensorTemp[ii]) > 1e-6:\n                    testValue = testValue + 1\n            else:\n                if abs(sensorTemp[ii]) > 1e-6:\n                    testValue = testValue + 1\n        testValue = testValue/len(nominals)\n    elif tempFault == \"BIASED\":\n        biasVal = 1.0\n        tempMeasurementModel.senBias = biasVal\n        truthValue = -3.251289338192501\n        unitTestSim.InitializeSimulation()\n        unitTestSim.ConfigureStopTime(simulationTime)\n        unitTestSim.ExecuteSimulation()\n    else:\n        NotImplementedError(\"Fault type specified does not exist.\")\n\n\n    sensorTemp = np.array(tempLog.temperature)\n    print(sensorTemp)\n\n\n\n    #\n    # compare the module results to the true values\n    #\n\n    if tempFault == \"TEMP_FAULT_SPIKING\":\n        if not unitTestSupport.isDoubleEqualRelative(testValue, truthValue, 5E-1): # only 101 values so need this to be relatively relaxed (within 50%)\n            testFailCount+= 1\n    elif not unitTestSupport.isDoubleEqualRelative(sensorTemp[-1], truthValue, 1E-12):\n        testFailCount += 1\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_encoder(show_plots, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test script tests the the features of an encoder, namely discretization and signal failures. It sets up\n    the reaction wheel speed message and encoder modules and runs the simulation for a number of steps. The script tests\n    each functionality of the module, including the discretization of the wheel speeds and the signal failures, such as\n    the signal being turned off or being stuck at the previous iteration.\n\n    In the reaction wheel message, three wheels are considered with varying values. Throughout the simulation, the\n    encoder module assumes different operating states, such as nominal (everything works as intended), off (wheel speeds\n    are off) and stuck (wheel speeds remain constant).\n\n    The limitations of this test are the same as the ones discussed on the module's .rst file. Also, the value of the\n    accuracy used is the limit for the test to pass.\n\n    **Test Parameters**\n\n    Args:\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    In this file we are checking the values of the variables\n\n    - ``wheelSpeedsEncoded``\n\n    which represents the array of reaction wheel speeds. This array is compared to the ``truewheelSpeedsEncoded`` array,\n    which contains the expected values of the wheel speeds after encoding.\n    \"\"\"\n    [testResults, testMessage] = encoderTest(show_plots, accuracy)\n    assert testResults < 1, testMessage",
  "def encoderTest(show_plots, accuracy):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    # Create simulation variable names\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    #\n    #  create the simulation process\n    #\n\n    testProcessRate = macros.sec2nano(1)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    #\n    #   setup the simulation tasks/objects\n    #\n\n    #\n    # Create RW speed message\n    #\n\n    speedMsgData = messaging.RWSpeedMsgPayload()\n    speedMsgData.wheelSpeeds = [100, 200, 300]\n    speedMsg = messaging.RWSpeedMsg().write(speedMsgData)\n\n    numRW = 3\n\n    #\n    #   Setup the reaction wheel speed encoder\n    #\n\n    wheelSpeedEncoder = encoder.Encoder()\n    wheelSpeedEncoder.ModelTag = 'rwSpeedsEncoder'\n    wheelSpeedEncoder.clicksPerRotation = 2\n    wheelSpeedEncoder.numRW = numRW\n    wheelSpeedEncoder.rwSpeedInMsg.subscribeTo(speedMsg)\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, wheelSpeedEncoder)\n\n    #\n    # log data\n    #\n\n    # log the RW speeds\n    wheelSpeedEncodedLog = wheelSpeedEncoder.rwSpeedOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, wheelSpeedEncodedLog)\n\n    #\n    #   initialize Simulation\n    #\n\n    unitTestSim.InitializeSimulation()\n    numSteps = 0\n\n    # run the sim\n    unitTestSim.TotalSim.SingleStepProcesses()\n    numSteps += 1\n    unitTestSim.TotalSim.SingleStepProcesses()\n    numSteps += 1\n    unitTestSim.TotalSim.SingleStepProcesses()\n    numSteps += 1\n\n    # update the encoder to be OFF\n    wheelSpeedEncoder.rwSignalState = [encoder.SIGNAL_OFF]*numRW\n\n    # run the sim\n    unitTestSim.TotalSim.SingleStepProcesses()\n    numSteps += 1\n\n    # update the wheel speeds\n    speedMsgData.wheelSpeeds = [500, 400, 300]\n    speedMsg = messaging.RWSpeedMsg().write(speedMsgData)\n    wheelSpeedEncoder.rwSpeedInMsg.subscribeTo(speedMsg)\n    wheelSpeedEncoder.rwSignalState = [encoder.SIGNAL_NOMINAL] * numRW\n\n    # run the sim\n    unitTestSim.TotalSim.SingleStepProcesses()\n    numSteps += 1\n\n    # change the wheel speeds but make the encoder stuck\n    speedMsgData.wheelSpeeds = [100, 200, 300]\n    speedMsg = messaging.RWSpeedMsg().write(speedMsgData)\n    wheelSpeedEncoder.rwSpeedInMsg.subscribeTo(speedMsg)\n    wheelSpeedEncoder.rwSignalState = [encoder.SIGNAL_STUCK] * numRW\n\n    # run the sim\n    unitTestSim.TotalSim.SingleStepProcesses()\n    numSteps += 1\n\n    #\n    # retrieve the logged data\n    #\n\n    wheelSpeedsEncoded = np.array(wheelSpeedEncodedLog.wheelSpeeds)\n\n    #\n    # set the truth vectors\n    #\n\n    trueWheelSpeedsEncoded = np.array([[100., 200., 300.],\n                                       [ 97.38937226, 197.92033718, 298.45130209],\n                                       [100.53096491, 201.06192983, 298.45130209],\n                                       [0., 0., 0.],\n                                       [499.51323192, 398.98226701, 298.45130209],\n                                       [499.51323192, 398.98226701, 298.45130209]])\n\n    #\n    # compare the module results to the true values\n    #\n\n    fail = 0\n    for i in range(numSteps):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(wheelSpeedsEncoded[i, 0:3], trueWheelSpeedsEncoded[i, :], 3, accuracy):\n            fail += 1\n\n    if fail > 0:\n        testFailCount += 1\n\n    if not testFailCount:\n        print(\"PASSED\")\n    else:\n        testMessages.append(\"FAILED: Encoder Test\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, setRwMsg, setDeviceStatusMsg, setEta_e2m, OmegaValue, setEta_m2c, accuracy):\n    \"\"\"\n    **Validation Test Description**\n\n    This unit test checks the output of the RW power module.  Only the power module is created, and all\n    required input messages are created from python.  The tests consider both default behavior and\n    manually setting behavior.\n\n    **Test Parameters**\n\n    The test parameters are described below.\n    All possible permutations of these cases are tests.\n\n    :param show_plots: flag if plots should be shown.  Not used in this script.\n    :param setRwMsg: [bool] flag if the RW state message should be set.  If not then a warning is created and the output\n                     message should be 0\n    :param setDeviceStatusMsg: [int] flag to check if a device is on or off.  If this msg is not set the device\n                               should default to being on. The options include:\n\n                               - 0,  use default behavior,\n                               - 1,  set msg and turn device off,\n                               - 2,  set msg and turn device on\n\n    :param setEta_e2m: [bool] to specify a conversion efficiency from electrical to mechanical power\n    :param OmegaValue: [RPM] specifies the RW wheel speed to either positive or negative values\n    :param setEta_m2c: [int] flag to set the mechanical to electrical conversion efficiency when breaking the RW.\n                             The cases include:\n\n                             - 0, default case of -1 turning of energy recovery,\n                             - 1, set the efficiency to zero,\n                             - 2, set the efficiency to 0.5\n\n    :param accuracy: [float] accuracy used when compute actual to truth power requirement\n    :return: void\n\n    **Description of Variables Being Tested**\n\n    In each case the module output power value is check against a python evaluated truth value.\n\n    \"\"\"\n\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = powerRW(show_plots, setRwMsg, setDeviceStatusMsg, setEta_e2m, OmegaValue, setEta_m2c, accuracy)\n    assert testResults < 1, testMessage",
  "def powerRW(show_plots, setRwMsg, setDeviceStatusMsg, setEta_e2m, OmegaValue, setEta_m2c, accuracy):\n    if not setRwMsg:\n        bskLogging.setDefaultLogLevel(bskLogging.BSK_ERROR)\n\n    \"\"\"Module Unit Test\"\"\"\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # create the rw power test module\n    testModule = ReactionWheelPower.ReactionWheelPower()\n    testModule.ModelTag = \"bskSat\"\n    testModule.basePowerNeed = 10.   # baseline power draw, Watts\n    rwMsg = messaging.RWConfigLogMsg()\n    testModule.rwStateInMsg.subscribeTo(rwMsg)\n\n    if setEta_e2m:\n        testModule.elecToMechEfficiency = 0.9\n        eta_e2m = testModule.elecToMechEfficiency\n    else:\n        eta_e2m = 1.0\n    if setEta_m2c:\n        testModule.mechToElecEfficiency = (setEta_m2c - 1.0)/2.0\n        eta_m2e = testModule.mechToElecEfficiency\n    else:\n        eta_m2e = -1\n\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    # set the RW status input message\n    OmegaValue = OmegaValue * macros.RPM        # convert to rad/sec\n    if setRwMsg:\n        rwStatusMsg = messaging.RWConfigLogMsgPayload()\n        rwStatusMsg.Omega = OmegaValue          # rad/sec\n        rwStatusMsg.u_current = 0.010           # Nm\n        rwMsg.write(rwStatusMsg)\n\n    # set device status message\n    if setDeviceStatusMsg > 0:\n        deviceStatusMsg = messaging.DeviceStatusMsgPayload()\n        deviceStatusMsg.deviceStatus = setDeviceStatusMsg - 1\n        statusMsg = messaging.DeviceStatusMsg().write(deviceStatusMsg)\n        testModule.nodeStatusInMsg.subscribeTo(statusMsg)\n\n    dataLog = testModule.nodePowerOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # pull logged data\n    drawData = dataLog.netPower\n    print(drawData)\n\n    # compare the module results to the truth values\n    if setRwMsg and setDeviceStatusMsg != 1:\n        wheelPower = OmegaValue * rwStatusMsg.u_current\n        truePower = testModule.basePowerNeed\n        if wheelPower > 0.0 or eta_m2e < 0.0:\n            truePower += abs(wheelPower)/eta_e2m\n        else:\n            print(eta_m2e)\n            truePower += eta_m2e * wheelPower\n        truePower *= -1.0\n    else:\n        truePower = 0.0\n\n    print([truePower]*3)\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray(\n        [truePower]*3, drawData, accuracy, \"powerRW\",\n        testFailCount, testMessages)\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + testModule.ModelTag)\n    else:\n        print(testMessages)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_allTest_SimplePowerSink(show_plots, function):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = eval(function + '()')\n    assert testResults < 1, testMessage",
  "def defaultPowerSink():\n    \"\"\"Module Unit Test\"\"\"\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    testModule = simplePowerSink.SimplePowerSink()\n    testModule.ModelTag = \"powerSink\"\n    testModule.nodePowerOut = 10.  # Watts\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    dataLog = testModule.nodePowerOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    drawData = dataLog.netPower\n\n    # compare the module results to the truth values\n    accuracy = 1e-16\n\n    truePower = 10.0  # Module should be off\n\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray(\n        [truePower]*3, drawData, accuracy, \"powerSinkOutput\",\n        testFailCount, testMessages)\n\n    if testFailCount:\n        print(\"Failed test_default()\")\n    else:\n        print(\"Passed\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def statusPowerSink():\n    \"\"\"Module Unit Test\"\"\"\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    testModule = simplePowerSink.SimplePowerSink()\n    testModule.ModelTag = \"powerSink\"\n    testModule.nodePowerOut = 10.  # Watts\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    # create the input messages\n    powerStatusMsg = messaging.DeviceStatusMsgPayload()  # Create a structure for the input message\n    powerStatusMsg.deviceStatus = 0\n    powerMsg = messaging.DeviceStatusMsg().write(powerStatusMsg)\n    testModule.nodeStatusInMsg.subscribeTo(powerMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = testModule.nodePowerOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    drawData = dataLog.netPower\n\n    # compare the module results to the truth values\n    accuracy = 1e-16\n\n    truePower = 0.0  # Module should be off\n\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray(\n        [truePower]*3, drawData, accuracy, \"powerSinkStatusTest\",\n        testFailCount, testMessages)\n\n    if testFailCount:\n        print(\"Failed test_status()\")\n    else:\n        print(\"Passed\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_simpleSolarPanel(show_plots, orbitDistance, eclipseValue, scAttitude):\n    \"\"\"\n    **Validation Test Description**\n\n    Unit test for simpleSolarPanel. The unit test specifically covers:\n\n    1. Shadowing: Does the panel correctly reflect shadowing from eclipse or attitude?\n\n        This is tested by setting an eclipse value to either 0 or 1 and verifying that the panel produces power or not.\n\n    2. Attitude dependence: Does the spacecraft power output correctly evaluate given the spacecraft attitude?\n\n        This is tested at three values of the attitude corresponding to sun-facing, a 60 degree rotation away\n        from the sun (half power), and a 90 degree rotation away from the sun (expected power).\n\n    3. Orbit dependence: Does distance from the sun impact power generation?\n\n        This is evaluated by testing the solar panel at both Earth (1AU) and Mars (1.52 AU) to see whether\n        power production drops.\n\n    Nominal power generation when face-on towards the Sun at earth is set to be 1372.5398 W, which assumes\n    a 1m^2 solar panel that operates at perfect efficiency.\n    \"\"\"\n\n    panelResults, panelMessage = run(show_plots, orbitDistance, eclipseValue, scAttitude)\n\n    assert panelResults < 1, [panelMessage]",
  "def run(showPlots, orbitDistance, eclipseValue, scAttitude):\n\n    #   Test initialization\n    testFailCount = 0                      \n    testMessages = []                      \n    unitTaskName = \"unitTask\"             \n    unitProcessName = \"TestProcess\"\n\n    #   Specify test-against parameter\n    referencePower = astroFunctions.solarFluxEarth  # W/m^2 at Earth\n    sunDistanceMult = pow(astroFunctions.AU*1000., 2.)/pow(orbitDistance, 2.)\n    scAttMult = np.cos(abs(np.arccos(0.5 * (np.trace(rbk.MRP2C(scAttitude))-1.))))  # extract cos(prv) to determine the attitude angle vs the sun\n    referenceMultiplier = 1.0 * eclipseValue * sunDistanceMult * scAttMult  # Nominally set to 1.0; modified by other vals\n\n    #   Simulation set-up\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(1.0)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    #   Input message set-up\n    eclipseMessage = messaging.EclipseMsgPayload()\n    eclipseMessage.shadowFactor = eclipseValue  # Set it to be totally in shadow\n    eclipseMsg = messaging.EclipseMsg().write(eclipseMessage)\n\n\n    sunMessage = messaging.SpicePlanetStateMsgPayload()\n    sunMessage.PlanetName = \"Sun\"\n    sunMessage.PositionVector = [0, 0, 0]\n    sunMsg = messaging.SpicePlanetStateMsg().write(sunMessage)\n\n    scMessage = messaging.SCStatesMsgPayload()\n    scMessage.r_BN_N = [-orbitDistance, 0, 0]\n    scMessage.sigma_BN = scAttitude\n    scMsg = messaging.SCStatesMsg().write(scMessage)\n\n    #   Module set-up\n    panel = simpleSolarPanel.SimpleSolarPanel()\n    panel.setPanelParameters(np.array([1, 0, 0]), 1.0, 1.0)\n    panel.stateInMsg.subscribeTo(scMsg)\n    panel.sunEclipseInMsg.subscribeTo(eclipseMsg)\n    panel.sunInMsg.subscribeTo(sunMsg)\n\n    unitTestSim.AddModelToTask(unitTaskName, panel)\n    \n    dataLog = panel.nodePowerOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    #   Execute the sim for 1 second.\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))\n    \n    unitTestSim.ExecuteSimulation()\n\n    powerData = dataLog.netPower\n\n    tol = 1e-7\n\n    if not unitTestSupport.isDoubleEqual(powerData[1], referencePower*referenceMultiplier, tol):\n        testFailCount += 1\n        testMessages.append('Error: simpleSolarPanel did not compute power correctly.')\n    \n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots):\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = storage_limits(show_plots)\n    assert testResults < 1, testMessage",
  "def storage_limits(show_plots):\n    \"\"\"\n    **Validation Test Description**\n\n    1. Whether the simpleBattery can add multiple nodes (core base class functionality);\n    2. That the battery correctly evaluates how much stored power it should have given a pair of five-watt input messages.\n\n    :param show_plots: Not used; no plots to be shown.\n\n    :return:\n    \"\"\"\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.1)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    test_battery = simplePowerMonitor.SimplePowerMonitor()\n    test_battery.storedCharge_Init = 0\n\n    powerMsg1 = messaging.PowerNodeUsageMsgPayload()\n    powerMsg1.netPower = 5.0\n    pw1Msg = messaging.PowerNodeUsageMsg().write(powerMsg1)\n    powerMsg2 = messaging.PowerNodeUsageMsgPayload()\n    powerMsg2.netPower = 5.0\n    pw2Msg = messaging.PowerNodeUsageMsg().write(powerMsg2)\n\n\n    # Test the addNodeToStorage method:\n    test_battery.addPowerNodeToModel(pw1Msg)\n    test_battery.addPowerNodeToModel(pw2Msg)\n    unitTestSim.AddModelToTask(unitTaskName, test_battery)\n\n    dataLog = test_battery.batPowerOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))\n\n    unitTestSim.ExecuteSimulation()\n\n    storedChargeLog = dataLog.storageLevel\n    capacityLog = dataLog.storageCapacity\n    netPowerLog = dataLog.currentNetPower\n\n    #   Check 1 - is net power equal to 10.?\n    for ind in range(0,len(netPowerLog)):\n        currentPower = netPowerLog[ind]\n        if currentPower < 10.:\n            testFailCount +=1\n            testMessages.append(\"FAILED: SimplePowerMonitor did not correctly log the net power.\")\n\n    #   Check 2 - is the stored power equivalent to 10*5 W-s?\n\n    if not unitTestSupport.isDoubleEqualRelative((10.),storedChargeLog[-1], 1e-8):\n        testFailCount+=1\n        testMessages.append(\"FAILED: SimplePowerMonitor did not track integrated power. Returned \"+str(storedChargeLog[-1,1])+\", expected \"+str((10.)))\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots):\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = storage_limits(show_plots)\n    assert testResults < 1, testMessage",
  "def storage_limits(show_plots):\n    \"\"\"\n    **Validation Test Description**\n\n    1. Whether the simpleBattery can add multiple nodes (core base class functionality);\n    2. That the battery correctly evaluates how much stored power it should have given a pair of five-watt\n       input messages.\n\n    :param show_plots: Not used; no plots to be shown.\n\n    :return:\n    \"\"\"\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.1)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    test_battery = simpleBattery.SimpleBattery()\n    test_battery.storedCharge_Init = 5.\n    test_battery.storageCapacity = 10.  # 10 W-s capacity.\n\n    powerMsg1 = messaging.PowerNodeUsageMsgPayload()\n    powerMsg1.netPower = 5.0\n    pw1Msg = messaging.PowerNodeUsageMsg().write(powerMsg1)\n    powerMsg2 = messaging.PowerNodeUsageMsgPayload()\n    powerMsg2.netPower = 5.0\n    pw2Msg = messaging.PowerNodeUsageMsg().write(powerMsg2)\n\n    # Test the addNodeToStorage method:\n    test_battery.addPowerNodeToModel(pw1Msg)\n    test_battery.addPowerNodeToModel(pw2Msg)\n\n    unitTestSim.AddModelToTask(unitTaskName, test_battery)\n\n    dataLog = test_battery.batPowerOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(5.0))\n\n    unitTestSim.ExecuteSimulation()\n\n    storedChargeLog = dataLog.storageLevel\n    capacityLog = dataLog.storageCapacity\n    netPowerLog = dataLog.currentNetPower\n\n    #   Check 1 - is net power equal to 10.?\n    for ind in range(0,len(netPowerLog)):\n        currentPower = netPowerLog[ind]\n        if currentPower !=10.:\n            testFailCount +=1\n            testMessages.append(\"FAILED: SimpleBattery did not correctly log the net power.\")\n\n    if not unitTestSupport.isDoubleEqualRelative((10.),storedChargeLog[-1], 1e-8):\n        testFailCount+=1\n        testMessages.append(\"FAILED: SimpleBattery did not track integrated power. Returned \"+str(storedChargeLog[-1,1])+\", expected \"+str((10.)))\n\n\n    for ind in range(0,len(storedChargeLog)):\n        if storedChargeLog[ind] > capacityLog[ind]:\n            testFailCount +=1\n            testMessages.append(\"FAILED: SimpleBattery's stored charge exceeded its capacity.\")\n\n        if storedChargeLog[ind] < 0.:\n            testFailCount +=1\n            testMessages.append(\"FAILED: SimpleBattery's stored charge was negative.\")\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_sensorThermal(show_plots, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test script tests the temperature modeling of a sensor with an insulated back and a power input as it\n    radiates to the outside environment and takes in heat from the sun. This module tests temperature change in three\n    separate cases:\n\n    - Zero: The starting temperature is zero degrees Celsius.\n    - Hot: The starting temperature is the converged hot temperature case at approximately 98 degrees Celsius.\n    - Cold: the starting temperature is the converged cold temperature case at approximately -75 degrees Celsius.\n\n    The thermal sensor is set to match the parameters in `scenarioSensorThermal.py`, which assumes a 2 kg aluminum\n    sensor with the reflectivity and absorptivity coefficients of kapton tape. The sensor is in orbit about the Earth\n    and is set to point directly in the direction of the sun.\n\n    **Test Parameters**\n\n    Args:\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    In this file we are checking the values of the variables\n\n    - ``sensorTemp``\n\n    which represents the temperature of the sensor. This array is compared to the ``truthTemp`` array, which contains\n    the true values of the temperature.\n    \"\"\"\n    [testResults, testMessage] = sensorThermalTest(show_plots, accuracy)\n    assert testResults < 1, testMessage",
  "def sensorThermalTest(show_plots, accuracy):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    # Create simulation variable names\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # set the simulation time variable used later on\n    simulationTime = macros.sec2nano(1.)\n\n    #\n    #  create the simulation process\n    #\n\n    testProcessRate = macros.sec2nano(1.0)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    #\n    #   setup the simulation tasks/objects\n    #\n\n    #  set device status message\n    sensorStatusMsgPayload = messaging.DeviceStatusMsgPayload()\n    sensorStatusMsgPayload.deviceStatus = 1\n    sensorStatusMsg = messaging.DeviceStatusMsg().write(sensorStatusMsgPayload)\n\n    #  set the spacecraft message\n    scStateMsgPayload = messaging.SCStatesMsgPayload()\n    scStateMsgPayload.r_BN_N = [6378*1000., 0., 0.]\n    scStateMsgPayload.sigma_BN = [0., 0., 0.]\n    scStateMsg = messaging.SCStatesMsg().write(scStateMsgPayload)\n\n    #  set the sun message\n    sunMsgPayload = messaging.SpicePlanetStateMsgPayload()\n    sunMsgPayload.PositionVector = [astroFunctions.AU*1000., 0., 0.]\n    sunMsg = messaging.SpicePlanetStateMsg().write(sunMsgPayload)\n\n\n    #\n    #   Setup the temperature modeling\n    #\n    sensorThermalModel = sensorThermal.SensorThermal()\n    sensorThermalModel.ModelTag = 'sensorThermalModel'\n    sensorThermalModel.nHat_B = [0, 0, 1]\n    sensorThermalModel.sensorArea = 1.0  # m^2\n    sensorThermalModel.sensorAbsorptivity = 0.25\n    sensorThermalModel.sensorEmissivity = 0.34\n    sensorThermalModel.sensorMass = 2.0  # kg\n    sensorThermalModel.sensorSpecificHeat = 890\n    sensorThermalModel.sensorPowerDraw = 30.0  # W\n    sensorThermalModel.T_0 = 0  # [\u00baC]\n    sensorThermalModel.sunInMsg.subscribeTo(sunMsg)\n    sensorThermalModel.stateInMsg.subscribeTo(scStateMsg)\n    sensorThermalModel.sensorStatusInMsg.subscribeTo(sensorStatusMsg)\n    unitTestSim.AddModelToTask(unitTaskName, sensorThermalModel)\n\n    #\n    # log data\n    #\n\n    # log the RW temperature\n    tempLog = sensorThermalModel.temperatureOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, tempLog)\n\n    #\n    #   initialize Simulation\n    #\n\n    unitTestSim.InitializeSimulation()\n    numTests = 0\n\n    # run the first test (nominal)\n    unitTestSim.ConfigureStopTime(simulationTime)\n    unitTestSim.ExecuteSimulation()\n    numTests += 1\n\n    # sensorThermalModel the test conditions\n    sensorThermalModel.T_0 = 97.961\n    sensorThermalModel.Reset(simulationTime)\n\n    # run the second test (hot case)\n    unitTestSim.ConfigureStopTime(2*simulationTime)\n    unitTestSim.ExecuteSimulation()\n    numTests += 1\n\n    # change the test conditions\n    sensorThermalModel.T_0 = -74.8505\n    sensorThermalModel.Reset(2*simulationTime)\n\n    # run the second test (cold case)\n    unitTestSim.ConfigureStopTime(3*simulationTime)\n    unitTestSim.ExecuteSimulation()\n    numTests += 1\n\n    #\n    # retrieve the logged data\n    #\n\n    sensorTemp = np.array(tempLog.temperature)\n\n    #\n    # set the truth vectors\n    #\n\n    trueTemp = np.array([0.0, -0.0443986873, 97.7691478, -74.8506601])\n\n    #\n    # compare the module results to the true values\n    #\n\n    # do the comparison\n    for i in range(numTests):\n        # check a vector values\n        if not unitTestSupport.isDoubleEqual(sensorTemp[i], trueTemp[i], accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Sensor Temperature Test failed test \" + str(i+1) + \"\\n\")\n\n    if not testFailCount:\n        print(\"PASSED\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_motorThermal(show_plots, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test script tests the temperature modelling of a general motor (in this case a reaction wheel). It sets up\n    the reaction wheel and runs 4 test scenarios:\n\n    - Nominal: the motor starts at the same temperature as the air surrounding it (20 degrees Celsius).\n    - Motor is colder: the motor starts at a lower temperature (0 degrees Celsius) than the ambient temperature (20\n      degrees Celsius).\n    - Motor is hotter: the motor starts at a higher temperature (20 degrees Celsius) than the ambient temperature (0\n      degrees Celsius).\n    - Motor is hotter and friction is accounted for: the motor starts at a higher temperature (20 degrees Celsius) than\n      the ambient temperature (0 degrees Celsius) and friction is modelled.\n\n    The sole reaction wheel is set up using the reaction wheel state effector, while taking advantage of the ability to\n    change the reaction wheel's properties on the fly. For simplicity, the torque is constant and set to the maximum\n    value that the reaction wheel can handle. Finally, the temperature modelling comes from this motorThermal module.\n\n    The limitations of this test are the same as the ones discussed on the module's .rst file. also, the value of the\n    accuracy used is the limit for the test to pass.\n\n    **Test Parameters**\n\n    Args:\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    In this file we are checking the values of the variables\n\n    - ``rwTemp``\n\n    which represents the array of motor temperatures. This array is compared to the ``truthTemp`` array, which contains\n    the true values of the temperature.\n    \"\"\"\n    [testResults, testMessage] = motorThermalTest(show_plots, accuracy)\n    assert testResults < 1, testMessage",
  "def motorThermalTest(show_plots, accuracy):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    # Create simulation variable names\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # set the simulation time variable used later on\n    simulationTime = macros.sec2nano(1.)\n\n    #\n    #  create the simulation process\n    #\n\n    testProcessRate = macros.sec2nano(0.1)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    #\n    #   setup the simulation tasks/objects\n    #\n\n    # create the spacecraft object\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    #\n    # add RW devices\n    #\n\n    # make a fresh RW factory instance, this is critical to run multiple times\n    rwFactory = simIncludeRW.rwFactory()\n\n    # store the RW dynamical model type\n    varRWModel = messaging.BalancedWheels\n\n    # create the reaction wheels\n    RW = rwFactory.create('Honeywell_HR16',\n                          [1, 0, 0],  # gsHat_B\n                          Omega=4000.,  # RPM\n                          maxMomentum=50.,\n                          RWModel=varRWModel,\n                          useRWfriction=True\n                          )\n    numRW = rwFactory.getNumOfDevices()\n\n    # set maximum values for RW speed\n    # RW1.Omega_max = 500 * macros.RPM\n\n    # create RW object container and tie to spacecraft object\n    rwStateEffector = reactionWheelStateEffector.ReactionWheelStateEffector()\n    rwStateEffector.ModelTag = \"ReactionWheel\"\n    rwFactory.addToSpacecraft(rwStateEffector.ModelTag, rwStateEffector, scObject)\n\n    # set RW torque command\n    cmdArray = messaging.ArrayMotorTorqueMsgPayload()\n    cmdArray.motorTorque = [50, 0, 0]  # [Nm]\n    cmdMsg = messaging.ArrayMotorTorqueMsg().write(cmdArray)\n    rwStateEffector.rwMotorCmdInMsg.subscribeTo(cmdMsg)\n\n    #\n    #   Setup the temperature modelling\n    #\n\n    thermalModel = motorThermal.MotorThermal()\n    thermalModel.ModelTag = 'rwThermals'\n    thermalModel.currentTemperature = 0  # [\u00baC]\n    thermalModel.efficiency = 0.5\n    thermalModel.ambientThermalResistance = 10\n    thermalModel.motorHeatCapacity = 10\n    thermalModel.rwStateInMsg.subscribeTo(rwStateEffector.rwOutMsgs[0])\n\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, rwStateEffector)\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n    unitTestSim.AddModelToTask(unitTaskName, thermalModel)\n\n    #\n    # log data\n    #\n\n    # log the RW temperature\n    tempLog = thermalModel.temperatureOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, tempLog)\n\n    #\n    #   initialize Simulation\n    #\n\n    unitTestSim.InitializeSimulation()\n    numTests = 0\n\n    # run the first test (nominal)\n    unitTestSim.ConfigureStopTime(simulationTime)\n    unitTestSim.ExecuteSimulation()\n    numTests += 1\n\n    # change the test conditions\n    thermalModel.currentTemperature = 0\n    thermalModel.ambientTemperature = 20\n\n    # run the second test (motor is colder than ambient)\n    unitTestSim.ConfigureStopTime(2*simulationTime)\n    unitTestSim.ExecuteSimulation()\n    numTests += 1\n\n    # change the test conditions\n    thermalModel.currentTemperature = 20\n    thermalModel.ambientTemperature = 0\n\n    # run the second test (motor is hotter than ambient)\n    unitTestSim.ConfigureStopTime(3*simulationTime)\n    unitTestSim.ExecuteSimulation()\n    numTests += 1\n\n    # change the test conditions\n    thermalModel.currentTemperature = 20\n    thermalModel.ambientTemperature = 0\n    RW.useRWfriction = True\n\n    # run the second test (motor is hotter than ambient and friction is used)\n    unitTestSim.ConfigureStopTime(4*simulationTime)\n    unitTestSim.ExecuteSimulation()\n    numTests += 1\n\n    #\n    # retrieve the logged data\n    #\n\n    rwTemp = np.array(tempLog.temperature)\n\n    #\n    # set the truth vectors\n    #\n\n    trueTemp = np.array([0.83985244, 1.67941113, 2.51867637, 3.35764846, 4.19632769,\n                         5.03471435, 5.87280873, 6.71061112, 7.54812182, 8.38534113, 0.86531353,\n                         1.73030786, 2.59498331, 3.45934019, 4.32337882, 5.18709952, 6.05050261,\n                         6.91358841, 7.77635723, 8.6388094, 20.83077463, 21.6612646, 22.49147018,\n                         23.32139167, 24.15102935, 24.9803835, 25.8094544, 26.63824235, 27.46674761,\n                         28.29497048, 20.83623573, 21.67218133, 22.50783709, 23.34320331, 24.17828028,\n                         25.01306827, 25.84756759, 26.68177852, 27.51570134, 28.34933636])\n\n    #\n    # compare the module results to the true values\n    #\n\n    # do the comparison\n\n    for i in range(numTests):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(rwTemp[10*i+1:10*i+11], trueTemp[10*i:10*i+10], 10, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Motor Temperature Test failed test \" + str(i+1) + \"\\n\")\n\n    if not testFailCount:\n        print(\"PASSED\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_stateArchitectureAllTests(show_plots, function):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = eval(function + '(show_plots)')\n    assert testResults < 1, testMessage",
  "def stateData(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    stateUse = [[10.0], [20.0]]\n    stateName = \"position\"\n    newState = stateArchitecture.StateData(stateName, stateUse)\n    newState.setState(stateUse)\n    \n    predictedDerivative = [[0.0], [0.0]]\n\n    if(newState.getRowSize() != len(stateUse)):\n        testFailCount += 1\n        testMessages.append(\"State row sized incorrectly\") \n    if(newState.getColumnSize() != len(stateUse[0])):\n        testFailCount += 1\n        testMessages.append(\"State column sized incorrectly\") \n    if(newState.getName() != stateName):\n        testFailCount += 1\n        testMessages.append(\"State name incorrect\")\n    if(newState.getState() != stateUse):\n        testFailCount += 1\n        testMessages.append(\"State equality check failure.\")\n    if(newState.getStateDeriv() != predictedDerivative):\n        testFailCount += 1\n        testMessages.append(\"State derivative zero check failure.\")\n\n    derivativeInc = [[1.0], [2.5]]\n    newState.setDerivative(derivativeInc)\n    newState.propagateState(0.1)\n\n    predictedDerivativeNum = numpy.array(predictedDerivative) + numpy.array(derivativeInc)\n    obsDerivativeNum = numpy.array(newState.getStateDeriv())\n    if(obsDerivativeNum.tolist() != predictedDerivativeNum.tolist()):\n        testFailCount += 1\n        testMessages.append(\"State derivative update check failure.\")\n\n    stateUpdateNum = numpy.array(newState.getState())\n    predUpStateNum = numpy.array(stateUse) + predictedDerivativeNum*0.1\n    if(stateUpdateNum.tolist() != stateUpdateNum.tolist()):\n        testFailCount += 1\n        testMessages.append(\"State propagation update check failure.\")\n    \n    priorState = stateUpdateNum\n    scaleFactor = 0.25\n    priorState *= scaleFactor\n    outState = newState*scaleFactor\n    newState.scaleState(scaleFactor)\n    stateUpdateNum = numpy.array(newState.getState())\n    if(stateUpdateNum.tolist() != priorState.tolist()):\n        testFailCount += 1\n        testMessages.append(\"State scaling update check failure.\")\n    if(outState.getState() != newState.getState()):\n        testFailCount += 1\n        testMessages.append(\"State scaling via * operator check failure.\")\n\n\n    dummyState = stateArchitecture.StateData()\n    if(dummyState.getRowSize() != 0):\n        testFailCount += 1\n        testMessages.append(\"Dummy state row sized incorrectly\")\n    if(dummyState.getColumnSize() != 0):\n        testFailCount += 1\n        testMessages.append(\"Dummy state column sized incorrectly\")\n\n    dummyState.setState(newState.getState())\n    \n    outState = dummyState + newState\n    if(outState.getState() != (2.0*stateUpdateNum).tolist()):\n        testFailCount += 1\n        testMessages.append(\"Plus operator failed on StateData\")\n\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" State data\")\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def stateProperties(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    newManager = stateArchitecture.DynParamManager()\n\n    gravList = [[9.81], [0.0], [0.1]]\n    gravName = \"g_N\"\n    newManager.createProperty(gravName, gravList)\n    \n    propRef = newManager.getPropertyReference(gravName)\n    \n    if propRef != gravList:\n        testFailCount += 1\n        testMessages.append(\"Create and property reference matching failed.\")\n    \n    newGravList = [[0.0], [9.81], [-0.1]]\n    newManager.setPropertyValue(gravName, newGravList)\n    propRef = newManager.getPropertyReference(gravName)\n    if propRef != newGravList:\n        testFailCount += 1\n        testMessages.append(\"Set and property reference matching failed.\")\n\n    newGravList = [[0.0], [9.81*2], [-0.1]]\n    newManager.createProperty(gravName, newGravList)\n    propRef = newManager.getPropertyReference(gravName)\n    if propRef != newGravList:\n        testFailCount += 1\n        testMessages.append(\"Set and property reference matching failed.\")\n\n    wrongGravList = [[0.0], [9.81], [-0.1]]\n    newManager.setPropertyValue(gravName+\"Scott\", newGravList)\n    propRef = newManager.getPropertyReference(gravName+\"Scott\")\n    if propRef != None:\n        testFailCount += 1\n        testMessages.append(\"Set and property reference matching failed.\")\n\n    massList = [[1500.0]]\n    massName = \"mass\"\n    newManager.createProperty(massName, massList)\n    massRef = newManager.getPropertyReference(massName)\n    if massRef != massList:\n        testFailCount += 1\n        testMessages.append(\"1x1 Eigen property creation failed.\")\n\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" State properties\")\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def stateArchitectureTest(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    newManager = stateArchitecture.DynParamManager()\n    \n    positionName = \"position\"\n    stateDim = [3, 1]\n    posState = newManager.registerState(stateDim[0], stateDim[1], positionName)\n    \n    velocityName = \"velocity\"\n    stateDim = [3, 1]\n    velState = newManager.registerState(stateDim[0], stateDim[1], velocityName)\n    \n    flexName = \"Array1_flex\"\n    flexDim = [2, 1]\n    flexState = newManager.registerState(flexDim[0], flexDim[1], flexName)\n    \n    if posState.getRowSize() != stateDim[0] or posState.getColumnSize() != stateDim[1]:\n        testFailCount += 1\n        testMessages.append(\"Position state returned improper size\")\n    \n    if velState.getName() != velocityName:\n        testFailCount += 1\n        testMessages.append(\"Failed to return proper state name for velocity\")\n    \n    if(newManager.registerState(stateDim[0], stateDim[1], positionName).getName() != positionName):\n        testFailCount += 1\n        testMessages.append(\"Failed to return proper state name in overload of call\")\n    newManager.registerState(stateDim[0], stateDim[1]+2, positionName)\n    \n    positionStateLookup = newManager.getStateObject(\"Array1_flex\")\n\n    if(positionStateLookup.getName() != flexName):\n        testFailCount += 1\n        testMessages.append(\"State lookup for solar array flex failed\")\n    \n    vectorFactor = 4.0\n    vecStart = [[1.0], [2.0], [3.5]]\n    posState.setState(vecStart)\n    velState.setState(vecStart)\n    vectorStart = newManager.getStateVector()\n    vectorComposite = vectorStart + vectorStart*vectorFactor + vectorStart*vectorFactor\n    numpyOutput = numpy.array(vecStart) + numpy.array(vecStart)*vectorFactor + numpy.array(vecStart)*vectorFactor\n    newManager.updateStateVector(vectorComposite)\n    \n    if(velState.getState() != numpyOutput.tolist()):\n        testFailCount += 1\n        testMessages.append(\"Velocity state update via state-manager failed\")\n\n    dt = 1.0;\n    posState.setDerivative(vecStart)\n    newManager.propagateStateVector(dt)\n    numpyOutput += numpy.array(vecStart)*dt\n    if(posState.getState() != numpyOutput.tolist()):\n        testFailCount += 1\n        testMessages.append(\"Position state propagation via state-manager failed\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" State manager\")\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def EigenConversions(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    inputArray = [[3.0], [1.0], [2.0]]\n    outputArray = sim_model.new_doubleArray(3)\n    stateArchitecture.eigenVector3d2CArray(inputArray, outputArray)\n    \n    flatList =  [y for x in inputArray for y in x]\n\n    for i in range(len(flatList)):\n        if(flatList[i] != sim_model.doubleArray_getitem(outputArray, i)):\n            testFailCount += 1\n            testMessages.append(\"3-vector conversion failed\")\n\n    inputArray = [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]\n    outputArray = sim_model.new_doubleArray(9)\n    stateArchitecture.eigenMatrix3d2CArray(inputArray, outputArray)\n    \n    flatList =  [y for x in inputArray for y in x]\n\n    for i in range(len(flatList)):\n        if(flatList[i] != sim_model.doubleArray_getitem(outputArray, i)):\n            print(sim_model.doubleArray_getitem(outputArray, i))\n            testFailCount += 1\n            testMessages.append(\"3x3 matrix conversion failed\")\n\n    inputArray = [[0.0, 1.0, 0.0, 2.0], [0.0, 0.0, 1.0, 0.5], [1.0, 0.0, 0.0, 2.7]]\n    outputArray = sim_model.new_doubleArray(12)\n    stateArchitecture.eigenMatrixXd2CArray(inputArray, outputArray)\n    \n    flatList =  [y for x in inputArray for y in x]\n\n    for i in range(len(flatList)):\n        if(flatList[i] != sim_model.doubleArray_getitem(outputArray, i)):\n            print(sim_model.doubleArray_getitem(outputArray, i))\n            testFailCount += 1\n            testMessages.append(\"3x4 matrix conversion failed\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Eigen Conversions\")\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def test_msmForceTorque(show_plots, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    The behavior of the MSM e-force and torque evaluation is tested.  3 space objects locations and\n    orientations are setup.  Each object is assigned 2-3 sphere locations and radii.  The voltage\n    input messages are setup such that each space object has its own potential.  The simulation\n    is run for a single update cycle and the resulting forces and torques acting on each body\n    are compared to hand-computed truth values.\n\n    **Test Parameters**\n\n    Args:\n        accuracy (float): relative accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    The module output messages for the inertial force vector and body torque vector are compared to\n    hand-calculated truth values using their relative accuracy.\n    \"\"\"\n    [testResults, testMessage] = msmForceTorqueTestFunction(show_plots, accuracy)\n    assert testResults < 1, testMessage",
  "def msmForceTorqueTestFunction(show_plots, accuracy):\n    \"\"\"Test method\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(0.5)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    module = msmForceTorque.MsmForceTorque()\n    module.ModelTag = \"msmForceTorqueTag\"\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Configure space object state and voltage input messages\n    sc0StateInMsgsData = messaging.SCStatesMsgPayload()\n    sc0StateInMsgsData.r_BN_N = [10., 2., 3.]\n    sc0StateInMsgsData.sigma_BN = [0.1, 0.2, 0.3]\n    sc0StateInMsg = messaging.SCStatesMsg().write(sc0StateInMsgsData)\n\n    sc1StateInMsgsData = messaging.SCStatesMsgPayload()\n    sc1StateInMsgsData.r_BN_N = [-10., -2., 3.]\n    sc1StateInMsgsData.sigma_BN = [-0.1, 0.2, 0.3]\n    sc1StateInMsg = messaging.SCStatesMsg().write(sc1StateInMsgsData)\n\n    sc2StateInMsgsData = messaging.SCStatesMsgPayload()\n    sc2StateInMsgsData.r_BN_N = [1., 1., 0.]\n    sc2StateInMsgsData.sigma_BN = [0.1, 0.2, -0.3]\n    sc2StateInMsg = messaging.SCStatesMsg().write(sc2StateInMsgsData)\n\n    volt0InMsgData = messaging.VoltMsgPayload()\n    volt0InMsgData.voltage = 30000.\n    volt0InMsg = messaging.VoltMsg().write(volt0InMsgData)\n\n    volt1InMsgData = messaging.VoltMsgPayload()\n    volt1InMsgData.voltage = -10000.\n    volt1InMsg = messaging.VoltMsg().write(volt1InMsgData)\n\n    volt2InMsgData = messaging.VoltMsgPayload()\n    volt2InMsgData.voltage = 20000.\n    volt2InMsg = messaging.VoltMsg().write(volt2InMsgData)\n\n    # create a list of sphere body-fixed locations and associated radii\n    spPosList = [\n        [1., 2., 3.]\n        , [4., 5., 6.]\n        , [14., 5., 6.]\n    ]\n    rList = [1., 2., 1.5]\n\n    # add spacecraft to state\n    module.addSpacecraftToModel(sc0StateInMsg\n                                , messaging.DoubleVector(rList[:-1])\n                                , unitTestSupport.npList2EigenXdVector(spPosList[:-1]))\n    module.addSpacecraftToModel(sc1StateInMsg\n                                , messaging.DoubleVector(rList)\n                                , unitTestSupport.npList2EigenXdVector(spPosList))\n    module.addSpacecraftToModel(sc2StateInMsg\n                                , messaging.DoubleVector(rList[:-1])\n                                , unitTestSupport.npList2EigenXdVector(spPosList[:-1]))\n\n    # subscribe input messages to module\n    module.voltInMsgs[0].subscribeTo(volt0InMsg)\n    module.voltInMsgs[1].subscribeTo(volt1InMsg)\n    module.voltInMsgs[2].subscribeTo(volt2InMsg)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.TotalSim.SingleStepProcesses()\n\n    # set truth force and torque values\n    fTruth = [\n        [6.48179e-05, 0.00147205, 0.000924806]\n        , [0.00107182, -0.000240543, 0.000110224]\n        , [-0.00113664, -0.00123151, -0.00103503]\n    ]\n    tauTruth = [\n        [-0.00268192, 0.00295288, -0.000603687]\n        , [0.00688387, -0.00209438, -0.00647544]\n        , [0.00581629, 0.007876, -0.00986612]\n    ]\n    chargeTruth = [\n        [1.99932e-6, 5.73861e-6]\n        , [-1.06715e-6, -2.51072e-6, -1.94044e-6]\n        , [1.30148e-6, 3.23131e-6]\n    ]\n\n    # pull module data and make sure it is correct\n    for i in range(3):\n        f = module.eForceOutMsgs[i].read().forceRequestInertial\n        testFailCount, testMessages = \\\n            unitTestSupport.compareDoubleArrayRelative(f, fTruth[i],\n                                                       accuracy, \"sc\" + str(i) + \" force test\",\n                                                       testFailCount, testMessages)\n        tau = module.eTorqueOutMsgs[i].read().torqueRequestBody\n        testFailCount, testMessages = \\\n            unitTestSupport.compareDoubleArrayRelative(tau, tauTruth[i],\n                                                       accuracy, \"sc\" + str(i) + \" torque test\",\n                                                       testFailCount, testMessages)\n\n        charge = unitTestSupport.columnToRowList(module.chargeMsmOutMsgs[i].read().q)\n        testFailCount, testMessages = \\\n            unitTestSupport.compareListRelative(charge, chargeTruth[i],\n                                                       accuracy, \"sc\" + str(i) + \" charge test\",\n                                                       testFailCount, testMessages)\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, \"\".join(testMessages)]",
  "def listStack(vec,simStopTime,unitProcRate):\n    # returns a list duplicated the number of times needed to be consistent with module output\n    return [vec] * int(simStopTime/(float(unitProcRate)/float(macros.sec2nano(1))))",
  "def writeNewRWCmds(self, u_cmd, numRW):\n    # create standard vector from SWIG template (see .i file)\n    NewRWCmdsVec = messaging.RWCmdMsgPayloadVector(numRW)\n\n    cmds = messaging.RWCmdMsgPayload()\n    for i in range(0, numRW):\n        cmds.u_cmd = u_cmd[i]\n        NewRWCmdsVec[i] = cmds  # set the data\n        self.NewRWCmds = NewRWCmdsVec",
  "def defaultReactionWheel():\n    RW = messaging.RWConfigMsgPayload()\n    RW.rWB_B = [[0.], [0.], [0.]]\n    RW.gsHat_B = [[1.], [0.], [0.]]\n    RW.w2Hat0_B = [[0.], [1.], [0.]]\n    RW.w3Hat0_B = [[0.], [0.], [1.]]\n    RW.RWModel = reactionWheelStateEffector.BalancedWheels\n    return RW",
  "def asEigen(v):\n    out = []\n    for i in range(0, len(v)):\n        out.append([v[i]])\n    return out",
  "def test_unitSimReactionWheel(show_plots, useFlag, testCase):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitSimReactionWheel(show_plots, useFlag, testCase)\n    assert testResults < 1, testMessage",
  "def unitSimReactionWheel(show_plots, useFlag, testCase):\n    testFail = False\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    # configure module\n    ReactionWheel = reactionWheelStateEffector.ReactionWheelStateEffector()\n    ReactionWheel.ModelTag = \"ReactionWheel\"\n\n    numRW = 2\n\n    RWs = []\n    for i in range(0, numRW):\n        RWs.append(defaultReactionWheel())\n\n    expOut = dict()  # expected output\n\n    print(testCase)\n    if testCase == 'basic':\n        pass\n\n    elif testCase == 'saturation':\n        RWs.append(defaultReactionWheel())\n        RWs[0].u_max = 1.\n        RWs[1].u_max = 2.\n        RWs[2].u_max = 2.\n        u_cmd = [-1.2, 1.5, 2.5]\n        writeNewRWCmds(ReactionWheel, u_cmd, len(RWs))\n\n        expOut['u_current'] = [-1., 1.5, 2.]\n\n    elif testCase == 'minimum':\n        RWs[0].u_min = .1\n        RWs[1].u_min = .0\n        u_cmd = [-.09, 0.0001]\n        writeNewRWCmds(ReactionWheel, u_cmd, len(RWs))\n\n        expOut['u_current'] = [0., 0.0001]\n\n    elif testCase == 'speedSaturation':\n        RWs.append(defaultReactionWheel())\n        RWs[0].Omega_max = 50.\n        RWs[1].Omega_max = 50.\n        RWs[2].Omega_max = 50.\n        RWs[0].Omega = 49.\n        RWs[1].Omega = 51.\n        RWs[2].Omega = -52.\n        u_cmd = [1.5, 1.5, 1.5]\n        writeNewRWCmds(ReactionWheel, u_cmd, len(RWs))\n\n        expOut['u_current'] = [1.5, 0.0, 1.5]\n\n    elif testCase == 'powerSaturation':\n        RWs.append(defaultReactionWheel())\n        RWs[0].P_max = 1.\n        RWs[1].P_max = 1.\n        RWs[2].P_max = 1.\n        RWs[0].Omega = 50.\n        RWs[1].Omega = 50.\n        RWs[2].Omega = 50.\n        u_cmd = [0.01, -0.04, 0.04]\n        writeNewRWCmds(ReactionWheel, u_cmd, len(RWs))\n\n        expOut['u_current'] = [0.01, -0.02, 0.02]\n\n    else:\n        raise Exception('invalid test case')\n\n    for i in range(0, len(RWs)):\n        ReactionWheel.addReactionWheel(RWs[i])\n\n    ReactionWheel.ConfigureRWRequests(0.)\n\n    if 'accuracy' not in vars():\n        accuracy = 1e-10\n\n    for outputName in list(expOut.keys()):\n        for i in range(0, len(RWs)):\n            if expOut[outputName][i] != ReactionWheel.ReactionWheelData[i].u_current:\n                print(\"expected: \" + str(expOut[outputName][i]))\n                print(\"got :\" + str(ReactionWheel.ReactionWheelData[i].u_current))\n                testFail = 1\n                break\n        if testFail:\n            break\n\n    if testFail:\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + ReactionWheel.ModelTag + \" Module failed \" +\n                            outputName + \" unit test\")\n\n    np.set_printoptions(precision=16)\n\n    # print out success message if no errors were found\n    if testFailCount == 0:\n        print(\"PASSED \")\n        colorText = 'ForestGreen'\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        passedText = r'\\textcolor{' + colorText + '}{' + \"FAILED\" + '}'\n\n    # Write some snippets for AutoTex\n    snippetName = testCase + 'PassFail'\n    unitTestSupport.writeTeXSnippet(snippetName, passedText, path)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_RWUpdate(show_plots, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    The objective of this script is to test the functionality of changing the reaction wheel (RW) characteristics while\n    the simulation is running. It starts by testing the initial setup, and then does four additional tests: the first\n    two change the maximum allowed torque, the third one changes the maximum power limit, and the final one changes the \n    current wheel speeds and maximum allowed wheel speeds. All these tests rely on the fact that, when a maximum or \n    minimum value is surpassed, the applied torque is capped accordingly.\n\n    As this test script is not parameterized, only one version of this script will run.\n\n    **Description of Variables Being Tested**\n\n    As discussed, in this file we check the values of the applied torque for each reaction wheel ``i``:\n\n    - ``rwStateEffector.rwOutMsgs[i].u_current``\n\n    For ease of use, this data is stored in ``dataRW``, which is then used to check if the tests are being passed.\n    \"\"\"\n    [testResults, testMessage] = RWUpdateTest(show_plots, accuracy)\n    assert testResults < 1, testMessage",
  "def RWUpdateTest(show_plots, accuracy):\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    # Create simulation variable names\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # set the simulation time variable used later on\n    simulationTime = macros.sec2nano(1.)\n\n    #\n    #  create the simulation process\n    #\n\n    testProcessRate = macros.sec2nano(1.)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    #\n    #   setup the simulation tasks/objects\n    #\n\n    # create the spacecraft object\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    #\n    # add RW devices\n    #\n\n    # make a fresh RW factory instance, this is critical to run multiple times\n    rwFactory = simIncludeRW.rwFactory()\n\n    # store the RW dynamical model type\n    varRWModel = messaging.BalancedWheels\n\n    # create the reaction wheels\n    RW1 = rwFactory.create('Honeywell_HR16'\n                           , [1, 0, 0]  # gsHat_B\n                           , Omega=500.  # RPM\n                           , maxMomentum=50.\n                           , RWModel=varRWModel\n                           )\n    RW2 = rwFactory.create('Honeywell_HR16'\n                           , [0, 1, 0]  # gsHat_B\n                           , Omega=500.  # RPM\n                           , maxMomentum=50.\n                           , RWModel=varRWModel\n                           )\n    RW3 = rwFactory.create('Honeywell_HR16'\n                           , [0, 0, 1]  # gsHat_B\n                           , Omega=500.  # RPM\n                           , maxMomentum=50.\n                           , RWModel=varRWModel\n                           )\n    numRW = rwFactory.getNumOfDevices()\n\n    # create RW object container and tie to spacecraft object\n    rwStateEffector = reactionWheelStateEffector.ReactionWheelStateEffector()\n    rwStateEffector.ModelTag = \"ReactionWheel\"\n    rwFactory.addToSpacecraft(rwStateEffector.ModelTag, rwStateEffector, scObject)\n\n    # set RW torque command\n    cmdArray = messaging.ArrayMotorTorqueMsgPayload()\n    cmdArray.motorTorque = [0.4, 0.1, -0.5]  # [Nm]\n    cmdMsg = messaging.ArrayMotorTorqueMsg().write(cmdArray)\n    rwStateEffector.rwMotorCmdInMsg.subscribeTo(cmdMsg)\n    trueTorque = [[0.4, 0., -0.5]]\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, rwStateEffector)\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    #\n    # log data\n    #\n\n    rwLogs = []\n    for item in range(numRW):\n        rwLogs.append(rwStateEffector.rwOutMsgs[item].recorder())\n        unitTestSim.AddModelToTask(unitTaskName, rwLogs[item])\n\n    #\n    #   initialize Simulation\n    #\n\n    unitTestSim.InitializeSimulation()\n    numTests = 0\n\n    #\n    # First test\n    #\n\n    # set the maximum torque values\n    RW1.u_max = 0.5\n    RW2.u_max = 0.5\n    RW3.u_max = 0.5\n    RW1.u_min = 0.2\n    RW2.u_min = 0.2\n    RW3.u_min = 0.2\n\n    # configure a simulation stop time and execute the simulation run\n    unitTestSim.ConfigureStopTime(simulationTime)\n    unitTestSim.ExecuteSimulation()\n    numTests += 1\n\n    # expected output\n    trueTorque.append([0.4, 0., -0.5])\n\n    #\n    # Second test\n    #\n\n    # reset the maximum torque values\n    RW1.u_max = 0.3\n    RW2.u_max = 0.3\n    RW3.u_max = 0.3\n    RW1.u_min = 0.05\n    RW2.u_min = 0.05\n    RW3.u_min = 0.05\n\n    # reconfigure a simulation stop time and re-execute the simulation run\n    unitTestSim.ConfigureStopTime(2*simulationTime)\n    unitTestSim.ExecuteSimulation()\n    numTests += 1\n\n    # expected output\n    trueTorque.append([0.3, 0.1, -0.3])\n\n    #\n    # Third test\n    #\n\n    # reset the maximum torque values\n    RW1.P_max = 0.7\n    RW2.P_max = 0.7\n    RW3.P_max = 0.7\n    RW1.Omega = 7\n    RW2.Omega = -5\n    RW3.Omega = 2\n\n    # reconfigure a simulation stop time and re-execute the simulation run\n    unitTestSim.ConfigureStopTime(3*simulationTime)\n    unitTestSim.ExecuteSimulation()\n    numTests += 1\n\n    # expected output\n    trueTorque.append([0.1, 0.1, -0.3])\n\n    #\n    # Fourth test\n    #\n\n    # reset the RW speed and set maximum values\n    RW1.P_max = -1\n    RW2.P_max = -1\n    RW3.P_max = -1\n    RW1.Omega = 100*macros.RPM\n    RW2.Omega = -200*macros.RPM\n    RW3.Omega = 50*macros.RPM\n    RW1.Omega_max = 100*macros.RPM\n    RW2.Omega_max = 100*macros.RPM\n    RW3.Omega_max = 100*macros.RPM\n\n    # reconfigure a simulation stop time and re-execute the simulation run\n    unitTestSim.ConfigureStopTime(4*simulationTime)\n    unitTestSim.ExecuteSimulation()\n    numTests += 1\n\n    # expected output\n    trueTorque.append([0., 0.1, -0.3])\n\n    #\n    # retrieve the logged data\n    #\n\n    dataRW = []\n    for i in range(numRW):\n        dataRW.append(rwLogs[i].u_current)\n    dataRW = np.array(dataRW)\n\n    #\n    # compare the module results to the true values\n    #\n\n    # do the comparison\n    for i in range(numTests+1):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataRW[:, i], trueTorque[i], numRW, accuracy):\n            testFailCount += 1\n            if i == 0:\n                testMessages.append(\"FAILED: Reaction Wheel Update Test failed setup\")\n            else:\n                testMessages.append(\"FAILED: Reaction Wheel Update Test failed test \" + str(i) + \"\\n\")\n\n    if not testFailCount:\n        print(\"PASSED\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_reactionWheelIntegratedTest(show_plots,useFlag,testCase):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = reactionWheelIntegratedTest(show_plots,useFlag,testCase)\n    assert testResults < 1, testMessage",
  "def reactionWheelIntegratedTest(show_plots,useFlag,testCase):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    stepSize = 0.0001\n    if testCase == 'BOE':\n        stepSize = 0.1\n    if testCase == 'FrictionSpinDown' or testCase == 'FrictionSpinUp':\n        stepSize = 0.01\n    if testCase == 'JitterFullyCoupled':\n        stepSize = 0.00001\n    testProcessRate = macros.sec2nano(stepSize)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # add RW devices\n    # The clearRWSetup() is critical if the script is to run multiple times\n    rwFactory = simIncludeRW.rwFactory()\n    varMaxMomentum = 100.            # Nms\n\n    if testCase == 'BalancedWheels' or testCase == 'BOE' or testCase == 'FrictionSpinDown' or testCase == 'FrictionSpinUp':\n        varRWModel = reactionWheelStateEffector.BalancedWheels\n    elif testCase == 'JitterSimple':\n        varRWModel = reactionWheelStateEffector.JitterSimple\n    elif testCase == 'JitterFullyCoupled':\n        varRWModel = reactionWheelStateEffector.JitterFullyCoupled\n\n    if testCase == 'BalancedWheels' or testCase == 'JitterSimple' or testCase == 'JitterFullyCoupled':\n        rwFactory.create(\n                'Honeywell_HR16'\n                ,[1,0,0]                # gsHat_B\n                ,Omega = 500.           # RPM\n                ,rWB_B = [0.1,0.,0.]    # m\n                ,maxMomentum = varMaxMomentum\n                ,RWModel= varRWModel\n                )\n        rwFactory.create(\n                'Honeywell_HR16',\n                [0,1,0]                 # gsHat_B\n                ,Omega = 200.          # RPM\n                ,rWB_B = [0.,0.1,0.]     # m\n                ,maxMomentum = varMaxMomentum\n                ,RWModel= varRWModel\n                )\n        rwFactory.create(\n                'Honeywell_HR16'\n                ,[0,0,1]                 # gsHat_B\n                ,Omega = -150.           # RPM\n                ,rWB_B = [0.,0.,0.1]     # m\n                ,maxMomentum = varMaxMomentum\n                ,RWModel= varRWModel\n                )\n    if testCase == 'BOE' or testCase == 'FrictionSpinDown' or testCase == 'FrictionSpinUp':\n        initialWheelSpeed = 100.\n        rwCopy1 = rwFactory.create(\n                'Honeywell_HR16'\n                ,[0,0,1]                # gsHat_B\n                ,Omega = initialWheelSpeed           # RPM\n                ,rWB_B = [0.0,0.,0.]    # m\n                ,maxMomentum = varMaxMomentum\n                ,RWModel= varRWModel\n                )\n        if testCase == 'FrictionSpinDown' or testCase == 'FrictionSpinUp':\n            rwCopy1.fCoulomb = 0.03\n            rwCopy1.fStatic = 0.06\n            rwCopy1.betaStatic = 0.15\n            rwCopy1.cViscous = 0.001\n            rwCopy1.omegaLimitCycle = 0.001\n            rwCopy1.Omega = 15.\n            rwCopy1.gsHat_B = [[np.sqrt(3)/3], [np.sqrt(3)/3], [np.sqrt(3)/3]]\n            rwCopy1.rWB_B = [[0.5],[-0.5],[0.5]]\n            rwCopy2 = rwFactory.create(\n                'Honeywell_HR16'\n                ,[np.sqrt(3)/3,np.sqrt(3)/3,np.sqrt(3)/3]               # gsHat_B\n                ,Omega = -initialWheelSpeed           # RPM\n                ,rWB_B = [-0.5,0.5,-0.5]    # m\n                ,maxMomentum = varMaxMomentum\n                ,RWModel= varRWModel\n                )\n            rwCopy2.fCoulomb = 0.03\n            rwCopy2.fStatic = 0.06\n            rwCopy2.betaStatic = 0.15\n            rwCopy2.cViscous = 0.001\n            rwCopy2.omegaLimitCycle = 0.001\n            rwCopy2.Omega = -15.\n        if testCase == 'FrictionSpinUp':\n            rwCopy1.Omega = 0.0\n            rwCopy2.Omega = 0.0\n\n    # increase HR16 imbalance for test\n    for key, rw in rwFactory.rwList.items():\n        rw.U_d *= 1e4\n        rw.U_s *= 1e4\n\n    # create RW object container and tie to spacecraft object\n    rwStateEffector = reactionWheelStateEffector.ReactionWheelStateEffector()\n    rwFactory.addToSpacecraft(\"ReactionWheels\", rwStateEffector, scObject)\n\n    # set RW torque command\n    cmdArray = messaging.ArrayMotorTorqueMsgPayload()\n    if testCase == 'BalancedWheels' or testCase == 'JitterSimple' or testCase == 'JitterFullyCoupled':\n        cmdArray.motorTorque = [0.20, 0.10, -0.50] # [Nm]\n    if testCase == 'BOE' or testCase == 'FrictionSpinDown':\n        cmdArray.motorTorque = [0.0] # [Nm]\n    if testCase == 'FrictionSpinUp':\n        cmdArray.motorTorque = [0.1, -0.1]\n    cmdMsg = messaging.ArrayMotorTorqueMsg().write(cmdArray)\n    rwStateEffector.rwMotorCmdInMsg.subscribeTo(cmdMsg)\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, rwStateEffector)\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    if testCase == 'BalancedWheels' or testCase == 'JitterSimple' or testCase == 'JitterFullyCoupled':\n        unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n        unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n        unitTestSim.earthGravBody.mu = 0.3986004415E+15  # meters!\n        unitTestSim.earthGravBody.isCentralBody = True\n        unitTestSim.earthGravBody.useSphericalHarmParams = False\n\n        scObject.gravField.gravBodies = spacecraft.GravBodyVector([unitTestSim.earthGravBody])\n\n    # log data\n    scDataLog = scObject.scStateOutMsg.recorder()\n    speedDataLog = rwStateEffector.rwSpeedOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, scDataLog)\n    unitTestSim.AddModelToTask(unitTaskName, speedDataLog)\n\n\n    # Define initial conditions of the sim\n    if testCase == 'BalancedWheels' or testCase == 'JitterSimple' or testCase == 'JitterFullyCoupled':\n        scObject.hub.r_BcB_B = [[-0.0002], [0.0001], [0.1]]\n        scObject.hub.r_CN_NInit = [[-4020338.690396649],\t[7490566.741852513],\t[5248299.211589362]]\n        scObject.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n        scObject.hub.omega_BN_BInit = [[0.08], [0.01], [0.0]]\n        scObject.hub.mHub = 750.0\n        scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n        scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    if testCase == 'BOE' or testCase == 'FrictionSpinDown' or testCase == 'FrictionSpinUp':\n        wheelSpeedMax = 6000.0*macros.RPM\n        wheelJs = varMaxMomentum/wheelSpeedMax\n        scObject.hub.mHub = 5.0\n        I1Hub = 2.0\n        scObject.hub.IHubPntBc_B = [[2., 0.0, 0.0], [0.0, 2., 0.0], [0.0, 0.0, I1Hub + wheelJs]]\n        scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n        scObject.hub.omega_BN_BInit = [[0.0], [0.0], [0.35]]\n        if testCase == 'FrictionSpinDown' or testCase == 'FrictionSpinUp':\n            scObject.hub.omega_BN_BInit = [[0.0], [0.0], [0.0]]\n            rw0DataLog = rwStateEffector.rwOutMsgs[0].recorder()\n            rw1DataLog = rwStateEffector.rwOutMsgs[1].recorder()\n            unitTestSim.AddModelToTask(unitTaskName, rw0DataLog)\n            unitTestSim.AddModelToTask(unitTaskName, rw1DataLog)\n        scObject.hub.r_CN_NInit = [[0.0], [0.0], [0.0]]\n        scObject.hub.v_CN_NInit = [[0.0], [0.0], [0.0]]\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n\n    stopTime = 1.0\n    if testCase == 'BOE':\n        stopTime = 10.0\n    if testCase == 'FrictionSpinDown' or testCase == 'FrictionSpinUp':\n        stopTime = 100.0\n    if testCase == 'JitterFullyCoupled':\n        stopTime = 0.1\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime/2))\n    unitTestSim.ExecuteSimulation()\n\n    if testCase == 'BalancedWheels' or testCase == 'JitterSimple' or testCase == 'JitterFullyCoupled':\n        cmdArray.motorTorque = [0.0, 0.0, 0.0] # [Nm]\n    if testCase == 'BOE':\n        motorTorque = 0.2\n        cmdArray.motorTorque = [motorTorque]\n    cmdMsg.write(cmdArray)\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n    orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbEnergy\")\n\n    posData = scDataLog.r_BN_N\n    sigmaData = scDataLog.sigma_BN\n    omegaData = scDataLog.omega_BN_B\n    if testCase == 'BOE' or testCase == 'FrictionSpinDown' or testCase == 'FrictionSpinUp':\n        wheelSpeeds = speedDataLog.wheelSpeeds[:, 0]\n        if testCase == 'BOE':\n            thetaOut = 4.0*np.arctan(sigmaData[:, 2])\n            # Find BOE calculations\n            timeBOE = np.array([2.0, 4.0, 6.0, 8.0, 10.0])\n            timeTorqueOn = 5.0\n            omegaBOE = np.zeros(5)\n            thetaBOE = np.zeros(5)\n            wheelSpeedBOE = np.zeros(5)\n            for i in range(5):\n                if timeBOE[i] > timeTorqueOn:\n                    omegaBOE[i] = scObject.hub.omega_BN_BInit[2][0] - motorTorque/I1Hub*(timeBOE[i]-timeTorqueOn)\n                    thetaBOE[i] = scObject.hub.omega_BN_BInit[2][0]*(timeBOE[i]-timeTorqueOn) - 0.5*motorTorque/I1Hub*(timeBOE[i]-timeTorqueOn)**2 + scObject.hub.omega_BN_BInit[2][0]*(timeTorqueOn)\n                    wheelSpeedBOE[i] = initialWheelSpeed*macros.RPM + (I1Hub + wheelJs)*motorTorque/(I1Hub*wheelJs)*(timeBOE[i]-timeTorqueOn)\n                else:\n                    omegaBOE[i] = scObject.hub.omega_BN_BInit[2][0]\n                    wheelSpeedBOE[i] = initialWheelSpeed*macros.RPM\n                    thetaBOE[i] = scObject.hub.omega_BN_BInit[2][0]*(timeBOE[i])\n        if testCase == 'FrictionSpinDown' or testCase == 'FrictionSpinUp':\n            wheelSpeedBeforeInteg1 = rw0DataLog.Omega\n            wheelSpeedBeforeInteg2 = rw1DataLog.Omega\n            frictionTorque1 = rw0DataLog.frictionTorque\n            frictionTorque2 = rw1DataLog.frictionTorque\n\n    dataPos = posData[-1]\n    dataSigma = sigmaData[-1]\n\n    if testCase == 'BalancedWheels':\n        truePos = [\n                    [-4.02553766e+06,   7.48712857e+06,   5.24933964e+06]\n                    ]\n\n        trueSigma = [\n                    [1.99853994e-02,   2.45647716e-03,   8.45356279e-06]\n                    ]\n\n    elif testCase == 'JitterSimple':\n        truePos = [\n                    [-4.02553766e+06,   7.48712857e+06,   5.24933964e+06]\n                    ]\n\n        trueSigma = [\n                    [1.98964221e-02,   2.24474932e-03,  -5.66618270e-05]\n                    ]\n\n    elif testCase == 'JitterFullyCoupled':\n        truePos = [\n                    [-4.02085866e+06,   7.49022306e+06,   5.24840326e+06]\n                    ]\n\n        trueSigma = [\n                    [1.98708924e-03,   2.26086385e-04,  -1.60335529e-05]\n                    ]\n\n    initialOrbAngMom_N = [\n                [orbAngMom_N[0,1], orbAngMom_N[0,2], orbAngMom_N[0,3]]\n                ]\n\n    finalOrbAngMom = [\n                [orbAngMom_N[-1,1], orbAngMom_N[-1,2], orbAngMom_N[-1,3]]\n                 ]\n\n    initialRotAngMom_N = [\n                [rotAngMom_N[0,1], rotAngMom_N[0,2], rotAngMom_N[0,3]]\n                ]\n\n    finalRotAngMom = [\n                [rotAngMom_N[-1,1], rotAngMom_N[-1,2], rotAngMom_N[-1,3]]\n                 ]\n\n    initialOrbEnergy = [\n                [orbEnergy[0,1]]\n                ]\n\n    finalOrbEnergy = [\n                [orbEnergy[-1,1]]\n                 ]\n\n    initialRotEnergy = [\n                [rotEnergy[int(len(rotEnergy)/2)+1,1]]\n                ]\n\n    finalRotEnergy = [\n                [rotEnergy[-1,1]]\n                 ]\n\n    plt.close(\"all\")\n    if testCase == 'BalancedWheels' or testCase == 'JitterFullyCoupled':\n        plt.figure()\n        plt.clf()\n        plt.plot(orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,1] - orbAngMom_N[0,1])/orbAngMom_N[0,1], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,2] - orbAngMom_N[0,2])/orbAngMom_N[0,2], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,3] - orbAngMom_N[0,3])/orbAngMom_N[0,3])\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Relative Difference\")\n        unitTestSupport.writeFigureLaTeX(\"ChangeInOrbitalAngularMomentum\" + testCase, \"Change in Orbital Angular Momentum \" + testCase, plt, r\"width=0.8\\textwidth\", path)\n        plt.figure()\n        plt.clf()\n        plt.plot(orbEnergy[:,0]*1e-9, (orbEnergy[:,1] - orbEnergy[0,1])/orbEnergy[0,1])\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Relative Difference\")\n        unitTestSupport.writeFigureLaTeX(\"ChangeInOrbitalEnergy\" + testCase, \"Change in Orbital Energy \" + testCase, plt, r\"width=0.8\\textwidth\", path)\n        plt.figure()\n        plt.clf()\n        plt.plot(rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,1] - rotAngMom_N[0,1])/rotAngMom_N[0,1], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,2] - rotAngMom_N[0,2])/rotAngMom_N[0,2], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,3] - rotAngMom_N[0,3])/rotAngMom_N[0,3])\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Relative Difference\")\n        unitTestSupport.writeFigureLaTeX(\"ChangeInRotationalAngularMomentum\" + testCase, \"Change in Rotational Angular Momentum \" + testCase, plt, r\"width=0.8\\textwidth\", path)\n        plt.figure()\n        plt.clf()\n        plt.plot(rotEnergy[int(len(rotEnergy)/2)+1:,0]*1e-9, (rotEnergy[int(len(rotEnergy)/2)+1:,1] - rotEnergy[int(len(rotEnergy)/2)+1,1])/rotEnergy[int(len(rotEnergy)/2)+1,1])\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Relative Difference\")\n        unitTestSupport.writeFigureLaTeX(\"ChangeInRotationalEnergy\" + testCase, \"Change in Rotational Energy \" + testCase, plt, r\"width=0.8\\textwidth\", path)\n        if show_plots:\n            plt.show()\n            plt.close('all')\n\n    if testCase == 'BOE':\n        plt.figure()\n        plt.clf()\n        plt.plot(scDataLog.times()*1e-9, thetaOut, label = 'Basilisk')\n        plt.plot(timeBOE, thetaBOE, 'ro', label='BOE')\n        plt.legend(loc='upper left', numpoints=1)\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Theta (rad)\")\n        unitTestSupport.writeFigureLaTeX(\"ReactionWheelBOETheta\", \"Reaction Wheel BOE Theta\", plt, r\"width=0.8\\textwidth\", path)\n\n        plt.figure()\n        plt.clf()\n        plt.plot(scDataLog.times()*1e-9, omegaData[:,2], label = 'Basilisk')\n        plt.plot(timeBOE, omegaBOE, 'ro', label='BOE')\n        plt.legend(loc='upper right', numpoints=1)\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Body Rate (rad/s)\")\n        unitTestSupport.writeFigureLaTeX(\"ReactionWheelBOEBodyRate\", \"Reaction Wheel BOE Body Rate\", plt, r\"width=0.8\\textwidth\", path)\n\n        plt.figure()\n        plt.clf()\n        plt.plot(scDataLog.times()*1e-9, wheelSpeeds, label = 'Basilisk')\n        plt.plot(timeBOE, wheelSpeedBOE, 'ro', label='BOE')\n        plt.legend(loc ='upper left', numpoints=1)\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Wheel Speed (rad/s)\")\n        unitTestSupport.writeFigureLaTeX(\"ReactionWheelBOERWRate\", \"Reaction Wheel BOE RW Rate\", plt, r\"width=0.8\\textwidth\", path)\n        if show_plots:\n            plt.show()\n            plt.close('all')\n\n    if testCase == 'FrictionSpinDown' or testCase == 'FrictionSpinUp':\n        plt.figure()\n        plt.clf()\n        plt.plot(scDataLog.times()*1e-9, omegaData[:,2], label='Basilisk')\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Body Rate (rad/s)\")\n        unitTestSupport.writeFigureLaTeX(\"ReactionWheel\" + testCase + \"TestBodyRates\", \"Reaction Wheel \" + testCase + \" Test Body Rates\", plt, r\"width=0.8\\textwidth\", path)\n\n        plt.figure()\n        plt.clf()\n        plt.plot(speedDataLog.times()*1e-9, wheelSpeeds, label = 'RW 1 Wheel Speed')\n        plt.plot(speedDataLog.times()*1e-9, wheelSpeeds, label = 'RW 2 Wheel Speed')\n        plt.legend(loc='upper right')\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Wheel Speed (rad/s)\")\n        unitTestSupport.writeFigureLaTeX(\"ReactionWheel\" + testCase + \"TestWheelSpeed\", \"Reaction Wheel \" + testCase + \" Test Wheel Speed\", plt, r\"width=0.8\\textwidth\", path)\n\n        print(wheelSpeedBeforeInteg1)\n        print(frictionTorque1)\n        plt.figure()\n        plt.clf()\n        plt.plot(wheelSpeedBeforeInteg1, frictionTorque1, label = 'RW 1 Friction Torque')\n        plt.plot(wheelSpeedBeforeInteg2, frictionTorque2, label = 'RW 2 Friction Torque')\n        plt.legend(loc='upper right')\n        plt.xlabel(\"Wheel Speed (rad/s)\")\n        plt.ylabel(\"Friction Torque (N-m)\")\n        axes = plt.gca()\n        plt.xlim([-15, 15])\n        unitTestSupport.writeFigureLaTeX(\"ReactionWheel\" + testCase + \"TestFrictionTorque\", \"Reaction Wheel \" + testCase + \" Test Friction Torque\", plt, r\"width=0.8\\textwidth\", path)\n        if show_plots:\n            plt.show()\n            plt.close('all')\n\n    accuracy = 1e-7\n    if testCase == 'BalancedWheels' or testCase == 'JitterSimple' or testCase == 'JitterFullyCoupled':\n        for i in range(0,len(truePos)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(dataPos,truePos[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: Reaction Wheel Integrated Test failed pos unit test\")\n\n        for i in range(0,len(trueSigma)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(dataSigma,trueSigma[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: Reaction Wheel Integrated Test failed attitude unit test\")\n\n    accuracy = 1e-10\n    if testCase == 'BalancedWheels' or testCase == 'JitterFullyCoupled':\n        for i in range(0,len(initialOrbAngMom_N)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i],initialOrbAngMom_N[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: Reaction Wheel Integrated Test failed orbital angular momentum unit test\")\n\n        for i in range(0,len(initialRotAngMom_N)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i],initialRotAngMom_N[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: Reaction Wheel Integrated Test failed rotational angular momentum unit test\")\n\n        for i in range(0,len(initialOrbEnergy)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i],initialOrbEnergy[i],1,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: Reaction Wheel Integrated Test failed orbital energy unit test\")\n\n        for i in range(0,len(initialRotEnergy)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(finalRotEnergy[i],initialRotEnergy[i],1,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: Reaction Wheel Integrated Test failed rotational energy unit test\")\n\n    accuracy = 1e-8\n    if testCase == 'BOE':\n        for i in range(5):\n            if abs((omegaBOE[i] - omegaData[int(timeBOE[i]/stepSize),2])/omegaBOE[i]) > accuracy:\n                testFailCount += 1\n                testMessages.append(\"FAILED: Reaction Wheel Integrated Test failed BOE body rates unit test\")\n            if abs((thetaBOE[i] - thetaOut[int(timeBOE[i]/stepSize)])/thetaBOE[i]) > accuracy:\n                testFailCount += 1\n                testMessages.append(\"FAILED: Reaction Wheel Integrated Test failed BOE theta unit test\")\n            if abs((wheelSpeedBOE[i] - wheelSpeeds[int(timeBOE[i]/stepSize)])/wheelSpeedBOE[i]) > accuracy:\n                testFailCount += 1\n                testMessages.append(\"FAILED: Reaction Wheel Integrated Test failed BOE wheel speed unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Reaction Wheel Integrated Sim \" + testCase)\n\n        # print out success message if no errors were found\n    if testCase == 'JitterSimple' and testFailCount == 0:\n        print(\"PASSED \")\n        colorText = 'ForestGreen'\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n        # Write some snippets for AutoTex\n        snippetName = testCase + 'PassFail'\n        unitTestSupport.writeTeXSnippet(snippetName, passedText, path)\n    elif testCase == 'JitterSimple' and testFailCount > 0:\n        colorText = 'Red'\n        passedText = r'\\textcolor{' + colorText + '}{' + \"FAILED\" + '}'\n        # Write some snippets for AutoTex\n        snippetName = testCase + 'PassFail'\n        unitTestSupport.writeTeXSnippet(snippetName, passedText, path)\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def test_dualHingedRigidBody(show_plots, useFlag, testCase):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = dualHingedRigidBodyTest(show_plots, useFlag, testCase)\n    assert testResults < 1, testMessage",
  "def dualHingedRigidBodyTest(show_plots, useFlag, testCase):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    \n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n    \n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n    \n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    \n    # Create test thread\n    testProcessRate = macros.sec2nano(0.0001)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    unitTestSim.panel1 = dualHingedRigidBodyStateEffector.DualHingedRigidBodyStateEffector()\n    unitTestSim.panel2 = dualHingedRigidBodyStateEffector.DualHingedRigidBodyStateEffector()\n\n    # Define Variable for panel 1\n    unitTestSim.panel1.ModelTag = \"panel1\"\n    unitTestSim.panel1.mass1 = 50.0\n    unitTestSim.panel1.IPntS1_S1 = [[50.0, 0.0, 0.0], [0.0, 25.0, 0.0], [0.0, 0.0, 25.0]]\n    unitTestSim.panel1.d1 = 0.75\n    unitTestSim.panel1.l1 = 1.5\n    unitTestSim.panel1.k1 = 100.0\n    unitTestSim.panel1.c1 = 0.0\n    unitTestSim.panel1.r_H1B_B = [[0.5], [0.0], [1.0]]\n    unitTestSim.panel1.dcm_H1B = [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel1.mass2 = 50.0\n    unitTestSim.panel1.IPntS2_S2 = [[50.0, 0.0, 0.0], [0.0, 25.0, 0.0], [0.0, 0.0, 25.0]]\n    unitTestSim.panel1.d2 = 0.75\n    unitTestSim.panel1.k2 = 100.0\n    unitTestSim.panel1.c2 = 0.0\n    unitTestSim.panel1.theta1Init = 5*numpy.pi/180.0\n    unitTestSim.panel1.theta1DotInit = 0.0\n    unitTestSim.panel1.theta2Init = 0.0\n    unitTestSim.panel1.theta2DotInit = 0.0\n\n    # Define Variables for panel 2\n    unitTestSim.panel2.ModelTag = \"panel2\"\n    unitTestSim.panel2.mass1 = 50.0\n    unitTestSim.panel2.IPntS1_S1 = [[50.0, 0.0, 0.0], [0.0, 25.0, 0.0], [0.0, 0.0, 25.0]]\n    unitTestSim.panel2.d1 = 0.75\n    unitTestSim.panel2.l1 = 1.5\n    unitTestSim.panel2.k1 = 100.0\n    unitTestSim.panel2.c1 = 0.0\n    unitTestSim.panel2.r_H1B_B = [[-0.5], [0.0], [1.0]]\n    unitTestSim.panel2.dcm_H1B = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel2.mass2 = 50.0\n    unitTestSim.panel2.IPntS2_S2 = [[50.0, 0.0, 0.0], [0.0, 25.0, 0.0], [0.0, 0.0, 25.0]]\n    unitTestSim.panel2.d2 = 0.75\n    unitTestSim.panel2.k2 = 100.0\n    unitTestSim.panel2.c2 = 0.0\n    unitTestSim.panel2.theta1Init = 5*numpy.pi/180.0\n    unitTestSim.panel2.theta1DotInit = 0.0\n    unitTestSim.panel2.theta2Init = 0.0\n    unitTestSim.panel2.theta2DotInit = 0.0\n\n    # Add panels to spaceCraft\n    # this next line is not working\n    scObject.addStateEffector(unitTestSim.panel1)\n    scObject.addStateEffector(unitTestSim.panel2)\n\n    scObject.hub.mHub = 750.0\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    # Set the initial values for the states\n    scObject.hub.r_CN_NInit = [[0.1], [-0.4], [0.3]]\n    scObject.hub.v_CN_NInit = [[-0.2], [0.5], [0.1]]\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.omega_BN_BInit = [[0.1], [-0.1], [0.1]]\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    if testCase == 'Gravity':\n        unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n        unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n        unitTestSim.earthGravBody.mu = 0.3986004415E+15 # meters!\n        unitTestSim.earthGravBody.isCentralBody = True\n        unitTestSim.earthGravBody.useSphericalHarmParams = False\n        scObject.gravField.gravBodies = spacecraft.GravBodyVector([unitTestSim.earthGravBody])\n        scObject.hub.r_CN_NInit = [[-4020338.690396649],\t[7490566.741852513],\t[5248299.211589362]]\n        scObject.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n\n    dataLog = scObject.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n\n    # Add energy and momentum variables to log\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n\n    stopTime = 1.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbEnergy\")\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n\n    initialOrbAngMom_N = [\n                [orbAngMom_N[0, 1], orbAngMom_N[0, 2], orbAngMom_N[0, 3]]\n                ]\n\n    finalOrbAngMom = [\n                [orbAngMom_N[-1, 1], orbAngMom_N[-1, 2], orbAngMom_N[-1, 3]]\n                 ]\n\n    initialRotAngMom_N = [\n                [rotAngMom_N[0, 1], rotAngMom_N[0, 2], rotAngMom_N[0, 3]]\n                ]\n\n    finalRotAngMom = [\n                [rotAngMom_N[-1, 1], rotAngMom_N[-1, 2], rotAngMom_N[-1, 3]]\n                 ]\n\n    initialOrbEnergy = [\n                [orbEnergy[0, 1]]\n                ]\n\n    finalOrbEnergy = [\n                [orbEnergy[-1, 1]]\n                 ]\n\n    initialRotEnergy = [\n                [rotEnergy[int(len(rotEnergy)/2)+1, 1]]\n                ]\n\n    finalRotEnergy = [\n                [rotEnergy[-1, 1]]\n                 ]\n\n    plt.close('all')\n    plt.figure()\n    plt.clf()\n    plt.plot(orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,1] - orbAngMom_N[0,1])/orbAngMom_N[0,1], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,2] - orbAngMom_N[0,2])/orbAngMom_N[0,2], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,3] - orbAngMom_N[0,3])/orbAngMom_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    unitTestSupport.writeFigureLaTeX(\"ChangeInOrbitalAngularMomentum\" + testCase, \"Change in Orbital Angular Momentum \" + testCase, plt, r\"width=0.8\\textwidth\", path)\n    plt.figure()\n    plt.clf()\n    plt.plot(orbEnergy[:,0]*1e-9, (orbEnergy[:,1] - orbEnergy[0,1])/orbEnergy[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    unitTestSupport.writeFigureLaTeX(\"ChangeInOrbitalEnergy\" + testCase, \"Change in Orbital Energy \" + testCase, plt, r\"width=0.8\\textwidth\", path)\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,1] - rotAngMom_N[0,1])/rotAngMom_N[0,1], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,2] - rotAngMom_N[0,2])/rotAngMom_N[0,2], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,3] - rotAngMom_N[0,3])/rotAngMom_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    unitTestSupport.writeFigureLaTeX(\"ChangeInRotationalAngularMomentum\" + testCase, \"Change in Rotational Angular Momentum \" + testCase, plt, r\"width=0.8\\textwidth\", path)\n    plt.figure()\n    plt.clf()\n    plt.plot(rotEnergy[:,0]*1e-9, (rotEnergy[:,1] - rotEnergy[0,1])/rotEnergy[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    unitTestSupport.writeFigureLaTeX(\"ChangeInRotationalEnergy\" + testCase, \"Change in Rotational Energy \" + testCase, plt, r\"width=0.8\\textwidth\", path)\n    if show_plots:\n        plt.show()\n        plt.close(\"all\")\n\n    accuracy = 1e-10\n    for i in range(0,len(initialOrbAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i],initialOrbAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Dual Hinged Rigid Body Integrated Test failed orbital angular momentum unit test\")\n\n    for i in range(0,len(initialRotAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i],initialRotAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Dual Hinged Rigid Body Integrated Test failed rotational angular momentum unit test\")\n\n    for i in range(0,len(initialOrbEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i],initialOrbEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Dual Hinged Rigid Body Integrated Test failed orbital energy unit test\")\n\n    for i in range(0,len(initialRotEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotEnergy[i],initialRotEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Dual Hinged Rigid Body Integrated Test failed rotational energy unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Dual Hinged Rigid Body Test\")\n    else:\n        print(\"FAILED: Dual Hinged Rigid Body Test\")\n        print(testMessages)\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def test_dualHingedRigidBodyMotorTorque(show_plots, useScPlus):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = dualHingedRigidBodyMotorTorque(show_plots, useScPlus)\n    assert testResults < 1, testMessage",
  "def dualHingedRigidBodyMotorTorque(show_plots, useScPlus):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    if useScPlus:\n        scObject = spacecraft.Spacecraft()\n        scObject.ModelTag = \"spacecraftBody\"\n    else:\n        scObject = spacecraftSystem.SpacecraftSystem()\n        scObject.ModelTag = \"spacecraftBody\"\n        scObject.primaryCentralSpacecraft.spacecraftName = scObject.ModelTag\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.01)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    unitTestSim.panel1 = dualHingedRigidBodyStateEffector.DualHingedRigidBodyStateEffector()\n    unitTestSim.panel2 = dualHingedRigidBodyStateEffector.DualHingedRigidBodyStateEffector()\n\n    # Define Variable for panel 1\n    unitTestSim.panel1.ModelTag = \"panel1\"\n    unitTestSim.panel1.mass1 = 50.0\n    unitTestSim.panel1.IPntS1_S1 = [[50.0, 0.0, 0.0], [0.0, 25.0, 0.0], [0.0, 0.0, 25.0]]\n    unitTestSim.panel1.d1 = 0.75\n    unitTestSim.panel1.l1 = 1.5\n    unitTestSim.panel1.k1 = 0.0\n    unitTestSim.panel1.c1 = 0.0\n    unitTestSim.panel1.r_H1B_B = [[0.5], [0.0], [1.0]]\n    unitTestSim.panel1.dcm_H1B = [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel1.mass2 = 50.0\n    unitTestSim.panel1.IPntS2_S2 = [[50.0, 0.0, 0.0], [0.0, 25.0, 0.0], [0.0, 0.0, 25.0]]\n    unitTestSim.panel1.d2 = 0.75\n    unitTestSim.panel1.k2 = 100.0\n    unitTestSim.panel1.c2 = 0.0\n    unitTestSim.panel1.theta1Init = 0*numpy.pi/180.0\n    unitTestSim.panel1.theta1DotInit = 0.0\n    unitTestSim.panel1.theta2Init = 0.0\n    unitTestSim.panel1.theta2DotInit = 0.0\n\n    # set a fixed motor torque message\n    motorMsgData = messaging.ArrayMotorTorqueMsgPayload()\n    motorMsgData.motorTorque = [2.0, 4.0]\n    motorMsg = messaging.ArrayMotorTorqueMsg().write(motorMsgData)\n    unitTestSim.panel1.motorTorqueInMsg.subscribeTo(motorMsg)\n\n    # Define Variables for panel 2\n    unitTestSim.panel2.ModelTag = \"panel2\"\n    unitTestSim.panel2.mass1 = 50.0\n    unitTestSim.panel2.IPntS1_S1 = [[50.0, 0.0, 0.0], [0.0, 25.0, 0.0], [0.0, 0.0, 25.0]]\n    unitTestSim.panel2.d1 = 0.75\n    unitTestSim.panel2.l1 = 1.5\n    unitTestSim.panel2.k1 = 0.0\n    unitTestSim.panel2.c1 = 0.0\n    unitTestSim.panel2.r_H1B_B = [[-0.5], [0.0], [1.0]]\n    unitTestSim.panel2.dcm_H1B = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel2.nameOfTheta1State = \"dualHingedRigidBody2Theta1\"\n    unitTestSim.panel2.nameOfTheta1DotState = \"dualHingedRigidBody2ThetaDot1\"\n    unitTestSim.panel2.mass2 = 50.0\n    unitTestSim.panel2.IPntS2_S2 = [[50.0, 0.0, 0.0], [0.0, 25.0, 0.0], [0.0, 0.0, 25.0]]\n    unitTestSim.panel2.d2 = 0.75\n    unitTestSim.panel2.k2 = 0.0\n    unitTestSim.panel2.c2 = 0.0\n    unitTestSim.panel2.nameOfTheta2State = \"dualHingedRigidBody2Theta2\"\n    unitTestSim.panel2.nameOfTheta2DotState = \"dualHingedRigidBody2ThetaDot2\"\n    unitTestSim.panel2.theta1Init = 0 * numpy.pi / 180.0\n    unitTestSim.panel2.theta1DotInit = 0.0\n    unitTestSim.panel2.theta2Init = 0.0\n    unitTestSim.panel2.theta2DotInit = 0.0\n\n    # Add panels to spaceCraft\n    scObjectPrimary = scObject\n    if not useScPlus:\n        scObjectPrimary = scObject.primaryCentralSpacecraft\n\n    scObjectPrimary.addStateEffector(unitTestSim.panel1)\n    scObjectPrimary.addStateEffector(unitTestSim.panel2)\n\n    # Define mass properties of the rigid part of the spacecraft\n    scObjectPrimary.hub.mHub = 750.0\n    scObjectPrimary.hub.r_BcB_B = [[0.0], [0.0], [1.0]]\n    scObjectPrimary.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    # Set the initial values for the states\n    scObjectPrimary.hub.r_CN_NInit = [[0.0], [0.0], [0.0]]\n    scObjectPrimary.hub.v_CN_NInit = [[0.0], [0.0], [0.0]]\n    scObjectPrimary.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObjectPrimary.hub.omega_BN_BInit = [[0.0], [0.0], [0.0]]\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel1)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel2)\n\n    dataLog = scObjectPrimary.scStateOutMsg.recorder()\n    dataPanel10Log = unitTestSim.panel1.dualHingedRigidBodyOutMsgs[0].recorder()\n    dataPanel11Log = unitTestSim.panel1.dualHingedRigidBodyOutMsgs[1].recorder()\n    dataPanel20Log = unitTestSim.panel2.dualHingedRigidBodyOutMsgs[0].recorder()\n    dataPanel21Log = unitTestSim.panel2.dualHingedRigidBodyOutMsgs[1].recorder()\n    data10Log = unitTestSim.panel1.dualHingedRigidBodyConfigLogOutMsgs[0].recorder()\n    data21Log = unitTestSim.panel2.dualHingedRigidBodyConfigLogOutMsgs[1].recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n    unitTestSim.AddModelToTask(unitTaskName, dataPanel10Log)\n    unitTestSim.AddModelToTask(unitTaskName, dataPanel11Log)\n    unitTestSim.AddModelToTask(unitTaskName, dataPanel20Log)\n    unitTestSim.AddModelToTask(unitTaskName, dataPanel21Log)\n    unitTestSim.AddModelToTask(unitTaskName, data10Log)\n    unitTestSim.AddModelToTask(unitTaskName, data21Log)\n\n    unitTestSim.InitializeSimulation()\n\n    variableLogTag = scObject.ModelTag\n    if not useScPlus:\n        variableLogTag += \".primaryCentralSpacecraft\"\n\n    unitTestSim.AddVariableForLogging(variableLogTag + \".totRotAngMomPntC_N\",\n                                      testProcessRate, 0, 2, 'double')\n\n    stopTime = 10.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    rOut_CN_N = dataLog.r_CN_N\n    vOut_CN_N = dataLog.v_CN_N\n    sigma_BN = dataLog.sigma_BN\n    thetaP1A1 = dataPanel10Log.theta\n    thetaP1A2 = dataPanel11Log.theta\n    thetaP2A1 = dataPanel20Log.theta\n    thetaP2A2 = dataPanel21Log.theta\n    rB1N = data10Log.r_BN_N[0]\n    vB1N = data10Log.v_BN_N[0]\n    sB1N = data10Log.sigma_BN[0]\n    oB1N = data10Log.omega_BN_B[0]\n    rB2N = data21Log.r_BN_N[0]\n    vB2N = data21Log.v_BN_N[0]\n    sB2N = data21Log.sigma_BN[0]\n    oB2N = data21Log.omega_BN_B[0]\n\n    rotAngMom_N = unitTestSim.GetLogVariableData(\n        variableLogTag + \".totRotAngMomPntC_N\")\n\n    # Get the last sigma and position\n    dataPos = [rOut_CN_N[-1]]\n\n    truePos = [[0., 0., 0.]]\n\n    initialRotAngMom_N = [[rotAngMom_N[0, 1], rotAngMom_N[0, 2], rotAngMom_N[0, 3]]]\n\n    finalRotAngMom = [rotAngMom_N[-1, 1:4]]\n\n    plt.close(\"all\")\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom_N[:, 0] * 1e-9, (rotAngMom_N[:, 1] - rotAngMom_N[0, 1]) ,\n             rotAngMom_N[:, 0] * 1e-9, (rotAngMom_N[:, 2] - rotAngMom_N[0, 2]) ,\n             rotAngMom_N[:, 0] * 1e-9, (rotAngMom_N[:, 3] - rotAngMom_N[0, 3]) )\n    plt.xlabel('time (s)')\n    plt.ylabel('Ang. Momentum Difference')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(dataLog.times() * 1e-9, vOut_CN_N[:, 0], dataLog.times() * 1e-9, vOut_CN_N[:, 1], dataLog.times() * 1e-9,\n             vOut_CN_N[:, 2])\n    plt.xlabel('time (s)')\n    plt.ylabel('m/s')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(dataLog.times() * macros.NANO2SEC, sigma_BN[:, 0],\n             color=unitTestSupport.getLineColor(0, 3),\n             label=r'$\\sigma_{1}$')\n    plt.plot(dataLog.times() * macros.NANO2SEC, sigma_BN[:, 1],\n             color=unitTestSupport.getLineColor(1, 3),\n             label=r'$\\sigma_{2}$')\n    plt.plot(dataLog.times() * macros.NANO2SEC, sigma_BN[:, 2],\n             color=unitTestSupport.getLineColor(2, 3),\n             label=r'$\\sigma_{3}$')\n    plt.legend(loc='lower right')\n    plt.xlabel('time (s)')\n    plt.ylabel(r'MRP $\\sigma_{B/N}$')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(dataPanel10Log.times() * macros.NANO2SEC, thetaP1A1*macros.R2D,\n             color=unitTestSupport.getLineColor(0, 4),\n             label=r'Panel 1 $\\theta_{1}$')\n    plt.plot(dataPanel10Log.times() * macros.NANO2SEC, thetaP1A2*macros.R2D,\n             color=unitTestSupport.getLineColor(1, 4),\n             label=r'Panel 1 $\\theta_{2}$')\n    plt.plot(dataPanel10Log.times() * macros.NANO2SEC, thetaP2A1 * macros.R2D,\n             color=unitTestSupport.getLineColor(2, 4),\n             label=r'Panel 2 $\\theta_{1}$')\n    plt.plot(dataPanel10Log.times() * macros.NANO2SEC, thetaP2A2 * macros.R2D,\n             color=unitTestSupport.getLineColor(3, 4),\n             label=r'Panel 2 $\\theta_{2}$')\n    plt.legend(loc='lower right')\n    plt.xlabel('time (s)')\n    plt.ylabel('Hinge Angles [deg]')\n\n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n    accuracy = 1e-10\n    for i in range(0, len(truePos)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataPos[i], truePos[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED:  Hinged Rigid Body integrated test failed position test\")\n\n    for i in range(0, len(initialRotAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(finalRotAngMom[i], initialRotAngMom_N[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\n                \"FAILED: Hinged Rigid Body integrated test failed rotational angular momentum unit test\")\n\n    # check config log messages\n    if not unitTestSupport.isArrayEqual(rB1N, [1.25, 0, 0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Dual Hinged Rigid Body integrated test failed panel 1 r_S1N_N config log test\")\n    if not unitTestSupport.isArrayEqual(vB1N, [0.0, 0, 0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Dual Hinged Rigid Body integrated test failed panel 1 v_S1N_N config log test\")\n    if not unitTestSupport.isArrayEqual(sB1N, [0.0, 0, 1.0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Dual Hinged Rigid Body integrated test failed panel 1 sigma_S1N config log test\")\n    if not unitTestSupport.isArrayEqual(oB1N, [0.0, 0, 0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Dual Hinged Rigid Body integrated test failed panel 1 omega_S1N_B config log test\")\n    if not unitTestSupport.isArrayEqual(rB2N, [-2.75, 0, 0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Dual Hinged Rigid Body integrated test failed panel 2 r_S2N_N config log test\")\n    if not unitTestSupport.isArrayEqual(vB2N, [0.0, 0, 0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Dual Hinged Rigid Body integrated test failed panel 2 v_S2N_N config log test\")\n    if not unitTestSupport.isArrayEqual(sB2N, [0.0, 0, 0.0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Dual Hinged Rigid Body integrated test failed panel 2 sigma_S2N config log test\")\n    if not unitTestSupport.isArrayEqual(oB2N, [0.0, 0, 0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Dual Hinged Rigid Body integrated test failed panel 2 omega_S2N_B config log test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Dual Hinged Rigid Body integrated test with motor torques\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def test_facetSRPDynamicEffector(show_plots):\n    r\"\"\"\n    **Validation Test Description**\n\n    The unit test for this module ensures that the calculated Solar Radiation Pressure (SRP) force and torque acting\n    on the spacecraft about the body-fixed point B is properly computed for a static spacecraft. The spacecraft\n    geometry defined in this test consists of a cubic hub and two circular solar arrays. Six square facets represent\n    the cubic hub and four circular facets describe the solar arrays. The SRP force and torque module values are\n    checked with values computed in python both initially and at a time halfway through the simulation.\n\n    **Test Parameters**\n\n    Args:\n        show_plots (bool): (True) Show plots, (False) Do not show plots\n\n    **Description of Variables Being Tested**\n\n    The initial module-computed SRP force value ``SRPDataForce_B`` is checked with the value computed in\n    python ``forceTest1Val``. The initial module-computed SRP torque value ``SRPDataTorque_B`` is also checked\n    with the value computed in python ``torqueTest1Val``. Similarly, these values halfway through the simulation\n    are checked to match.\n    \"\"\"\n    testResults = []\n    testMessage = []\n\n    srpRes, srpMsg = TestfacetSRPDynamicEffector(False)\n    testMessage.append(srpMsg)\n    testResults.append(srpRes)\n\n    testSum = sum(testResults)\n    snippetName = \"unitTestPassFail\"\n\n    if testSum == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED\")\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed\")\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n\n    unitTestSupport.writeTeXSnippet(snippetName, passedText, path)\n\n    assert testSum < 1, testMessage",
  "def checkFacetSRPForce(index, area, specCoeff, diffCoeff, normal_B, sigma_BN, scPos, sunPos):\n    \"\"\"This function calculates the per-facet SRP force acting on the spacecraft.\"\"\"\n    # Define required constants\n    speedLight = 299792458.0\n    AstU = 149597870700.0\n    solarRadFlux = 1368.0\n\n    # Compute dcm_BN using MRP transformation\n    dcm_BN = rbk.MRP2C(sigma_BN)\n\n    # Convert vectors from the N frame to the B frame\n    r_BN_B = np.matmul(dcm_BN, scPos)\n    r_SN_B = np.matmul(dcm_BN, sunPos)\n    r_SB_B = r_SN_B - r_BN_B\n\n    # Determine unit direction vector pointing from point B on the spacecraft to the Sun\n    sHat = r_SB_B / np.linalg.norm(r_SB_B)\n\n    # Calculate the incidence angle theta between the facet normal vector and the Sun-direction vector\n    cosTheta = np.dot(sHat, normal_B)\n    intermediate = np.cross(sHat, normal_B)\n    sinTheta = np.linalg.norm(intermediate)\n    theta = np.arctan2(sinTheta, cosTheta)\n\n    # Calculate the facet projected area onto the plane whose normal vector is the Sun-direction vector\n    projArea = area * np.cos(theta)\n\n    # Calculate the solar radiation pressure acting on the facet\n    numAU = AstU / np.linalg.norm(r_SB_B)\n    SRPPressure = (solarRadFlux / speedLight) * numAU * numAU\n\n    # Compute the SRP force acting on the facet only if the facet is illuminated by the Sun\n    if projArea > 0:\n        srp_force = -SRPPressure * projArea * np.cos(theta) * ( (1-specCoeff) * sHat + 2 * ( (diffCoeff / 3) + specCoeff * np.cos(theta)) * normal_B )\n    else:\n        srp_force = np.zeros([3,])\n\n    return srp_force",
  "def checkFacetSRPTorque(index, area, specCoeff, diffCoeff, normal_B, locationPntB_B, sigma_BN, scPos, sunPos):\n    \"\"\"This function calculates the per-facet SRP torque acting on the spacecraft.\"\"\"\n    # Define required constants\n    speedLight = 299792458.0\n    AstU = 149597870700.0\n    solarRadFlux = 1368.0\n\n    # Compute dcm_BN using MRP transformation\n    dcm_BN = rbk.MRP2C(sigma_BN)\n\n    # Convert vectors from the N frame to the B frame\n    r_BN_B = np.matmul(dcm_BN, scPos)\n    r_SN_B = np.matmul(dcm_BN, sunPos)\n    r_SB_B = r_SN_B - r_BN_B\n\n    # Determine unit direction vector pointing from point B on the spacecraft to the Sun\n    sHat = r_SB_B / np.linalg.norm(r_SB_B)\n\n    # Calculate the incidence angle theta between the facet normal vector and the Sun-direction vector\n    cosTheta = np.dot(sHat, normal_B)\n    intermediate = np.cross(sHat, normal_B)\n    sinTheta = np.linalg.norm(intermediate)\n    theta = np.arctan2(sinTheta, cosTheta)\n\n    # Calculate the facet projected area onto the plane whose normal vector is the Sun-direction vector\n    projArea = area * np.cos(theta)\n\n    # Calculate the solar radiation pressure acting on the facet\n    numAU = AstU / np.linalg.norm(r_SB_B)\n    SRPPressure = (solarRadFlux / speedLight) * numAU * numAU\n\n    # Compute the SRP force contribution from the facet only if the facet is illuminated by the Sun\n    if projArea > 0:\n        srp_force = -SRPPressure * projArea * np.cos(theta) * ( (1-specCoeff) * sHat + 2 * ( (diffCoeff / 3) + specCoeff * np.cos(theta)) * normal_B )\n    else:\n        srp_force = np.zeros([3, ])\n\n    # Calculate the SRP torque contribution from the facet\n    srp_torque = np.cross(locationPntB_B, srp_force)\n\n    return srp_torque",
  "def TestfacetSRPDynamicEffector(show_plots):\n    \"\"\"Call this routine directly to run the unit test.\"\"\"\n    # Init test support variables\n    testFailCount = 0\n    testMessages = []\n\n    # Create the simulation task and process\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n    scSim = SimulationBaseClass.SimBaseClass()\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n    simulationTimeStep_Sec = 0.1\n    simulationTimeStep_NS = macros.sec2nano(simulationTimeStep_Sec)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep_NS))\n\n    # Create the spacecraft object\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraft\"\n\n    # Add the Earth and Sun as gravitational bodies\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    earth = gravFactory.createEarth()\n    sun = gravFactory.createSun()\n    earth.isCentralBody = True  # ensure this is the central gravitational body\n    earthIdx = 0\n    sunIdx = 1\n    earthStateMsg = messaging.SpicePlanetStateMsgPayload()\n    earthStateMsg.PositionVector = [0.0, -149598023 * 1000, 0.0]\n    earthStateMsg.VelocityVector = [0.0, 0.0, 0.0]\n    earthMsg = messaging.SpicePlanetStateMsg().write(earthStateMsg)\n    gravFactory.gravBodies['earth'].planetBodyInMsg.subscribeTo(earthMsg)\n    sunStateMsg = messaging.SpicePlanetStateMsgPayload()\n    sunStateMsg.PositionVector = [0.0, 0.0, 0.0]\n    sunStateMsg.VelocityVector = [0.0, 0.0, 0.0]\n    sunMsg = messaging.SpicePlanetStateMsg().write(sunStateMsg)\n    gravFactory.gravBodies['sun'].planetBodyInMsg.subscribeTo(sunMsg)\n\n    # Create an instance of the facetSRPEffector module to be tested\n    newSRP = facetSRPDynamicEffector.FacetSRPDynamicEffector()\n    newSRP.ModelTag = \"FacetSRP\"\n\n    # Connect the Sun's ephemeris message to the module\n    newSRP.sunInMsg.subscribeTo(sunMsg)\n\n    # Add the SRP dynamic effector to the spacecraft object\n    scObject.addDynamicEffector(newSRP)\n\n    # Define the spacecraft geometry for this test\n    try:\n        # Define the facet surface areas\n        area1 = 1.5*1.5  # [m^2]\n        area2 = np.pi*(0.5*7.5)*(0.5*7.5)  # [m^2]\n        facetAreas = [area1, area1, area1, area1, area1, area1, area2, area2, area2, area2]\n\n        # Define the facet normals in B frame components\n        facetNormal1 = np.array([1.0, 0.0, 0.0])\n        facetNormal2 = np.array([0.0, 1.0, 0.0])\n        facetNormal3 = np.array([-1.0, 0.0, 0.0])\n        facetNormal4 = np.array([0.0, -1.0, 0.0])\n        facetNormal5 = np.array([0.0, 0.0, 1.0])\n        facetNormal6 = np.array([0.0, 0.0, -1.0])\n        facetNormal7 = np.array([0.0, 1.0, 0.0])\n        facetNormal8 = np.array([0.0, -1.0, 0.0])\n        facetNormal9 = np.array([0.0, 1.0, 0.0])\n        facetNormal10 = np.array([0.0, -1.0, 0.0])\n        normals_B = [facetNormal1, facetNormal2, facetNormal3, facetNormal4, facetNormal5, facetNormal6, facetNormal7, facetNormal8, facetNormal9, facetNormal10]\n\n        # Define the facet center of pressure locations with respect to point B in B frame components\n        facetLoc1 = np.array([0.75, 0.0, 0.0])  # [m]\n        facetLoc2 = np.array([0.0, 0.75, 0.0])  # [m]\n        facetLoc3 = np.array([-0.75, 0.0, 0.0])  # [m]\n        facetLoc4 = np.array([0.0, -0.75, 0.0])  # [m]\n        facetLoc5 = np.array([0.0, 0.0, 0.75])  # [m]\n        facetLoc6 = np.array([0.0, 0.0, -0.75])  # [m]\n        facetLoc7 = np.array([4.5, 0.0, 0.75])  # [m]\n        facetLoc8 = np.array([4.5, 0.0, 0.75])  # [m]\n        facetLoc9 = np.array([-4.5, 0.0, 0.75])  # [m]\n        facetLoc10 = np.array([-4.5, 0.0, 0.75])  # [m]\n        locationsPntB_B = [facetLoc1, facetLoc2, facetLoc3, facetLoc4, facetLoc5, facetLoc6, facetLoc7, facetLoc8, facetLoc9, facetLoc10]\n\n        # Define the facet optical coefficients\n        specCoeff = np.array([0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9])\n        diffCoeff = np.array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n\n        # Populate the scGeometry structure with the facet information\n        for i in range(len(facetAreas)):\n            newSRP.addFacet(facetAreas[i], specCoeff[i], diffCoeff[i], normals_B[i], locationsPntB_B[i])\n    except:\n        testFailCount += 1\n        testMessages.append(\"ERROR: FacetDrag unit test failed while setting facet parameters.\")\n        return testFailCount, testMessages\n\n    # Set up the spacecraft orbit\n    oe = orbitalMotion.ClassicElements()\n    r_eq = 6371*1000.0  # [m]\n    rN = np.array([r_eq+2000.0, -149598023 * 1000, 0.0])  # [m]\n    vN = np.array([0.0, 7.90854, 0.0])  # [m/s]\n    sig_BN = np.array([0.0, 0.0, 0.0])\n\n    # Initialize spacecraft states with the initialization variables\n    scObject.hub.r_CN_NInit = rN  # [m] r_CN_N\n    scObject.hub.v_CN_NInit = vN  # [m] v_CN_N\n    scObject.hub.sigma_BNInit = sig_BN\n\n    # Set up data logging\n    scPosDataLog = scObject.scStateOutMsg.recorder()\n    sunPosDataLog = gravFactory.gravBodies['sun'].planetBodyInMsg.recorder()\n\n    # Add the BSK objects to the simulation process\n    scSim.AddModelToTask(simTaskName, scObject)\n    scSim.AddModelToTask(simTaskName, newSRP)\n    scSim.AddModelToTask(simTaskName, scPosDataLog)\n    scSim.AddModelToTask(simTaskName, sunPosDataLog)\n\n    # Set the simulation time\n    simTimeSec = 10.0  # [s]\n    simulationTime = macros.sec2nano(simTimeSec)\n\n    # Initialize the simulation\n    scSim.InitializeSimulation()\n\n    # Add the data for logging\n    scSim.AddVariableForLogging(newSRP.ModelTag + \".forceExternal_B\", simulationTimeStep_NS, 0, 2, 'double')\n    scSim.AddVariableForLogging(newSRP.ModelTag + \".torqueExternalPntB_B\", simulationTimeStep_NS, 0, 2, 'double')\n\n    # Configure the simulation stop time and execute the simulation run\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    # Retrieve the logged data\n    timespan = scPosDataLog.times()\n    r_BN_N = scPosDataLog.r_BN_N\n    sigma_BN = scPosDataLog.sigma_BN\n    r_SN_N = sunPosDataLog.PositionVector\n    SRPDataForce_B = scSim.GetLogVariableData(newSRP.ModelTag + \".forceExternal_B\")\n    SRPDataTorque_B = scSim.GetLogVariableData(newSRP.ModelTag + \".torqueExternalPntB_B\")\n\n    # Store the logged data for plotting\n    srpForce_B_plotting = SRPDataForce_B\n    srpForce_B_plotting = np.delete(srpForce_B_plotting, 0, axis=1)\n    srpTorque_B_plotting = SRPDataTorque_B\n    srpTorque_B_plotting = np.delete(srpTorque_B_plotting, 0, axis=1)\n\n    # Plotting results\n    plt.figure()\n    plt.clf()\n    plt.plot(timespan * 1e-9, r_BN_N[:, 0], label=r'$r_{\\mathcal{B}/\\mathcal{N}} \\cdot \\hat{n}_1$')\n    plt.plot(timespan * 1e-9, r_BN_N[:, 1], label=r'$r_{\\mathcal{B}/\\mathcal{N}} \\cdot \\hat{n}_2$')\n    plt.plot(timespan * 1e-9, r_BN_N[:, 2], label=r'$r_{\\mathcal{B}/\\mathcal{N}} \\cdot \\hat{n}_3$')\n    plt.xlabel(r'Time (s)')\n    plt.ylabel(r'${}^\\mathcal{N} r_{\\mathcal{B}/\\mathcal{N}}$ (m)')\n    plt.legend()\n\n    plt.figure()\n    plt.clf()\n    plt.plot(timespan * 1e-9, srpForce_B_plotting[:, 0], label=r'$F \\cdot \\hat{b}_1$')\n    plt.plot(timespan * 1e-9, srpForce_B_plotting[:, 1], label=r'$F \\cdot \\hat{b}_2$')\n    plt.plot(timespan * 1e-9, srpForce_B_plotting[:, 2], label=r'$F \\cdot \\hat{b}_3$')\n    plt.xlabel(r'Time (s)')\n    plt.ylabel(r'${}^\\mathcal{B} F_{SRP, B}$ (N)')\n    plt.legend()\n\n    plt.figure()\n    plt.clf()\n    plt.plot(timespan * 1e-9, srpTorque_B_plotting[:, 0], label=r'$L \\cdot \\hat{b}_1$')\n    plt.plot(timespan * 1e-9, srpTorque_B_plotting[:, 1], label=r'$L \\cdot \\hat{b}_2$')\n    plt.plot(timespan * 1e-9, srpTorque_B_plotting[:, 2], label=r'$L \\cdot \\hat{b}_3$')\n    plt.xlabel(r'Time (s)')\n    plt.ylabel(r'${}^\\mathcal{B} L_{SRP, B}$ (Nm)')\n    plt.legend()\n\n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n    # Compare the retrieved data to the expected values computed in python\n    accuracy = 1e-15\n    forceTest1Val = np.zeros([3,])\n    forceTest2Val = np.zeros([3,])\n    torqueTest1Val = np.zeros([3, ])\n    torqueTest2Val = np.zeros([3, ])\n    index2 = int(0.5*simTimeSec / simulationTimeStep_Sec)\n\n    for i in range(len(facetAreas)):\n        forceTest1Val += checkFacetSRPForce(i, facetAreas[i], specCoeff[i], diffCoeff[i], normals_B[i], sigma_BN[1], r_BN_N[1], r_SN_N[1])\n        forceTest2Val += checkFacetSRPForce(i, facetAreas[i], specCoeff[i], diffCoeff[i], normals_B[i], sigma_BN[index2], r_BN_N[index2],\n                                       r_SN_N[index2])\n        torqueTest1Val += checkFacetSRPTorque(i, facetAreas[i], specCoeff[i], diffCoeff[i], normals_B[i], locationsPntB_B[i], sigma_BN[1],\n                                            r_BN_N[1], r_SN_N[1])\n        torqueTest2Val += checkFacetSRPTorque(i, facetAreas[i], specCoeff[i], diffCoeff[i], normals_B[i],\n                                              locationsPntB_B[i], sigma_BN[index2],\n                                              r_BN_N[index2], r_SN_N[index2])\n    if not unitTestSupport.isArrayEqual(SRPDataForce_B[1, 1:4], forceTest1Val, 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  FacetSRPEffector failed unit test at t=\" + str(\n            SRPDataForce_B[1, 0] * macros.NANO2SEC) + \"sec with a value difference of \" + str(\n            SRPDataForce_B[1, 1:] - forceTest1Val))\n        print(SRPDataForce_B[1, 1:])\n        print(forceTest1Val)\n\n    if not unitTestSupport.isArrayEqual(SRPDataForce_B[index2, 1:4], forceTest2Val, 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  FacetSRPEffector failed unit test at t=\" + str(\n            SRPDataForce_B[index2, 0] * macros.NANO2SEC) + \"sec with a value difference of \" + str(\n            SRPDataForce_B[index2, 1:] - forceTest2Val))\n        print(SRPDataForce_B[index2, 1:])\n        print(forceTest2Val)\n\n    if not unitTestSupport.isArrayEqual(SRPDataTorque_B[1, 1:4], torqueTest1Val, 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  FacetSRPEffector failed unit test at t=\" + str(\n            SRPDataTorque_B[1, 0] * macros.NANO2SEC) + \"sec with a value difference of \" + str(\n            SRPDataTorque_B[1, 1:] - torqueTest1Val))\n        print(SRPDataTorque_B[1, 1:])\n        print(torqueTest1Val)\n\n    if not unitTestSupport.isArrayEqual(SRPDataTorque_B[index2, 1:4], torqueTest2Val, 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  FacetSRPEffector failed unit test at t=\" + str(\n            SRPDataTorque_B[index2, 0] * macros.NANO2SEC) + \"sec with a value difference of \" + str(\n            SRPDataTorque_B[index2, 1:] - torqueTest2Val))\n        print(SRPDataTorque_B[index2, 1:])\n        print(torqueTest2Val)\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"PASSED\")\n\n    return testFailCount, testMessages",
  "def truthMagneticTorque(bField_N, sigmaBN, mtbCmds, GtMatrix, numMTB, maxDipole):\n    \n    temp = np.asarray(GtMatrix[0:3*numMTB])\n    GtMatrix = np.reshape(temp, (3, numMTB))\n    bField_N = np.asarray(bField_N)\n    BN = RigidBodyKinematics.MRP2C(sigmaBN)\n    bField_B = BN @ bField_N\n    for i in range(len(mtbCmds)):\n        if mtbCmds[i] > maxDipole:\n            mtbCmds[i] = maxDipole\n        if mtbCmds[i] < -maxDipole:\n            mtbCmds[i] = -maxDipole\n\n    mtbCmds = np.asarray(mtbCmds[0:numMTB])\n    bTilde = np.asarray(RigidBodyKinematics.v3Tilde(bField_B))\n    tauNet = - bTilde @ GtMatrix @ mtbCmds\n    return tauNet",
  "def test_MtbEffector(show_plots, accuracy, maxDipole):\n    r\"\"\"\n    **Validation Test Description**\n\n    Compose a general description of what is being tested in this unit test script.\n\n    **Test Parameters**\n\n    Discuss the test parameters used.\n\n    Args:\n        param1 (int): Dummy test parameter for this parameterized unit test\n        param2 (int): Dummy test parameter for this parameterized unit test\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    Here discuss what variables and states are being checked. \n    \"\"\"\n    [testResults, testMessage] = MtbEffectorTestFunction(show_plots, accuracy, maxDipole)\n    assert testResults < 1, testMessage",
  "def MtbEffectorTestFunction(show_plots, accuracy, maxDipole):\n    \"\"\"Call this routine directly to run the unit test.\"\"\"\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n   \n    # create simulation variable names\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n\n\n    # create a sim module as an empty container\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    # create the simulation process\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n\n    # create the dynamics task and specify the integration update time\n    simulationTimeStep = macros.sec2nano(1.)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n    simTime = 3.\n    simulationTime = macros.sec2nano(simTime)\n\n\n    # create Earth Gravity Body\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    earth = gravFactory.createEarth()\n    earth.isCentralBody = True  # ensure this is the central gravitational body\n    mu = earth.mu\n    \n    \n    # initialize spacecraft object and set properties\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"bskTestSat\"\n\n    I = [10.5, 0., 0.,\n         0., 8., 0.,\n         0., 0., 6.75]\n    scObject.hub.mHub = 10.0  # kg - spacecraft mass (arbitrary)\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]  # m - position vector of body-fixed point B relative to CM\n    scObject.hub.IHubPntBc_B = unitTestSupport.np2EigenMatrix3d(I)\n    \n    oe = orbitalMotion.ClassicElements()\n    oe.a = 6778.14 * 1000.  # meters\n    oe.e = 0.0\n    oe.i = 45. * macros.D2R\n    oe.Omega = 60. * macros.D2R\n    oe.omega = 0. * macros.D2R\n    oe.f = 0. * macros.D2R\n    rN, vN = orbitalMotion.elem2rv(mu, oe)\n    scObject.hub.r_CN_NInit = rN  # m   - r_CN_N\n    scObject.hub.v_CN_NInit = vN  # m/s - v_CN_N\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]  # sigma_CN_B\n    scObject.hub.omega_BN_BInit = [[0.0], [0.0], [0.0]]  # rad/s - omega_CN_B\n\n    # add spacecraft object\n    scSim.AddModelToTask(simTaskName, scObject)\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n    \n    \n    # add magnetic field module\n    magModule = magneticFieldWMM.MagneticFieldWMM()\n    magModule.ModelTag = \"WMM\"\n    magModule.dataPath = bskPath + '/supportData/MagneticField/'\n    epochMsg = unitTestSupport.timeStringToGregorianUTCMsg('2020 May 12, 00:00:0.0 (UTC)')\n    magModule.epochInMsg.subscribeTo(epochMsg)\n    magModule.addSpacecraftToModel(scObject.scStateOutMsg)  # this command can be repeated if multiple\n    scSim.AddModelToTask(simTaskName, magModule)\n    \n    \n    # add magnetic torque bar effector\n    mtbEff = MtbEffector.MtbEffector()\n    mtbEff.ModelTag = \"MtbEff\"\n    scObject.addDynamicEffector(mtbEff)\n    scSim.AddModelToTask(simTaskName, mtbEff)\n    \n    \n    # mtbConfigData message\n    mtbConfigParams = messaging.MTBArrayConfigMsgPayload()\n    mtbConfigParams.numMTB = 3\n    # row major toque bar alignments\n    mtbConfigParams.GtMatrix_B = [\n        1., 0., 0.,\n        0., 1., 0.,\n        0., 0., 1.\n    ]\n    mtbConfigParams.maxMtbDipoles = [maxDipole]*4\n    mtbParamsInMsg = messaging.MTBArrayConfigMsg().write(mtbConfigParams)\n    \n    \n    # MTBCmdMsgPayload, mtbCmdInMsg\n    mtbCmdInMsgContainer = messaging.MTBCmdMsgPayload()\n    mtbCmdInMsgContainer.mtbDipoleCmds = [0.2, 0.2, 0.2]\n    mtbCmdInMsg = messaging.MTBCmdMsg().write(mtbCmdInMsgContainer)\n    \n    # subscribe to mesaages \n    mtbEff.mtbCmdInMsg.subscribeTo(mtbCmdInMsg)\n    mtbEff.mtbParamsInMsg.subscribeTo(mtbParamsInMsg)\n    mtbEff.magInMsg.subscribeTo(magModule.envOutMsgs[0])\n    \n    \n    # Setup data logging before the simulation is initialized\n    numDataPoints = 3600\n    samplingTime = unitTestSupport.samplingTime(simulationTime, simulationTimeStep, numDataPoints)\n    dataLog = scObject.scStateOutMsg.recorder(samplingTime)\n    dataLogMag = magModule.envOutMsgs[0].recorder(samplingTime)\n    dataLogMTB = mtbEff.mtbOutMsg.recorder(samplingTime)\n    \n    scSim.AddModelToTask(simTaskName, dataLogMTB)\n    scSim.AddModelToTask(simTaskName, dataLogMag)\n    scSim.AddModelToTask(simTaskName, dataLog)\n    \n\n    # initialize Simulation\n    scSim.InitializeSimulation()\n\n    # configure a simulation stop time and execute the simulation run\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    # retrieve the logged data\n    attData = dataLog.sigma_BN\n    mtbData = dataLogMTB.mtbNetTorque_B\n    dataMagField = dataLogMag.magField_N\n    np.set_printoptions(precision=16)\n     \n    # plot net mtb torque\n    if show_plots:\n        plt.close(\"all\")  # clears out plots from earlier test runs\n        plt.figure(1)\n        for idx in range(0, 3):\n            plt.plot(dataLogMTB.times() * macros.NANO2SEC, mtbData[:, idx],\n                     color=unitTestSupport.getLineColor(idx, 3),\n                     label=r'$\\tau_' + str(idx) + '$')\n        plt.legend(loc='lower right')\n        plt.xlabel('Time [s]')\n        plt.ylabel(r'MTB Net Torque $\\tau_{B}$ [Nm]')\n\n        # plot magnetic field data in the Inertial frame\n        plt.figure(2)\n        for idx in range(3):\n            plt.plot(dataLogMag.times() * macros.NANO2SEC, dataMagField[:, idx] * 1e9,\n                     color=unitTestSupport.getLineColor(idx, 3),\n                     label=r'$B\\_N_{' + str(idx) + '}$')\n        plt.legend(loc='lower right')\n        plt.xlabel('Time [s]')\n        plt.ylabel('Magnetic Field [nT]')\n\n        # plot the Body relative to Inertial attitude\n        plt.figure(3)\n        for idx in range(0, 3):\n            plt.plot(dataLog.times() * macros.NANO2SEC, attData[:, idx],\n                     color=unitTestSupport.getLineColor(idx, 3),\n                     label=r'$\\sigma_' + str(idx) + '$')\n        plt.legend(loc='lower right')\n        plt.xlabel('Time [s]')\n        plt.ylabel(r'MRP Attitude $\\sigma_{B/N}$')\n\n        plt.show()\n\n    # compare gravity gradient torque vector to the truth\n\n    # use mtbData[1:, :] since mtbData is the torque from prev iterations\n    for sV, mtbTauV, bV in zip(attData[1:, :], mtbData[1:, :], dataMagField):\n        mtbTauTruth = truthMagneticTorque(bV, sV, mtbCmdInMsgContainer.mtbDipoleCmds,\n                                          mtbConfigParams.GtMatrix_B,\n                                          mtbConfigParams.numMTB,\n                                          maxDipole\n                                          )\n        \n        testFailCount, testMessages = unitTestSupport.compareVector(mtbTauV,\n                                                                    mtbTauTruth,\n                                                                    accuracy,\n                                                                    \"mtbTorque_B\",\n                                                                    testFailCount, testMessages)\n     \n    if testFailCount == 0:\n        print(\"PASSED: Mtb Effector\")\n    else:\n        print(\"Failed: Mtb Effector\")\n\n    return testFailCount, testMessages",
  "def addTimeColumn(time, data):\n    return numpy.transpose(numpy.vstack([[time], numpy.transpose(data)]))",
  "def test_spacecraftSystemAllTest(show_plots, function):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = eval(function + '(show_plots)')\n    assert testResults < 1, testMessage",
  "def SCConnected(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scSystem = spacecraftSystem.SpacecraftSystem()\n    scSystem.ModelTag = \"spacecraftSystem\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.001)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scSystem)\n\n    # Define initial conditions of primary spacecraft\n    scSystem.primaryCentralSpacecraft.hub.mHub = 100\n    scSystem.primaryCentralSpacecraft.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scSystem.primaryCentralSpacecraft.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    scSystem.primaryCentralSpacecraft.hub.r_CN_NInit = [[-4020338.690396649],\t[7490566.741852513],\t[5248299.211589362]]\n    scSystem.primaryCentralSpacecraft.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n    scSystem.primaryCentralSpacecraft.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scSystem.primaryCentralSpacecraft.hub.omega_BN_BInit = [[0.5], [-0.4], [0.7]]\n\n    # Define docking information\n    dock1SC1 = spacecraftSystem.DockingData()\n    dock1SC1.r_DB_B = [[1.0], [0.0], [0.0]]\n    dock1SC1.dcm_DB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    dock1SC1.portName = \"sc1port1\"\n    scSystem.primaryCentralSpacecraft.addDockingPort(dock1SC1)\n\n    unitTestSim.panel1 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n\n    # Define Variable for panel 1\n    unitTestSim.panel1.mass = 100.0\n    unitTestSim.panel1.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel1.d = 1.5\n    unitTestSim.panel1.k = 100.0\n    unitTestSim.panel1.c = 0.0\n    unitTestSim.panel1.r_HB_B = [[0.5], [0.0], [1.0]]\n    unitTestSim.panel1.dcm_HB = [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel1.thetaInit = 5*numpy.pi/180.0\n    unitTestSim.panel1.thetaDotInit = 0.0\n\n    scSystem.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel1)\n\n    unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n    unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n    unitTestSim.earthGravBody.mu = 0.3986004415E+15 # meters!\n    unitTestSim.earthGravBody.isCentralBody = True\n    unitTestSim.earthGravBody.useSphericalHarmParams = False\n\n    scSystem.primaryCentralSpacecraft.gravField.gravBodies = spacecraftSystem.GravBodyVector([unitTestSim.earthGravBody])\n\n    sc2 = spacecraftSystem.SpacecraftUnit()\n    sc2.hub.mHub = 100\n    sc2.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    sc2.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    sc2.spacecraftName = \"spacecraft2\"\n\n    # Define docking information\n    dock1SC2 = spacecraftSystem.DockingData()\n    dock1SC2.r_DB_B = [[-1.0], [0.0], [0.0]]\n    dock1SC2.dcm_DB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    dock1SC2.portName = \"sc2port1\"\n    sc2.addDockingPort(dock1SC2)\n\n    # Define docking information\n    dock2SC2 = spacecraftSystem.DockingData()\n    dock2SC2.r_DB_B = [[1.0], [0.0], [0.0]]\n    dock2SC2.dcm_DB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    dock2SC2.portName = \"sc2port2\"\n    sc2.addDockingPort(dock2SC2)\n\n    # Define gravity for sc2\n    sc2.gravField.gravBodies = spacecraftSystem.GravBodyVector([unitTestSim.earthGravBody])\n\n    sc3 = spacecraftSystem.SpacecraftUnit()\n    sc3.hub.mHub = 100\n    sc3.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    sc3.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    sc3.spacecraftName = \"spacecraft3\"\n\n    # Define docking information\n    dock1SC3 = spacecraftSystem.DockingData()\n    dock1SC3.r_DB_B = [[-1.0], [0.0], [0.0]]\n    dock1SC3.dcm_DB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    dock1SC3.portName = \"sc3port1\"\n    sc3.addDockingPort(dock1SC3)\n\n    unitTestSim.panel2 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n\n    # Define Variables for panel 2\n    unitTestSim.panel2.mass = 100.0\n    unitTestSim.panel2.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel2.d = 1.5\n    unitTestSim.panel2.k = 100.0\n    unitTestSim.panel2.c = 0.0\n    unitTestSim.panel2.r_HB_B = [[-0.5], [0.0], [1.0]]\n    unitTestSim.panel2.dcm_HB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel2.thetaInit = 0.0\n    unitTestSim.panel2.thetaDotInit = 0.0\n\n    sc3.addStateEffector(unitTestSim.panel2)\n\n    # Define gravity for sc2\n    sc3.gravField.gravBodies = spacecraftSystem.GravBodyVector([unitTestSim.earthGravBody])\n\n    # Attach spacecraft2 to spacecraft\n    scSystem.attachSpacecraftToPrimary(sc2, dock1SC2.portName, dock1SC1.portName)\n\n    # Attach spacecraft3 to spacecraft2\n    scSystem.attachSpacecraftToPrimary(sc3, dock1SC3.portName, dock2SC2.portName)\n\n    dataLog = scSystem.primaryCentralSpacecraft.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.AddVariableForLogging(scSystem.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scSystem.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scSystem.ModelTag + \".primaryCentralSpacecraft\" + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scSystem.ModelTag + \".primaryCentralSpacecraft\" + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n\n    stopTime = 1.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    orbEnergy = unitTestSim.GetLogVariableData(scSystem.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbEnergy\")\n    orbAngMom_N = unitTestSim.GetLogVariableData(scSystem.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scSystem.ModelTag + \".primaryCentralSpacecraft\" + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scSystem.ModelTag + \".primaryCentralSpacecraft\" + \".totRotEnergy\")\n\n    r_BN_NOutput = dataLog.r_BN_N\n    sigma_BNOutput = dataLog.sigma_BN\n\n    truePos = [\n                [-4072255.7737936215, 7456050.4649078, 5258610.029627514]\n                ]\n\n    trueSigma = [\n                [3.73034285e-01,  -2.39564413e-03,   2.08570797e-01]\n                ]\n\n    initialOrbAngMom_N = [\n                [orbAngMom_N[0,1], orbAngMom_N[0,2], orbAngMom_N[0,3]]\n                ]\n\n    finalOrbAngMom = [\n                [orbAngMom_N[-1,1], orbAngMom_N[-1,2], orbAngMom_N[-1,3]]\n                 ]\n\n    initialRotAngMom_N = [\n                [rotAngMom_N[0,1], rotAngMom_N[0,2], rotAngMom_N[0,3]]\n                ]\n\n    finalRotAngMom = [\n                [rotAngMom_N[-1,1], rotAngMom_N[-1,2], rotAngMom_N[-1,3]]\n                 ]\n\n    initialOrbEnergy = [\n                [orbEnergy[0,1]]\n                ]\n\n    finalOrbEnergy = [\n                [orbEnergy[-1,1]]\n                 ]\n\n    initialRotEnergy = [\n                [rotEnergy[0,1]]\n                ]\n\n    finalRotEnergy = [\n                [rotEnergy[-1,1]]\n                 ]\n\n    plt.close(\"all\")\n    plt.figure()\n    plt.clf()\n    plt.plot(orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,1] - orbAngMom_N[0,1])/orbAngMom_N[0,1], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,2] - orbAngMom_N[0,2])/orbAngMom_N[0,2], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,3] - orbAngMom_N[0,3])/orbAngMom_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInOrbitalAngularMomentumSystem\"\n    PlotTitle = \"Change in Orbital Angular Momentum with Gravity\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(orbEnergy[:,0]*1e-9, (orbEnergy[:,1] - orbEnergy[0,1])/orbEnergy[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInOrbitalEnergySystem\"\n    PlotTitle = \"Change in Orbital Energy with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,1] - rotAngMom_N[0,1])/rotAngMom_N[0,1], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,2] - rotAngMom_N[0,2])/rotAngMom_N[0,2], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,3] - rotAngMom_N[0,3])/rotAngMom_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInRotationalAngularMomentumSystem\"\n    PlotTitle = \"Change In Rotational Angular Momentum with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotEnergy[:,0]*1e-9, (rotEnergy[:,1] - rotEnergy[0,1])/rotEnergy[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInRotationalEnergySystem\"\n    PlotTitle = \"Change In Rotational Energy with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    accuracy = 1e-8\n    # for i in range(0,len(truePos)):\n    #     # check a vector values\n    #     if not unitTestSupport.isArrayEqualRelative(r_BN_NOutput[-1,:],truePos[i],3,accuracy):\n    #         testFailCount += 1\n    #         testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed pos unit test\")\n    #\n    # for i in range(0,len(trueSigma)):\n    #     # check a vector values\n    #     if not unitTestSupport.isArrayEqualRelative(sigma_BNOutput[-1,:],trueSigma[i],3,accuracy):\n    #         testFailCount += 1\n    #         testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed attitude unit test\")\n\n    accuracy = 1e-10\n    for i in range(0,len(initialOrbAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i],initialOrbAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed orbital angular momentum unit test\")\n\n    for i in range(0,len(initialRotAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i],initialRotAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed rotational angular momentum unit test\")\n\n    for i in range(0,len(initialRotEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotEnergy[i],initialRotEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed rotational energy unit test\")\n\n    for i in range(0,len(initialOrbEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i],initialOrbEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed orbital energy unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Spacecraft Translation and Rotation Integrated Sim Test\")\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def SCConnectedAndUnconnected(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scSystem = spacecraftSystem.SpacecraftSystem()\n    scSystem.ModelTag = \"spacecraftSystem\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.001)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scSystem)\n\n    # Define initial conditions of primary spacecraft\n    scSystem.primaryCentralSpacecraft.hub.mHub = 100\n    scSystem.primaryCentralSpacecraft.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scSystem.primaryCentralSpacecraft.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    scSystem.primaryCentralSpacecraft.hub.r_CN_NInit = [[-4020338.690396649],\t[7490566.741852513],\t[5248299.211589362]]\n    scSystem.primaryCentralSpacecraft.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n    scSystem.primaryCentralSpacecraft.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scSystem.primaryCentralSpacecraft.hub.omega_BN_BInit = [[0.5], [-0.4], [0.7]]\n\n    # Define docking information\n    dock1SC1 = spacecraftSystem.DockingData()\n    dock1SC1.r_DB_B = [[1.0], [0.0], [0.0]]\n    dock1SC1.dcm_DB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    dock1SC1.portName = \"sc1port1\"\n    scSystem.primaryCentralSpacecraft.addDockingPort(dock1SC1)\n\n    unitTestSim.panel1 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n\n    # Define Variable for panel 1\n    unitTestSim.panel1.mass = 100.0\n    unitTestSim.panel1.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel1.d = 1.5\n    unitTestSim.panel1.k = 100.0\n    unitTestSim.panel1.c = 0.0\n    unitTestSim.panel1.r_HB_B = [[0.5], [0.0], [1.0]]\n    unitTestSim.panel1.dcm_HB = [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel1.thetaInit = 5*numpy.pi/180.0\n    unitTestSim.panel1.thetaDotInit = 0.0\n\n    scSystem.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel1)\n\n    unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n    unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n    unitTestSim.earthGravBody.mu = 0.3986004415E+15 # meters!\n    unitTestSim.earthGravBody.isCentralBody = True\n    unitTestSim.earthGravBody.useSphericalHarmParams = False\n\n    scSystem.primaryCentralSpacecraft.gravField.gravBodies = spacecraftSystem.GravBodyVector([unitTestSim.earthGravBody])\n\n    sc2 = spacecraftSystem.SpacecraftUnit()\n    sc2.hub.mHub = 100\n    sc2.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    sc2.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    sc2.spacecraftName = \"spacecraft2\"\n\n    # Define docking information\n    dock1SC2 = spacecraftSystem.DockingData()\n    dock1SC2.r_DB_B = [[-1.0], [0.0], [0.0]]\n    dock1SC2.dcm_DB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    dock1SC2.portName = \"sc2port1\"\n    sc2.addDockingPort(dock1SC2)\n\n    # Define docking information\n    dock2SC2 = spacecraftSystem.DockingData()\n    dock2SC2.r_DB_B = [[1.0], [0.0], [0.0]]\n    dock2SC2.dcm_DB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    dock2SC2.portName = \"sc2port2\"\n    sc2.addDockingPort(dock2SC2)\n\n    # Define gravity for sc2\n    sc2.gravField.gravBodies = spacecraftSystem.GravBodyVector([unitTestSim.earthGravBody])\n\n    sc3 = spacecraftSystem.SpacecraftUnit()\n    sc3.hub.mHub = 100\n    sc3.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    sc3.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    sc3.spacecraftName = \"spacecraft3\"\n\n    # Define docking information\n    dock1SC3 = spacecraftSystem.DockingData()\n    dock1SC3.r_DB_B = [[-1.0], [0.0], [0.0]]\n    dock1SC3.dcm_DB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    dock1SC3.portName = \"sc3port1\"\n    sc3.addDockingPort(dock1SC3)\n\n    unitTestSim.panel2 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n\n    # Define Variables for panel 2\n    unitTestSim.panel2.mass = 100.0\n    unitTestSim.panel2.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel2.d = 1.5\n    unitTestSim.panel2.k = 100.0\n    unitTestSim.panel2.c = 0.0\n    unitTestSim.panel2.r_HB_B = [[-0.5], [0.0], [1.0]]\n    unitTestSim.panel2.dcm_HB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel2.thetaInit = 0.0\n    unitTestSim.panel2.thetaDotInit = 0.0\n\n    sc3.addStateEffector(unitTestSim.panel2)\n\n    # Define gravity for sc2\n    sc3.gravField.gravBodies = spacecraftSystem.GravBodyVector([unitTestSim.earthGravBody])\n\n    # Attach spacecraft2 to spacecraft\n    scSystem.attachSpacecraftToPrimary(sc2, dock1SC2.portName, dock1SC1.portName)\n\n    # Attach spacecraft3 to spacecraft2\n    scSystem.attachSpacecraftToPrimary(sc3, dock1SC3.portName, dock2SC2.portName)\n\n    # Define two independent spacecraft\n    sc4 = spacecraftSystem.SpacecraftUnit()\n    sc4.hub.mHub = 100\n    sc4.hub.r_BcB_B = [[0.0], [0.0], [0.1]]\n    sc4.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    sc4.hub.r_CN_NInit = [[7490566.741852513],[-4020338.690396649],[5248299.211589362]]\n    sc4.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n    sc4.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    sc4.hub.omega_BN_BInit = [[0.5], [-0.4], [0.7]]\n    sc4.spacecraftName = \"spacecraft4\"\n\n    # Define gravity for sc4\n    sc4.gravField.gravBodies = spacecraftSystem.GravBodyVector([unitTestSim.earthGravBody])\n\n    unitTestSim.panel3 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n\n    # Define Variables for panel 1 on sc4\n    unitTestSim.panel3.mass = 100.0\n    unitTestSim.panel3.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel3.d = 1.5\n    unitTestSim.panel3.k = 100.0\n    unitTestSim.panel3.c = 0.0\n    unitTestSim.panel3.r_HB_B = [[-0.5], [0.0], [1.0]]\n    unitTestSim.panel3.dcm_HB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel3.thetaInit = 0.0\n    unitTestSim.panel3.thetaDotInit = 0.0\n\n    sc4.addStateEffector(unitTestSim.panel3)\n\n    scSystem.addSpacecraftUndocked(sc4)\n\n    sc5 = spacecraftSystem.SpacecraftUnit()\n    sc5.hub.mHub = 100\n    sc5.hub.r_BcB_B = [[0.1], [0.0], [0.0]]\n    sc5.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    sc5.hub.r_CN_NInit = [[5248299.211589362],[7490566.741852513],[-4020338.690396649]]\n    sc5.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n    sc5.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    sc5.hub.omega_BN_BInit = [[0.5], [-0.4], [0.7]]\n    sc5.spacecraftName = \"spacecraft5\"\n\n    # Define gravity for sc4\n    sc5.gravField.gravBodies = spacecraftSystem.GravBodyVector([unitTestSim.earthGravBody])\n\n    scSystem.addSpacecraftUndocked(sc5)\n\n    dataLog = scSystem.primaryCentralSpacecraft.scStateOutMsg.recorder()\n    dataLog4 = sc4.scStateOutMsg.recorder()\n    dataLog5 = sc5.scStateOutMsg.recorder()\n    dataEngLog = scSystem.primaryCentralSpacecraft.scEnergyMomentumOutMsg.recorder()\n    dataEngLog4 = sc4.scEnergyMomentumOutMsg.recorder()\n    dataEngLog5 = sc5.scEnergyMomentumOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n    unitTestSim.AddModelToTask(unitTaskName, dataLog4)\n    unitTestSim.AddModelToTask(unitTaskName, dataLog5)\n    unitTestSim.AddModelToTask(unitTaskName, dataEngLog)\n    unitTestSim.AddModelToTask(unitTaskName, dataEngLog4)\n    unitTestSim.AddModelToTask(unitTaskName, dataEngLog5)\n\n    unitTestSim.InitializeSimulation()\n\n    stopTime = 1.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    r_BN_NOutput = addTimeColumn(dataLog.times(), dataLog.r_BN_N)\n    sigma_BNOutput = addTimeColumn(dataLog.times(), dataLog.sigma_BN)\n    r_BN_NOutput1 = addTimeColumn(dataLog4.times(), dataLog4.r_BN_N)\n    sigma_BNOutput1 = addTimeColumn(dataLog4.times(), dataLog4.sigma_BN)\n    r_BN_NOutput2 = addTimeColumn(dataLog5.times(), dataLog5.r_BN_N)\n    sigma_BNOutput2 = addTimeColumn(dataLog5.times(), dataLog5.sigma_BN)\n\n    rotEnergy = addTimeColumn(dataEngLog.times(), dataEngLog.spacecraftRotEnergy)\n    orbEnergy = addTimeColumn(dataEngLog.times(), dataEngLog.spacecraftOrbEnergy)\n    rotAngMom_N = addTimeColumn(dataEngLog.times(), dataEngLog.spacecraftRotAngMomPntC_N)\n    orbAngMom_N = addTimeColumn(dataEngLog.times(), dataEngLog.spacecraftOrbAngMomPntN_N)\n\n    rotEnergy1 = addTimeColumn(dataEngLog4.times(), dataEngLog4.spacecraftRotEnergy)\n    orbEnergy1 = addTimeColumn(dataEngLog4.times(), dataEngLog4.spacecraftOrbEnergy)\n    rotAngMom1_N = addTimeColumn(dataEngLog4.times(), dataEngLog4.spacecraftRotAngMomPntC_N)\n    orbAngMom1_N = addTimeColumn(dataEngLog4.times(), dataEngLog4.spacecraftOrbAngMomPntN_N)\n\n    rotEnergy2 = addTimeColumn(dataEngLog5.times(), dataEngLog5.spacecraftRotEnergy)\n    orbEnergy2 = addTimeColumn(dataEngLog5.times(), dataEngLog5.spacecraftOrbEnergy)\n    rotAngMom2_N = addTimeColumn(dataEngLog5.times(), dataEngLog5.spacecraftRotAngMomPntC_N)\n    orbAngMom2_N = addTimeColumn(dataEngLog5.times(), dataEngLog5.spacecraftOrbAngMomPntN_N)\n\n    truePos = [\n                [-4072255.7737936215, 7456050.4649078, 5258610.029627514]\n                ]\n\n    trueSigma = [\n                [3.73034285e-01,  -2.39564413e-03,   2.08570797e-01]\n                ]\n\n    initialOrbAngMom_N = [\n                [orbAngMom_N[0,1], orbAngMom_N[0,2], orbAngMom_N[0,3]]\n                ]\n\n    finalOrbAngMom = [\n                [orbAngMom_N[-1,1], orbAngMom_N[-1,2], orbAngMom_N[-1,3]]\n                 ]\n\n    initialRotAngMom_N = [\n                [rotAngMom_N[0,1], rotAngMom_N[0,2], rotAngMom_N[0,3]]\n                ]\n\n    finalRotAngMom = [\n                [rotAngMom_N[-1,1], rotAngMom_N[-1,2], rotAngMom_N[-1,3]]\n                 ]\n\n    initialOrbEnergy = [\n                [orbEnergy[0,1]]\n                ]\n\n    finalOrbEnergy = [\n                [orbEnergy[-1,1]]\n                 ]\n\n    initialRotEnergy = [\n                [rotEnergy[0,1]]\n                ]\n\n    finalRotEnergy = [\n                [rotEnergy[-1,1]]\n                 ]\n\n    plt.figure()\n    plt.clf()\n    plt.plot(orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,1] - orbAngMom_N[0,1])/orbAngMom_N[0,1], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,2] - orbAngMom_N[0,2])/orbAngMom_N[0,2], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,3] - orbAngMom_N[0,3])/orbAngMom_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInOrbitalAngularMomentum\"\n    PlotTitle = \"Change in Orbital Angular Momentum with Gravity\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(orbEnergy[:,0]*1e-9, (orbEnergy[:,1] - orbEnergy[0,1])/orbEnergy[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInOrbitalEnergy\"\n    PlotTitle = \"Change in Orbital Energy with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,1] - rotAngMom_N[0,1])/rotAngMom_N[0,1], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,2] - rotAngMom_N[0,2])/rotAngMom_N[0,2], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,3] - rotAngMom_N[0,3])/rotAngMom_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInRotationalAngularMomentum\"\n    PlotTitle = \"Change In Rotational Angular Momentum with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotEnergy[:,0]*1e-9, (rotEnergy[:,1] - rotEnergy[0,1])/rotEnergy[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInRotationalEnergy\"\n    PlotTitle = \"Change In Rotational Energy with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n\n    plt.figure()\n    plt.clf()\n    plt.plot(orbAngMom1_N[:,0]*1e-9, (orbAngMom1_N[:,1] - orbAngMom1_N[0,1])/orbAngMom1_N[0,1], orbAngMom1_N[:,0]*1e-9, (orbAngMom1_N[:,2] - orbAngMom1_N[0,2])/orbAngMom1_N[0,2], orbAngMom1_N[:,0]*1e-9, (orbAngMom1_N[:,3] - orbAngMom1_N[0,3])/orbAngMom1_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInOrbitalAngularMomentum1\"\n    PlotTitle = \"Change in Orbital Angular Momentum with Gravity\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(orbEnergy1[:,0]*1e-9, (orbEnergy1[:,1] - orbEnergy1[0,1])/orbEnergy1[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInOrbitalEnergy1\"\n    PlotTitle = \"Change in Orbital Energy with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom1_N[:,0]*1e-9, (rotAngMom1_N[:,1] - rotAngMom1_N[0,1])/rotAngMom1_N[0,1], rotAngMom1_N[:,0]*1e-9, (rotAngMom1_N[:,2] - rotAngMom1_N[0,2])/rotAngMom1_N[0,2], rotAngMom1_N[:,0]*1e-9, (rotAngMom1_N[:,3] - rotAngMom1_N[0,3])/rotAngMom1_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInRotationalAngularMomentum1\"\n    PlotTitle = \"Change In Rotational Angular Momentum with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotEnergy1[:,0]*1e-9, (rotEnergy1[:,1] - rotEnergy1[0,1])/rotEnergy1[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInRotationalEnergy1\"\n    PlotTitle = \"Change In Rotational Energy with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n\n    plt.figure()\n    plt.clf()\n    plt.plot(orbAngMom2_N[:,0]*1e-9, (orbAngMom2_N[:,1] - orbAngMom2_N[0,1])/orbAngMom2_N[0,1], orbAngMom2_N[:,0]*1e-9, (orbAngMom2_N[:,2] - orbAngMom2_N[0,2])/orbAngMom2_N[0,2], orbAngMom2_N[:,0]*1e-9, (orbAngMom2_N[:,3] - orbAngMom2_N[0,3])/orbAngMom2_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInOrbitalAngularMomentum2\"\n    PlotTitle = \"Change in Orbital Angular Momentum with Gravity\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(orbEnergy2[:,0]*1e-9, (orbEnergy2[:,1] - orbEnergy2[0,1])/orbEnergy2[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInOrbitalEnergy2\"\n    PlotTitle = \"Change in Orbital Energy with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom2_N[:,0]*1e-9, (rotAngMom2_N[:,1] - rotAngMom2_N[0,1])/rotAngMom2_N[0,1], rotAngMom2_N[:,0]*1e-9, (rotAngMom2_N[:,2] - rotAngMom2_N[0,2])/rotAngMom2_N[0,2], rotAngMom2_N[:,0]*1e-9, (rotAngMom2_N[:,3] - rotAngMom2_N[0,3])/rotAngMom2_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInRotationalAngularMomentum2\"\n    PlotTitle = \"Change In Rotational Angular Momentum with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotEnergy2[:,0]*1e-9, (rotEnergy2[:,1] - rotEnergy2[0,1])/rotEnergy2[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    PlotName = \"ChangeInRotationalEnergy2\"\n    PlotTitle = \"Change In Rotational Energy with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    accuracy = 1e-8\n    # for i in range(0,len(truePos)):\n    #     # check a vector values\n    #     if not unitTestSupport.isArrayEqualRelative(r_BN_NOutput[-1,:],truePos[i],3,accuracy):\n    #         testFailCount += 1\n    #         testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed pos unit test\")\n    #\n    # for i in range(0,len(trueSigma)):\n    #     # check a vector values\n    #     if not unitTestSupport.isArrayEqualRelative(sigma_BNOutput[-1,:],trueSigma[i],3,accuracy):\n    #         testFailCount += 1\n    #         testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed attitude unit test\")\n\n    accuracy = 1e-10\n    for i in range(0,len(initialOrbAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i],initialOrbAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed orbital angular momentum unit test\")\n\n    for i in range(0,len(initialRotAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i],initialRotAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed rotational angular momentum unit test\")\n\n    for i in range(0,len(initialRotEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotEnergy[i],initialRotEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed rotational energy unit test\")\n\n    for i in range(0,len(initialOrbEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i],initialOrbEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed orbital energy unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Spacecraft Translation and Rotation Integrated Sim Test\")\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def test_nHingedRigidBodyAllTest(show_plots, testCase):\n    \"\"\"\nIn this integrated test there are two hinged rigid bodies connected to the spacecraft hub, one with 4 \\\ninterconnected panels and one with 3 interconnected panels.  Depending on the scenario, there are different \\\nsuccess criteria.  Each scenario checks the conservation of orbital angular momentum, the conservation of orbital \\\nenergy, the conservation of rotational angular momentum and the conservation of rotational energy.\n\n\n**Test Parameters:**\n\n- testCase: [string]\n    defines whether or not the gravity is included in this test.\n\n**Description of Variables Being Tested**\n\nThis test checks the conservation of the spacecraft orbital angular momentum, the rotational angular momentum, \\\nthe orbital energy and the rotational energy.\n\n**Test Descriptions:**\n\ntestCase == 'Gravity'\nIn this test the simulation is placed into orbit around Earth with point gravity and has no damping in \\\nthe hinged rigid bodies.\n\ntestCase == 'NoGravity'\nIn this test, the spacecraft is placed in free space (no gravity) and has no damping in the hinged rigid bodies.\n\nThe following figures show the conservation of the quantities described in the success criteria for each scenario. \\\nThe conservation plots are all relative difference plots. All conservation plots show integration error which is the \\\ndesired result. In the python test these values are automatically checked therefore when the tests pass, these \\\nvalues have all been confirmed to be conserved.\n\n    \"\"\"\n    [testResults, testMessage] = nHingedRigidBody(show_plots, testCase)\n    assert testResults < 1, testMessage",
  "def nHingedRigidBody(show_plots, testCase):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.0001)  # update process rate update time\n    plottingRate = 0.01\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    unitTestSim.effector1 = nHingedRigidBodyStateEffector.NHingedRigidBodyStateEffector()\n    unitTestSim.effector2 = nHingedRigidBodyStateEffector.NHingedRigidBodyStateEffector()\n    unitTestSim.panel = nHingedRigidBodyStateEffector.HingedPanel()\n\n    unitTestSim.effector1.r_HB_B = [[0.5], [0.0], [1.0]]\n    unitTestSim.effector1.dcm_HB = [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]\n\n    unitTestSim.effector2.r_HB_B = [[-0.5], [0.0], [1.0]]\n    unitTestSim.effector2.dcm_HB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n\n    # Define Variable for a panel\n    unitTestSim.panel.mass = 50.0\n    unitTestSim.panel.IPntS_S = [[50.0, 0.0, 0.0], [0.0, 25.0, 0.0], [0.0, 0.0, 25.0]]\n    unitTestSim.panel.d = 0.75\n    unitTestSim.panel.k = 500.0\n    unitTestSim.panel.c = 0.0\n    unitTestSim.panel.thetaInit = 5*numpy.pi/180.0\n    unitTestSim.panel.thetaDotInit = 0.0\n    unitTestSim.panel.theta_0 = 0.0\n\n    # Add panels to effector 4 to one 3 to the other\n    unitTestSim.effector1.addHingedPanel(unitTestSim.panel)\n    unitTestSim.panel.thetaInit = 0.0\n    unitTestSim.effector1.addHingedPanel(unitTestSim.panel)\n    unitTestSim.effector1.addHingedPanel(unitTestSim.panel)\n    unitTestSim.effector1.addHingedPanel(unitTestSim.panel)\n    # 3 on effector 2\n    unitTestSim.effector2.addHingedPanel(unitTestSim.panel)\n    unitTestSim.effector2.addHingedPanel(unitTestSim.panel)\n    unitTestSim.effector2.addHingedPanel(unitTestSim.panel)\n\n    # Add effector to spaceCraft\n    scObject.addStateEffector(unitTestSim.effector1)\n    scObject.addStateEffector(unitTestSim.effector2)\n\n    scObject.hub.mHub = 750.0\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    # Set the initial values for the states\n    scObject.hub.r_CN_NInit = [[0.1], [-0.4], [0.3]]\n    scObject.hub.v_CN_NInit = [[-0.2], [0.5], [0.1]]\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.omega_BN_BInit = [[0.1], [-0.1], [0.1]]\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    if testCase == 'Gravity':\n        unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n        unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n        unitTestSim.earthGravBody.mu = 0.3986004415E+15 # meters!\n        unitTestSim.earthGravBody.isCentralBody = True\n        unitTestSim.earthGravBody.useSphericalHarmParams = False\n        scObject.gravField.gravBodies = spacecraft.GravBodyVector([unitTestSim.earthGravBody])\n        scObject.hub.r_CN_NInit = [[-4020338.690396649],\t[7490566.741852513],\t[5248299.211589362]]\n        scObject.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n\n    dataLog = scObject.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.AddVariableForLogging(\"spacecraftBody.dynManager.getStateObject('nHingedRigidBody1Theta').getState()\", plottingRate, 0, 3, 'double')\n    unitTestSim.AddVariableForLogging(\"spacecraftBody.dynManager.getStateObject('nHingedRigidBody2Theta').getState()\", plottingRate, 0, 2, 'double')\n\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbEnergy\", plottingRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", plottingRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", plottingRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", plottingRate, 0, 0, 'double')\n\n    stopTime = 1.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    nHingedRigidBody1ThetasOut = unitTestSim.GetLogVariableData(\"spacecraftBody.dynManager.getStateObject('nHingedRigidBody1Theta').getState()\")\n    nHingedRigidBody2ThetasOut = unitTestSim.GetLogVariableData(\"spacecraftBody.dynManager.getStateObject('nHingedRigidBody2Theta').getState()\")\n\n    orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbEnergy\")\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n\n    initialOrbAngMom_N = [[orbAngMom_N[0, 1], orbAngMom_N[0, 2], orbAngMom_N[0, 3]]]\n\n    finalOrbAngMom = [orbAngMom_N[-1]]\n\n    initialRotAngMom_N = [[rotAngMom_N[0, 1], rotAngMom_N[0, 2], rotAngMom_N[0, 3]]]\n\n    finalRotAngMom = [rotAngMom_N[-1]]\n\n    initialOrbEnergy = [[orbEnergy[0, 1]]]\n\n    finalOrbEnergy = [orbEnergy[-1]]\n\n    initialRotEnergy = [[rotEnergy[0, 1]]]\n\n    finalRotEnergy = [rotEnergy[-1]]\n\n    plt.close(\"all\")\n\n    plt.figure()\n    plt.clf()\n    plt.plot(orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,1] - orbAngMom_N[0,1])/orbAngMom_N[0,1], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,2] - orbAngMom_N[0,2])/orbAngMom_N[0,2], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,3] - orbAngMom_N[0,3])/orbAngMom_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    plt.suptitle(\"Change in Orbital Angular Momentum \")\n    plt.figure()\n    plt.clf()\n    plt.plot(orbEnergy[:,0]*1e-9, (orbEnergy[:,1] - orbEnergy[0,1])/orbEnergy[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    plt.suptitle(\"Change in Orbital Energy \")\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,1] - rotAngMom_N[0,1])/rotAngMom_N[0,1], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,2] - rotAngMom_N[0,2])/rotAngMom_N[0,2], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,3] - rotAngMom_N[0,3])/rotAngMom_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    plt.suptitle(\"Change in Rotational Angular Momentum\")\n    plt.figure()\n    plt.clf()\n    plt.plot(rotEnergy[:,0]*1e-9, (rotEnergy[:,1] - rotEnergy[0,1])/rotEnergy[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    plt.suptitle(\"Change in Rotational Energy\")\n\n    plt.figure()\n    plt.clf()\n    plt.plot(nHingedRigidBody1ThetasOut[:,0]*1e-9, nHingedRigidBody1ThetasOut[:,1]*180/numpy.pi,'-b')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Panel 1 Theta 1 (deg)')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(nHingedRigidBody1ThetasOut[:,0]*1e-9, nHingedRigidBody1ThetasOut[:,2]*180/numpy.pi,'-b')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Panel 1 Theta 2 (deg)')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(nHingedRigidBody1ThetasOut[:,0]*1e-9, nHingedRigidBody1ThetasOut[:,3]*180/numpy.pi,'-b')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Panel 1 Theta 3 (deg)')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(nHingedRigidBody1ThetasOut[:,0]*1e-9, nHingedRigidBody1ThetasOut[:,4]*180/numpy.pi,'-b')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Panel 1 Theta 4 (deg)')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(nHingedRigidBody2ThetasOut[:,0]*1e-9, nHingedRigidBody2ThetasOut[:,1]*180/numpy.pi,'-b')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Panel 2 Theta 1 (deg)')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(nHingedRigidBody2ThetasOut[:,0]*1e-9, nHingedRigidBody2ThetasOut[:,2]*180/numpy.pi,'-b')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Panel 2 Theta 2 (deg)')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(nHingedRigidBody2ThetasOut[:,0]*1e-9, nHingedRigidBody2ThetasOut[:,3]*180/numpy.pi,'-b')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Panel 2 Theta 3 (deg)')\n\n    if show_plots:\n        plt.show()\n        plt.close(\"all\")\n\n    accuracy = 1e-10\n\n    finalOrbAngMom = numpy.delete(finalOrbAngMom, 0, axis=1)  # remove time column\n    finalRotAngMom = numpy.delete(finalRotAngMom, 0, axis=1)  # remove time column\n    finalRotEnergy = numpy.delete(finalRotEnergy, 0, axis=1)  # remove time column\n    finalOrbEnergy = numpy.delete(finalOrbEnergy, 0, axis=1)  # remove time column\n\n    for i in range(0, len(initialOrbAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i], initialOrbAngMom_N[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: N Hinged Rigid Body integrated test failed orbital angular momentum unit test\")\n\n    for i in range(0, len(initialRotAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i], initialRotAngMom_N[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\n                \"FAILED: N Hinged Rigid Body integrated test failed rotational angular momentum unit test\")\n\n    for i in range(0, len(initialRotEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotEnergy[i], initialRotEnergy[i], 1, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: N Hinged Rigid Body integrated test failed rotational energy unit test\")\n\n    for i in range(0, len(initialOrbEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i], initialOrbEnergy[i], 1, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: N Hinged Rigid Body integrated test failed orbital energy unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" N Hinged Rigid Body integrated test\")\n        print(\"Error tolerance for all tests was\" + str(accuracy))\n\n\n    assert testFailCount < 1, testMessages\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "class ResultsStore:\n    def __init__(self):\n        self.PassFail = []\n    def texSnippet(self):\n        for i in range(len(self.PassFail)):\n            snippetName = 'Result' + str(i)\n            if self.PassFail[i] == 'PASSED':\n                textColor = 'ForestGreen'\n            elif self.PassFail[i] == 'FAILED':\n                textColor = 'Red'\n            texSnippet =  r'\\textcolor{' + textColor + '}{'+ self.PassFail[i] + '}'\n            unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)",
  "def testFixture():\n    listRes = ResultsStore()\n    yield listRes\n    listRes.texSnippet()",
  "def test_bore_ang_calc(testFixture, show_plots, boresightLoc, eulerLoc):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = bore_ang_calc_func(testFixture, show_plots, boresightLoc, eulerLoc)\n    assert testResults < 1, testMessage",
  "def bore_ang_calc_func(testFixture, show_plots, boresightLoc, eulerLoc):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    # Create a sim module as an empty container\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    TotalSim = SimulationBaseClass.SimBaseClass()\n\n    DynUnitTestProc = TotalSim.CreateNewProcess(unitProcessName)\n    # create the dynamics task and specify the integration update time\n    DynUnitTestProc.addTask(TotalSim.CreateNewTask(unitTaskName, macros.sec2nano(1.0)))\n\n    spiceMessage = messaging.SpicePlanetStateMsgPayload()\n    stateMessage = messaging.SCStatesMsgPayload()\n    angMessage = messaging.BoreAngleMsgPayload()\n    vehPosition = [10000.0, 0.0, 0.0]\n    sunPosition = [10000.0, 1000.0, 0.0]\n    stateMessage.r_BN_N = vehPosition\n    stateMessage.v_BN_N = [-365052.0511, 0.0, 0.0]\n    if eulerLoc[0] == 0.0:\n        stateMessage.sigma_BN = [0.0, 0.0, 0.0]\n    else:\n        stateMessage.sigma_BN = RigidBodyKinematics.euler3212MRP(eulerLoc)\n    spiceMessage.PositionVector = sunPosition\n    spiceMessage.PlanetName = \"sun\"\n    # Inertial State output Message\n    scMsg = messaging.SCStatesMsg().write(stateMessage)\n\n    # Sun Planet Data Message\n    sunMsg = messaging.SpicePlanetStateMsg().write(spiceMessage)\n\n    # Initialize the spice modules that we are using.\n    BACObject = boreAngCalc.BoreAngCalc()\n    BACObject.ModelTag = \"solarArrayBoresight\"\n    BACObject.boreVec_B = boresightLoc  # boresight in body frame\n    BACObject.scStateInMsg.subscribeTo(scMsg)\n    BACObject.celBodyInMsg.subscribeTo(sunMsg)\n\n    TotalSim.AddModelToTask(unitTaskName, BACObject)\n    #\n    # Configure simulation\n    TotalSim.ConfigureStopTime(int(1.0 * 1E9))\n\n    dataLog = BACObject.angOutMsg.recorder()\n    TotalSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Execute simulation\n    TotalSim.InitializeSimulation()\n    TotalSim.AddVariableForLogging(BACObject.ModelTag + \".boreVec_Po\", 1, 0, 2, \"double\")\n    TotalSim.ExecuteSimulation()\n    ###################################################################################################################\n    #\n    # Begin testing module results to truth values\n\n    simMiss = dataLog.missAngle\n    simAz = dataLog.azimuth\n    simBoreVecPt = TotalSim.GetLogVariableData(BACObject.ModelTag + \".boreVec_Po\")\n\n    # Truth values\n    dcm_BN = RigidBodyKinematics.MRP2C(stateMessage.sigma_BN)\n    relPosVector = numpy.subtract(spiceMessage.PositionVector, stateMessage.r_BN_N)\n    relVelVector = numpy.subtract(spiceMessage.VelocityVector, stateMessage.v_BN_N)\n    magRelVelVec = numpy.sqrt(relVelVector[0] ** 2 + relVelVector[1] ** 2 + relVelVector[2] ** 2)\n    if magRelVelVec == 0:\n        secPointVector = numpy.zeros((1, 3))\n        magSecPtVec = 0\n    else:\n        secPointVector = numpy.cross(relPosVector, relVelVector) / numpy.linalg.norm(numpy.cross(relPosVector,\n                                                                                                 relVelVector))\n        magSecPtVec = 1\n    primPointVector = relPosVector / numpy.linalg.norm(relPosVector)  # r_p/b_N\n    dcm_PoN = numpy.zeros((3, 3))\n    dcm_PoN[0, 0:2] = primPointVector[0:2]\n    magPrimPtVec = numpy.sqrt(primPointVector[0] ** 2 + primPointVector[1] ** 2 + primPointVector[2] ** 2)\n    if magPrimPtVec != 0 and magSecPtVec != 0:\n        dcm_PoN_2 = numpy.cross(primPointVector, secPointVector) / numpy.linalg.norm(\n            numpy.cross(primPointVector, secPointVector))\n        for i in range(3):\n            dcm_PoN[2, i] = dcm_PoN_2[i]\n    dcm_PoN_1 = numpy.cross(dcm_PoN_2, primPointVector)\n    for i in range(3):\n        dcm_PoN[1, i] = dcm_PoN_1[i]\n    dcm_BPo = numpy.dot(dcm_BN, dcm_PoN.transpose())\n    vecBore_B = numpy.zeros((3, 1))\n    for i in range(3):\n        vecBore_B[i, 0] = BACObject.boreVec_B[i][0]\n    boreVecPoint = numpy.dot(numpy.transpose(dcm_BPo), vecBore_B)\n    boreVecPoint_1 = []\n    for i in range(3):\n        boreVecPoint_1.append(boreVecPoint[i, 0])\n    boreVecPoint_1 = numpy.array(boreVecPoint_1)\n\n    ####################################################################################################################\n    # attempt calculation in body frame\n    r_B = numpy.dot(dcm_BN, stateMessage.r_BN_N)  # BN * N = B\n\n    # Set tolersnce\n    AllowTolerance = 1E-10\n    boreVecPoint_final = [numpy.ndarray.tolist(boreVecPoint_1)]\n    simBoreVecPt_final = [numpy.delete([simBoreVecPt[0]],0)]\n\n    testFailCount, testMessages = unitTestSupport.compareArray(boreVecPoint_final, simBoreVecPt_final,\n                                                               AllowTolerance,\n                                                               \"Calculating the vector boreVec_Po.\",\n                                                               testFailCount, testMessages)\n    # Truth values\n    #boreVecPoint_1 = [0.0, 1.0, 0.0]\n\n    baselinePoint = [1.0, 0.0, 0.0]\n    baselinePoint = numpy.array(baselinePoint)\n    dotValue = numpy.dot(boreVecPoint_1, baselinePoint)\n    r_N = numpy.dot(numpy.transpose(dcm_BN), BACObject.boreVec_B)\n    r_N = [item for sublist in r_N for item in sublist]\n    baselineProj = numpy.dot(numpy.transpose(dcm_PoN), baselinePoint)\n    dotValue_2 = numpy.dot(r_N, baselineProj)\n    boresightMissAng = numpy.arccos(dotValue)\n    boresightMissAng_2 = numpy.arccos(dotValue_2)  # boresight calc using body frame\n    if boresightMissAng == numpy.pi / 2:\n        simAz_final = numpy.array(simAz[-1])\n        boresightAzimuth = simAz_final\n        print(\"The miss angle is 0, therefore the miss angle is ill defined!\")\n    else:\n        boresightAzimuth = numpy.arctan2(boreVecPoint_1[2], boreVecPoint_1[1])\n\n    # Next Check\n    AllowTolerance = 1E-10\n    simMiss_final = numpy.array(simMiss[-1])\n    if (boresightMissAng - simMiss_final) > AllowTolerance:  # Skip test days that are Sunday because of the end of a GPS week\n        testFailCount += 1\n        testMessages.append(\n            \"FAILED: Calculating the miss angle of the boresight failed with difference of: %(DiffVal)f \\n\" % \\\n            {\"DiffVal\": boresightMissAng - simMiss_final})\n    simAz_final = numpy.array(simAz[-1])\n    if (boresightAzimuth - simAz_final) > AllowTolerance:  # Skip test days that are Sunday because of the end of a GPS week\n        testFailCount += 1\n        testMessages.append(\n            \"FAILED: Calculating the azimuth angle of the boresight failed with difference of: %(DiffVal)f \\n\" % \\\n            {\"DiffVal\": boresightAzimuth - simAz_final})\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED\")\n        testFixture.PassFail.append(\"PASSED\")\n    else:\n        print(testMessages)\n        testFixture.PassFail.append(\"FAILED\")\n\n    # each test method requires a single assert method to be called\n    #   this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def __init__(self):\n        self.PassFail = []",
  "def texSnippet(self):\n        for i in range(len(self.PassFail)):\n            snippetName = 'Result' + str(i)\n            if self.PassFail[i] == 'PASSED':\n                textColor = 'ForestGreen'\n            elif self.PassFail[i] == 'FAILED':\n                textColor = 'Red'\n            texSnippet =  r'\\textcolor{' + textColor + '}{'+ self.PassFail[i] + '}'\n            unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)",
  "def test_bore_ang_calc_inertial_heading(show_plots, inertialHeading, eulerLoc):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = bore_ang_calc_inertial_heading_func(show_plots, inertialHeading, eulerLoc)\n    assert testResults < 1, testMessage",
  "def bore_ang_calc_inertial_heading_func(show_plots, inertialHeading, eulerLoc):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    # Assign task and process names\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"unitProcess\"  # arbitrary name (don't change)\n\n    # Create the sim module, process and task\n    TotalSim = SimulationBaseClass.SimBaseClass()\n    UnitTestProc = TotalSim.CreateNewProcess(unitProcessName)\n    UnitTestProc.addTask(TotalSim.CreateNewTask(unitTaskName, mc.sec2nano(1.0)))\n\n    # Create the state message and populate it\n    stateMessage = messaging.SCStatesMsgPayload()\n    stateMessage.sigma_BN = rbk.euler3212MRP(eulerLoc)\n    scMsg = messaging.SCStatesMsg().write(stateMessage)\n\n    # Initialize the bac module\n    BACObject = boreAngCalc.BoreAngCalc()\n    BACObject.ModelTag = \"solarArrayBoresight\"\n    boreVec_B = [1.0, 0.0, 0.0]\n    BACObject.boreVec_B = boreVec_B  # boresight in body frame\n    BACObject.scStateInMsg.subscribeTo(scMsg)\n    BACObject.inertialHeadingVec_N = inertialHeading\n    TotalSim.AddModelToTask(unitTaskName, BACObject)\n\n    # Configure the recorder\n    dataLog = BACObject.angOutMsg.recorder()\n    TotalSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Execute simulation\n    TotalSim.InitializeSimulation()\n    TotalSim.TotalSim.SingleStepProcesses()\n\n    # Configure the tests\n\n    # Compute the inertial heading in B frame\n    dcm_BN = rbk.MRP2C(stateMessage.sigma_BN)\n    inertialHeading_B = dcm_BN.dot(np.array(inertialHeading))\n\n    # Compute the miss angle\n    missAngle = math.acos(np.array(boreVec_B).dot(inertialHeading_B))\n\n    # Extract the miss angle from data\n    simMissAngle = dataLog.missAngle[0]\n\n    # Compare the results\n    tol = 1E-10\n    if not unitTestSupport.isDoubleEqual(missAngle, simMissAngle, tol):\n        testFailCount += 1\n        testMessages.append(\"FAILED: Calculating the miss angle of the boresight failed \\n\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED\")\n    else:\n        print(testMessages)\n\n    return [testFailCount, ''.join(testMessages)]",
  "class DataStore:\n    def __init__(self):\n        self.Date = [] # replace these with appropriate containers for the data to be stored for plotting\n        self.MarsPosErr = []\n        self.EarthPosErr = []\n        self.SunPosErr = []",
  "def test_orb_elem_convert(a, e, i, AN, AP, f, mu, name, DispPlot=False):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = orbElem(a, e, i, AN, AP, f, mu, name, DispPlot)\n    assert testResults < 1, testMessage",
  "def orbElem(a, e, i, AN, AP, f, mu, name, DispPlot):\n    # Elem2RV\n    testFailCount1 = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    # Create a sim module as an empty container\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    TotalSim = SimulationBaseClass.SimBaseClass()\n\n    DynUnitTestProc = TotalSim.CreateNewProcess(unitProcessName)\n    # # create the dynamics task and specify the integration update time\n    testProcessRate = macros.sec2nano(1.0)\n    DynUnitTestProc.addTask(TotalSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Initialize the modules that we are using.\n    orb_elemObject = orbElemConvert.OrbElemConvert()\n    orb_elemObject.ModelTag = \"OrbElemConvertData\"\n\n    # Add Model To Task\n    TotalSim.AddModelToTask(unitTaskName, orb_elemObject)\n\n    # Set element values\n    epsDiff = 0.0000001\n    orb_elemObject.mu = mu\n\n    ###### ELEM2RV ######\n    TotalSim.AddVariableForLogging('OrbElemConvertData.r_N', testProcessRate, 0, 2, 'double')\n    TotalSim.AddVariableForLogging('OrbElemConvertData.v_N', testProcessRate, 0, 2, 'double')\n\n    # Create and write messages\n    ElemMessage = messaging.ClassicElementsMsgPayload()\n    elemMsg = messaging.ClassicElementsMsg()\n\n    if e == 1.0:\n        ElemMessage.a = 0.0\n        ElemMessage.rPeriap = -a\n    else:\n        ElemMessage.a = a # meters\n    ElemMessage.e = e\n    ElemMessage.i = i\n    ElemMessage.Omega = AN\n    ElemMessage.omega = AP\n    ElemMessage.f = f\n\n    elemMsg.write(ElemMessage)\n    orb_elemObject.elemInMsg.subscribeTo(elemMsg)\n\n    # Log Message to test WriteOutputMessage()\n    dataLog = orb_elemObject.spiceStateOutMsg.recorder()\n    TotalSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Execute simulation\n    TotalSim.ConfigureStopTime(int(1E9))\n    TotalSim.InitializeSimulation()\n    TotalSim.ExecuteSimulation()\n\n    # Get r and v from sim\n    vSim = TotalSim.GetLogVariableData('OrbElemConvertData.v_N')\n    vSim = numpy.delete(vSim[-1], 0, axis=0)\n    rSim = TotalSim.GetLogVariableData('OrbElemConvertData.r_N')\n    rSim = numpy.delete(rSim[-1], 0, axis=0)\n\n    # Get r and v from message\n    rMsgPlanet = dataLog.PositionVector[-1]\n    vMsgPlanet = dataLog.VelocityVector[-1]\n    rMsgPlanetDiff = numpy.subtract(rSim, rMsgPlanet)\n    for g in range(3):\n        if abs(rMsgPlanetDiff[g]) > 0:\n            testMessages.append(\" FAILED: Planet Position Message, column \" + str(g))\n            testFailCount1 += 1\n    vMsgPlanetDiff = numpy.subtract(vSim, vMsgPlanet)\n    for g in range(3):\n        if abs(vMsgPlanetDiff[g]) > 0:\n            testMessages.append(\" FAILED: Planet Velocity Message, column \" + str(g))\n            testFailCount1 += 1\n\n    # Calculation of elem2rv\n    if e == 1.0 and a > 0.0:  # rectilinear elliptic orbit case\n        Ecc = f  # f is treated as ecc.anomaly\n        r = a * (1 - e * math.cos(Ecc))  # orbit radius\n        v = math.sqrt(2 * mu / r - mu / a)\n        ir = numpy.zeros(3)\n        ir[0] = math.cos(AN) * math.cos(AP) - math.sin(AN) * math.sin(AP) * math.cos(i)\n        ir[1] = math.sin(AN) * math.cos(AP) + math.cos(AN) * math.sin(AP) * math.cos(i)\n        ir[2] = math.sin(AP) * math.sin(i)\n        rTruth = numpy.multiply(r, ir)\n        if math.sin(Ecc) > 0:\n            vTruth = numpy.multiply(-v, ir)\n        else:\n            vTruth = numpy.multiply(v, ir)\n    else:\n        if e == 1 and a < 0:  # parabolic case\n            rp = -a  # radius at periapses\n            p = 2 * rp  # semi-latus rectum\n            a = 0.0\n        else:  # elliptic and hyperbolic cases\n            p = a * (1 - e * e)  # semi-latus rectum\n\n        r = p / (1 + e * math.cos(f))  # orbit radius\n        theta = AP + f  # true latitude angle\n        h = math.sqrt(mu * p)  # orbit ang.momentum mag.\n\n        rTruth = numpy.zeros(3)\n        rTruth[0] = r * (math.cos(AN) * math.cos(theta) - math.sin(AN) * math.sin(theta) * math.cos(i))\n        rTruth[1] = r * (math.sin(AN) * math.cos(theta) + math.cos(AN) * math.sin(theta) * math.cos(i))\n        rTruth[2] = r * (math.sin(theta) * math.sin(i))\n\n        vTruth = numpy.zeros(3)\n        vTruth[0] = -mu / h * (math.cos(AN) * (math.sin(theta) + e * math.sin(AP)) + math.sin(AN) * (math.cos(\n            theta) + e * math.cos(AP)) * math.cos(i))\n        vTruth[1] = -mu / h * (math.sin(AN) * (math.sin(theta) + e * math.sin(AP)) - math.cos(AN) * (math.cos(\n            theta) + e * math.cos(AP)) * math.cos(i))\n        vTruth[2] = -mu / h * (-(math.cos(theta) + e * math.cos(AP)) * math.sin(i))\n\n    # Position and Velocity Diff Checks\n    rDiff = numpy.subtract(rSim, rTruth)\n    vDiff = numpy.subtract(vSim, vTruth)\n    rDiffcsv = numpy.asarray(rDiff)\n    vDiffcsv = numpy.asarray(vDiff)\n    for g in range(3):\n        if abs(rDiff[g]) > epsDiff:\n            testMessages.append(\" FAILED: Position Vector, column \" + str(g))\n            testFailCount1 += 1\n    for g in range(3):\n        if abs(vDiff[g]) > epsDiff:\n            testMessages.append(\" FAILED: Velocity Vector, column \" + str(g))\n            testFailCount1 += 1\n\n    if name != 0:\n        if testFailCount1 == 0:\n            colorText = 'ForestGreen'\n            passFailMsg = \"\"  # \"Passed: \" + name + \".\"\n            passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n        else:\n            colorText = 'Red'\n            passFailMsg = \"Failed: \" + name + \".\"\n            testMessages.append(passFailMsg)\n            testMessages.append(\" | \")\n            passedText = r'\\textcolor{' + colorText + '}{' + \"FAILED\" + '}'\n\n        # Write some snippets for AutoTex\n        snippetName = name + \"PassedText1\"\n        snippetContent = passedText\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n\n        snippetName = name + \"PassFailMsg1\"\n        snippetContent = passFailMsg\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n\n    ###### RV2ELEM ######\n    # RV2Elem\n    testFailCount2 = 0  # zero unit test result counter\n\n    for g in range(2):\n        TotalSim = SimulationBaseClass.SimBaseClass()\n        DynUnitTestProc = TotalSim.CreateNewProcess(unitProcessName)\n\n        # # create the dynamics task and specify the integration update time\n        testProcessRate = macros.sec2nano(1.0)\n        DynUnitTestProc.addTask(TotalSim.CreateNewTask(unitTaskName, testProcessRate))\n\n        # Initialize the modules that we are using.\n        orb_elemObject = orbElemConvert.OrbElemConvert()\n        orb_elemObject.ModelTag = \"OrbElemConvertData\"\n\n        # Add Model To Task\n        TotalSim.AddModelToTask(unitTaskName, orb_elemObject)\n\n        # Log Variables\n        TotalSim.AddVariableForLogging('OrbElemConvertData.CurrentElem.a')\n        TotalSim.AddVariableForLogging('OrbElemConvertData.CurrentElem.e')\n        TotalSim.AddVariableForLogging('OrbElemConvertData.CurrentElem.i')\n        TotalSim.AddVariableForLogging('OrbElemConvertData.CurrentElem.Omega')\n        TotalSim.AddVariableForLogging('OrbElemConvertData.CurrentElem.omega')\n        TotalSim.AddVariableForLogging('OrbElemConvertData.CurrentElem.f')\n        TotalSim.AddVariableForLogging('OrbElemConvertData.r_N', testProcessRate, 0, 2, 'double')\n        TotalSim.AddVariableForLogging('OrbElemConvertData.v_N', testProcessRate, 0, 2, 'double')\n\n        orb_elemObject.mu = mu\n\n        if g == 0:\n            CartMessage = messaging.SCStatesMsgPayload()\n            CartMessage.r_BN_N = rSim\n            CartMessage.v_BN_N = vSim\n            stateScMsg = messaging.SCStatesMsg().write(CartMessage)\n            orb_elemObject.scStateInMsg.subscribeTo(stateScMsg)\n        else:\n            CartMessage = messaging.SpicePlanetStateMsgPayload()\n            CartMessage.PositionVector = rSim\n            CartMessage.VelocityVector = vSim\n            stateSpMsg = messaging.SpicePlanetStateMsg().write(CartMessage)\n            orb_elemObject.spiceStateInMsg.subscribeTo(stateSpMsg)\n\n        dataElemLog = orb_elemObject.elemOutMsg.recorder()\n        TotalSim.AddModelToTask(unitTaskName, dataElemLog)\n\n        # Execute simulation\n        TotalSim.ConfigureStopTime(int(1E9))\n        TotalSim.InitializeSimulation()\n        TotalSim.ExecuteSimulation()\n\n        aOut = TotalSim.GetLogVariableData('OrbElemConvertData.CurrentElem.a')\n        aOut = numpy.delete(aOut[-1], 0, axis=0)\n        eOut = TotalSim.GetLogVariableData('OrbElemConvertData.CurrentElem.e')\n        eOut = numpy.delete(eOut[-1], 0, axis=0)\n        iOut = TotalSim.GetLogVariableData('OrbElemConvertData.CurrentElem.i')\n        iOut = numpy.delete(iOut[-1], 0, axis=0)\n        ANOut = TotalSim.GetLogVariableData('OrbElemConvertData.CurrentElem.Omega')\n        ANOut = numpy.delete(ANOut[-1], 0, axis=0)\n        APOut = TotalSim.GetLogVariableData('OrbElemConvertData.CurrentElem.omega')\n        APOut = numpy.delete(APOut[-1], 0, axis=0)\n        fOut = TotalSim.GetLogVariableData('OrbElemConvertData.CurrentElem.f')\n        fOut = numpy.delete(fOut[-1], 0, axis=0)\n\n        # Element Diff Check\n        ElemDiff = [(a - aOut), (e - eOut), (i - iOut), (AN - ANOut), (AP - APOut), (f - fOut)]\n        ElemDiffcsv = numpy.asarray(ElemDiff)\n        for g in range(6):\n            # check for angle roll over with 2*pi\n            if g > 2:\n                if abs(ElemDiff[g] - 2 * math.pi) < epsDiff:\n                    ElemDiff[g] -= 2 * math.pi\n                elif abs(ElemDiff[g] + 2 * math.pi) < epsDiff:\n                    ElemDiff[g] += 2 * math.pi\n            if abs(ElemDiff[g]) > epsDiff:\n                testMessages.append(\" FAILED: Sim Orbital Element \" + str(g))\n                testFailCount2 += 1\n\n    aMsg = dataElemLog.a[-1]\n    eMsg = dataElemLog.e[-1]\n    iMsg = dataElemLog.i[-1]\n    ANMsg = dataElemLog.Omega[-1]\n    APMsg = dataElemLog.omega[-1]\n    fMsg = dataElemLog.f[-1]\n\n    ElemMsgDiff = [(aOut - aMsg), (eOut - eMsg), (iOut - iMsg), (ANOut - ANMsg), (APOut - APMsg), (fOut - fMsg)]\n    for g in range(6):\n        # check for angle roll over with 2*pi\n        if g > 2:\n            if abs(ElemDiff[g] - 2 * math.pi) < epsDiff:\n                ElemDiff[g] -= 2 * math.pi\n            elif abs(ElemDiff[g] + 2 * math.pi) < epsDiff:\n                ElemDiff[g] += 2 * math.pi\n        if abs(ElemMsgDiff[g]) > 0:\n            testMessages.append(\" FAILED: Orbital Element Message \" + str(g))\n            testFailCount2 += 1\n    ######### Calculate rv2elem #########\n    # Calculate the specific angular momentum and its magnitude\n    epsConv = 0.0000000001\n    hVec = numpy.cross(rTruth, vTruth)\n    h = numpy.linalg.norm(hVec)\n    p = h * h / mu\n\n    # Calculate the line of nodes\n    v3 = numpy.array([0.0, 0.0, 1.0])\n    nVec = numpy.cross(v3, hVec)\n    n = numpy.linalg.norm(nVec)\n\n    # Orbit eccentricity and energy\n    r = numpy.linalg.norm(rTruth)\n    v = numpy.linalg.norm(vTruth)\n    eVec = numpy.multiply(v * v / mu - 1.0 / r, rTruth)\n    v3 = numpy.multiply(numpy.dot(rTruth, vTruth) / mu, vTruth)\n    eVec = numpy.subtract(eVec, v3)\n    eO = numpy.linalg.norm(eVec)\n    rmag = r\n    rPeriap = p / (1.0 + eO)\n\n    # compute semi - major axis\n    alpha = 2.0 / r - v * v / mu\n    if (math.fabs(alpha) > epsConv): # elliptic or hyperbolic case\n        aO = 1.0 / alpha\n        rApoap = p / (1.0 - eO)\n    else:                        # parabolic case\n        rp = p / 2.0\n        aO = 0.0 # a is not defined for parabola, so -rp is returned instead\n        rApoap = 0.0\n\n    # Calculate the inclination\n    iO = math.acos(hVec[2] / h)\n\n    # Calculate AP, AN, and True anomaly\n    if eO >= 1e-11 and iO >= 1e-11:\n    # Case 1: Non - circular, inclined orbit\n        Omega = math.acos(nVec[0] / n)\n        if (nVec[1] < 0.0):\n            Omega = 2.0 * math.pi - Omega\n        omega = math.acos(numpy.dot(nVec, eVec) / n / eO)\n        if eVec[2] < 0.0:\n            omega = 2.0 * math.pi - omega\n        fO = math.acos(numpy.dot(eVec, rTruth) / eO / r)\n        if numpy.dot(rTruth, vTruth) < 0.0:\n            fO = 2.0 * math.pi - fO\n    elif eO >= 1e-11 and iO < 1e-11:\n    # Case 2: Non - circular, equatorial orbit\n    # Equatorial orbit has no ascending node\n        Omega = 0.0\n        # True longitude of periapsis, omegatilde_true\n        omega = math.acos(eVec[0] / eO)\n        if eVec[1] < 0.0:\n            omega = 2.0 * math.pi - omega\n        fO = math.acos(numpy.dot(eVec, rTruth) / eO / r)\n        if numpy.dot(rTruth, vTruth) < 0.0:\n            fO = 2.0 * math.pi - fO\n    elif eO < 1e-11 and iO >= 1e-11:\n    # Case 3: Circular, inclined orbit\n        Omega = math.acos(nVec[0] / n)\n        if (nVec[1] < 0.0):\n            Omega = 2.0 * math.pi - Omega\n        omega = 0.0\n        # Argument of latitude, u = omega + f * /\n        fO = math.acos(numpy.dot(nVec, rTruth) / n / r)\n        if rTruth[2] < 0.0:\n            fO = 2.0 * math.pi - fO\n    elif eO < 1e-11 and iO < 1e-11:\n    # Case 4: Circular, equatorial orbit\n        Omega = 0.0\n        omega = 0.0\n        # True longitude, lambda_true\n        fO = math.acos(rTruth[0] / r)\n        if rTruth[1] < 0:\n            fO = 2.0 * math.pi - fO\n    else:\n        print(\"Error: rv2elem couldn't identify orbit type.\\n\")\n    if (eO >= 1.0 and math.fabs(fO) > math.pi):\n        twopiSigned = math.copysign(2.0 * math.pi, fO)\n        fO -= twopiSigned\n\n    # Element Diff Check\n    ElemCalcDiff = [(aO - aOut), (eO - eOut), (iO - iOut), (Omega - ANOut), (omega - APOut), (fOut - fOut)]\n    ElemCalcDiffcsv = numpy.asarray(ElemCalcDiff)\n    for g in range(6):\n        # check for angle roll over with 2*pi\n        if g > 2:\n            if abs(ElemCalcDiff[g] - 2 * math.pi) < epsDiff:\n                ElemCalcDiff[g] -= 2 * math.pi\n            elif abs(ElemCalcDiff[g] + 2 * math.pi) < epsDiff:\n                ElemCalcDiff[g] += 2 * math.pi\n        if abs(ElemCalcDiff[g]) > epsDiff:\n            testMessages.append(\" FAILED: Calculated Orbital Element \" + str() + str(g))\n            testFailCount2 += 1\n\n    # create plot\n    # txt = 'e = ' + str(e) + ' and a = ' + str(a) + 'km'\n    fact = (len(str(abs(a)))-3.0)\n\n    plt.figure(1,figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.clf()\n    # fig1.text(.5, .05, txt, ha='center')\n    ax1 = plt.subplot(211)\n    ax1.cla()\n    index = numpy.arange(3)\n    bar_width = 0.35\n    opacity = 0.8\n    rects1 = ax1.bar(index, rSim, bar_width, alpha=opacity, color='b', label='Simulated Position')\n    rects2 = ax1.bar(index + bar_width, rTruth, bar_width, alpha=opacity, color='g', label='Calculated Position')\n    ax1.spines['left'].set_position('zero')\n    ax1.spines['right'].set_color('none')\n    ax1.spines['bottom'].set_position('zero')\n    ax1.spines['top'].set_color('none')\n    for xtick in ax1.get_xticklabels():\n        xtick.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.5))\n    ax1.xaxis.set_ticks_position('bottom')\n    ax1.yaxis.set_ticks_position('left')\n    plt.ylabel('Position (m)')\n    plt.xticks(index + bar_width, ('X', 'Y', 'Z'))\n    plt.legend(loc='lower right')\n\n    ax2 = plt.subplot(212)\n    ax2.cla()\n    rects1 = ax2.bar(index, vSim, bar_width, alpha=opacity, color='b', label='Simulated Velocity')\n    rects2 = ax2.bar(index + bar_width, vTruth, bar_width, alpha=opacity, color='g', label='Calculated Velocity')\n    ax2.spines['left'].set_position('zero')\n    ax2.spines['right'].set_color('none')\n    ax2.spines['bottom'].set_position('zero')\n    ax2.spines['top'].set_color('none')\n    for xtick in ax2.get_xticklabels():\n        xtick.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.5))\n    ax2.xaxis.set_ticks_position('bottom')\n    ax2.yaxis.set_ticks_position('left')\n    plt.ylabel('Velocity (m/s)')\n    plt.xticks(index + bar_width, ('X', 'Y', 'Z'))\n    plt.legend(loc='lower right')\n\n    if name != 0:\n        unitTestSupport.writeFigureLaTeX(name, \"$e = \" + str(e) + \"$ and $a = 10^\" + str(int(fact)) + \"$km\",\n                                         plt, 'height=0.7\\\\textwidth, keepaspectratio', path)\n        if testFailCount2 == 0:\n            colorText = 'ForestGreen'\n            passFailMsg = \"\"  # \"Passed: \" + name + \".\"\n            passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n        else:\n            colorText = 'Red'\n            passFailMsg = \"Failed: \" + name + \".\"\n            testMessages.append(passFailMsg)\n            testMessages.append(\" | \")\n            passedText = r'\\textcolor{' + colorText + '}{' + \"FAILED\" + '}'\n\n        # Write some snippets for AutoTex\n        snippetName = name + \"PassedText2\"\n        snippetContent = passedText\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n\n        snippetName = name + \"PassFailMsg2\"\n        snippetContent = passFailMsg\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n\n    if DispPlot:\n        plt.show()\n        plt.close()\n    testFailCount = testFailCount1+testFailCount2\n\n    if testFailCount:\n        print(\"Failed\")\n        print(testMessages)\n    else:\n        print(\"PASSED\")\n\n    return [testFailCount, ''.join(testMessages)]",
  "def __init__(self):\n        self.Date = [] # replace these with appropriate containers for the data to be stored for plotting\n        self.MarsPosErr = []\n        self.EarthPosErr = []\n        self.SunPosErr = []",
  "def test_hingedRigidBodyMotor(show_plots, K, P, sensedTheta, sensedThetaDot, refTheta, refThetaDot, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This test checks if the output motor torque matches what is expected from the PD control law for the given reference and sensed hinged rigid body state.\n\n    **Test Parameters**\n\n    Args:\n        K (double): Proportional gain value.\n        P (double): Derivative gain value.\n        sensedTheta (double): sensed theta value.\n        sensedThetaDot (double): sensed thetaDot value.\n        refTheta (double): reference theta value.\n        refThetaDot (double): reference thetaDot value.\n        accuracy (double): unit text accuracy\n\n    **Description of Variables Being Tested**\n    \n    K and P are varied (note both must be set to positive values). The sensed hinged rigid body state is held constant while the reference is also varied to check positive and negative deltas.\n\n    \"\"\"\n    [testResults, testMessage] = hingedRigidBodyMotorTestFunction(show_plots, K, P, sensedTheta, sensedThetaDot, refTheta, refThetaDot, accuracy)\n    assert testResults < 1, testMessage",
  "def hingedRigidBodyMotorTestFunction(show_plots, K, P, sensedTheta, sensedThetaDot, refTheta, refThetaDot, accuracy):\n    \"\"\"Test method\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(0.5)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    module = hingedRigidBodyMotor.HingedRigidBodyMotor()\n    module.ModelTag = \"hingedRigidBodyMotorTag\"\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Configure blank module input messages\n    hingedBodyStateSensedInMsgData = messaging.HingedRigidBodyMsgPayload()\n    hingedBodyStateSensedInMsgData.theta = sensedTheta\n    hingedBodyStateSensedInMsgData.thetaDot = sensedThetaDot\n    hingedBodyStateSensedInMsg = messaging.HingedRigidBodyMsg().write(hingedBodyStateSensedInMsgData)\n\n    hingedBodyStateReferenceInMsgData = messaging.HingedRigidBodyMsgPayload()\n    hingedBodyStateReferenceInMsgData.theta = refTheta\n    hingedBodyStateReferenceInMsgData.thetaDot = refThetaDot\n    hingedBodyStateReferenceInMsg = messaging.HingedRigidBodyMsg().write(hingedBodyStateReferenceInMsgData)\n\n    # subscribe input messages to module\n    module.hingedBodyStateSensedInMsg.subscribeTo(hingedBodyStateSensedInMsg)\n    module.hingedBodyStateReferenceInMsg.subscribeTo(hingedBodyStateReferenceInMsg)\n    \n    module.K = K\n    module.P = P\n\n    # setup output message recorder objects\n    dataLog = module.motorTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))\n    unitTestSim.ExecuteSimulation()\n\n    # pull module data and make sure it is correct\n    trueTorque = -K*(sensedTheta-refTheta)-P*(sensedThetaDot-refThetaDot)\n    torqueEqualTest = unitTestSupport.isDoubleEqualRelative(trueTorque, dataLog.motorTorque[-1][0], accuracy)\n    if not torqueEqualTest:\n        testFailCount += 1;\n        testMessages.append(\"Failed motor torque.\")\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, \"\".join(testMessages)]",
  "def defaultVSCMG():\n    VSCMG = messaging.VSCMGConfigMsgPayload()\n\n    VSCMG.rGB_B = [[0.],[0.],[0.]]\n    VSCMG.gsHat0_B = [[0.],[0.],[0.]]\n    VSCMG.gtHat0_B = [[0.],[0.],[0.]]\n    VSCMG.ggHat_B = [[0.],[0.],[0.]]\n    VSCMG.u_s_max = -1\n    VSCMG.u_s_min = -1\n    VSCMG.u_s_f = 0.\n    VSCMG.wheelLinearFrictionRatio = -1\n    VSCMG.u_g_current = 0.\n    VSCMG.u_g_max = -1\n    VSCMG.u_g_min = -1\n    VSCMG.u_g_f = 0.\n    VSCMG.gimbalLinearFrictionRatio = -1\n    VSCMG.Omega = 0.\n    VSCMG.gamma = 0.\n    VSCMG.gammaDot = 0.\n    VSCMG.Omega_max = 6000. * macros.RPM\n    VSCMG.gammaDot_max = -1\n    VSCMG.IW1 = 100./VSCMG.Omega_max # 0.159154943092\n    VSCMG.IW2 = 0.5*VSCMG.IW1 # 0.0795774715459\n    VSCMG.IW3 = 0.5*VSCMG.IW1 # 0.0795774715459\n    VSCMG.IG1 = 0.1\n    VSCMG.IG2 = 0.2\n    VSCMG.IG3 = 0.3\n    VSCMG.U_s = 4.8e-06 * 1e4\n    VSCMG.U_d = 1.54e-06 * 1e4\n    VSCMG.l = 0.01\n    VSCMG.L = 0.1\n    VSCMG.rGcG_G = [[0.0001],[-0.02],[0.1]]\n    VSCMG.massW = 6.\n    VSCMG.massG = 6.\n    VSCMG.VSCMGModel = 0\n    return VSCMG",
  "def computeFFT(y,dt):\n    Fs = 1.0/dt  # sampling rate\n    Ts = dt # sampling interval\n    n = len(y) # length of the signal\n    k = np.arange(n)\n    T = n/Fs\n    frq = k/T # two sides frequency range\n    frq = frq[list(range(n//2))] # one side frequency range\n    Y = np.fft.fft(y)/n # fft computing and normalization\n    Y = Y[list(range(n//2))]\n    Y = abs(Y)\n    return [frq,Y]",
  "def findPeaks(Y,maxfind):\n        peakIdxs = np.r_[True, Y[1:] > Y[:-1]] & np.r_[Y[:-1] > Y[1:], True]\n        peakIdxs[0] = False\n        peakIdxs[-1] = False\n\n        peakIdxs = np.array(np.where(peakIdxs==True))[0]\n        threshold = np.sort(Y[peakIdxs])[-maxfind]\n        peakIdxs = peakIdxs[np.where(Y[peakIdxs] >= threshold)[0]]\n\n        return peakIdxs",
  "def test_VSCMGIntegratedTest(show_plots,useFlag,testCase):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = VSCMGIntegratedTest(show_plots,useFlag,testCase)\n    assert testResults < 1, testMessage",
  "def VSCMGIntegratedTest(show_plots,useFlag,testCase):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    if testCase == 'JitterFullyCoupled' or testCase == 'JitterFullyCoupledGravity':\n        dt = 0.00001\n        duration = 0.01\n    else:\n        dt = 0.001\n        duration = 1.\n    testProcessRate = macros.sec2nano(dt)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # add RW devices\n    VSCMGs = []\n\n    ang = 54.75 * np.pi/180\n\n    VSCMGs.append(defaultVSCMG())\n    VSCMGs[0].gsHat0_B = [[1.0], [0.0], [0.0]]\n    VSCMGs[0].gtHat0_B = [[0.0], [1.0], [0.0]]\n    VSCMGs[0].ggHat_B = [[0.0], [0.0], [1.0]]\n    VSCMGs[0].Omega = 2000 * macros.RPM\n    VSCMGs[0].gamma = 0.\n    VSCMGs[0].gammaDot = 0.06\n    VSCMGs[0].rGB_B = [[0.1], [0.002], [-0.02]]\n\n    VSCMGs.append(defaultVSCMG())\n    VSCMGs[1].gsHat0_B = [[0.0], [1.0], [0.0]]\n    VSCMGs[1].ggHat_B = [[math.cos(ang)], [0.0], [math.sin(ang)]]\n    VSCMGs[1].gtHat0_B = np.cross(np.array([math.cos(ang), 0.0, math.sin(ang)]),np.array([0.0, 1.0, 0.0]))\n    VSCMGs[1].Omega =  350 * macros.RPM\n    VSCMGs[1].gamma = 0.\n    VSCMGs[1].gammaDot = 0.011\n    VSCMGs[1].rGB_B = [[0.0], [-0.05], [0.0]]\n\n    VSCMGs.append(defaultVSCMG())\n    VSCMGs[2].gsHat0_B = [[0.0], [-1.0], [0.0]]\n    VSCMGs[2].ggHat_B = [[-math.cos(ang)], [0.0], [math.sin(ang)]]\n    VSCMGs[2].gtHat0_B = np.cross(np.array([-math.cos(ang), 0.0, math.sin(ang)]),np.array([0.0, -1.0, 0.0]))\n    VSCMGs[2].Omega = -900 * macros.RPM\n    VSCMGs[2].gamma = 0.\n    VSCMGs[2].gammaDot = -0.003\n    VSCMGs[2].rGB_B = [[-0.1], [0.05], [0.05]]\n\n    if testCase == 'BalancedWheels':\n        VSCMGModel = 0\n    elif testCase == 'JitterSimple':\n        VSCMGModel = 1\n    elif testCase == 'JitterFullyCoupled' or testCase == 'JitterFullyCoupledGravity':\n        VSCMGModel = 2\n\n    for VSCMG in VSCMGs:\n        VSCMG.VSCMGModel = VSCMGModel\n\n    if testCase == 'JitterFullyCoupled':\n        VSCMGs = [VSCMGs[0],VSCMGs[2]]\n\n    N = len(VSCMGs)\n\n    # create VSCMG object container and tie to spacecraft object\n    rwStateEffector = vscmgStateEffector.VSCMGStateEffector()\n    rwStateEffector.ModelTag = \"VSCMGs\"\n    for item in VSCMGs:\n        rwStateEffector.AddVSCMG(item)\n    scObject.addStateEffector(rwStateEffector)\n\n    # set RW torque command\n    cmdArray = messaging.VSCMGArrayTorqueMsgPayload()\n    if testCase == 'BalancedWheels' or testCase == 'JitterFullyCoupled':\n        cmdArray.wheelTorque = [0.0, 0.0, 0.0]  # [Nm]\n        cmdArray.gimbalTorque = [0.0, 0.0, 0.0]  # [Nm]\n    else:\n        cmdArray.wheelTorque = [0.001, 0.005, -0.009] # [Nm]\n        cmdArray.gimbalTorque = [0.008, -0.0015, -0.006] # [Nm]\n    cmdMsg = messaging.VSCMGArrayTorqueMsg().write(cmdArray)\n    rwStateEffector.cmdsInMsg.subscribeTo(cmdMsg)\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, rwStateEffector)\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    if testCase != 'JitterFullyCoupled':\n        unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n        unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n        unitTestSim.earthGravBody.mu = 0.3986004415E+15 # meters!\n        unitTestSim.earthGravBody.isCentralBody = True\n        unitTestSim.earthGravBody.useSphericalHarmParams = False\n\n        scObject.gravField.gravBodies = spacecraft.GravBodyVector([unitTestSim.earthGravBody])\n\n    scObject.hub.mHub = 750.0\n    scObject.hub.r_BcB_B = [[-0.0002], [0.0001], [0.1]]\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    if testCase == 'JitterFullyCoupled':\n        scObject.hub.r_CN_NInit = [[0.1],\t[-0.2],\t[0.3]]\n        scObject.hub.v_CN_NInit = [[-0.4],\t[0.5],\t[-0.8]]\n    else:\n        scObject.hub.r_CN_NInit = [[-4020338.690396649],\t[7490566.741852513],\t[5248299.211589362]]\n        scObject.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.omega_BN_BInit = [[0.08], [0.01], [0.0]]\n\n    # log data\n    dataLog = scObject.scStateOutMsg.recorder()\n    speedLog = rwStateEffector.speedOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n    unitTestSim.AddModelToTask(unitTaskName, speedLog)\n\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(duration))\n\n    unitTestSim.InitializeSimulation()\n\n    posRef = scObject.dynManager.getStateObject(\"hubPosition\")\n    sigmaRef = scObject.dynManager.getStateObject(\"hubSigma\")\n\n    unitTestSim.ExecuteSimulation()\n\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n    orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbEnergy\")\n\n    wheelSpeeds = speedLog.wheelSpeeds\n    gimbalAngles = speedLog.gimbalAngles\n    gimbalRates = speedLog.gimbalRates\n    sigmaData = dataLog.sigma_BN\n    omegaData = dataLog.omega_BN_B\n\n    dataPos = posRef.getState()\n    dataSigma = sigmaRef.getState()\n    dataPos = [[dataPos[0][0], dataPos[1][0], dataPos[2][0]]]\n    dataSigma = [[dataSigma[0][0], dataSigma[1][0], dataSigma[2][0]]]\n\n    if testCase == 'BalancedWheels':\n        truePos = [\n            [-4025537.664298894, 7487128.570444949, 5249339.643828076]\n        ]\n\n        trueSigma = [\n            [0.0185829763256, 0.00212563436704, -0.00118728497031]\n        ]\n\n    elif testCase == 'JitterSimple':\n        truePos = [\n            [-4025537.659558947, 7487128.570662447, 5249339.653774626]\n        ]\n\n        trueSigma = [\n            [0.018774477186285467, 0.0018376842577357564, -0.00023633044221463834]\n        ]\n\n    elif testCase == 'JitterFullyCoupled':\n        truePos = [\n            [0.0970572658434, -0.195562924079, 0.191874379545]\n        ]\n\n        trueSigma = [\n            [0.000201909373901, 2.9217809421e-05, 4.00231302121e-06]\n        ]\n    elif testCase == 'JitterFullyCoupledGravity':\n        truePos = [\n            [-4020390.68802, 7490532.37502, 5248309.52745]\n        ]\n\n        trueSigma = [\n            [0.000201662012765, 2.92123940252e-05, 4.15606551702e-06]\n        ]\n\n\n\n    initialOrbAngMom_N = [\n                [orbAngMom_N[0,1], orbAngMom_N[0,2], orbAngMom_N[0,3]]\n                ]\n\n    finalOrbAngMom = [\n                [orbAngMom_N[-1,1], orbAngMom_N[-1,2], orbAngMom_N[-1,3]]\n                 ]\n\n    initialRotAngMom_N = [\n                [rotAngMom_N[0,1], rotAngMom_N[0,2], rotAngMom_N[0,3]]\n                ]\n\n    finalRotAngMom = [\n                [rotAngMom_N[-1,1], rotAngMom_N[-1,2], rotAngMom_N[-1,3]]\n                 ]\n\n    initialOrbEnergy = [\n                [orbEnergy[0,1]]\n                ]\n\n    finalOrbEnergy = [\n                [orbEnergy[-1,1]]\n                 ]\n\n    initialRotEnergy = [\n                [rotEnergy[0,1]]\n                ]\n\n    finalRotEnergy = [\n                [rotEnergy[-1,1]]\n                 ]\n    plt.close(\"all\")\n    plt.figure()\n    plt.plot(orbAngMom_N[:,0]*1e-9, orbAngMom_N[:,1] - orbAngMom_N[0,1], orbAngMom_N[:,0]*1e-9, orbAngMom_N[:,2] - orbAngMom_N[0,2], orbAngMom_N[:,0]*1e-9, orbAngMom_N[:,3] - orbAngMom_N[0,3])\n    plt.title(\"Change in Orbital Angular Momentum\")\n    unitTestSupport.writeFigureLaTeX(\"ChangeInOrbitalAngularMomentum\" + testCase,\n                                     \"Change in Orbital Angular Momentum \" + testCase, plt, \"width=0.80\\\\textwidth\",\n                                     path)\n\n    plt.figure()\n    plt.plot(rotAngMom_N[:,0]*1e-9, rotAngMom_N[:,1] - rotAngMom_N[0,1], rotAngMom_N[:,0]*1e-9, rotAngMom_N[:,2] - rotAngMom_N[0,2], rotAngMom_N[:,0]*1e-9, rotAngMom_N[:,3] - rotAngMom_N[0,3])\n    plt.title(\"Change in Rotational Angular Momentum\")\n    unitTestSupport.writeFigureLaTeX(\"ChangeInOrbitalEnergy\" + testCase, \"Change in Orbital Energy \" + testCase, plt,\n                                     \"width=0.80\\\\textwidth\", path)\n\n    plt.figure()\n    plt.plot(orbEnergy[:,0]*1e-9, orbEnergy[:,1] - orbEnergy[0,1])\n    plt.title(\"Change in Orbital Energy\")\n    unitTestSupport.writeFigureLaTeX(\"ChangeInRotationalAngularMomentum\" + testCase,\n                                     \"Change in Rotational Angular Momentum \" + testCase, plt, \"width=0.80\\\\textwidth\",\n                                     path)\n\n    plt.figure()\n    plt.plot(rotEnergy[:,0]*1e-9, rotEnergy[:,1] - rotEnergy[0,1])\n    plt.title(\"Change in Rotational Energy\")\n    unitTestSupport.writeFigureLaTeX(\"ChangeInRotationalEnergy\" + testCase, \"Change in Rotational Energy \" + testCase,\n                                     plt, \"width=0.80\\\\textwidth\", path)\n\n    plt.figure()\n    for i in range(0,N):\n        plt.subplot(4,1,i+1)\n        plt.plot(speedLog.times()*1.0E-9, wheelSpeeds[:,i] / (2.0 * math.pi) * 60, label='RWA' + str(i))\n        plt.xlabel('Time (s)')\n        plt.ylabel(r'RW' + str(i) + r' $\\Omega$ (RPM)')\n\n    plt.figure()\n    for i in range(0,N):\n        plt.subplot(4,1,i+1)\n        plt.plot(speedLog.times()*1.0E-9, gimbalAngles[:,i], label=str(i))\n        plt.xlabel('Time (s)')\n        plt.ylabel(r'$\\gamma_'+str(i)+'$ (rad)')\n\n    plt.figure()\n    for i in range(0,N):\n        plt.subplot(4,1,i+1)\n        plt.plot(speedLog.times()*1.0E-9, gimbalRates[:,i] * 180/np.pi, label=str(i))\n        plt.xlabel('Time (s)')\n        plt.ylabel(r'$\\dot{\\gamma}_'+str(i)+'$ (d/s)')\n\n    plt.figure()\n    for i in range(0,N):\n        plt.subplot(4,1,i+1)\n        plt.plot(dataLog.times()*1.0E-9, sigmaData[:,i], label='MRP' + str(i))\n        plt.xlabel('Time (s)')\n        plt.ylabel(r'MRP b' + str(i))\n\n    plt.figure()\n    for i in range(0,N):\n        plt.subplot(4,1,i+1)\n        plt.plot(dataLog.times()*1.0E-9, omegaData[:,i] * 180/math.pi, label='omega' + str(i))\n        plt.xlabel('Time (s)')\n        plt.ylabel(r'b' + str(i) + r' $\\omega$ (d/s)')\n\n    if testCase != 'BalancedWheels' and testCase != 'JitterFullyCoupledGravity':\n        istart = int(.01/dt)\n        sigmaDataCut = sigmaData#sigmaData[istart:,:]\n        thetaData = np.empty([len(sigmaDataCut[:,0]),2])\n        thetaData[:,0] = sigmaDataCut[:,0]\n        for i in range(0,len(thetaData[:,0])):\n            thetaData[i,1] = 4*np.arctan(np.linalg.norm(sigmaDataCut[i,1:]))\n\n        if testCase == 'JitterSimple':\n            fitOrd = 11\n        else:\n            fitOrd = 9\n\n        thetaFit = np.empty([len(sigmaDataCut[:,0]),2])\n        thetaFit[:,0] = thetaData[:,0]\n        p = np.polyfit(thetaData[:,0]*1e-9,thetaData[:,1],fitOrd)\n        thetaFit[:,1] = np.polyval(p,thetaFit[:,0]*1e-9)\n\n        plt.figure()\n        plt.plot(thetaData[:,0]*1e-9, thetaData[:,1]-thetaFit[:,1])\n        plt.title(\"Principle Angle Fit\")\n        plt.xlabel('Time (s)')\n        plt.ylabel(r'$\\theta$ (deg)')\n\n        [frq,Y] = computeFFT(thetaData[:,1]-thetaFit[:,1],dt)\n        peakIdxs = findPeaks(Y,N)\n        wheelSpeeds_data = np.array(frq[peakIdxs])*60.\n        wheelSpeeds_true = np.sort(abs(np.array([VSCMG.Omega/macros.RPM for VSCMG in VSCMGs])))\n\n        fig, ax = plt.subplots(2,1)\n        ax[0].plot(thetaFit[:,0]*1e-9,thetaData[:,1]-thetaFit[:,1])\n        ax[0].set_xlabel('Time')\n        ax[0].set_ylabel('Amplitude')\n        ax[1].plot(frq,abs(Y),'r')\n        ax[1].set_xlabel('Freq (Hz)')\n        ax[1].set_ylabel('Magnitude')\n        ax[1].plot(frq[peakIdxs],Y[peakIdxs],'bo')\n        plt.xlim((0,VSCMGs[0].Omega_max/macros.RPM/60.))\n\n        plt.figure()\n        plt.plot(thetaData[:,0]*1e-9, thetaData[:,1])\n        plt.title(\"Principle Angle\")\n        plt.xlabel('Time (s)')\n        plt.ylabel(r'$\\theta$ (deg)')\n\n    if show_plots == True:\n        plt.show()\n        plt.close('all')\n\n    accuracy = 1e-7\n    for i in range(0,len(truePos)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(dataPos[i],truePos[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: VSCMG Integrated Test failed pos unit test\")\n\n    for i in range(0,len(trueSigma)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(dataSigma[i],trueSigma[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: VSCMG Integrated Test failed attitude unit test\")\n\n    if testCase == 'JitterSimple':\n        for i in range(N):\n            # check a vector values\n            if not abs(wheelSpeeds_data[i] - wheelSpeeds_true[i]) / wheelSpeeds_true[i] < .09:\n                testFailCount += 1\n                testMessages.append(\"FAILED: VSCMG Integrated Test failed jitter unit test\")\n\n    accuracy = 1e-10\n    if testCase == 'BalancedWheels' or testCase == 'JitterFullyCoupled':\n\n        for i in range(0,len(initialOrbAngMom_N)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i],initialOrbAngMom_N[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: VSCMG Integrated Test failed orbital angular momentum unit test\")\n\n        for i in range(0,len(initialRotAngMom_N)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i],initialRotAngMom_N[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: VSCMG Integrated Test failed rotational angular momentum unit test\")\n\n        for i in range(0, len(initialOrbEnergy)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i], initialOrbEnergy[i], 1, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: VSCMG Integrated Test failed orbital energy unit test\")\n\n        for i in range(0, len(initialRotEnergy)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(finalRotEnergy[i], initialRotEnergy[i], 1, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: VSCMG Integrated Test failed rot energy unit test\")\n\n    # print out success message if no errors were found\n    if  testFailCount == 0:\n        print(\"PASSED \")\n        colorText = 'ForestGreen'\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n        # Write some snippets for AutoTex\n        snippetName = testCase + 'PassFail'\n        unitTestSupport.writeTeXSnippet(snippetName, passedText, path)\n    elif testFailCount > 0:\n        colorText = 'Red'\n        passedText = r'\\textcolor{' + colorText + '}{' + \"FAILED\" + '}'\n        # Write some snippets for AutoTex\n        snippetName = testCase + 'PassFail'\n        unitTestSupport.writeTeXSnippet(snippetName, passedText, path)\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" VSCMG Integrated Sim Test\")\n    else:\n        print(testMessages)\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def listStack(vec,simStopTime,unitProcRate):\n    # returns a list duplicated the number of times needed to be consistent with module output\n    return [vec] * int(simStopTime/(float(unitProcRate)/float(macros.sec2nano(1))))",
  "def writeNewVSCMGCmds(self,u_s_cmd,u_g_cmd,numVSCMG):\n    NewVSCMGCmdsVec = messaging.VSCMGCmdMsgPayloadVector(numVSCMG)\n    cmds = messaging.VSCMGCmdMsgPayload()\n    for i in range(0,numVSCMG):\n        cmds.u_s_cmd = u_s_cmd[i]\n        cmds.u_g_cmd = u_g_cmd[i]\n        NewVSCMGCmdsVec[i] = cmds  # set the data\n    self.newVSCMGCmds = NewVSCMGCmdsVec",
  "def defaultVSCMG(VSCMG):\n    VSCMG.rGB_B = [[0.],[0.],[0.]]\n    VSCMG.gsHat0_B = [[1.],[0.],[0.]]\n    VSCMG.gtHat0_B = [[1.],[0.],[0.]]\n    VSCMG.ggHat_B = [[1.],[0.],[0.]]\n    VSCMG.w2Hat0_B = [[0.],[1.],[0.]]\n    VSCMG.w3Hat0_B = [[0.],[0.],[1.]]\n    VSCMG.theta = 0.\n    VSCMG.u_s_current = 0.\n    VSCMG.u_s_max = 0.\n    VSCMG.u_s_min = 0.\n    VSCMG.u_s_f = 0.\n    VSCMG.u_g_current = 0.\n    VSCMG.u_g_max = 0.\n    VSCMG.u_g_min = 0.\n    VSCMG.u_g_f = 0.\n    VSCMG.Omega = 0.\n    VSCMG.gamma = 0.\n    VSCMG.gammaDot = 0.\n    VSCMG.Omega_max = 1000.\n    VSCMG.gammaDot_max = -1\n    VSCMG.IW1 = 0.\n    VSCMG.IW2 = 0.\n    VSCMG.IW3 = 0.\n    VSCMG.U_s = 0.\n    VSCMG.U_d = 0.\n    VSCMG.massW = 0.\n    VSCMG.massG = 0.\n    VSCMG.wheelLinearFrictionRatio = 0.\n    VSCMG.VSCMGModel = 0\n    return",
  "def asEigen(v):\n    out = []\n    for i in range(0,len(v)):\n        out.append([v[i]])\n    return out",
  "def test_unitSimVSCMG(show_plots, useFlag, testCase):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitSimVSCMG(show_plots, useFlag, testCase)\n    assert testResults < 1, testMessage",
  "def unitSimVSCMG(show_plots, useFlag, testCase):\n    testFail = False\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    # configure module\n    VSCMG = vscmgStateEffector.VSCMGStateEffector()\n    VSCMG.ModelTag = \"VSCMG\"\n\n    numVSCMG = 2\n\n    VSCMGs = []\n    for i in range(0,numVSCMG):\n        msg = messaging.VSCMGConfigMsgPayload()\n        defaultVSCMG(msg)\n        VSCMGs.append(msg)\n\n    expOut = dict()  # expected output\n\n    if testCase == 'basic':\n        pass\n\n    elif testCase == 'saturation':\n        VSCMGs[0].u_s_max = 1.\n        VSCMGs[1].u_s_max = 2.\n        VSCMGs[0].u_g_max = 1.\n        VSCMGs[1].u_g_max = 2.\n        u_s_cmd = [-1.2,1.5]\n        u_g_cmd = [-1.2,1.5]\n        writeNewVSCMGCmds(VSCMG,u_s_cmd,u_g_cmd,len(VSCMGs))\n\n        expOut['u_s_current'] = [-1.,1.5]\n\n    elif testCase == 'minimum':\n        VSCMGs[0].u_s_min = .1\n        VSCMGs[1].u_s_min = .0\n        VSCMGs[0].u_g_min = .1\n        VSCMGs[1].u_g_min = .0\n        u_s_cmd = [-.09,0.0001]\n        u_g_cmd = [-.09,0.0001]\n        writeNewVSCMGCmds(VSCMG,u_s_cmd,u_g_cmd,len(VSCMGs))\n\n        expOut['u_s_current'] = [0.,0.0001]\n\n    elif testCase == 'friction':\n        u_s_f = [0.1,0.]\n        u_g_f = [0.1,0.]\n        Omega = [-20.,0.]\n        Omega_max = [100.,0.]\n        gammaDot = [-20.,0.]\n        gammaDot_max = [100.,0.]\n        wheelLinearFrictionRatio = [0.1,0.]\n        gimbalLinearFrictionRatio = [0.1,0.]\n        for i in range(0,numVSCMG):\n            VSCMGs[i].u_s_f = u_s_f[i]\n            VSCMGs[i].Omega = Omega[i]\n            VSCMGs[i].Omega_max = Omega_max[i]\n            VSCMGs[i].wheelLinearFrictionRatio = wheelLinearFrictionRatio[i]\n            VSCMGs[i].u_g_f = u_g_f[i]\n            VSCMGs[i].gammaDot = gammaDot[i]\n            VSCMGs[i].gammaDot_max = gammaDot_max[i]\n            VSCMGs[i].gimbalLinearFrictionRatio = gimbalLinearFrictionRatio[i]\n        u_s_cmd = [-1.,0.]\n        u_g_cmd = [-1.,0.]\n        writeNewVSCMGCmds(VSCMG,u_s_cmd,u_g_cmd,len(VSCMGs))\n\n        expOut['u_s_current'] = np.asarray(u_s_cmd) + np.asarray(u_s_f)\n\n    else:\n        raise Exception('invalid test case')\n\n    for i in range(0,len(VSCMGs)):\n        VSCMG.AddVSCMG(VSCMGs[i])\n\n    VSCMG.ConfigureVSCMGRequests(0.)\n\n    if not 'accuracy' in vars():\n        accuracy = 1e-10\n\n    for outputName in list(expOut.keys()):\n        for i in range(0,numVSCMG):\n            if expOut[outputName][i] != getattr(VSCMG.VSCMGData[i], outputName):\n                print(\"expected: \" + str(expOut[outputName][i]))\n                print(\"got :\" + str(getattr(VSCMG.VSCMGData[i], outputName)))\n                testFail = 1\n                break\n        if testFail:\n            break\n\n    if testFail:\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + VSCMG.ModelTag + \" Module failed \" +\n                            outputName + \" unit test\")\n\n    np.set_printoptions(precision=16)\n\n    # print out success message if no errors were found\n    if testFailCount == 0:\n        print(\"PASSED \")\n    else:\n        print(testMessages)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_gravityGradientModule(show_plots, cmOffset, planetCase):\n    r\"\"\"\n    **Validation Test Description**\n\n    This test creates a spacecraft in orbit about either Earth or Venus to check if the correct gravity gradient\n    torque is evaluated.  Multiple test scenario combinations are possible where either a single or multiple\n    gravity bodies are included, using either zero planet ephemeris for the single planet case, or using SPICE\n    for the multi-planet scenario.\n\n    **Test Parameters**\n\n    The following list discusses in detail the various test parameters used. These are test tested in\n    all possible permutations (except show_plots of course) which is turned off for ``pytest`` usage.\n\n    :param show_plots:  flag to show some simulation plots\n    :param cmOffset:    center of mass offset vector in meters\n    :param planetCase: integer flag with values (0,1,2,3).  The cases consider the following simulation scenarios:\n\n                        - Case 0 indicates a simulation with only Earth present at (0,0,0).\n                        - Case 1 is a simulation with both Earth and Venus present using Spice, but the gravity\n                          gradient torque is only evaluated using Earth.\n                        - Case 2 is same as 1 but Venus is also included in the torque evaluation.\n                        - Case 3 is like 2 but here the spacecraft is orbiting venus.\n    :return: None\n\n    **Description of Variables Being Tested**\n\n    The gravity effector torque output message is compared against a python evaluated vector.\n\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(\n            show_plots, cmOffset, planetCase, 2.0)\n    assert testResults < 1, testMessage",
  "def truthGravityGradient(mu, rN, sigmaBN, hub):\n    I = hub.IHubPntBc_B\n    r = np.linalg.norm(rN)\n    BN = RigidBodyKinematics.MRP2C(sigmaBN)\n    rHatB = np.matmul(BN, rN) / r\n\n    ggTorque = 3*mu/r/r/r * np.cross(rHatB, np.matmul(I, rHatB))\n\n    return ggTorque",
  "def run(show_plots, cmOffset, planetCase, simTime):\n    \"\"\"Call this routine directly to run the unit test.\"\"\"\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n\n\n    # Create simulation variable names\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n\n    #  Create a sim module as an empty container\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    #  create the simulation process\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n\n    # create the dynamics task and specify the integration update time\n    simulationTimeStep = macros.sec2nano(1.0)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n    simulationTime = macros.sec2nano(simTime)\n\n    # create Earth Gravity Body\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    earth = gravFactory.createEarth()\n    earth.isCentralBody = True  # ensure this is the central gravitational body\n    mu = earth.mu\n\n    if planetCase:\n        # here all planet positions are provided by Spice, and both Earth and Venus are include\n        # for gravity acceleration calculations\n        venus = gravFactory.createVenus()\n        timeInitString = \"2012 MAY 1 00:28:30.0\"\n        gravFactory.createSpiceInterface(bskPath + '/supportData/EphemerisData/',\n                                         timeInitString,\n                                         epochInMsgName=True)\n\n        scSim.AddModelToTask(simTaskName, gravFactory.spiceObject, -1)\n\n        if planetCase == 3:\n            # orbit should be defined relative to Venus\n            earth.isCentralBody = False\n            venus.isCentralBody = True\n            mu = venus.mu\n            gravFactory.spiceObject.zeroBase = 'venus'  # spacecraft states are logged relative to Earth for plotting\n        else:\n            gravFactory.spiceObject.zeroBase = 'earth'  # spacecraft states are logged relative to Earth for plotting\n\n    # setup the orbit using classical orbit elements\n    oe = orbitalMotion.ClassicElements()\n    rLEO = 7000. * 1000      # meters\n    oe.a = rLEO\n    oe.e = 0.0001\n    oe.i = 33.3 * macros.D2R\n    oe.Omega = 48.2 * macros.D2R\n    oe.omega = 347.8 * macros.D2R\n    oe.f = 85.3 * macros.D2R\n    rN, vN = orbitalMotion.elem2rv(mu, oe)\n    oe = orbitalMotion.rv2elem(mu, rN, vN)      # this stores consistent initial orbit elements\n                                                # with circular or equatorial orbit, some angles are arbitrary\n\n    # setup basic spacecraft module\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"bskTestSat\"\n    IIC = [[500., 0., 0.]\n           , [0., 800., 0.]\n           , [0., 0., 350.]]\n    scObject.hub.r_BcB_B = cmOffset\n    scObject.hub.mHub = 100.0  # kg - spacecraft mass\n    scObject.hub.IHubPntBc_B = IIC\n    scObject.hub.r_CN_NInit = rN  # m   - r_BN_N\n    scObject.hub.v_CN_NInit = vN  # m/s - v_BN_N\n    scObject.hub.sigma_BNInit = [[0.1], [0.2], [-0.3]]  # sigma_BN_B\n    scObject.hub.omega_BN_BInit = [[0.0], [0.0], [0.0]]  # rad/s - omega_BN_B\n\n    scSim.AddModelToTask(simTaskName, scObject)\n\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    # add gravity gradient effector\n    ggEff = GravityGradientEffector.GravityGradientEffector()\n    ggEff.ModelTag = scObject.ModelTag\n    ggEff.addPlanetName(earth.planetName)\n    if planetCase >= 2:\n        ggEff.addPlanetName(venus.planetName)\n    scObject.addDynamicEffector(ggEff)\n    scSim.AddModelToTask(simTaskName, ggEff)\n\n    #\n    #   Setup data logging before the simulation is initialized\n    #\n    numDataPoints = 50\n    samplingTime = unitTestSupport.samplingTime(simulationTime, simulationTimeStep, numDataPoints)\n    dataLog = scObject.scStateOutMsg.recorder(samplingTime)\n    dataLogGG = ggEff.gravityGradientOutMsg.recorder(samplingTime)\n    scSim.AddModelToTask(simTaskName, dataLog)\n    scSim.AddModelToTask(simTaskName, dataLogGG)\n\n    #\n    #   initialize Simulation\n    #\n    scSim.InitializeSimulation()\n\n    #\n    #   configure a simulation stop time and execute the simulation run\n    #\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    #\n    #   retrieve the logged data\n    #\n    posData = dataLog.r_BN_N\n    attData = dataLog.sigma_BN\n    ggData = dataLogGG.gravityGradientTorque_B\n    np.set_printoptions(precision=16)\n\n    #\n    #   plot the results\n    #\n    if show_plots:\n        plt.close(\"all\")  # clears out plots from earlier test runs\n\n        # draw the inertial position vector components\n        plt.close(\"all\")  # clears out plots from earlier test runs\n        plt.figure(1)\n        for idx in range(0, 3):\n            plt.plot(dataLog.times() * macros.NANO2MIN, attData[:, idx],\n                     color=unitTestSupport.getLineColor(idx, 3),\n                     label=r'$\\sigma_' + str(idx) + '$')\n        plt.legend(loc='lower right')\n        plt.xlabel('Time [min]')\n        plt.ylabel(r'MRP Attitude $\\sigma_{B/N}$')\n\n        plt.figure(2)\n        for idx in range(0, 3):\n            plt.plot(dataLog.times() * macros.NANO2MIN, posData[:, idx]/1000,\n                     color=unitTestSupport.getLineColor(idx, 3),\n                     label=r'$r_' + str(idx) + '$')\n        plt.legend(loc='lower right')\n        plt.xlabel('Time [min]')\n        plt.ylabel(r'Inertial Position coordinates [km]')\n\n        plt.figure(3)\n        for idx in range(0, 3):\n            plt.plot(dataLogGG.times() * macros.NANO2MIN, ggData[:, idx] ,\n                     color=unitTestSupport.getLineColor(idx, 3),\n                     label=r'$r_' + str(idx) + '$')\n        plt.legend(loc='lower right')\n        plt.xlabel('Time [min]')\n        plt.ylabel(r'GG Torque [Nm]')\n\n        plt.show()\n        plt.close(\"all\")\n\n    # compare gravity gradient torque vector to the truth\n    accuracy = 1e-10\n    for rV, sV, ggV in zip(posData, attData, ggData):\n        ggTruth = truthGravityGradient(mu, rV[0:3], sV[0:3], scObject.hub)\n        testFailCount, testMessages = unitTestSupport.compareVector(ggV[0:3],\n                                                                    ggTruth,\n                                                                    accuracy,\n                                                                    \"gravityGradientTorque_B\",\n                                                                    testFailCount, testMessages)\n\n    print(\"Accuracy used: \" + str(accuracy))\n    if testFailCount == 0:\n        print(\"PASSED: Gravity Effector\")\n    else:\n        print(\"Failed: Gravity Effector\")\n\n    return testFailCount, testMessages",
  "def test_massDepletionTest(show_plots, thrusterType):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = massDepletionTest(show_plots, thrusterType)\n    assert testResults < 1, testMessage",
  "def massDepletionTest(show_plots, thrusterType):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.1)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # add thruster devices\n    thFactory = simIncludeThruster.thrusterFactory()\n    thFactory.create(\n        'TEST_Thruster',\n        [1, 0, 0],  # location in B-frame\n        [0, 1, 0]  # direction in B-frame\n    )\n\n    # create thruster object container and tie to spacecraft object\n    if thrusterType == \"dynamicEffector\":\n        thrustersEffector = thrusterDynamicEffector.ThrusterDynamicEffector()\n    elif thrusterType == \"stateEffector\":\n        thrustersEffector = thrusterStateEffector.ThrusterStateEffector()\n    else:\n        print(\"Invalid thruster type.\")\n        return\n    thFactory.addToSpacecraft(\"Thrusters\",\n                              thrustersEffector,\n                              scObject)\n\n    unitTestSim.fuelTankStateEffector = fuelTank.FuelTank()\n    unitTestSim.fuelTankStateEffector.setTankModel(fuelTank.TANK_MODEL_CONSTANT_VOLUME)\n    tankModel = fuelTank.cvar.FuelTankModelConstantVolume\n    tankModel.propMassInit = 40.0\n    tankModel.r_TcT_TInit = [[0.0], [0.0], [0.0]]\n    unitTestSim.fuelTankStateEffector.r_TB_B = [[0.0], [0.0], [0.0]]\n    tankModel.radiusTankInit = 46.0 / 2.0 / 3.2808399 / 12.0\n\n    # Add tank\n    scObject.addStateEffector(unitTestSim.fuelTankStateEffector)\n    unitTestSim.fuelTankStateEffector.addThrusterSet(thrustersEffector)\n\n    # set thruster commands\n    ThrustMessage = messaging.THRArrayOnTimeCmdMsgPayload()\n    ThrustMessage.OnTimeRequest = [9.9]\n    thrCmdMsg = messaging.THRArrayOnTimeCmdMsg().write(ThrustMessage)\n    thrustersEffector.cmdsInMsg.subscribeTo(thrCmdMsg)\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.fuelTankStateEffector)\n    unitTestSim.AddModelToTask(unitTaskName, thrustersEffector)\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n    unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n    unitTestSim.earthGravBody.mu = 0.3986004415E+15  # meters!\n    unitTestSim.earthGravBody.isCentralBody = True\n    unitTestSim.earthGravBody.useSphericalHarmParams = False\n\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector([unitTestSim.earthGravBody])\n\n    dataLog = scObject.scStateOutMsg.recorder()\n    fuelLog = unitTestSim.fuelTankStateEffector.fuelTankOutMsg.recorder()\n    thrLog = thrustersEffector.thrusterOutMsgs[0].recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n    unitTestSim.AddModelToTask(unitTaskName, fuelLog)\n    unitTestSim.AddModelToTask(unitTaskName, thrLog)\n\n    scObject.hub.mHub = 750.0\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n    scObject.hub.r_CN_NInit = [[-4020338.690396649], [7490566.741852513], [5248299.211589362]]\n    scObject.hub.v_CN_NInit = [[-5199.77710904224], [-3436.681645356935], [1041.576797498721]]\n    scObject.hub.sigma_BNInit = [[0.1], [0.2], [-0.3]]\n    scObject.hub.omega_BN_BInit = [[0.001], [-0.01], [0.03]]\n\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n\n    posRef = scObject.dynManager.getStateObject(\"hubPosition\")\n    sigmaRef = scObject.dynManager.getStateObject(\"hubSigma\")\n\n    stopTime = 60.0 * 10.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n\n    thrust = thrLog.thrustForce_B\n    thrustPercentage = thrLog.thrustFactor\n    fuelMass = fuelLog.fuelMass\n    fuelMassDot = fuelLog.fuelMassDot\n\n    plt.close(\"all\")\n    plt.figure(1)\n    plt.plot(orbAngMom_N[:, 0] * 1e-9, orbAngMom_N[:, 1] - orbAngMom_N[0, 1], orbAngMom_N[:, 0] * 1e-9,\n             orbAngMom_N[:, 2] - orbAngMom_N[0, 2], orbAngMom_N[:, 0] * 1e-9, orbAngMom_N[:, 3] - orbAngMom_N[0, 3])\n    plt.title(\"Change in Orbital Angular Momentum\")\n    plt.figure(2)\n    plt.plot(rotAngMom_N[:, 0] * 1e-9, rotAngMom_N[:, 1] - rotAngMom_N[0, 1], rotAngMom_N[:, 0] * 1e-9,\n             rotAngMom_N[:, 2] - rotAngMom_N[0, 2], rotAngMom_N[:, 0] * 1e-9, rotAngMom_N[:, 3] - rotAngMom_N[0, 3])\n    plt.title(\"Change in Rotational Angular Momentum\")\n    plt.figure(3)\n    plt.plot(rotEnergy[:, 0] * 1e-9, rotEnergy[:, 1] - rotEnergy[0, 1])\n    plt.title(\"Change in Rotational Energy\")\n    plt.figure(4)\n    plt.plot(thrLog.times() * 1e-9, thrust[:, 0], thrLog.times() * 1e-9, thrust[:, 1], thrLog.times() * 1e-9,\n             thrust[:, 2])\n    plt.xlim([0, 20])\n    plt.ylim([0, 1])\n    plt.title(\"Thrust\")\n    plt.figure(5)\n    plt.plot(thrLog.times() * 1e-9, thrustPercentage)\n    plt.xlim([0, 20])\n    plt.ylim([0, 1.1])\n    plt.title(\"Thrust Percentage\")\n    plt.figure(6)\n    plt.plot(fuelLog.times() * 1e-9, fuelMass)\n    plt.xlim([0, 20])\n    plt.title(\"Fuel Mass\")\n    plt.figure(7)\n    plt.plot(fuelLog.times() * 1e-9, fuelMassDot)\n    plt.xlim([0, 20])\n    plt.title(\"Fuel Mass Dot\")\n\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    dataPos = posRef.getState()\n    dataSigma = sigmaRef.getState()\n    dataPos = [[dataPos[0][0], dataPos[1][0], dataPos[2][0]]]\n    dataSigma = [[dataSigma[0][0], dataSigma[1][0], dataSigma[2][0]]]\n\n    if thrusterType == \"dynamicEffector\":\n        truePos = [[-6.7815933935338277e+06, 4.9468685979815889e+06, 5.4867416696776701e+06]]\n        trueSigma = [[1.4401781243854264e-01, -6.4168702021364002e-02, 3.0166086824900967e-01]]\n    elif thrusterType == \"stateEffector\":\n        truePos = [[-6781593.400948599, 4946868.619447934, 5486741.690842073]]\n        trueSigma = [[0.14367298348925786, -0.06487574480164254, 0.3032693696902734]]\n\n    accuracy = 1e-6\n    for i in range(0, len(truePos)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(dataPos[i], truePos[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Thruster Integrated Test failed pos unit test\")\n\n    snippetName = thrusterType + 'PositionPassFail'\n    passFail(testFailCount, snippetName)\n\n    accuracy = 1e-4\n    for i in range(0, len(trueSigma)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(dataSigma[i], trueSigma[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Thruster Integrated Test failed attitude unit test\")\n\n    snippetName = thrusterType + 'AttitudePassFail'\n    passFail(testFailCount, snippetName)\n\n    if testFailCount == 0:\n        print(\"PASSED: Thruster Integrated Sim Test\")\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def axisChangeHelper(r_BcB_B):\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.1)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # add thruster devices\n    thFactory = simIncludeThruster.thrusterFactory()\n    thFactory.create(\n        'TEST_Thruster',\n        [1, 0, 0] + [i[0] for i in r_BcB_B],  # location in B-frame\n        [0, 1, 0]  # direction in B-frame\n    )\n\n    # create thruster object container and tie to spacecraft object\n    thrustersEffector = thrusterDynamicEffector.ThrusterDynamicEffector()\n    thFactory.addToSpacecraft(\"Thrusters\",\n                              thrustersEffector,\n                              scObject)\n\n    # add tank\n    unitTestSim.fuelTankStateEffector = fuelTank.FuelTank()\n    unitTestSim.fuelTankStateEffector.setTankModel(fuelTank.TANK_MODEL_CONSTANT_VOLUME)\n    tankModel = fuelTank.cvar.FuelTankModelConstantVolume\n    tankModel.propMassInit = 40.0\n    tankModel.r_TcT_TInit = [[0.0], [0.0], [0.0]]\n    unitTestSim.fuelTankStateEffector.r_TB_B = r_BcB_B\n    tankModel.radiusTankInit = 46.0 / 2.0 / 3.2808399 / 12.0\n\n    # Add tank and thruster\n    scObject.addStateEffector(unitTestSim.fuelTankStateEffector)\n\n    # set thruster commands\n    ThrustMessage = messaging.THRArrayOnTimeCmdMsgPayload()\n    ThrustMessage.OnTimeRequest = [9.9]\n    thrCmdMsg = messaging.THRArrayOnTimeCmdMsg().write(ThrustMessage)\n    thrustersEffector.cmdsInMsg.subscribeTo(thrCmdMsg)\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, thrustersEffector)\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n    unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n    unitTestSim.earthGravBody.mu = 0.3986004415E+15  # meters!\n    unitTestSim.earthGravBody.isCentralBody = True\n    unitTestSim.earthGravBody.useSphericalHarmParams = False\n\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector([unitTestSim.earthGravBody])\n\n    scObject.hub.mHub = 750.0\n    scObject.hub.r_BcB_B = r_BcB_B\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n    scObject.hub.r_CN_NInit = [[-4020338.690396649 - r_BcB_B[0][0]], [7490566.741852513 - r_BcB_B[1][0]],\n                               [5248299.211589362 - r_BcB_B[2][0]]]\n    scObject.hub.v_CN_NInit = [[-5199.77710904224], [-3436.681645356935], [1041.576797498721]]\n    scObject.hub.sigma_BNInit = [[0.1], [0.2], [-0.3]]\n    scObject.hub.omega_BN_BInit = [[0.001], [-0.01], [0.03]]\n\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n\n    posRef = scObject.dynManager.getStateObject(\"hubPosition\")\n    sigmaRef = scObject.dynManager.getStateObject(\"hubSigma\")\n\n    stopTime = 60.0 * 10.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n\n    dataPos = posRef.getState()\n    dataSigma = sigmaRef.getState()\n    dataPos = [[stopTime, dataPos[0][0], dataPos[1][0], dataPos[2][0]]]\n    dataSigma = [[stopTime, dataSigma[0][0], dataSigma[1][0], dataSigma[2][0]]]\n    return dataPos, dataSigma",
  "def test_axisChange(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    dataPos1, dataSigma1 = axisChangeHelper([[0.0], [0.0], [0.0]])\n    dataPos2, dataSigma2 = axisChangeHelper([[0.5], [0.0], [0.0]])",
  "def passFail(testFailCountInput, snippetName):\n    if testFailCountInput < 1:\n        textMsg = 'PASSED'\n        textColor = 'ForestGreen'\n    else:\n        textMsg = 'FAILED'\n        textColor = 'Red'\n\n    texSnippet = r'\\textcolor{' + textColor + '}{' + textMsg + '}'\n    unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)",
  "def test_tankModelConstantVolume(show_plots=False):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = tankModelConstantVolume(show_plots)\n    assert testResults < 1, testMessage",
  "def test_tankModelConstantDensity(show_plots=False):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = tankModelConstantDensity(show_plots)\n    assert testResults < 1, testMessage",
  "def test_tankModelEmptying(show_plots=False):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = tankModelEmptying(show_plots)\n    assert testResults < 1, testMessage",
  "def test_tankModelUniformBurn(show_plots=False):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = tankModelUniformBurn(show_plots)\n    assert testResults < 1, testMessage",
  "def test_tankModelCentrifugalBurn(show_plots=False):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = tankModelCentrifugalBurn(show_plots)\n    assert testResults < 1, testMessage",
  "def tankModelConstantVolume(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    \n    model = fuelTank.cvar.FuelTankModelConstantVolume\n    model.propMassInit = 10\n    model.r_TcT_TInit = [[1],[1],[1]]\n    model.radiusTankInit = 5\n    \n    trials = [(0, 0), (10, -1), (5, -1)] #mFuel, mDotFuel\n    true_ITankPntT_T =      [\n                                [0,0,0,0,0,0,0,0,0],\n                                [100,0,0,0,100,0,0,0,100],\n                                [50,0,0,0,50,0,0,0,50]\n                            ]\n    true_IPrimeTankPntT_T = [\n                                [0,0,0,0,0,0,0,0,0],\n                                [-10,0,0,0,-10,0,0,0,-10],\n                                [-10,0,0,0,-10,0,0,0,-10]\n                            ]\n    true_r_TcT_T =           [\n                                [1,1,1],\n                                [1,1,1],\n                                [1,1,1]\n                            ]\n    true_rPrime_TcT_T =      [\n                                [0,0,0],\n                                [0,0,0],\n                                [0,0,0]\n                            ]\n    true_rPPrime_TcT_T =     [\n                                [0,0,0],\n                                [0,0,0],\n                                [0,0,0]\n                            ]\n    \n    accuracy = 1e-8\n    for idx, trial in enumerate(trials):\n        model.computeTankProps(trial[0])\n        model.computeTankPropDerivs(*trial)\n        dataITank = model.ITankPntT_T\n        dataITank = [dataITank[i][j] for i in range(3) for j in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataITank, true_ITankPntT_T[idx],9,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank constant volume unit test failed ITankPntT_T test\")\n\n        dataIPrimeTank = model.IPrimeTankPntT_T\n        dataIPrimeTank = [dataIPrimeTank[i][j] for i in range(3) for j in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataIPrimeTank, true_IPrimeTankPntT_T[idx],9,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank constant volume unit test failed IPrimeTankPntT_T test\")\n\n        dataR = model.r_TcT_T\n        dataR = [dataR[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataR, true_r_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank constant volume unit test failed r_TcT_T test\")\n\n        dataRPrime = model.rPrime_TcT_T\n        dataRPrime = [dataRPrime[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataRPrime, true_rPrime_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank constant volume unit test failed rPrime_TcT_T test\")\n\n        dataRPPrime = model.rPPrime_TcT_T\n        dataRPPrime = [dataRPPrime[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataRPPrime, true_rPPrime_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank constant volume unit test failed rPPrime_TcT_T test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Fuel Tank constant volume unit test\")\n\n    snippetName = 'ConstVolPassFail'\n    passFail(testFailCount, snippetName)\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def tankModelConstantDensity(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    \n    model = fuelTank.cvar.FuelTankModelConstantDensity\n    model.propMassInit = 10;\n    model.r_TcT_TInit = [[1],[1],[1]]\n    model.radiusTankInit = 5\n    \n    trials = [(0, 0), (10, -1), (5, -1)] #mFuel, mDotFuel\n    true_ITankPntT_T =      [\n                                [0,0,0,0,0,0,0,0,0],\n                                [100,0,0,0,100,0,0,0,100],\n                                [31.498026247371826,0,0,0,31.498026247371826,0,0,0,31.498026247371826]\n                            ]\n    true_IPrimeTankPntT_T = [\n                                [0,0,0,0,0,0,0,0,0],\n                                [-16.666666666666668,0,0,0,-16.666666666666668,0,0,0,-16.666666666666668],\n                                [-10.499342082457275,0,0,0,-10.499342082457275,0,0,0,-10.499342082457275]\n                            ]\n    true_r_TcT_T =           [\n                                [1,1,1],\n                                [1,1,1],\n                                [1,1,1]\n                            ]\n    true_rPrime_TcT_T =      [\n                                [0,0,0],\n                                [0,0,0],\n                                [0,0,0]\n                            ]\n    true_rPPrime_TcT_T =     [\n                                [0,0,0],\n                                [0,0,0],\n                                [0,0,0]\n                            ]\n    \n    accuracy = 1e-8\n    for idx, trial in enumerate(trials):\n        model.computeTankProps(trial[0])\n        model.computeTankPropDerivs(*trial)\n        dataITank = model.ITankPntT_T\n        dataITank = [dataITank[i][j] for i in range(3) for j in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataITank, true_ITankPntT_T[idx],9,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank constant volume unit test failed ITankPntT_T test\")\n\n        dataIPrimeTank = model.IPrimeTankPntT_T\n        dataIPrimeTank = [dataIPrimeTank[i][j] for i in range(3) for j in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataIPrimeTank, true_IPrimeTankPntT_T[idx],9,accuracy):\n            print(dataIPrimeTank, idx)\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank constant volume unit test failed IPrimeTankPntT_T test\")\n\n        dataR = model.r_TcT_T\n        dataR = [dataR[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataR, true_r_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank constant volume unit test failed r_TcT_T test\")\n\n        dataRPrime = model.rPrime_TcT_T\n        dataRPrime = [dataRPrime[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataRPrime, true_rPrime_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank constant volume unit test failed rPrime_TcT_T test\")\n\n        dataRPPrime = model.rPPrime_TcT_T\n        dataRPPrime = [dataRPPrime[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataRPPrime, true_rPPrime_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank constant volume unit test failed rPPrime_TcT_T test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Fuel Tank constant volume unit test\")\n\n    snippetName = 'ConstDensPassFail'\n    passFail(testFailCount, snippetName)\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def tankModelEmptying(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    \n    model = fuelTank.cvar.FuelTankModelEmptying\n    model.propMassInit = 10\n    model.r_TcT_TInit = [[1],[1],[1]]\n    model.radiusTankInit = 5\n    \n    trials = [(0, 0), (10, -1), (5, -1)] #mFuel, mDotFuel\n    true_ITankPntT_T =      [\n                                [0,0,0,0,0,0,0,0,0],\n                                [100,0,0,0,100,0,0,0,100],\n                                [50.0,0,0,0,50.0,0,0,0,50]\n                            ]\n    true_IPrimeTankPntT_T = [\n                                [0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0],\n                                [-8.75,0,0,0,-8.75,0,0,0,-12.5]\n                            ]\n    true_r_TcT_T =           [\n                                [1,1,1-5.0],\n                                [1,1,1],\n                                [1,1,1.0-15.0/8.0]\n                            ]\n    true_rPrime_TcT_T =      [\n                                [0,0,0],\n                                [0,0,0],\n                                [0,0,-3.0/8.0]\n                            ]\n    true_rPPrime_TcT_T =     [\n                                [0,0,0],\n                                [0,0,0],\n                                [0,0,-17.0/30.0]\n                            ]\n    \n    accuracy = 1e-8\n    for idx, trial in enumerate(trials):\n        model.computeTankProps(trial[0])\n        model.computeTankPropDerivs(*trial)\n        dataITank = model.ITankPntT_T\n        dataITank = [dataITank[i][j] for i in range(3) for j in range(3)]\n        if not unitTestSupport.isArrayEqual(dataITank, true_ITankPntT_T[idx],9,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank emptying unit test failed ITankPntT_T test\")\n\n        dataIPrimeTank = model.IPrimeTankPntT_T\n        dataIPrimeTank = [dataIPrimeTank[i][j] for i in range(3) for j in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataIPrimeTank, true_IPrimeTankPntT_T[idx],9,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank emptying unit test failed IPrimeTankPntT_T test\")\n\n        dataR = model.r_TcT_T\n        dataR = [dataR[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataR, true_r_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank emptying unit test failed r_TcT_T test\")\n\n        dataRPrime = model.rPrime_TcT_T\n        dataRPrime = [dataRPrime[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataRPrime, true_rPrime_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank emptying unit test failed rPrime_TcT_T test\")\n\n        dataRPPrime = model.rPPrime_TcT_T\n        dataRPPrime = [dataRPPrime[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataRPPrime, true_rPPrime_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank emptying unit test failed rPPrime_TcT_T test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Fuel Tank constant volume unit test\")\n\n    snippetName = 'EmptyingPassFail'\n    passFail(testFailCount, snippetName)\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def tankModelUniformBurn(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    \n    model = fuelTank.cvar.FuelTankModelUniformBurn\n    model.propMassInit = 10\n    model.r_TcT_TInit = [[1],[1],[1]]\n    model.radiusTankInit = 5\n    model.lengthTank = 5;\n    \n    trials = [(0, 0), (10, -1), (5, -1)] #mFuel, mDotFuel\n    true_ITankPntT_T =      [\n                                [0,0,0,0,0,0,0,0,0],\n                                [83.33333333333334,0,0,0,83.33333333333334,0,0,0,125],\n                                [41.66666666666667,0,0,0,41.66666666666667,0,0,0,62.5]\n                            ]\n    true_IPrimeTankPntT_T = [\n                                [0,0,0,0,0,0,0,0,0],\n                                [-8.3333333333334,0,0,0,-8.3333333333334,0,0,0,-12.5],\n                                [-8.3333333333334,0,0,0,-8.3333333333334,0,0,0,-12.5]\n                            ]\n    true_r_TcT_T =           [\n                                [1,1,1],\n                                [1,1,1],\n                                [1,1,1]\n                            ]\n    true_rPrime_TcT_T =      [\n                                [0,0,0],\n                                [0,0,0],\n                                [0,0,0]\n                            ]\n    true_rPPrime_TcT_T =     [\n                                [0,0,0],\n                                [0,0,0],\n                                [0,0,0]\n                            ]\n    \n    accuracy = 1e-8\n    for idx, trial in enumerate(trials):\n        model.computeTankProps(trial[0])\n        model.computeTankPropDerivs(*trial)\n        dataITank = model.ITankPntT_T\n        dataITank = [dataITank[i][j] for i in range(3) for j in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataITank, true_ITankPntT_T[idx],9,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank centrifugal burn unit test failed ITankPntT_T test\")\n\n        dataIPrimeTank = model.IPrimeTankPntT_T\n        dataIPrimeTank = [dataIPrimeTank[i][j] for i in range(3) for j in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataIPrimeTank, true_IPrimeTankPntT_T[idx],9,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank centrifugal burn unit test failed IPrimeTankPntT_T test\")\n\n        dataR = model.r_TcT_T\n        dataR = [dataR[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataR, true_r_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank centrifugal burn unit test failed r_TcT_T test\")\n\n        dataRPrime = model.rPrime_TcT_T\n        dataRPrime = [dataRPrime[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataRPrime, true_rPrime_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank centrifugal burn unit test failed rPrime_TcT_T test\")\n\n        dataRPPrime = model.rPPrime_TcT_T\n        dataRPPrime = [dataRPPrime[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataRPPrime, true_rPPrime_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank centrifugal burn unit test failed rPPrime_TcT_T test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Fuel Tank constant volume unit test\")\n\n    snippetName = 'UniformBurnPassFail'\n    passFail(testFailCount, snippetName)\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def tankModelCentrifugalBurn(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    \n    model = fuelTank.cvar.FuelTankModelCentrifugalBurn\n    model.propMassInit = 10\n    model.r_TcT_TInit = [[1],[1],[1]]\n    model.radiusTankInit = 5\n    model.lengthTank = 5\n    \n    trials = [(0, 0), (10, -1), (5, -1)] #mFuel, mDotFuel\n    true_ITankPntT_T =      [\n                                [0,0,0,0,0,0,0,0,0],\n                                [83.33333333333334,0,0,0,83.33333333333334,0,0,0,125],\n                                [57.291666666666671,0,0,0,57.291666666666671,0,0,0,93.75]\n                            ]\n    true_IPrimeTankPntT_T = [\n                                [0,0,0,0,0,0,0,0,0],\n                                [-2.0833333333333335,0,0,0,-2.0833333333333335,0,0,0,0.0],\n                                [-8.3333333333333339,0,0,0,-8.3333333333333339,0,0,0,-12.500000000000002]\n                            ]\n    true_r_TcT_T =           [\n                                [1,1,1],\n                                [1,1,1],\n                                [1,1,1]\n                            ]\n    true_rPrime_TcT_T =      [\n                                [0,0,0],\n                                [0,0,0],\n                                [0,0,0]\n                            ]\n    true_rPPrime_TcT_T =     [\n                                [0,0,0],\n                                [0,0,0],\n                                [0,0,0]\n                            ]\n    \n    accuracy = 1e-8\n    for idx, trial in enumerate(trials):\n        model.computeTankProps(trial[0])\n        model.computeTankPropDerivs(*trial)\n        dataITank = model.ITankPntT_T\n        dataITank = [dataITank[i][j] for i in range(3) for j in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataITank, true_ITankPntT_T[idx],9,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank uniform burn unit test failed ITankPntT_T test\")\n\n        dataIPrimeTank = model.IPrimeTankPntT_T\n        dataIPrimeTank = [dataIPrimeTank[i][j] for i in range(3) for j in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataIPrimeTank, true_IPrimeTankPntT_T[idx],9,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank uniform burn unit test failed IPrimeTankPntT_T test\")\n\n        dataR = model.r_TcT_T\n        dataR = [dataR[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataR, true_r_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank uniform burn unit test failed r_TcT_T test\")\n\n        dataRPrime = model.rPrime_TcT_T\n        dataRPrime = [dataRPrime[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataRPrime, true_rPrime_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank uniform burn unit test failed rPrime_TcT_T test\")\n\n        dataRPPrime = model.rPPrime_TcT_T\n        dataRPPrime = [dataRPPrime[i][0] for i in range(3)]\n        if not unitTestSupport.isArrayEqualRelative(dataRPPrime, true_rPPrime_TcT_T[idx],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Fuel Tank uniform burn unit test failed rPPrime_TcT_T test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Fuel Tank constant volume unit test\")\n\n    snippetName = 'CentrifugalPassFail'\n    passFail(testFailCount, snippetName)\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def passFail(testFailCountInput, snippetName):\n    if testFailCountInput < 1:\n        textMsg = 'PASSED'\n        textColor = 'ForestGreen'\n    else:\n        textMsg = 'FAILED'\n        textColor = 'Red'\n\n    texSnippet =  r'\\textcolor{' + textColor + '}{'+ textMsg + '}'\n    unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)",
  "def test_scenarioDragOrbit():\n    \"\"\"This function is called by the py.test environment.\"\"\"\n    # each test method requires a single assert method to be called\n    earthCase = \"Earth\"\n    marsCase = \"Mars\"\n    orb1 = \"LPO\"\n    orb2 = \"LTO\"\n    showVal = False\n    testResults = []\n    testMessage = []\n    [leoResults, leoMessages] = run(\n            showVal, orb1, earthCase)\n    #[gtoResults, gtoMessages] = run(\n    #    showVal, orb2, earthCase)\n    #[lmoResults, lmoMessages] = run(\n        #showVal, orb1, marsCase)\n    #[mtoResults, mtoMessages] = run(\n        #showVal, orb2, marsCase)\n\n    testResults = leoResults#+gtoResults#+lmoResults+mtoResults\n    testMessage.append(leoMessages)\n    #testMessage.append(gtoMessages)\n    ##testMessage.append(lmoMessages)\n    #testMessage.append(mtoMessages)\n\n    assert testResults < 1, testMessage",
  "def expAtmoComp(alt, baseDens, scaleHeight):\n    dens = baseDens * math.exp(-alt/scaleHeight)\n    return dens",
  "def cannonballDragComp(dragCoeff, dens, area, vel, att):\n    dragDir_N = -vel / np.linalg.norm(vel)\n    dcm_BN = RigidBodyKinematics.MRP2C(att)\n    dragDir_B = dcm_BN.dot(dragDir_N)\n\n    dragForce = 0.5 * dragCoeff * dens * area * np.linalg.norm(vel)**2.0 * dragDir_B\n    return dragForce",
  "def run(show_plots, orbitCase, planetCase):\n    \"\"\"Call this routine directly to run the tutorial scenario.\"\"\"\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n\n\n    # Create simulation variable names\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n\n    #  Create a sim module as an empty container\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    #  create the simulation process\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n\n    # create the dynamics task and specify the integration update time\n    simulationTimeStep = macros.sec2nano(1.0)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n\n\n\n    #   Initialize new atmosphere and drag model, add them to task\n    newAtmo = exponentialAtmosphere.ExponentialAtmosphere()\n    atmoTaskName = \"atmosphere\"\n    newAtmo.ModelTag = \"ExpAtmo\"\n\n    projArea = 10.0  # Set drag area in m^2\n    dragCoeff = 2.2  # Set drag ceofficient\n\n    dragEffector = dragDynamicEffector.DragDynamicEffector()\n    dragEffector.ModelTag = \"DragEff\"\n\n    dragEffectorTaskName = \"drag\"\n    dragEffector.coreParams.projectedArea = projArea\n    dragEffector.coreParams.dragCoeff = dragCoeff\n    dragEffector.coreParams.comOffset = [1., 0., 0.]\n\n    dynProcess.addTask(scSim.CreateNewTask(atmoTaskName, simulationTimeStep))\n    dynProcess.addTask(scSim.CreateNewTask(dragEffectorTaskName, simulationTimeStep))\n    scSim.AddModelToTask(atmoTaskName, newAtmo)\n\n    #\n    #   setup the simulation tasks/objects\n    #\n\n    # initialize spacecraft object and set properties\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n    newAtmo.addSpacecraftToModel(scObject.scStateOutMsg)\n\n    simpleNavObj = simpleNav.SimpleNav()\n    scSim.AddModelToTask(simTaskName, simpleNavObj)\n    simpleNavObj.scStateInMsg.subscribeTo(scObject.scStateOutMsg)\n\n    scObject.addDynamicEffector(dragEffector)\n\n    # add spacecraft object to the simulation process\n    scSim.AddModelToTask(simTaskName, scObject)\n    scSim.AddModelToTask(dragEffectorTaskName, dragEffector)\n    # clear prior gravitational body and SPICE setup definitions\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n\n    dragEffector.atmoDensInMsg.subscribeTo(newAtmo.envOutMsgs[0])\n\n    if planetCase == \"Earth\":\n        planet = gravFactory.createEarth()\n    elif planetCase == \"Mars\":\n        planet = gravFactory.createMars()\n        planet.isCentralBody = True          # ensure this is the central gravitational body\n    mu = planet.mu\n    # attach gravity model to spacecraft\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    #\n    #   setup orbit and simulation time\n    oe = orbitalMotion.ClassicElements()\n\n    if planetCase == \"Earth\":\n        r_eq = 6371*1000.0\n        refBaseDens = 1.217\n        refScaleHeight = 8500.0\n\n    elif planetCase == \"Mars\":\n        refBaseDens = 0.020\n        refScaleHeight = 11100.0\n        r_eq = 3389.5 * 1000.0\n    else:\n        return 1, \"Test failed- did not initialize planets.\"\n    if orbitCase == \"LPO\":\n        orbAltMin = 300.0*1000.0\n        orbAltMax = orbAltMin\n    elif orbitCase == \"LTO\":\n        orbAltMin = 300*1000.0\n        orbAltMax = 800.0 * 1000.0\n\n    newAtmo.planetRadius = r_eq\n    newAtmo.scaleHeight = refScaleHeight\n    newAtmo.baseDensity = refBaseDens\n\n    rMin = r_eq + orbAltMin\n    rMax = r_eq + orbAltMax\n    oe.a = (rMin+rMax)/2.0\n    oe.e = 1.0 - rMin/oe.a\n    oe.i = 0.0*macros.D2R\n\n    oe.Omega = 0.0*macros.D2R\n    oe.omega = 0.0*macros.D2R\n    oe.f     = 0.0*macros.D2R\n    rN, vN = orbitalMotion.elem2rv(mu, oe)\n    oe = orbitalMotion.rv2elem(mu, rN, vN)      # this stores consistent initial orbit elements\n                                                # with circular or equatorial orbit, some angles are\n                                                # arbitrary\n\n    # set the simulation time\n    n = np.sqrt(mu/oe.a/oe.a/oe.a)\n    P = 2.*np.pi/n\n\n    simulationTime = macros.sec2nano(1*P)\n\n    #\n    #   Setup data logging before the simulation is initialized\n    #\n\n    numDataPoints = 100\n    samplingTime = unitTestSupport.samplingTime(simulationTime, simulationTimeStep, numDataPoints)\n    dataLog = scObject.scStateOutMsg.recorder(samplingTime)\n    dataNewAtmoLog = newAtmo.envOutMsgs[0].recorder(samplingTime)\n    scSim.AddModelToTask(simTaskName, dataLog)\n    scSim.AddModelToTask(simTaskName, dataNewAtmoLog)\n\n    scSim.AddVariableForLogging('DragEff.forceExternal_B', samplingTime, StartIndex=0, StopIndex=2)\n    #\n    #   initialize Spacecraft States with initialization variables\n    #\n    scObject.hub.r_CN_NInit = rN  # m - r_CN_N\n    scObject.hub.v_CN_NInit = vN  # m - v_CN_N\n\n    #\n    #   initialize Simulation\n    #\n    scSim.InitializeSimulation()\n\n    #\n    #   configure a simulation stop time and execute the simulation run\n    #\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    #\n    #   retrieve the logged data\n    #\n    posData = dataLog.r_BN_N\n    velData = dataLog.v_BN_N\n    attData = dataLog.sigma_BN\n    dragForce = scSim.GetLogVariableData('DragEff.forceExternal_B')\n    densData = dataNewAtmoLog.neutralDensity\n    np.set_printoptions(precision=16)\n\n    #   Compare to expected values\n\n    endInd = dragForce.shape[0]\n\n    refDragForce = np.zeros([endInd,3])\n    refDensData = np.zeros([endInd,1])\n    accuracy = 1e-13\n    # print planetCase\n    # print orbitCase\n    for ind in range(0, endInd-1):\n        # print \"Position data:\", posData[ind,1:]\n        # print \"Velocity data:\", velData[ind,1:]\n        # print \"Density data:\", densData[ind,1]\n        refDragForce[ind] = cannonballDragComp(dragCoeff,densData[ind],projArea,velData[ind], attData[ind])\n        # print \"Reference drag data:\", refDragForce[ind,:]\n        # print \"Drag Data:\", dragForce[ind,1:]\n        # print \"\"\n        # check a vector values\n    for ind in range(1,endInd-1):\n        if not unitTestSupport.isArrayEqual(dragForce[ind,1:4], refDragForce[ind],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\n                \"FAILED:  DragEffector failed force unit test with a value difference of \"\n                + str(np.linalg.norm(dragForce[ind,1:4]-refDragForce[ind])))\n\n    #\n    #   plot the results\n    #\n    if show_plots:\n        plt.close(\"all\")  # clears out plots from earlier test runs\n\n        # draw the inertial position vector components\n        plt.figure(1)\n        fig = plt.gcf()\n        ax = fig.gca()\n        ax.ticklabel_format(useOffset=False, style='plain')\n        for idx in range(0,3):\n            plt.plot(dataLog.times()*macros.NANO2SEC/P, posData[:, idx]/1000.,\n                     color=unitTestSupport.getLineColor(idx,3),\n                     label='$r_{BN,'+str(idx)+'}$')\n        plt.legend(loc='lower right')\n        plt.xlabel('Time [orbits]')\n        plt.ylabel('Inertial Position [km]')\n\n        # draw orbit in perifocal frame\n        b = oe.a*np.sqrt(1-oe.e*oe.e)\n        p = oe.a*(1-oe.e*oe.e)\n        plt.figure(2,figsize=np.array((1.0, b/oe.a))*4.75,dpi=100)\n        plt.axis(np.array([-oe.rApoap, oe.rPeriap, -b, b])/1000*1.25)\n        # draw the planet\n        fig = plt.gcf()\n        ax = fig.gca()\n\n        planetColor= '#008800'\n        planetRadius = planet.radEquator/1000\n        ax.add_artist(plt.Circle((0, 0), planetRadius, color=planetColor))\n        # draw the actual orbit\n        rData=[]\n        fData=[]\n        for idx in range(0,len(posData)):\n            oeData = orbitalMotion.rv2elem(mu,posData[idx,0:3],velData[idx,0:3])\n            rData.append(oeData.rmag)\n            fData.append(oeData.f + oeData.omega - oe.omega)\n        plt.plot(rData*np.cos(fData)/1000, rData*np.sin(fData)/1000\n                 ,color='#aa0000'\n                 ,linewidth = 3.0\n                 )\n        # draw the full osculating orbit from the initial conditions\n        fData = np.linspace(0,2*np.pi,100)\n        rData = []\n        for idx in range(0,len(fData)):\n            rData.append(p/(1+oe.e*np.cos(fData[idx])))\n        plt.plot(rData*np.cos(fData)/1000, rData*np.sin(fData)/1000\n                 ,'--'\n                 , color='#555555'\n                 )\n        plt.xlabel('$i_e$ Cord. [km]')\n        plt.ylabel('$i_p$ Cord. [km]')\n        plt.grid()\n\n        plt.figure()\n        fig = plt.gcf()\n        ax = fig.gca()\n        ax.ticklabel_format(useOffset=False, style='plain')\n        smaData = []\n        for idx in range(0, len(posData)):\n            oeData = orbitalMotion.rv2elem(mu, posData[idx, 0:3], velData[idx, 0:3])\n            smaData.append(oeData.a/1000.)\n        plt.plot(posData[:, 0]*macros.NANO2SEC/P, smaData\n                 ,color='#aa0000',\n                 )\n        plt.xlabel('Time [orbits]')\n        plt.ylabel('SMA [km]')\n\n\n        plt.figure()\n        fig = plt.gcf()\n        ax = fig.gca()\n        ax.ticklabel_format(useOffset=False, style='sci')\n        plt.plot( dataNewAtmoLog.times()*macros.NANO2SEC, densData)\n        plt.title('Density Data vs. Time')\n        plt.xlabel('Time')\n        plt.ylabel('Density in kg/m^3')\n\n        plt.show()\n        plt.close(\"all\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + dragEffector.ModelTag)\n    else:\n        print(\"Failed: \" + dragEffector.ModelTag)\n\n    return testFailCount, testMessages",
  "def test_hingedRigidBody(show_plots, function):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = eval(function + '(show_plots)')\n    assert testResults < 1, testMessage",
  "def test_hingedRigidBodyMotorTorque(show_plots, useScPlus):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = hingedRigidBodyMotorTorque(show_plots, useScPlus)\n    assert testResults < 1, testMessage",
  "def hingedRigidBodyGravity(show_plots):\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraftSystem.SpacecraftSystem()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.001)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Create two hinged rigid bodies\n    unitTestSim.panel1 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n    unitTestSim.panel2 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n\n    # Define Variable for panel 1\n    unitTestSim.panel1.mass = 100.0\n    unitTestSim.panel1.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel1.d = 1.5\n    unitTestSim.panel1.k = 100.0\n    unitTestSim.panel1.c = 0.0\n    unitTestSim.panel1.r_HB_B = [[0.5], [0.0], [1.0]]\n    unitTestSim.panel1.dcm_HB = [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel1.thetaInit = 5*numpy.pi/180.0\n    unitTestSim.panel1.thetaDotInit = 0.0\n    unitTestSim.panel1.ModelTag = \"Panel1\"\n\n    # Define Variables for panel 2\n    unitTestSim.panel2.mass = 100.0\n    unitTestSim.panel2.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel2.d = 1.5\n    unitTestSim.panel2.k = 100.0\n    unitTestSim.panel2.c = 0.0\n    unitTestSim.panel2.r_HB_B = [[-0.5], [0.0], [1.0]]\n    unitTestSim.panel2.dcm_HB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel2.thetaInit = 0.0\n    unitTestSim.panel2.thetaDotInit = 0.0\n    unitTestSim.panel2.ModelTag = \"Panel2\"\n\n    # Add panels to spaceCraft\n    scObject.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel1)\n    scObject.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel2)\n\n    # Define mass properties of the rigid part of the spacecraft\n    scObject.primaryCentralSpacecraft.hub.mHub = 750.0\n    scObject.primaryCentralSpacecraft.hub.r_BcB_B = [[0.0], [0.0], [1.0]]\n    scObject.primaryCentralSpacecraft.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    # Set the initial values for the states\n    scObject.primaryCentralSpacecraft.hub.r_CN_NInit = [[-4020338.690396649],\t[7490566.741852513],\t[5248299.211589362]]\n    scObject.primaryCentralSpacecraft.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n    scObject.primaryCentralSpacecraft.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.omega_BN_BInit = [[0.1], [-0.1], [0.1]]\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel1)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel2)\n\n    # Add Earth gravity to the sim\n    unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n    unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n    unitTestSim.earthGravBody.mu = 0.3986004415E+15 # meters!\n    unitTestSim.earthGravBody.isCentralBody = True\n    unitTestSim.earthGravBody.useSphericalHarmParams = False\n    scObject.primaryCentralSpacecraft.gravField.gravBodies = spacecraft.GravBodyVector([unitTestSim.earthGravBody])\n\n    # Log the spacecraft state message\n    datLog = scObject.primaryCentralSpacecraft.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, datLog)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n\n    # Add energy and momentum variables to log\n    unitTestSim.AddVariableForLogging(unitTestSim.panel1.ModelTag + \".forceOnBody_B\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(unitTestSim.panel2.ModelTag + \".forceOnBody_B\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n\n    stopTime = 2.5\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    sigmaOut = datLog.sigma_BN\n\n    forcePanel1 = unitTestSim.GetLogVariableData(unitTestSim.panel1.ModelTag + \".forceOnBody_B\")\n    forcePanel2 = unitTestSim.GetLogVariableData(unitTestSim.panel2.ModelTag + \".forceOnBody_B\")\n    orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbEnergy\")\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totRotEnergy\")\n\n    dataSigma = [sigmaOut[-1]]\n\n    trueSigma = [[0.06170318243240492, -0.07089090074412899, 0.06409500412692531]]\n\n    initialOrbAngMom_N = [[orbAngMom_N[0,1], orbAngMom_N[0,2], orbAngMom_N[0,3]]]\n\n    finalOrbAngMom = [orbAngMom_N[-1]]\n\n    initialRotAngMom_N = [[rotAngMom_N[0,1], rotAngMom_N[0,2], rotAngMom_N[0,3]]]\n\n    finalRotAngMom = [rotAngMom_N[-1]]\n\n    initialOrbEnergy = [[orbEnergy[0,1]]]\n\n    finalOrbEnergy = [orbEnergy[-1]]\n\n    initialRotEnergy = [[rotEnergy[0,1]]]\n\n    finalRotEnergy = [rotEnergy[-1]]\n\n    plt.close(\"all\")\n    plt.figure()\n    plt.clf()\n    plt.plot(orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,1] - orbAngMom_N[0,1])/orbAngMom_N[0,1], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,2] - orbAngMom_N[0,2])/orbAngMom_N[0,2], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,3] - orbAngMom_N[0,3])/orbAngMom_N[0,3])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    PlotName = \"ChangeInOrbitalAngularMomentumGravity\"\n    PlotTitle = \"Change in Orbital Angular Momentum with Gravity\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(orbEnergy[:,0]*1e-9, (orbEnergy[:,1] - orbEnergy[0,1])/orbEnergy[0,1])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    PlotName = \"ChangeInOrbitalEnergyGravity\"\n    PlotTitle = \"Change in Orbital Energy with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,1] - rotAngMom_N[0,1])/rotAngMom_N[0,1], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,2] - rotAngMom_N[0,2])/rotAngMom_N[0,2], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,3] - rotAngMom_N[0,3])/rotAngMom_N[0,3])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    PlotName = \"ChangeInRotationalAngularMomentumGravity\"\n    PlotTitle = \"Change In Rotational Angular Momentum with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotEnergy[:,0]*1e-9, (rotEnergy[:,1] - rotEnergy[0,1])/rotEnergy[0,1])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    PlotName = \"ChangeInRotationalEnergyGravity\"\n    PlotTitle = \"Change In Rotational Energy with Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(forcePanel1[:,0]*1e-9, forcePanel1[:,1], forcePanel1[:,0]*1e-9, forcePanel1[:,2], forcePanel1[:,0]*1e-9, forcePanel1[:,3])\n    plt.xlabel('time (s)')\n    plt.ylabel('Force about Point B')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(forcePanel2[:,0]*1e-9, forcePanel2[:,1], forcePanel2[:,0]*1e-9, forcePanel2[:,2], forcePanel2[:,0]*1e-9, forcePanel2[:,3])\n    plt.xlabel('time (s)')\n    plt.ylabel('Force about Point B')\n\n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n    accuracy = 1e-10\n    for i in range(0,len(trueSigma)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(dataSigma[i],trueSigma[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED:  Hinged Rigid Body integrated test failed gravity attitude test\")\n\n    finalOrbAngMom = numpy.delete(finalOrbAngMom, 0, axis=1)  # remove time column\n    finalRotAngMom = numpy.delete(finalRotAngMom, 0, axis=1)  # remove time column\n    finalRotEnergy = numpy.delete(finalRotEnergy, 0, axis=1)  # remove time column\n    finalOrbEnergy = numpy.delete(finalOrbEnergy, 0, axis=1)  # remove time column\n\n    for i in range(0,len(initialOrbAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i],initialOrbAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test failed gravity orbital angular momentum unit test\")\n\n    for i in range(0,len(initialRotAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i],initialRotAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test failed gravity rotational angular momentum unit test\")\n\n    for i in range(0,len(initialRotEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotEnergy[i],initialRotEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test failed gravity rotational energy unit test\")\n\n    for i in range(0,len(initialOrbEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i],initialOrbEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test failed gravity orbital energy unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Hinged Rigid Body gravity integrated test\")\n\n    assert testFailCount < 1, testMessages\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def hingedRigidBodyNoGravity(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter  \n    testMessages = []  # create empty list to store test log messages\n    \n    scObject = spacecraftSystem.SpacecraftSystem()\n    scObject.ModelTag = \"spacecraftBody\"\n    \n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n    \n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    \n    # Create test thread\n    testProcessRate = macros.sec2nano(0.001)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    unitTestSim.panel1 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n    unitTestSim.panel2 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n\n    # Define Variable for panel 1\n    unitTestSim.panel1.mass = 100.0\n    unitTestSim.panel1.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel1.d = 1.5\n    unitTestSim.panel1.k = 100.0\n    unitTestSim.panel1.c = 0.0\n    unitTestSim.panel1.r_HB_B = [[0.5], [0.0], [1.0]]\n    unitTestSim.panel1.dcm_HB = [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel1.thetaInit = 5*numpy.pi/180.0\n    unitTestSim.panel1.thetaDotInit = 0.0\n\n    # Define Variables for panel 2\n    unitTestSim.panel2.mass = 100.0\n    unitTestSim.panel2.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel2.d = 1.5\n    unitTestSim.panel2.k = 100.0\n    unitTestSim.panel2.c = 0.0\n    unitTestSim.panel2.r_HB_B = [[-0.5], [0.0], [1.0]]\n    unitTestSim.panel2.dcm_HB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel2.thetaInit = 0.0\n    unitTestSim.panel2.thetaDotInit = 0.0\n\n    # Add panels to spaceCraft\n    scObject.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel1)\n    scObject.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel2)\n\n    # Define mass properties of the rigid part of the spacecraft\n    scObject.primaryCentralSpacecraft.hub.mHub = 750.0\n    scObject.primaryCentralSpacecraft.hub.r_BcB_B = [[0.0], [0.0], [1.0]]\n    scObject.primaryCentralSpacecraft.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    # Set the initial values for the states\n    scObject.primaryCentralSpacecraft.hub.r_CN_NInit = [[0.1], [-0.4], [0.3]]\n    scObject.primaryCentralSpacecraft.hub.v_CN_NInit = [[-0.2], [0.5], [0.1]]\n    scObject.primaryCentralSpacecraft.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.omega_BN_BInit = [[0.1], [-0.1], [0.1]]\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel1)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel2)\n\n    dataLog = scObject.primaryCentralSpacecraft.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n    \n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n\n    stopTime = 2.5\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    sigmaOut = dataLog.sigma_BN\n    rOut_BN_N = dataLog.r_BN_N\n    vOut_CN_N = dataLog.v_CN_N\n\n    orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbEnergy\")\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totRotEnergy\")\n\n    # Get the last sigma and position\n    dataSigma = [sigmaOut[-1]]\n    dataPos = [rOut_BN_N[-1]]\n\n    truePos = [[-0.15832794740648992, 1.122481716747217, -0.37975995949382907]]\n\n    trueSigma = [[0.06170318243240492, -0.07089090074412899, 0.06409500412692531]]\n\n    initialOrbAngMom_N = [[orbAngMom_N[0,1], orbAngMom_N[0,2], orbAngMom_N[0,3]]]\n\n    finalOrbAngMom = [orbAngMom_N[-1]]\n\n    initialRotAngMom_N = [[rotAngMom_N[0,1], rotAngMom_N[0,2], rotAngMom_N[0,3]]]\n\n    finalRotAngMom = [rotAngMom_N[-1]]\n\n    initialOrbEnergy = [[orbEnergy[0,1]]]\n\n    finalOrbEnergy = [orbEnergy[-1]]\n\n    initialRotEnergy = [[rotEnergy[0,1]]]\n\n    finalRotEnergy = [rotEnergy[-1]]\n\n    plt.close(\"all\")\n    plt.figure()\n    plt.clf()\n    plt.plot(orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,1] - orbAngMom_N[0,1])/orbAngMom_N[0,1], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,2] - orbAngMom_N[0,2])/orbAngMom_N[0,2], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,3] - orbAngMom_N[0,3])/orbAngMom_N[0,3])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    PlotName = \"ChangeInOrbitalAngularMomentumNoGravity\"\n    PlotTitle = \"Change in Orbital Angular Momentum No Gravity\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(orbEnergy[:,0]*1e-9, (orbEnergy[:,1] - orbEnergy[0,1])/orbEnergy[0,1])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    PlotName = \"ChangeInOrbitalEnergyNoGravity\"\n    PlotTitle = \"Change in Orbital Energy No Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,1] - rotAngMom_N[0,1])/rotAngMom_N[0,1], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,2] - rotAngMom_N[0,2])/rotAngMom_N[0,2], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,3] - rotAngMom_N[0,3])/rotAngMom_N[0,3])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    PlotName = \"ChangeInRotationalAngularMomentumNoGravity\"\n    PlotTitle = \"Change In Rotational Angular Momentum No Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotEnergy[:,0]*1e-9, (rotEnergy[:,1] - rotEnergy[0,1])/rotEnergy[0,1])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    PlotName = \"ChangeInRotationalEnergyNoGravity\"\n    PlotTitle = \"Change In Rotational Energy No Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(dataLog.times()*1e-9, vOut_CN_N[:,0], dataLog.times()*1e-9, vOut_CN_N[:,1], dataLog.times()*1e-9, vOut_CN_N[:,2])\n    plt.xlabel('time (s)')\n    plt.ylabel('m/s')\n    PlotName = \"VelocityOfCenterOfMassNoGravity\"\n    PlotTitle = \"Velocity Of Center Of Mass No Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(dataLog.times()*1e-9, (vOut_CN_N[:,0] - vOut_CN_N[:,0])/vOut_CN_N[:,0], dataLog.times()*1e-9,\n             (vOut_CN_N[:,1] - vOut_CN_N[:,1])/vOut_CN_N[:,1], dataLog.times()*1e-9,\n             (vOut_CN_N[:,2] - vOut_CN_N[:,2])/vOut_CN_N[:,2])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    PlotName = \"ChangeInVelocityOfCenterOfMassNoGravity\"\n    PlotTitle = \"Change In Velocity Of Center Of Mass No Gravity\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n    accuracy = 1e-10\n    for i in range(0,len(truePos)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(dataPos[i],truePos[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED:  Hinged Rigid Body integrated test failed position test\")\n\n    for i in range(0,len(trueSigma)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(dataSigma[i],trueSigma[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED:  Hinged Rigid Body integrated test failed attitude test\")\n\n    finalOrbAngMom = numpy.delete(finalOrbAngMom, 0, axis=1)  # remove time column\n    finalRotAngMom = numpy.delete(finalRotAngMom, 0, axis=1)  # remove time column\n    finalRotEnergy = numpy.delete(finalRotEnergy, 0, axis=1)  # remove time column\n    finalOrbEnergy = numpy.delete(finalOrbEnergy, 0, axis=1)  # remove time column\n\n    for i in range(0,len(initialOrbAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i],initialOrbAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test failed orbital angular momentum unit test\")\n\n    for i in range(0,len(initialRotAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i],initialRotAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test failed rotational angular momentum unit test\")\n\n    for i in range(0,len(initialRotEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotEnergy[i],initialRotEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test failed rotational energy unit test\")\n\n    for i in range(0,len(initialOrbEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i],initialOrbEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test failed orbital energy unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Hinged Rigid Body integrated test\")\n\n    assert testFailCount < 1, testMessages\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def hingedRigidBodyNoGravityDamping(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraftSystem.SpacecraftSystem()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.001)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    unitTestSim.panel1 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n    unitTestSim.panel2 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n\n    # Define Variable for panel 1\n    unitTestSim.panel1.mass = 100.0\n    unitTestSim.panel1.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel1.d = 1.5\n    unitTestSim.panel1.k = 100.0\n    unitTestSim.panel1.c = 6.0\n    unitTestSim.panel1.r_HB_B = [[0.5], [0.0], [1.0]]\n    unitTestSim.panel1.dcm_HB = [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel1.thetaInit = 5*numpy.pi/180.0\n    unitTestSim.panel1.thetaDotInit = 0.0\n\n    # Define Variables for panel 2\n    unitTestSim.panel2.mass = 100.0\n    unitTestSim.panel2.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel2.d = 1.5\n    unitTestSim.panel2.k = 100.0\n    unitTestSim.panel2.c = 7.0\n    unitTestSim.panel2.r_HB_B = [[-0.5], [0.0], [1.0]]\n    unitTestSim.panel2.dcm_HB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel2.thetaInit = 0.0\n    unitTestSim.panel2.thetaDotInit = 0.0\n\n    # Add panels to spaceCraft\n    scObject.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel1)\n    scObject.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel2)\n\n    # Define mass properties of the rigid part of the spacecraft\n    scObject.primaryCentralSpacecraft.hub.mHub = 750.0\n    scObject.primaryCentralSpacecraft.hub.r_BcB_B = [[0.0], [0.0], [1.0]]\n    scObject.primaryCentralSpacecraft.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    # Set the initial values for the states\n    scObject.primaryCentralSpacecraft.hub.r_CN_NInit = [[0.1], [-0.4], [0.3]]\n    scObject.primaryCentralSpacecraft.hub.v_CN_NInit = [[-0.2], [0.5], [0.1]]\n    scObject.primaryCentralSpacecraft.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.omega_BN_BInit = [[0.1], [-0.1], [0.1]]\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel1)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel2)\n\n    dataLog = scObject.primaryCentralSpacecraft.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n\n    stopTime = 2.5\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    vOut_CN_N = dataLog.v_CN_N\n\n    orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbEnergy\")\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".primaryCentralSpacecraft\" + \".totRotAngMomPntC_N\")\n\n    initialOrbAngMom_N = [[orbAngMom_N[0,1], orbAngMom_N[0,2], orbAngMom_N[0,3]]]\n\n    finalOrbAngMom = [orbAngMom_N[-1]]\n\n    initialRotAngMom_N = [[rotAngMom_N[0,1], rotAngMom_N[0,2], rotAngMom_N[0,3]]]\n\n    finalRotAngMom = [rotAngMom_N[-1]]\n\n    initialOrbEnergy = [[orbEnergy[0,1]]]\n\n    finalOrbEnergy = [orbEnergy[-1]]\n\n    plt.close(\"all\")\n    plt.figure()\n    plt.clf()\n    plt.plot(orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,1] - orbAngMom_N[0,1])/orbAngMom_N[0,1], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,2] - orbAngMom_N[0,2])/orbAngMom_N[0,2], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,3] - orbAngMom_N[0,3])/orbAngMom_N[0,3])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    PlotName = \"ChangeInOrbitalAngularMomentumNoGravityDamping\"\n    PlotTitle = \"Change in Orbital Angular Momentum No Gravity with Damping\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(orbEnergy[:,0]*1e-9, (orbEnergy[:,1] - orbEnergy[0,1])/orbEnergy[0,1])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    PlotName = \"ChangeInOrbitalEnergyNoGravityDamping\"\n    PlotTitle = \"Change in Orbital Energy No Gravity with Damping\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,1] - rotAngMom_N[0,1])/rotAngMom_N[0,1], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,2] - rotAngMom_N[0,2])/rotAngMom_N[0,2], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,3] - rotAngMom_N[0,3])/rotAngMom_N[0,3])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    PlotName = \"ChangeInRotationalAngularMomentumNoGravityDamping\"\n    PlotTitle = \"Change In Rotational Angular Momentum No Gravity with Damping\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(dataLog.times()*1e-9, vOut_CN_N[:, 0],\n             dataLog.times()*1e-9, vOut_CN_N[:, 1],\n             dataLog.times()*1e-9, vOut_CN_N[:, 2])\n    plt.xlabel('time (s)')\n    plt.ylabel('m/s')\n    PlotName = \"VelocityOfCenterOfMassNoGravityDamping\"\n    PlotTitle = \"Velocity Of Center Of Mass No Gravity with Damping\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(dataLog.times()*1e-9, (vOut_CN_N[:, 0] - vOut_CN_N[:, 0])/vOut_CN_N[:, 0],\n             dataLog.times()*1e-9, (vOut_CN_N[:, 1] - vOut_CN_N[:, 1])/vOut_CN_N[:, 1],\n             dataLog.times()*1e-9, (vOut_CN_N[:, 2] - vOut_CN_N[:, 2])/vOut_CN_N[:, 2])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    PlotName = \"ChangeInVelocityOfCenterOfMassNoGravityDamping\"\n    PlotTitle = \"Change In Velocity Of Center Of Mass No Gravity with Damping\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n    finalOrbAngMom = numpy.delete(finalOrbAngMom, 0, axis=1)  # remove time column\n    finalRotAngMom = numpy.delete(finalRotAngMom, 0, axis=1)  # remove time column\n    finalOrbEnergy = numpy.delete(finalOrbEnergy, 0, axis=1)  # remove time column\n\n    accuracy = 1e-10\n    for i in range(0,len(initialOrbAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i],initialOrbAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test with damping failed orbital angular momentum unit test\")\n\n    for i in range(0,len(initialRotAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i],initialRotAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test with damping failed rotational angular momentum unit test\")\n\n    for i in range(0,len(initialOrbEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i],initialOrbEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test with damping failed orbital energy unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Hinged Rigid Body integrated test with damping\")\n\n    assert testFailCount < 1, testMessages\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def hingedRigidBodyThetaSS(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraftSystem.SpacecraftSystem()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    stepSize = 0.1\n    testProcessRate = macros.sec2nano(stepSize)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    unitTestSim.panel1 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n    unitTestSim.panel2 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n\n    # Define Variable for panel 1\n    unitTestSim.panel1.mass = 100.0\n    unitTestSim.panel1.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel1.d = 1.5\n    unitTestSim.panel1.k = 100.0\n    unitTestSim.panel1.c = 75\n    unitTestSim.panel1.r_HB_B = [[0.5], [1.0], [0.0]]\n    unitTestSim.panel1.dcm_HB = [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]\n    unitTestSim.panel1.thetaInit = 0.0\n    unitTestSim.panel1.thetaDotInit = 0.0\n\n    # Define Variables for panel 2\n    unitTestSim.panel2.mass = 100.0\n    unitTestSim.panel2.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel2.d = 1.5\n    unitTestSim.panel2.k = 100.0\n    unitTestSim.panel2.c = 75\n    unitTestSim.panel2.r_HB_B = [[-0.5], [1.0], [0.0]]\n    unitTestSim.panel2.dcm_HB = [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]\n    unitTestSim.panel2.thetaInit = 0.0\n    unitTestSim.panel2.thetaDotInit = 0.0\n\n    # Add panels to spaceCraft\n    scObject.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel1)\n    scObject.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel2)\n\n    # Add external force and torque\n    extFTObject = extForceTorque.ExtForceTorque()\n    extFTObject.ModelTag = \"externalDisturbance\"\n    extFTObject.extTorquePntB_B = [[0], [0], [0]]\n    extFTObject.extForce_B = [[0], [1], [0]]\n    scObject.primaryCentralSpacecraft.addDynamicEffector(extFTObject)\n    unitTestSim.AddModelToTask(unitTaskName, extFTObject)\n\n    # Define mass properties of the rigid part of the spacecraft\n    scObject.primaryCentralSpacecraft.hub.mHub = 750.0\n    scObject.primaryCentralSpacecraft.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    # Set the initial values for the states\n    scObject.primaryCentralSpacecraft.hub.r_CN_NInit = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.v_CN_NInit = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.omega_BN_BInit = [[0.0], [0.0], [0.0]]\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel1)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel2)\n\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.AddVariableForLogging(\"spacecraftBody.dynManager.getStateObject('spacecrafthingedRigidBodyTheta1').getState()\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(\"spacecraftBody.dynManager.getStateObject('spacecrafthingedRigidBodyTheta2').getState()\", testProcessRate, 0, 0, 'double')\n\n    stopTime = 60.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    theta1Out = unitTestSim.GetLogVariableData(\"spacecraftBody.dynManager.getStateObject('spacecrafthingedRigidBodyTheta1').getState()\")\n    theta2Out = unitTestSim.GetLogVariableData(\"spacecraftBody.dynManager.getStateObject('spacecrafthingedRigidBodyTheta2').getState()\")\n\n    # Developing the lagrangian result\n    # Define initial values\n    spacecraft = spacecraftClass()\n    spacecraft.hub.mass = scObject.primaryCentralSpacecraft.hub.mHub\n    spacecraft.hub.Inertia = scObject.primaryCentralSpacecraft.hub.IHubPntBc_B[2][2]\n    # Define variables for panel1\n    spacecraft.panel1.mass = unitTestSim.panel1.mass\n    spacecraft.panel1.Inertia = unitTestSim.panel1.IPntS_S[1][1]\n    spacecraft.panel1.Rhinge = numpy.linalg.norm(numpy.asarray(unitTestSim.panel1.r_HB_B))\n    spacecraft.panel1.beta = numpy.arctan2(unitTestSim.panel1.r_HB_B[1][0],unitTestSim.panel1.r_HB_B[0][0])\n    spacecraft.panel1.thetaH = 0.0\n    spacecraft.panel1.d = unitTestSim.panel1.d\n    spacecraft.panel1.k = unitTestSim.panel1.k\n    spacecraft.panel1.c = unitTestSim.panel1.c\n    # Define variables for panel2\n    spacecraft.panel2.mass = unitTestSim.panel2.mass\n    spacecraft.panel2.Inertia = unitTestSim.panel2.IPntS_S[1][1]\n    spacecraft.panel2.Rhinge = numpy.linalg.norm(numpy.asarray(unitTestSim.panel2.r_HB_B))\n    spacecraft.panel2.beta = numpy.arctan2(unitTestSim.panel2.r_HB_B[1][0],unitTestSim.panel2.r_HB_B[0][0])\n    spacecraft.panel2.thetaH = numpy.pi\n    spacecraft.panel2.d = unitTestSim.panel2.d\n    spacecraft.panel2.k = unitTestSim.panel2.k\n    spacecraft.panel2.c = unitTestSim.panel2.c\n    # Define body force and torque\n    spacecraft.xThrust_B = 0.0\n    spacecraft.yThrust_B = extFTObject.extForce_B[1][0]\n    spacecraft.Torque = 0.0\n\n    # Define initial conditions of the sim\n    time = numpy.arange(0.0,stopTime + stepSize,stepSize).flatten()\n    x0 = numpy.zeros(10)\n    x0[3] = unitTestSim.panel1.thetaInit\n    x0[4] = -unitTestSim.panel2.thetaInit\n\n    X = numpy.zeros((len(x0),len(time)))\n    X[:,0] = x0\n    for j in range (1,(len(time))):\n        X[:, j] = rk4(planarFlexFunction, X[:, j-1], stepSize, time[j-1], spacecraft)\n\n    # Find steady state value\n    variablesIn = boxAndWingParameters()\n    variablesIn.k = spacecraft.panel1.k\n    variablesIn.d = spacecraft.panel1.d\n    variablesIn.F = spacecraft.yThrust_B\n    variablesIn.mSC = spacecraft.hub.mass + spacecraft.panel1.mass + spacecraft.panel2.mass\n    variablesIn.mSP = spacecraft.panel1.mass\n    thetaSSGuess = -0.01\n    tolerance = 1e-10\n    thetaSS = newtonRapshon(boxAndWingsFandFPrime,thetaSSGuess,tolerance,variablesIn)\n\n    plt.close(\"all\")\n    plt.figure()\n    plt.clf()\n    plt.plot(time, X[3,:],'-b',label = \"Lagrangian\")\n    plt.plot(theta1Out[:,0]*1e-9, theta1Out[:,1],'-r',label = \"Basilisk\")\n    plt.plot(theta1Out[-1,0]*1e-9, thetaSS,'ok',label = \"BOE Calculation\")\n    plt.xlabel('time (s)')\n    plt.ylabel('theta 1 (rad)')\n    plt.legend(loc ='upper right',numpoints = 1)\n    PlotName = \"BOECalculationForSteadyStateTheta1DeflectionVsSimulation\"\n    PlotTitle = \"BOE Calculation for Steady State Theta 1 Deflection vs Simulation\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(time, -X[4,:],'-b',label = \"Lagrangian\")\n    plt.plot(theta2Out[:,0]*1e-9, theta2Out[:,1],'-r',label = \"Basilisk\")\n    plt.plot(theta2Out[-1,0]*1e-9, thetaSS,'ok',label = \"BOE Calculation\")\n    plt.xlabel('time (s)')\n    plt.ylabel('theta 2 (rad)')\n    plt.legend(loc ='upper right',numpoints = 1)\n    PlotName = \"BOECalculationForSteadyStateTheta2DeflectionVsSimulation\"\n    PlotTitle = \"BOE Calculation for Steady State Theta 2 Deflection vs Simulation\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n    \n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n\n    accuracy = 1e-6\n    if abs(theta1Out[-1,1] - thetaSS) > accuracy:\n        testFailCount += 1\n        testMessages.append(\"FAILED: Hinged Rigid Body integrated steady state test failed theta 1 comparison \")\n\n    if abs(theta2Out[-1,1] - thetaSS) > accuracy:\n        testFailCount += 1\n        testMessages.append(\"FAILED: Hinged Rigid Body integrated steady state test failed theta 2 comparison \")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Hinged Rigid Body steady state Integrated test\")\n\n    assert testFailCount < 1, testMessages\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def hingedRigidBodyFrequencyAmp(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraftSystem.SpacecraftSystem()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    stepSize = 0.1\n    testProcessRate = macros.sec2nano(stepSize)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    unitTestSim.panel1 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n    unitTestSim.panel2 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n\n    # Define Variable for panel 1\n    unitTestSim.panel1.mass = 100.0\n    unitTestSim.panel1.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel1.d = 1.5\n    unitTestSim.panel1.k = 300.0\n    unitTestSim.panel1.c = 0.0\n    unitTestSim.panel1.r_HB_B = [[0.5], [1.0], [0.0]]\n    unitTestSim.panel1.dcm_HB = [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]\n    unitTestSim.panel1.thetaInit = 0.0\n    unitTestSim.panel1.thetaDotInit = 0.0\n\n    # Define Variables for panel 2\n    unitTestSim.panel2.mass = 100.0\n    unitTestSim.panel2.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel2.d = 1.5\n    unitTestSim.panel2.k = 300.0\n    unitTestSim.panel2.c = 0.0\n    unitTestSim.panel2.r_HB_B = [[-0.5], [1.0], [0.0]]\n    unitTestSim.panel2.dcm_HB = [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]\n    unitTestSim.panel2.thetaInit = 0.0\n    unitTestSim.panel2.thetaDotInit = 0.0\n\n    # Add panels to spaceCraft\n    scObject.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel1)\n    scObject.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel2)\n\n    # Add external force and torque\n    extFTObject = extForceTorque.ExtForceTorque()\n    extFTObject.ModelTag = \"externalDisturbance\"\n    extFTObject.extTorquePntB_B = [[0], [0], [0]]\n    force = 1\n    extFTObject.extForce_B = [[0], [force], [0]]\n    scObject.primaryCentralSpacecraft.addDynamicEffector(extFTObject)\n    unitTestSim.AddModelToTask(unitTaskName, extFTObject)\n\n    # Define mass properties of the rigid part of the spacecraft\n    scObject.primaryCentralSpacecraft.hub.mHub = 750.0\n    scObject.primaryCentralSpacecraft.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    # Set the initial values for the states\n    scObject.primaryCentralSpacecraft.hub.r_CN_NInit = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.v_CN_NInit = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.omega_BN_BInit = [[0.0], [0.0], [0.0]]\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel1)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel2)\n\n    dataLog = scObject.primaryCentralSpacecraft.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.AddVariableForLogging(\"spacecraftBody.dynManager.getStateObject('spacecrafthingedRigidBodyTheta1').getState()\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(\"spacecraftBody.dynManager.getStateObject('spacecrafthingedRigidBodyTheta2').getState()\", testProcessRate, 0, 0, 'double')\n\n    stopTime = 58\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime/2))\n    unitTestSim.ExecuteSimulation()\n\n    extFTObject.extTorquePntB_B = [0.0, 0.0, 0.0]\n    extFTObject.extForce_B = [0.0, 0.0, 0.0]\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    rOut_BN_N = dataLog.r_BN_N\n    sigmaOut_BN = dataLog.sigma_BN\n    thetaOut = 4.0*numpy.arctan(sigmaOut_BN[:,2])\n\n    theta1Out = unitTestSim.GetLogVariableData(\"spacecraftBody.dynManager.getStateObject('spacecrafthingedRigidBodyTheta1').getState()\")\n    theta2Out = unitTestSim.GetLogVariableData(\"spacecraftBody.dynManager.getStateObject('spacecrafthingedRigidBodyTheta2').getState()\")\n\n    # Developing the lagrangian result\n    # Define initial values\n    spacecraft = spacecraftClass()\n    spacecraft.hub.mass = scObject.primaryCentralSpacecraft.hub.mHub\n    spacecraft.hub.Inertia = scObject.primaryCentralSpacecraft.hub.IHubPntBc_B[2][2]\n    # Define variables for panel1\n    spacecraft.panel1.mass = unitTestSim.panel1.mass\n    spacecraft.panel1.Inertia = unitTestSim.panel1.IPntS_S[1][1]\n    spacecraft.panel1.Rhinge = numpy.linalg.norm(numpy.asarray(unitTestSim.panel1.r_HB_B))\n    spacecraft.panel1.beta = numpy.arctan2(unitTestSim.panel1.r_HB_B[1][0],unitTestSim.panel1.r_HB_B[0][0])\n    spacecraft.panel1.thetaH = 0.0\n    spacecraft.panel1.d = unitTestSim.panel1.d\n    spacecraft.panel1.k = unitTestSim.panel1.k\n    spacecraft.panel1.c = unitTestSim.panel1.c\n    # Define variables for panel2\n    spacecraft.panel2.mass = unitTestSim.panel2.mass\n    spacecraft.panel2.Inertia = unitTestSim.panel2.IPntS_S[1][1]\n    spacecraft.panel2.Rhinge = numpy.linalg.norm(numpy.asarray(unitTestSim.panel2.r_HB_B))\n    spacecraft.panel2.beta = numpy.arctan2(unitTestSim.panel2.r_HB_B[1][0],unitTestSim.panel2.r_HB_B[0][0])\n    spacecraft.panel2.thetaH = numpy.pi\n    spacecraft.panel2.d = unitTestSim.panel2.d\n    spacecraft.panel2.k = unitTestSim.panel2.k\n    spacecraft.panel2.c = unitTestSim.panel2.c\n    # Define body force and torque\n\n    # Define initial conditions of the sim\n    check = 0\n    time = numpy.arange(0.0,stopTime + stepSize,stepSize).flatten()\n    x0 = numpy.zeros(10)\n    x0[3] = unitTestSim.panel1.thetaInit\n    x0[4] = -unitTestSim.panel2.thetaInit\n\n    X = numpy.zeros((len(x0),len(time)))\n    X[:,0] = x0\n    for j in range (1,(len(time))):\n        if time[j-1] < stopTime/2:\n            spacecraft.xThrust_B = 0.0\n            spacecraft.yThrust_B = force\n            spacecraft.Torque = 0.0\n        else:\n            spacecraft.xThrust_B = 0.0\n            spacecraft.yThrust_B = 0.0\n            spacecraft.Torque = 0.0\n        X[:, j] = rk4(planarFlexFunction, X[:, j-1], stepSize, time[j-1], spacecraft)\n        if check == 0 and X[3,j] < X[3,j-1]:\n            check = 1\n        if check ==1 and X[3,j] > X[3,j-1]:\n            check = 2\n        if check == 2 and X[3,j] < X[3,j-1]:\n            check = 3\n            indexFirstPeak = j-1\n        if check == 3 and X[3,j] > X[3,j-1]:\n            check = 4\n        if check==4 and X[3,j] < X[3,j-1]:\n            check = 5\n            indexSecondPeak = j-1\n        if check == 5 and X[3,j] > X[3,j-1]:\n            check = 6\n        if check==6 and X[3,j] < X[3,j-1]:\n            check = 7\n            indexThirdPeak = j-1\n\n    # Find the period\n    T1 = time[indexSecondPeak] - time[indexFirstPeak]\n    T2 = time[indexThirdPeak] - time[indexSecondPeak]\n    freqHz = 1/((T1 + T2)/2)\n    matrixM = numpy.zeros([6,6])\n    matrixM[0,0] = 1.0\n    matrixM[1,1] = spacecraft.hub.mass + spacecraft.panel1.mass + spacecraft.panel2.mass\n    matrixM[2,2] = 1.0\n    matrixM[3,3] = spacecraft.panel1.Inertia + spacecraft.panel1.mass*spacecraft.panel1.d**2\n    matrixM[4,4] = 1.0\n    matrixM[5,5] = spacecraft.panel2.Inertia + spacecraft.panel2.mass*spacecraft.panel2.d**2\n    # Define off diagonal terms\n    matrixM[1,3] = spacecraft.panel1.mass*spacecraft.panel1.d\n    matrixM[1,5] = spacecraft.panel2.mass*spacecraft.panel2.d\n    matrixM[3,1] = spacecraft.panel1.mass*spacecraft.panel1.d\n    matrixM[5,1] = spacecraft.panel2.mass*spacecraft.panel2.d\n    # Define A matrix\n    matrixA = numpy.zeros([6,6])\n    matrixA[0,1] = 1.0\n    matrixA[2,3] = 1.0\n    matrixA[4,5] = 1.0\n    matrixA[3,2] = -spacecraft.panel1.k\n    matrixA[3,3] = -spacecraft.panel1.c\n    matrixA[5,4] = -spacecraft.panel2.k\n    matrixA[5,5] = -spacecraft.panel2.c\n    # Define Atilde\n    matrixAtilde = numpy.dot(numpy.linalg.inv(matrixM),matrixA)\n    eigenValues = numpy.linalg.eigvals(matrixAtilde)\n    omegaAnalytical = numpy.imag(eigenValues[2])\n    omegaAnalyticalHz = omegaAnalytical/(2*numpy.pi)\n    diffFreq = (freqHz-omegaAnalyticalHz)/omegaAnalyticalHz\n\n    # Find thetaMax - the max deflection while the force is being applied\n    variablesIn = boxAndWingParameters()\n    variablesIn.k = spacecraft.panel1.k\n    variablesIn.d = spacecraft.panel1.d\n    variablesIn.F = force\n    variablesIn.mSC = spacecraft.hub.mass + spacecraft.panel1.mass + spacecraft.panel2.mass\n    variablesIn.mSP = spacecraft.panel1.mass\n    thetaSSGuess = -0.01\n    tolerance = 1e-14\n    thetaSS = newtonRapshon(boxAndWingsFandFPrime,thetaSSGuess,tolerance,variablesIn)\n    thetaMax = 2*thetaSS\n    # Pull thetaMax from the sim\n    thetaMaxSim = min(X[3,:])\n    diffThetaMax = abs((thetaMax-thetaMaxSim)/thetaMax)\n\n    # Find energy to find thetaMax2 - the max deflection while the force is not being applied\n    massTotal = spacecraft.hub.mass + 2.0*spacecraft.panel1.mass\n\n    yHubDotOff = X[6, int(stopTime/2/stepSize)]\n    theta1Off = X[3, int(stopTime/2/stepSize)]\n    theta1OffDot = X[8, int(stopTime/2/stepSize)]\n    Rsp1DotOff = numpy.array([-spacecraft.panel1.d*theta1OffDot*numpy.sin(theta1Off), yHubDotOff + spacecraft.panel1.d*theta1OffDot*numpy.cos(theta1Off)])\n    vYCMOff =  1.0/massTotal*(spacecraft.hub.mass*yHubDotOff + 2*spacecraft.panel1.mass*Rsp1DotOff[1])\n    EnergyOff = 0.5*spacecraft.hub.mass*yHubDotOff**2 + 2*(0.5*spacecraft.panel1.mass*numpy.dot(Rsp1DotOff,Rsp1DotOff) + 0.5*spacecraft.panel1.Inertia*theta1OffDot**2 + 0.5*spacecraft.panel1.k*theta1Off**2)\n    EnergyFinalWithoutSpring = 0.5*massTotal*vYCMOff**2\n    EnergyInSpringFinal = EnergyOff - EnergyFinalWithoutSpring\n    thetaMax2 = numpy.sqrt(EnergyInSpringFinal/spacecraft.panel1.k)\n    # Pull thetaMax2 from the sim\n    thetaMax2Sim = max(X[3,:])\n    diffTheta2Max = abs((thetaMax2-thetaMax2Sim)/thetaMax2)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(time, X[3,:],'-b',label = \"Lagrangian\")\n    plt.plot(theta1Out[:,0]*1e-9, theta1Out[:,1],'-r',label = \"Basilisk\")\n    plt.plot([theta1Out[0,0]*1e-9, theta1Out[-1,0]*1e-9], [2*thetaSS, 2*thetaSS],'-g',label = \"Theta Max\")\n    plt.plot([theta1Out[0,0]*1e-9, theta1Out[-1,0]*1e-9], [thetaMax2, thetaMax2],'-k',label = \"Theta Max 2\")\n    plt.xlabel('time (s)')\n    plt.ylabel('theta (rad)')\n    plt.legend(loc ='upper left',numpoints = 1)\n    PlotName = \"MaxThetaWhileForcing\"\n    PlotTitle = \"Max Theta While Forcing\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    # Write Results to tex snippet\n    snippetName = \"FrequencyResults\"\n    texSnippet =  str(omegaAnalyticalHz) + \" & \" + str(freqHz) +  \" & \" + str(diffFreq)\n    unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)\n    snippetName = \"Theta1Results\"\n    texSnippet =  str(thetaMax) + \" & \" + str(thetaMaxSim) +  \" & \" + str(diffThetaMax)\n    unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)\n    snippetName = \"Theta2Results\"\n    texSnippet =  str(thetaMax2) + \" & \" + str(thetaMax2Sim) +  \" & \" + str(diffTheta2Max)\n    unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)\n\n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n    accuracy = 5e-3\n    if abs((freqHz - omegaAnalyticalHz)/omegaAnalyticalHz) > accuracy:\n        testFailCount += 1\n        testMessages.append(\"FAILED: Hinged Rigid Body integrated theta max test failed frequency comparison \")\n\n    if abs((thetaMax - thetaMaxSim)/thetaMax) > accuracy:\n        testFailCount += 1\n        testMessages.append(\"FAILED: Hinged Rigid Body integrated theta max test failed max comparison \")\n\n    if abs((thetaMax2 - thetaMax2Sim)/thetaMax2) > accuracy:\n        testFailCount += 1\n        testMessages.append(\"FAILED: Hinged Rigid Body integrated theta max test failed max 2 comparison \")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"Hinged Rigid Body Frequency and Amplitude Integrated test\")\n\n    assert testFailCount < 1, testMessages\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def hingedRigidBodyMotorTorque(show_plots, useScPlus):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    if useScPlus:\n        scObject = spacecraft.Spacecraft()\n        scObject.ModelTag = \"spacecraftBody\"\n    else:\n        scObject = spacecraftSystem.SpacecraftSystem()\n        scObject.ModelTag = \"spacecraftBody\"\n        scObject.primaryCentralSpacecraft.spacecraftName = scObject.ModelTag\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.01)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    unitTestSim.panel1 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n    unitTestSim.panel2 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n\n    # Define Variable for panel 1\n    unitTestSim.panel1.mass = 100.0\n    unitTestSim.panel1.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel1.d = 1.5\n    unitTestSim.panel1.k = 0.0\n    unitTestSim.panel1.c = 0.0\n    unitTestSim.panel1.r_HB_B = [[0.5], [0.0], [1.0]]\n    unitTestSim.panel1.dcm_HB = [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel1.thetaInit = 0 * numpy.pi / 180.0\n    unitTestSim.panel1.thetaDotInit = 0.0\n    unitTestSim.panel1.ModelTag = \"panel1\"\n\n    # set a fixed motor torque message\n    motorMsgData = messaging.ArrayMotorTorqueMsgPayload()\n    motorMsgData.motorTorque = [2.0]\n    motorMsg = messaging.ArrayMotorTorqueMsg().write(motorMsgData)\n    unitTestSim.panel1.motorTorqueInMsg.subscribeTo(motorMsg)\n\n    # Define Variables for panel 2\n    unitTestSim.panel2.mass = 100.0\n    unitTestSim.panel2.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel2.d = 1.5\n    unitTestSim.panel2.k = 0.0\n    unitTestSim.panel2.c = 0.0\n    unitTestSim.panel2.r_HB_B = [[-0.5], [0.0], [1.0]]\n    unitTestSim.panel2.dcm_HB = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    unitTestSim.panel2.thetaInit = 0.0 * macros.D2R\n    unitTestSim.panel2.thetaDotInit = 0.0\n    unitTestSim.panel2.ModelTag = \"panel2\"\n\n    # Add panels to spaceCraft\n    scObjectPrimary = scObject\n    if not useScPlus:\n        scObjectPrimary = scObject.primaryCentralSpacecraft\n\n    scObjectPrimary.addStateEffector(unitTestSim.panel1)\n    scObjectPrimary.addStateEffector(unitTestSim.panel2)\n\n    # Define mass properties of the rigid part of the spacecraft\n    scObjectPrimary.hub.mHub = 750.0\n    scObjectPrimary.hub.r_BcB_B = [[0.0], [0.0], [1.0]]\n    scObjectPrimary.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    # Set the initial values for the states\n    scObjectPrimary.hub.r_CN_NInit = [[0.0], [0.0], [0.0]]\n    scObjectPrimary.hub.v_CN_NInit = [[0.0], [0.0], [0.0]]\n    scObjectPrimary.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObjectPrimary.hub.omega_BN_BInit = [[0.0], [0.0], [0.0]]\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel1)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel2)\n\n    if not useScPlus:\n        scStateMsg = scObject.primaryCentralSpacecraft.scStateOutMsg\n    else:\n        scStateMsg = scObject.scStateOutMsg\n    dataLog = scStateMsg.recorder()\n    dataPanel1 = unitTestSim.panel1.hingedRigidBodyOutMsg.recorder()\n    dataPanel2 = unitTestSim.panel2.hingedRigidBodyOutMsg.recorder()\n    dataPanel1Log = unitTestSim.panel1.hingedRigidBodyConfigLogOutMsg.recorder()\n    dataPanel2Log = unitTestSim.panel2.hingedRigidBodyConfigLogOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n    unitTestSim.AddModelToTask(unitTaskName, dataPanel1)\n    unitTestSim.AddModelToTask(unitTaskName, dataPanel2)\n    unitTestSim.AddModelToTask(unitTaskName, dataPanel1Log)\n    unitTestSim.AddModelToTask(unitTaskName, dataPanel2Log)\n\n    unitTestSim.InitializeSimulation()\n\n    variableLogTag = scObject.ModelTag\n    if not useScPlus:\n        variableLogTag += \".primaryCentralSpacecraft\"\n\n    unitTestSim.AddVariableForLogging(variableLogTag + \".totRotAngMomPntC_N\",\n                                      testProcessRate, 0, 2, 'double')\n\n    stopTime = 10.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    rOut_CN_N = dataLog.r_CN_N\n    vOut_CN_N = dataLog.v_CN_N\n    sigma_BN = dataLog.sigma_BN\n    theta1 = dataPanel1.theta\n    theta2 = dataPanel2.theta\n\n    rB1N = dataPanel1Log.r_BN_N[0]\n    vB1N = dataPanel1Log.v_BN_N[0]\n    sB1N = dataPanel1Log.sigma_BN[0]\n    oB1N = dataPanel1Log.omega_BN_B[0]\n    rB2N = dataPanel2Log.r_BN_N[0]\n    vB2N = dataPanel2Log.v_BN_N[0]\n    sB2N = dataPanel2Log.sigma_BN[0]\n    oB2N = dataPanel2Log.omega_BN_B[0]\n\n    rotAngMom_N = unitTestSim.GetLogVariableData(\n        variableLogTag + \".totRotAngMomPntC_N\")\n\n    # Get the last sigma and position\n    dataPos = [rOut_CN_N[-1]]\n\n    truePos = [[0., 0., 0.]]\n\n    initialRotAngMom_N = [[rotAngMom_N[0, 1], rotAngMom_N[0, 2], rotAngMom_N[0, 3]]]\n\n    finalRotAngMom = [rotAngMom_N[-1]]\n\n    plt.close(\"all\")\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom_N[:, 0] * 1e-9, (rotAngMom_N[:, 1] - rotAngMom_N[0, 1]) ,\n             rotAngMom_N[:, 0] * 1e-9, (rotAngMom_N[:, 2] - rotAngMom_N[0, 2]) ,\n             rotAngMom_N[:, 0] * 1e-9, (rotAngMom_N[:, 3] - rotAngMom_N[0, 3]) )\n    plt.xlabel('time (s)')\n    plt.ylabel('Ang. Momentum Difference')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(dataLog.times() * 1e-9, vOut_CN_N[:, 0],\n             dataLog.times() * 1e-9, vOut_CN_N[:, 1],\n             dataLog.times() * 1e-9, vOut_CN_N[:, 2])\n    plt.xlabel('time (s)')\n    plt.ylabel('m/s')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(dataLog.times() * macros.NANO2SEC, sigma_BN[:, 0],\n             color=unitTestSupport.getLineColor(0, 3),\n             label=r'$\\sigma_{1}$')\n    plt.plot(dataLog.times() * macros.NANO2SEC, sigma_BN[:, 1],\n             color=unitTestSupport.getLineColor(1, 3),\n             label=r'$\\sigma_{2}$')\n    plt.plot(dataLog.times() * macros.NANO2SEC, sigma_BN[:, 2],\n             color=unitTestSupport.getLineColor(2, 3),\n             label=r'$\\sigma_{3}$')\n    plt.legend(loc='lower right')\n    plt.xlabel('time (s)')\n    plt.ylabel(r'MRP $\\sigma_{B/N}$')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(dataPanel1.times() * macros.NANO2SEC, theta1*macros.R2D,\n             color=unitTestSupport.getLineColor(0, 3),\n             label=r'$\\theta_{1}$')\n    plt.plot(dataPanel2.times() * macros.NANO2SEC, theta2*macros.R2D,\n             color=unitTestSupport.getLineColor(1, 3),\n             label=r'$\\theta_{2}$')\n    plt.legend(loc='lower right')\n    plt.xlabel('time (s)')\n    plt.ylabel('Hinge Angles [deg]')\n\n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n    accuracy = 1e-10\n    for i in range(0, len(truePos)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataPos[i], truePos[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED:  Hinged Rigid Body integrated test failed position test\")\n\n    finalRotAngMom = numpy.delete(finalRotAngMom, 0, axis=1)  # remove time column\n    for i in range(0, len(initialRotAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(finalRotAngMom[i], initialRotAngMom_N[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\n                \"FAILED: Hinged Rigid Body integrated test failed rotational angular momentum unit test\")\n\n    # check config log messages\n    if not unitTestSupport.isArrayEqual(rB1N, [2.0, 0, 0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Hinged Rigid Body integrated test failed panel 1 r_BN_N config log test\")\n    if not unitTestSupport.isArrayEqual(vB1N, [0.0, 0, 0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Hinged Rigid Body integrated test failed panel 1 v_BN_N config log test\")\n    if not unitTestSupport.isArrayEqual(sB1N, [0.0, 0, 1.0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Hinged Rigid Body integrated test failed panel 1 sigma_BN config log test\")\n    if not unitTestSupport.isArrayEqual(oB1N, [0.0, 0, 0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Hinged Rigid Body integrated test failed panel 1 omega_BN_B config log test\")\n    if not unitTestSupport.isArrayEqual(rB2N, [-2.0, 0, 0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Hinged Rigid Body integrated test failed panel 2 r_BN_N config log test\")\n    if not unitTestSupport.isArrayEqual(vB2N, [0.0, 0, 0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Hinged Rigid Body integrated test failed panel 2 v_BN_N config log test\")\n    if not unitTestSupport.isArrayEqual(sB2N, [0.0, 0, 0.0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Hinged Rigid Body integrated test failed panel 2 sigma_BN config log test\")\n    if not unitTestSupport.isArrayEqual(oB2N, [0.0, 0, 0], 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  Hinged Rigid Body integrated test failed panel 2 omega_BN_B config log test\")\n\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Hinged Rigid Body integrated test with motor torques\")\n\n    assert testFailCount < 1, testMessages\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def hingedRigidBodyLagrangVsBasilisk(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraftSystem.SpacecraftSystem()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    stepSize = 0.1\n    testProcessRate = macros.sec2nano(stepSize)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    unitTestSim.panel1 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n    unitTestSim.panel2 = hingedRigidBodyStateEffector.HingedRigidBodyStateEffector()\n\n    # Define Variable for panel 1\n    unitTestSim.panel1.mass = 100.0\n    unitTestSim.panel1.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel1.d = 1.5\n    unitTestSim.panel1.k = 5000.0\n    unitTestSim.panel1.c = 75\n    unitTestSim.panel1.r_HB_B = [[0.5], [1.0], [0.0]]\n    unitTestSim.panel1.dcm_HB = [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]\n    unitTestSim.panel1.thetaInit = 0.0\n    unitTestSim.panel1.thetaDotInit = 0.0\n\n    # Define Variables for panel 2\n    unitTestSim.panel2.mass = 100.0\n    unitTestSim.panel2.IPntS_S = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    unitTestSim.panel2.d = 1.5\n    unitTestSim.panel2.k = 5000.0\n    unitTestSim.panel2.c = 75\n    unitTestSim.panel2.r_HB_B = [[-0.5], [1.0], [0.0]]\n    unitTestSim.panel2.dcm_HB = [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]\n    unitTestSim.panel2.thetaInit = 0.0\n    unitTestSim.panel2.thetaDotInit = 0.0\n\n    # Add panels to spaceCraft\n    scObject.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel1)\n    scObject.primaryCentralSpacecraft.addStateEffector(unitTestSim.panel2)\n\n    # Define force and torque\n    momentArm1_B = numpy.array([0.05, 0.0, 0.0])\n    force1_B = numpy.array([0.2, 0.7, 0.0])\n    torque1_B = numpy.cross(momentArm1_B,force1_B)\n    momentArm2_B = numpy.array([-0.03, 0.0, 0.0])\n    force2_B = numpy.array([0.0, 1.0, 0.0])\n    torque2_B = numpy.cross(momentArm2_B,force2_B)\n\n    # Add external force and torque\n    extFTObject = extForceTorque.ExtForceTorque()\n    extFTObject.ModelTag = \"externalDisturbance\"\n    extFTObject.extForce_B = [[force1_B[0]], [force1_B[1]], [force1_B[2]]]\n    extFTObject.extTorquePntB_B = [[torque1_B[0]], [torque1_B[1]], [torque1_B[2]]]\n    scObject.primaryCentralSpacecraft.addDynamicEffector(extFTObject)\n    unitTestSim.AddModelToTask(unitTaskName, extFTObject)\n\n    # Define mass properties of the rigid part of the spacecraft\n    scObject.primaryCentralSpacecraft.hub.mHub = 750.0\n    scObject.primaryCentralSpacecraft.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    # Set the initial values for the states\n    scObject.primaryCentralSpacecraft.hub.r_CN_NInit = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.v_CN_NInit = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.primaryCentralSpacecraft.hub.omega_BN_BInit = [[0.0], [0.0], [0.0]]\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel1)\n    unitTestSim.AddModelToTask(unitTaskName, unitTestSim.panel2)\n\n    dataLog = scObject.primaryCentralSpacecraft.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.AddVariableForLogging(\"spacecraftBody.dynManager.getStateObject('spacecrafthingedRigidBodyTheta1').getState()\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(\"spacecraftBody.dynManager.getStateObject('spacecrafthingedRigidBodyTheta2').getState()\", testProcessRate, 0, 0, 'double')\n\n    # Define times that the new forces will be applies\n    force1OffTime = 5.0\n    force2OnTime = 11.0\n    force2OffTime = 18.0\n    stopTime = 20.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(force1OffTime))\n    unitTestSim.ExecuteSimulation()\n\n    # Turn force1 off\n    extFTObject.extForce_B = [[0.0], [0.0], [0.0]]\n    extFTObject.extTorquePntB_B = [[0.0], [0.0], [0.0]]\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(force2OnTime))\n    unitTestSim.ExecuteSimulation()\n\n    # Turn force2 on\n    extFTObject.extForce_B = [[force2_B[0]], [force2_B[1]], [force2_B[2]]]\n    extFTObject.extTorquePntB_B = [[torque2_B[0]], [torque2_B[1]], [torque2_B[2]]]\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(force2OffTime))\n    unitTestSim.ExecuteSimulation()\n\n    # Turn force2 off and finish sim\n    extFTObject.extForce_B = [[0.0], [0.0], [0.0]]\n    extFTObject.extTorquePntB_B = [[0.0], [0.0], [0.0]]\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    theta1Out = unitTestSim.GetLogVariableData(\"spacecraftBody.dynManager.getStateObject('spacecrafthingedRigidBodyTheta1').getState()\")\n    theta2Out = unitTestSim.GetLogVariableData(\"spacecraftBody.dynManager.getStateObject('spacecrafthingedRigidBodyTheta2').getState()\")\n\n    rOut_BN_N = dataLog.r_BN_N\n    sigmaOut_BN = dataLog.sigma_BN\n    thetaOut = 4.0*numpy.arctan(sigmaOut_BN[:,2])\n\n    # Developing the lagrangian result\n    # Define initial values\n    spacecraft = spacecraftClass()\n    spacecraft.hub.mass = scObject.primaryCentralSpacecraft.hub.mHub\n    spacecraft.hub.Inertia = scObject.primaryCentralSpacecraft.hub.IHubPntBc_B[2][2]\n    # Define variables for panel1\n    spacecraft.panel1.mass = unitTestSim.panel1.mass\n    spacecraft.panel1.Inertia = unitTestSim.panel1.IPntS_S[1][1]\n    spacecraft.panel1.Rhinge = numpy.linalg.norm(numpy.asarray(unitTestSim.panel1.r_HB_B))\n    spacecraft.panel1.beta = numpy.arctan2(unitTestSim.panel1.r_HB_B[1][0],unitTestSim.panel1.r_HB_B[0][0])\n    spacecraft.panel1.thetaH = 0.0\n    spacecraft.panel1.d = unitTestSim.panel1.d\n    spacecraft.panel1.k = unitTestSim.panel1.k\n    spacecraft.panel1.c = unitTestSim.panel1.c\n    # Define variables for panel2\n    spacecraft.panel2.mass = unitTestSim.panel2.mass\n    spacecraft.panel2.Inertia = unitTestSim.panel2.IPntS_S[1][1]\n    spacecraft.panel2.Rhinge = numpy.linalg.norm(numpy.asarray(unitTestSim.panel2.r_HB_B))\n    spacecraft.panel2.beta = numpy.arctan2(unitTestSim.panel2.r_HB_B[1][0],unitTestSim.panel2.r_HB_B[0][0])\n    spacecraft.panel2.thetaH = numpy.pi\n    spacecraft.panel2.d = unitTestSim.panel2.d\n    spacecraft.panel2.k = unitTestSim.panel2.k\n    spacecraft.panel2.c = unitTestSim.panel2.c\n\n    # Define initial conditions of the sim\n    time = numpy.arange(0.0,stopTime + stepSize,stepSize).flatten()\n    x0 = numpy.zeros(10)\n    x0[3] = unitTestSim.panel1.thetaInit\n    x0[4] = -unitTestSim.panel2.thetaInit\n\n    X = numpy.zeros((len(x0),len(time)))\n    X[:,0] = x0\n    for j in range (1,(len(time))):\n        if time[j-1] < force1OffTime:\n            spacecraft.xThrust_B = force1_B[0]\n            spacecraft.yThrust_B = force1_B[1]\n            spacecraft.Torque = torque1_B[2]\n        elif time[j-1] >= force2OnTime and time[j-1] < force2OffTime:\n            spacecraft.xThrust_B = force2_B[0]\n            spacecraft.yThrust_B = force2_B[1]\n            spacecraft.Torque = torque2_B[2]\n        else:\n            spacecraft.xThrust_B = 0.0\n            spacecraft.yThrust_B = 0.0\n            spacecraft.Torque = 0.0\n        X[:, j] = rk4(planarFlexFunction, X[:, j-1], stepSize, time[j-1], spacecraft)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(time, X[0,:],'-b',label = \"Lagrangian\")\n    plt.plot(dataLog.times()*1e-9, (rOut_BN_N[:,0]-rOut_BN_N[:,0]),'-r',label = \"Basilisk\")\n    plt.plot([time[25], time[75], time[125], time[175]], [X[0,25], X[0,75], X[0,125], X[0,175],],'ok',label = \"Test Points\")\n    plt.xlabel('time (s)')\n    plt.ylabel('x position (m)')\n    plt.legend(loc ='upper left',numpoints = 1)\n    PlotName = \"XPositionLagrangianVsBasilisk\"\n    PlotTitle = \"X Position Lagrangian Vs Basilisk\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(time, X[1,:],'-b',label = \"Lagrangian\")\n    plt.plot(dataLog.times()*1e-9, (rOut_BN_N[:,1]-rOut_BN_N[:,1]),'r',label = \"Basilisk\")\n    plt.plot([time[25], time[75], time[125], time[175]], [X[1,25], X[1,75], X[1,125], X[1,175],],'ok',label = \"Test Points\")\n    plt.xlabel('time (s)')\n    plt.ylabel('y position (m)')\n    plt.legend(loc ='upper left',numpoints = 1)\n    PlotName = \"YPositionLagrangianVsBasilisk\"\n    PlotTitle = \"Y Position Lagrangian Vs Basilisk\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(time, X[2,:],'-b',label = \"Lagrangian\")\n    plt.plot(dataLog.times()*1e-9, thetaOut,'-r',label = \"Basilisk\")\n    plt.plot([time[25], time[75], time[125], time[175]], [X[2,25], X[2,75], X[2,125], X[2,175],],'ok',label = \"Test Points\")\n    plt.xlabel('time (s)')\n    plt.ylabel('theta (rad)')\n    plt.legend(loc ='upper left',numpoints = 1)\n    PlotName = \"ThetaLagrangianVsBasilisk\"\n    PlotTitle = \"Theta Lagrangian Vs Basilisk\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(time, X[3,:],'-b',label = \"Lagrangian\")\n    plt.plot(theta1Out[:,0]*1e-9, theta1Out[:,1],'-r',label = \"Basilisk\")\n    plt.plot([time[25], time[75], time[125], time[175]], [X[3,25], X[3,75], X[3,125], X[3,175],],'ok',label = \"Test Points\")\n    plt.xlabel('time (s)')\n    plt.ylabel('theta 1 (rad)')\n    plt.legend(loc ='upper left',numpoints = 1)\n    PlotName = \"Theta1LagrangianVsBasilisk\"\n    PlotTitle = \"Theta 1 Position Lagrangian Vs Basilisk\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(time, -X[4,:],'-b',label = \"Lagrangian\")\n    plt.plot(theta2Out[:,0]*1e-9, theta2Out[:,1],'-r',label = \"Basilisk\")\n    plt.plot([time[25], time[75], time[125], time[175]], [-X[4,25], -X[4,75], -X[4,125], -X[4,175],],'ok',label = \"Test Points\")\n    plt.xlabel('time (s)')\n    plt.ylabel('theta 2 (rad)')\n    plt.legend(loc ='lower left',numpoints = 1)\n    PlotName = \"Theta2LagrangianVsBasilisk\"\n    PlotTitle = \"Theta 2 Lagrangian Vs Basilisk\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n    accuracy = 1e-10\n    timeList = [25, 75, 125, 175]\n\n    for i in timeList:\n        if abs(X[0,i] - (rOut_BN_N[i,0]-rOut_BN_N[0,0])) > accuracy:\n            print(abs(X[0,i] - (rOut_BN_N[i,0]-rOut_BN_N[0,0])))\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test Lagrangian vs. Basilisk failed x position comparison \")\n        if abs(X[1,i] - (rOut_BN_N[i,1]-rOut_BN_N[0,1])) > accuracy:\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test Lagrangian vs. Basilisk failed y position comparison \")\n        if abs(X[2,i] - thetaOut[i]) > accuracy:\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test Lagrangian vs. Basilisk failed theta comparison \")\n        if abs(X[3,i] - theta1Out[i,1]) > accuracy:\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test Lagrangian vs. Basilisk failed theta 1 comparison \")\n        if abs(-X[4,i] - theta2Out[i,1]) > accuracy:\n            testFailCount += 1\n            testMessages.append(\"FAILED: Hinged Rigid Body integrated test Lagrangian vs. Basilisk failed theta 2 comparison \")\n\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Hinged Rigid Body Transient Integrated test\")\n\n    assert testFailCount < 1, testMessages\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def planarFlexFunction(x, t, variables):\n    theta = x[2]\n    theta1 = x[3]\n    theta2 = x[4]\n    xHubDot = x[5]\n    yHubDot = x[6]\n    thetaDot = x[7]\n    theta1Dot = x[8]\n    theta2Dot = x[9]\n    # Define variables for hub\n    mHub = variables.hub.mass\n    IHub = variables.hub.Inertia\n    # Define variables for panel1\n    mSP1 = variables.panel1.mass\n    ISP1 = variables.panel1.Inertia\n    Rhinge1 = variables.panel1.Rhinge\n    beta1 = variables.panel1.beta\n    thetaH1 = variables.panel1.thetaH\n    d1 = variables.panel1.d\n    k1 = variables.panel1.k\n    c1 = variables.panel1.c\n    # Define variables for panel2\n    mSP2 = variables.panel2.mass\n    ISP2 = variables.panel2.Inertia\n    Rhinge2 = variables.panel2.Rhinge\n    beta2 = variables.panel2.beta\n    thetaH2 = variables.panel2.thetaH\n    d2 = variables.panel2.d\n    k2 = variables.panel2.k\n    c2 = variables.panel2.c\n    Tx_B = variables.xThrust_B\n    Ty_B = variables.yThrust_B\n    Torque = variables.Torque\n\n    # Convert Tx_B and Ty_B to the inertial frame\n    dcm_BN = numpy.array([[numpy.cos(theta), numpy.sin(theta)],\n                          [-numpy.sin(theta), numpy.cos(theta)]])\n    Thrust_N = numpy.dot(dcm_BN.transpose(),numpy.array([[Tx_B],[Ty_B]]))\n    Tx = Thrust_N[0,0]\n    Ty = Thrust_N[1,0]\n\n    matrixA = numpy.zeros((5,5))\n    vectorB = numpy.zeros(5)\n    # Populate X Translation Equation\n    matrixA[0,0] = 1.0\n    matrixA[0,1] = 0.0\n    matrixA[0,2] = -1/(mHub + mSP1 + mSP2)*(mSP1*Rhinge1*numpy.sin(beta1 + theta) + mSP2*Rhinge2*numpy.sin(beta2 + theta) + d1*mSP1*numpy.sin(thetaH1 + theta + theta1) + d2*mSP2*numpy.sin(thetaH2 + theta + theta2))\n    matrixA[0,3] = -1/(mHub + mSP1 + mSP2)*(d1*mSP1*numpy.sin(thetaH1 + theta + theta1))\n    matrixA[0,4] = -1/(mHub + mSP1 + mSP2)*(d2*mSP2*numpy.sin(thetaH2 + theta + theta2))\n    vectorB[0] = 1/(mHub + mSP1 + mSP2)*(Tx + mSP1*Rhinge1*numpy.cos(beta1 + theta)*thetaDot**2 + mSP2*Rhinge2*numpy.cos(beta2 + theta)*thetaDot**2 + d1*mSP1*numpy.cos(thetaH1 + theta + theta1)*thetaDot**2 + d2*mSP2*numpy.cos(thetaH2 + theta + theta2)*thetaDot**2\n               + 2*d1*mSP1*numpy.cos(thetaH1 + theta + theta1)*thetaDot*theta1Dot + d1*mSP1*numpy.cos(thetaH1 + theta + theta1)*theta1Dot**2 + 2*d2*mSP2*numpy.cos(thetaH2 + theta + theta2)*thetaDot*theta2Dot\n               + d2*mSP2*numpy.cos(thetaH2 + theta + theta2)*theta2Dot**2)\n    # Populate Y Translation Equation\n    matrixA[1,0] = 0.0\n    matrixA[1,1] = 1.0\n    matrixA[1,2] = 1/(mHub + mSP1 + mSP2)*(mSP1*Rhinge1*numpy.cos(beta1 + theta) + mSP2*Rhinge2*numpy.cos(beta2 + theta) + d1*mSP1*numpy.cos(thetaH1 + theta + theta1) + d2*mSP2*numpy.cos(thetaH2 + theta + theta2))\n    matrixA[1,3] = 1/(mHub + mSP1 + mSP2)*(d1*mSP1*numpy.cos(thetaH1 + theta + theta1))\n    matrixA[1,4] = 1/(mHub + mSP1 + mSP2)*(d2*mSP2*numpy.cos(thetaH2 + theta + theta2))\n    vectorB[1] = 1/(mHub + mSP1 + mSP2)*(Ty + mSP1*Rhinge1*numpy.sin(beta1 + theta)*thetaDot**2 + mSP2*Rhinge2*numpy.sin(beta2 + theta)*thetaDot**2 + d1*mSP1*numpy.sin(thetaH1 + theta + theta1)*thetaDot**2 + d2*mSP2*numpy.sin(thetaH2 + theta + theta2)*thetaDot**2\n               + 2*d1*mSP1*numpy.sin(thetaH1 + theta + theta1)*thetaDot*theta1Dot + d1*mSP1*numpy.sin(thetaH1 + theta + theta1)*theta1Dot**2 + 2*d2*mSP2*numpy.sin(thetaH2 + theta + theta2)*thetaDot*theta2Dot\n               + d2*mSP2*numpy.sin(thetaH2 + theta + theta2)*theta2Dot**2)\n    # Populate theta Equation\n    matrixA[2,0] = -1/(IHub + ISP1 + ISP2 + d1**2*mSP1 + d2**2*mSP2 + mSP1*Rhinge1**2 + mSP2*Rhinge2**2 + 2*d1*mSP1*Rhinge1*numpy.cos(beta1 - thetaH1 - theta1) + 2*d2*mSP2*Rhinge2*numpy.cos(beta2 - thetaH2 - theta2))*(mSP1*Rhinge1*numpy.sin(beta1 + theta)\n                 + mSP2*Rhinge2*numpy.sin(beta2 + theta) + d1*mSP1*numpy.sin(thetaH1 + theta + theta1) + d2*mSP2*numpy.sin(thetaH2 + theta + theta2))\n    matrixA[2,1] = 1/(IHub + ISP1 + ISP2 + d1**2*mSP1 + d2**2*mSP2 + mSP1*Rhinge1**2 + mSP2*Rhinge2**2 + 2*d1*mSP1*Rhinge1*numpy.cos(beta1 - thetaH1 - theta1) + 2*d2*mSP2*Rhinge2*numpy.cos(beta2 - thetaH2 - theta2))*(mSP1*Rhinge1*numpy.cos(beta1 + theta)\n                 + mSP2*Rhinge2*numpy.cos(beta2 + theta) + d1*mSP1*numpy.cos(thetaH1 + theta + theta1) + d2*mSP2*numpy.cos(thetaH2 + theta + theta2))\n    matrixA[2,2] = 1.0\n    matrixA[2,3] = 1/(IHub + ISP1 + ISP2 + d1**2*mSP1 + d2**2*mSP2 + mSP1*Rhinge1**2 + mSP2*Rhinge2**2 + 2*d1*mSP1*Rhinge1*numpy.cos(beta1 - thetaH1 - theta1) + 2*d2*mSP2*Rhinge2*numpy.cos(beta2 - thetaH2 - theta2))*(ISP1\n                 + d1**2*mSP1 + d1*mSP1*Rhinge1*numpy.cos(beta1 - thetaH1 - theta1))\n    matrixA[2,4] = 1/(IHub + ISP1 + ISP2 + d1**2*mSP1 + d2**2*mSP2 + mSP1*Rhinge1**2 + mSP2*Rhinge2**2 + 2*d1*mSP1*Rhinge1*numpy.cos(beta1 - thetaH1 - theta1) + 2*d2*mSP2*Rhinge2*numpy.cos(beta2 - thetaH2 - theta2))*(ISP2\n                 + d2**2*mSP2 + d2*mSP2*Rhinge2*numpy.cos(beta2 - thetaH2 - theta2))\n    vectorB[2] = 1/(IHub + ISP1 + ISP2 + d1**2*mSP1 + d2**2*mSP2 + mSP1*Rhinge1**2 + mSP2*Rhinge2**2 + 2*d1*mSP1*Rhinge1*numpy.cos(beta1 - thetaH1 - theta1) + 2*d2*mSP2*Rhinge2*numpy.cos(beta2 - thetaH2 - theta2))*(Torque\n              - 2*d1*mSP1*Rhinge1*numpy.sin(beta1 - thetaH1 - theta1)*thetaDot*theta1Dot - d1*mSP1*Rhinge1*numpy.sin(beta1 - thetaH1 - theta1)*theta1Dot**2\n              - 2*d2*mSP2*Rhinge2*numpy.sin(beta2 - thetaH2 - theta2)*thetaDot*theta2Dot - d2*mSP2*Rhinge2*numpy.sin(beta2 - thetaH2 - theta2)*theta2Dot**2)\n    # Populate theta1 Equation\n    matrixA[3,0] = -1/(ISP1 + d1**2*mSP1)*(d1*mSP1*numpy.sin(thetaH1 + theta + theta1))\n    matrixA[3,1] = 1/(ISP1 + d1**2*mSP1)*(d1*mSP1*numpy.cos(thetaH1 + theta + theta1))\n    matrixA[3,2] = 1/(ISP1 + d1**2*mSP1)*(ISP1 + d1**2*mSP1 + d1*mSP1*Rhinge1*numpy.cos(beta1 - thetaH1 - theta1))\n    matrixA[3,3] = 1.0\n    matrixA[3,4] = 0.0\n    vectorB[3] = 1/(ISP1 + d1**2*mSP1)*(-k1*theta1 + d1*mSP1*Rhinge1*numpy.sin(beta1 - thetaH1 - theta1)*thetaDot**2 - c1*theta1Dot)\n    # Populate theta2 Equation\n    matrixA[4,0] = -1/(ISP2 + d2**2*mSP2)*(d2*mSP2*numpy.sin(thetaH2 + theta + theta2))\n    matrixA[4,1] = 1/(ISP2 + d2**2*mSP2)*(d2*mSP2*numpy.cos(thetaH2 + theta + theta2))\n    matrixA[4,2] = 1/(ISP2 + d2**2*mSP2)*(ISP2 + d2**2*mSP2 + d2*mSP2*Rhinge2*numpy.cos(beta2 - thetaH2 - theta2))\n    matrixA[4,3] = 0.0\n    matrixA[4,4] = 1.0\n    vectorB[4] = 1/(ISP2 + d2**2*mSP2)*(-k2*theta2 + d2*mSP2*Rhinge2*numpy.sin(beta2 - thetaH2 - theta2)*thetaDot**2 - c2*theta2Dot)\n\n    Xdot = numpy.zeros(len(x))\n    # Populate Trivial derivatives\n    Xdot[0] = xHubDot\n    Xdot[1] = yHubDot\n    Xdot[2] = thetaDot\n    Xdot[3] = theta1Dot\n    Xdot[4] = theta2Dot\n    # Calculate nontrivial derivatives\n    result = numpy.dot(numpy.linalg.inv(matrixA),vectorB)\n    Xdot[5:10] = result\n\n    return Xdot",
  "def rk4(Fn, X, h, t, varargin):\n    k1 = h*Fn(X, t, varargin)\n    k2 = h*Fn(X+k1/2, t+h/2, varargin)\n    k3 = h*Fn(X+k2/2, t+h/2, varargin)\n    k4 = h*Fn(X+k3, t+h, varargin)\n    Z = X + (k1 + 2*k2 + 2*k3 + k4)/6.0\n    return Z",
  "class solarPanel:\n    mass = 0.0\n    Inertia = 0.0\n    Rhinge = 0.0\n    beta = 0.0\n    thetaH = 0.0\n    d = 0.0\n    k = 0.0\n    c = 0.0",
  "class hubClass:\n    mass = 0.0\n    Inertia = 0.0",
  "class spacecraftClass:\n    panel1 = solarPanel()\n    panel2 = solarPanel()\n    hub = hubClass()\n    xThrust_B = 0.0\n    yThrust_B = 0.0\n    Torque = 0.0",
  "def newtonRapshon(funcAndDervi,guess,tolerance,variables):\n    xOld = guess\n    for i in range(1,101):\n        fx, fPrimex = funcAndDervi(xOld, variables)\n        xNew = xOld - fx/fPrimex\n        if abs(xNew - xOld) < tolerance:\n            break\n        xOld = xNew\n    return xNew",
  "def boxAndWingsFandFPrime(theta,variables):\n    # Define variables\n    F = variables.F\n    mSC = variables.mSC\n    k = variables.k\n    mSP = variables.mSP\n    d = variables.d\n    aSP = F/mSC\n    fX = k*theta + mSP*aSP*d*numpy.cos(theta)\n    fPrimeX = k - mSP*aSP*d*numpy.sin(theta)\n    return fX, fPrimeX",
  "class boxAndWingParameters:\n    F = 0\n    mSC = 0\n    k = 0\n    mSP = 0\n    d = 0",
  "def test_fuelSloshAllTest(show_plots,useFlag,testCase):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = fuelSloshTest(show_plots,useFlag,testCase)\n    assert testResults < 1, testMessage",
  "def fuelSloshTest(show_plots,useFlag,testCase):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    \n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n    \n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n    \n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    \n    # Create test thread\n    testProcessRate = macros.sec2nano(0.001)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    unitTestSim.particle1 = linearSpringMassDamper.LinearSpringMassDamper()\n    unitTestSim.particle2 = linearSpringMassDamper.LinearSpringMassDamper()\n    unitTestSim.particle3 = linearSpringMassDamper.LinearSpringMassDamper()\n\n    # Define Variables for particle 1\n    unitTestSim.particle1.k = 100.0\n    unitTestSim.particle1.c = 0.0\n    unitTestSim.particle1.r_PB_B = [[0.1], [0], [-0.1]]\n    unitTestSim.particle1.pHat_B = [[np.sqrt(3)/3], [np.sqrt(3)/3], [np.sqrt(3)/3]]\n    unitTestSim.particle1.rhoInit = 0.05\n    unitTestSim.particle1.rhoDotInit = 0.0\n    unitTestSim.particle1.massInit = 10.0\n\n    # Define Variables for particle 2\n    unitTestSim.particle2.k = 100.0\n    unitTestSim.particle2.c = 0.0\n    unitTestSim.particle2.r_PB_B = [[0], [0], [0.1]]\n    unitTestSim.particle2.pHat_B = [[np.sqrt(3)/3], [-np.sqrt(3)/3], [-np.sqrt(3)/3]]\n    unitTestSim.particle2.rhoInit = -0.025\n    unitTestSim.particle2.rhoDotInit = 0.0\n    unitTestSim.particle2.massInit = 20.0\n\n    # Define Variables for particle 3\n    unitTestSim.particle3.k = 100.0\n    unitTestSim.particle3.c = 0.0\n    unitTestSim.particle3.r_PB_B = [[-0.1], [0], [0.1]]\n    unitTestSim.particle3.pHat_B = [[-np.sqrt(3)/3], [-np.sqrt(3)/3], [np.sqrt(3)/3]]\n    unitTestSim.particle3.rhoInit = -0.015\n    unitTestSim.particle3.rhoDotInit = 0.0\n    unitTestSim.particle3.massInit = 15.0\n\n    if testCase == 'MassDepletion':\n        thrusterCommandName = \"acs_thruster_cmds\"\n        # add thruster devices\n        thFactory = simIncludeThruster.thrusterFactory()\n        thFactory.create('MOOG_Monarc_445',\n                                  [1,0,0],                # location in S frame\n                                  [0,1,0]                 # direction in S frame\n                                  )\n\n        # create thruster object container and tie to spacecraft object\n        thrustersDynamicEffector = thrusterDynamicEffector.ThrusterDynamicEffector()\n        thFactory.addToSpacecraft(\"Thrusters\",\n                                  thrustersDynamicEffector,\n                                  scObject)\n\n        unitTestSim.fuelTankStateEffector = fuelTank.FuelTank()\n        unitTestSim.fuelTankStateEffector.setTankModel(fuelTank.TANK_MODEL_CONSTANT_VOLUME)\n        tankModel = fuelTank.cvar.FuelTankModelConstantVolume\n        tankModel.propMassInit = 40.0\n        tankModel.r_TcT_TInit = [[0.0],[0.0],[0.0]]\n        unitTestSim.fuelTankStateEffector.r_TB_B = [[0.0],[0.0],[0.0]]\n        tankModel.radiusTankInit = 46.0 / 2.0 / 3.2808399 / 12.0\n\n        # Add tank and thruster\n        scObject.addStateEffector(unitTestSim.fuelTankStateEffector)\n        unitTestSim.fuelTankStateEffector.addThrusterSet(thrustersDynamicEffector)\n\n        # set thruster commands\n        ThrustMessage = messaging.THRArrayOnTimeCmdMsgPayload()\n        ThrustMessage.OnTimeRequest = [5.0]\n        thrInMsg = messaging.THRArrayOnTimeCmdMsg().write(ThrustMessage)\n        thrustersDynamicEffector.cmdsInMsg.subscribeTo(thrInMsg)\n\n        # Add test module to runtime call list\n        unitTestSim.AddModelToTask(unitTaskName, unitTestSim.fuelTankStateEffector)\n        unitTestSim.AddModelToTask(unitTaskName, thrustersDynamicEffector)\n        dataTank = unitTestSim.fuelTankStateEffector.fuelTankOutMsg.recorder()\n        unitTestSim.AddModelToTask(unitTaskName, dataTank)\n\n        # Add particles to tank to activate mass depletion\n        unitTestSim.fuelTankStateEffector.pushFuelSloshParticle(unitTestSim.particle1)\n        unitTestSim.fuelTankStateEffector.pushFuelSloshParticle(unitTestSim.particle2)\n        unitTestSim.fuelTankStateEffector.pushFuelSloshParticle(unitTestSim.particle3)\n\n    # Add particles to spacecraft\n    scObject.addStateEffector(unitTestSim.particle1)\n    scObject.addStateEffector(unitTestSim.particle2)\n    scObject.addStateEffector(unitTestSim.particle3)\n\n    if testCase == 'Damping':\n        unitTestSim.particle1.c = 15.0\n        unitTestSim.particle2.c = 17.0\n        unitTestSim.particle3.c = 11.0\n    \n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    scObject.hub.mHub = 750\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n    scObject.hub.r_CN_NInit = [[0.5], [0.4], [-0.7]]\n    scObject.hub.v_CN_NInit = [[0.1], [0.-5], [0.3]]\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.omega_BN_BInit = [[0.1], [-0.1], [0.1]]\n\n    if testCase == 'Gravity':\n        unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n        unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n        unitTestSim.earthGravBody.mu = 0.3986004415E+15 # meters!\n        unitTestSim.earthGravBody.isCentralBody = True\n        unitTestSim.earthGravBody.useSphericalHarmParams = False\n        scObject.gravField.gravBodies = spacecraft.GravBodyVector([unitTestSim.earthGravBody])\n        scObject.hub.r_CN_NInit = [[-4020338.690396649],\t[7490566.741852513],\t[5248299.211589362]]\n        scObject.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n\n    dataLog = scObject.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n    if testCase == 'MassDepletion':\n        unitTestSim.AddVariableForLogging(\n            \"spacecraftBody.dynManager.getStateObject('linearSpringMassDamperMass1').getState()\", testProcessRate, 0, 0, 'double')\n        unitTestSim.AddVariableForLogging(\n            \"spacecraftBody.dynManager.getStateObject('linearSpringMassDamperMass2').getState()\", testProcessRate, 0, 0, 'double')\n        unitTestSim.AddVariableForLogging(\n            \"spacecraftBody.dynManager.getStateObject('linearSpringMassDamperMass3').getState()\", testProcessRate, 0, 0, 'double')\n\n\n    posRef = scObject.dynManager.getStateObject(\"hubPosition\")\n    sigmaRef = scObject.dynManager.getStateObject(\"hubSigma\")\n\n    stopTime = 2.5\n    if testCase == 'MassDepletion':\n        stopTime = 10.0\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    if testCase == 'MassDepletion':\n        fuelMass = dataTank.fuelMass\n        fuelMassDot = dataTank.fuelMassDot\n        mass1Out = unitTestSim.GetLogVariableData(\n            \"spacecraftBody.dynManager.getStateObject('linearSpringMassDamperMass1').getState()\")\n        mass2Out = unitTestSim.GetLogVariableData(\n            \"spacecraftBody.dynManager.getStateObject('linearSpringMassDamperMass2').getState()\")\n        mass3Out = unitTestSim.GetLogVariableData(\n            \"spacecraftBody.dynManager.getStateObject('linearSpringMassDamperMass3').getState()\")\n\n    orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbEnergy\")\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n\n    initialOrbAngMom_N = [\n                [orbAngMom_N[0,1], orbAngMom_N[0,2], orbAngMom_N[0,3]]\n                ]\n\n    finalOrbAngMom = [\n                [orbAngMom_N[-1,1], orbAngMom_N[-1,2], orbAngMom_N[-1,3]]\n                 ]\n\n    initialRotAngMom_N = [\n                [rotAngMom_N[0,1], rotAngMom_N[0,2], rotAngMom_N[0,3]]\n                ]\n\n    finalRotAngMom = [\n                [rotAngMom_N[-1,1], rotAngMom_N[-1,2], rotAngMom_N[-1,3]]\n                 ]\n\n    initialOrbEnergy = [\n                [orbEnergy[0,1]]\n                ]\n\n    finalOrbEnergy = [\n                [orbEnergy[-1,1]]\n                 ]\n\n    initialRotEnergy = [\n                [rotEnergy[0,1]]\n                ]\n\n    finalRotEnergy = [\n                [rotEnergy[-1,1]]\n                 ]\n\n    plt.close('all')\n    if testCase != 'MassDepletion':\n        plt.figure()\n        plt.clf()\n        plt.plot(orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,1] - orbAngMom_N[0,1])/orbAngMom_N[0,1], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,2] - orbAngMom_N[0,2])/orbAngMom_N[0,2], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,3] - orbAngMom_N[0,3])/orbAngMom_N[0,3])\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Relative Difference\")\n        unitTestSupport.writeFigureLaTeX(\"ChangeInOrbitalAngularMomentum\" + testCase, \"Change in Orbital Angular Momentum \" + testCase, plt, r\"width=0.8\\textwidth\", path)\n        plt.figure()\n        plt.clf()\n        plt.plot(orbEnergy[:,0]*1e-9, (orbEnergy[:,1] - orbEnergy[0,1])/orbEnergy[0,1])\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Relative Difference\")\n        unitTestSupport.writeFigureLaTeX(\"ChangeInOrbitalEnergy\" + testCase, \"Change in Orbital Energy \" + testCase, plt, r\"width=0.8\\textwidth\", path)\n        plt.figure()\n        plt.clf()\n        plt.plot(rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,1] - rotAngMom_N[0,1])/rotAngMom_N[0,1], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,2] - rotAngMom_N[0,2])/rotAngMom_N[0,2], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,3] - rotAngMom_N[0,3])/rotAngMom_N[0,3])\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Relative Difference\")\n        unitTestSupport.writeFigureLaTeX(\"ChangeInRotationalAngularMomentum\" + testCase, \"Change in Rotational Angular Momentum \" + testCase, plt, r\"width=0.8\\textwidth\", path)\n    if testCase == 'Gravity' or testCase == 'NoGravity':\n        plt.figure()\n        plt.clf()\n        plt.plot(rotEnergy[:,0]*1e-9, (rotEnergy[:,1] - rotEnergy[0,1])/rotEnergy[0,1])\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Relative Difference\")\n        unitTestSupport.writeFigureLaTeX(\"ChangeInRotationalEnergy\" + testCase, \"Change in Rotational Energy \" + testCase, plt, r\"width=0.8\\textwidth\", path)\n    if testCase == 'MassDepletion':\n        plt.figure()\n        plt.plot(dataTank.times()*1e-9, fuelMass)\n        plt.title(\"Tank Fuel Mass\")\n        plt.figure()\n        plt.plot(dataTank.times()*1e-9, fuelMassDot)\n        plt.title(\"Tank Fuel Mass Dot\")\n        plt.figure()\n        plt.plot(mass1Out[:,0]*1e-9, mass1Out[:,1])\n        plt.title(\"Fuel Particle 1 Mass\")\n        plt.figure()\n        plt.plot(mass2Out[:,0]*1e-9, mass2Out[:,1])\n        plt.title(\"Fuel Particle 2 Mass\")\n        plt.figure()\n        plt.plot(mass3Out[:,0]*1e-9, mass3Out[:,1])\n        plt.title(\"Fuel Particle 3 Mass\")\n        mDotFuel = -0.19392039093\n        mDotParicle1True = mDotFuel*(10./85.)\n        mDotParicle2True = mDotFuel*(20./85.)\n        mDotParicle3True = mDotFuel*(15./85.)\n        mDotParicle1Data = (mass1Out[2,1] - mass1Out[1,1])/((mass1Out[2,0] - mass1Out[1,0])*1e-9)\n        mDotParicle2Data = (mass2Out[2,1] - mass2Out[1,1])/((mass2Out[2,0] - mass2Out[1,0])*1e-9)\n        mDotParicle3Data = (mass3Out[2,1] - mass3Out[1,1])/((mass3Out[2,0] - mass3Out[1,0])*1e-9)\n\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    if testCase != 'MassDepletion':\n        accuracy = 1e-10\n        for i in range(0,len(initialOrbAngMom_N)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i],initialOrbAngMom_N[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: Linear Spring Mass Damper unit test failed orbital angular momentum unit test\")\n\n        for i in range(0,len(initialRotAngMom_N)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i],initialRotAngMom_N[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: Linear Spring Mass Damper unit test failed rotational angular momentum unit test\")\n\n        if testCase == 'Gravity' or testCase == 'NoGravity':\n            for i in range(0,len(initialRotEnergy)):\n                # check a vector values\n                if not unitTestSupport.isArrayEqualRelative(finalRotEnergy[i],initialRotEnergy[i],1,accuracy):\n                    testFailCount += 1\n                    testMessages.append(\"FAILED: Linear Spring Mass Damper unit test failed rotational energy unit test\")\n\n        for i in range(0,len(initialOrbEnergy)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i],initialOrbEnergy[i],1,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: Linear Spring Mass Damper unit test failed orbital energy unit test\")\n\n    if testCase == 'MassDepletion':\n        accuracy = 1e-4\n        if not unitTestSupport.isDoubleEqual(mDotParicle1Data,mDotParicle1True,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Linear Spring Mass Damper unit test failed mass 1 dot test\")\n        if not unitTestSupport.isDoubleEqual(mDotParicle2Data,mDotParicle2True,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Linear Spring Mass Damper unit test failed mass 2 dot test\")\n        if not unitTestSupport.isDoubleEqual(mDotParicle3Data,mDotParicle3True,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Linear Spring Mass Damper unit test failed mass 3 dot test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Linear Spring Mass Damper Test\")\n\n    assert testFailCount < 1, testMessages\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def test_unitFacetDrag():\n    \"\"\"This function is called by the py.test environment.\"\"\"\n    # each test method requires a single assert method to be called\n\n    testResults = []\n    testMessage = []\n\n    dragRes, dragMsg = TestDragCalculation()\n    testMessage.append(dragMsg)\n    testResults.append(dragRes)\n\n    shadowRes, shadowMsg = TestShadowCalculation()\n    testMessage.append(shadowMsg)\n    testResults.append(shadowRes)\n\n    testSum = sum(testResults)\n\n    snippetName = \"unitTestPassFail\"\n\n    if testSum == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED\")\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed\")\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippetName, passedText, path)\n\n    assert testSum < 1, testMessage",
  "def TestDragCalculation():\n\n    #   Init test support variables\n    testFailCount = 0\n    testMessages = []\n\n    ##   Simulation initialization\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n    simulationTimeStep = macros.sec2nano(5.)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    # initialize spacecraft object and set properties\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    ##   Initialize new atmosphere and drag model, add them to task\n    newAtmo = exponentialAtmosphere.ExponentialAtmosphere()\n    newAtmo.ModelTag = \"ExpAtmo\"\n    newAtmo.addSpacecraftToModel(scObject.scStateOutMsg)\n\n    newDrag = facetDragDynamicEffector.FacetDragDynamicEffector()\n    newDrag.ModelTag = \"FacetDrag\"\n    newDrag.atmoDensInMsg.subscribeTo(newAtmo.envOutMsgs[0])\n\n    scObject.addDynamicEffector(newDrag)\n\n    try:\n        scAreas = [1.0, 1.0]\n        scCoeff = np.array([2.0, 2.0])\n        B_normals = [np.array([1, 0, 0]), np.array([0, 1, 0])]\n        B_locations = [np.array([0.1,0,0]), np.array([0,0.1,0])]\n\n        for i in range(0,len(scAreas)):\n            newDrag.addFacet(scAreas[i], scCoeff[i], B_normals[i], B_locations[i])\n    except:\n        testFailCount += 1\n        testMessages.append(\"ERROR: FacetDrag unit test failed while setting facet parameters.\")\n        return testFailCount, testMessages\n\n    # clear prior gravitational body and SPICE setup definitions\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    planet = gravFactory.createEarth()\n\n    planet.isCentralBody = True          # ensure this is the central gravitational body\n    mu = planet.mu\n    # attach gravity model to spacecraft\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    #\n    #   setup orbit and simulation time\n    oe = orbitalMotion.ClassicElements()\n\n    r_eq = 6371*1000.0\n    refBaseDens = 1.217\n    refScaleHeight = 8500.0\n\n    #   Set base density, equitorial radius, scale height in Atmosphere\n    newAtmo.baseDensity = refBaseDens\n    newAtmo.scaleHeight = refScaleHeight\n    newAtmo.planetRadius = r_eq\n\n    rN = np.array([r_eq+200.0e3,0,0])\n    vN = np.array([0,7.788e3,0])\n    sig_BN = np.array([0,0,0])\n    #   initialize Spacecraft States with the initialization variables\n    scObject.hub.r_CN_NInit = rN  # m - r_CN_N\n    scObject.hub.v_CN_NInit = vN  # m - v_CN_N\n    scObject.hub.sigma_BNInit = sig_BN\n\n    simulationTime = macros.sec2nano(5.)\n    #\n    #   Setup data logging before the simulation is initialized\n    #\n    numDataPoints = 10\n\n    # add BSK objects to the simulation process\n    scSim.AddModelToTask(simTaskName, scObject)\n    scSim.AddModelToTask(simTaskName, newAtmo)\n    scSim.AddModelToTask(simTaskName, newDrag)\n\n    # setup logging\n    dataLog = scObject.scStateOutMsg.recorder()\n    scSim.AddModelToTask(simTaskName, dataLog)\n    atmoLog = newAtmo.envOutMsgs[0].recorder()\n    scSim.AddModelToTask(simTaskName, atmoLog)\n\n    #\n    #   initialize Simulation\n    #\n    scSim.InitializeSimulation()\n\n    scSim.AddVariableForLogging(newDrag.ModelTag + \".forceExternal_B\",\n                                      simulationTimeStep, 0, 2, 'double')\n    scSim.AddVariableForLogging(newDrag.ModelTag + \".torqueExternalPntB_B\",\n                                      simulationTimeStep, 0, 2, 'double')\n\n    #   configure a simulation stop time and execute the simulation run\n    #\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    #   Retrieve logged data\n    dragDataForce_B = scSim.GetLogVariableData(newDrag.ModelTag + \".forceExternal_B\")\n    dragTorqueData = scSim.GetLogVariableData(newDrag.ModelTag + \".torqueExternalPntB_B\")\n    posData = dataLog.r_BN_N\n    velData = dataLog.v_BN_N\n    attData = dataLog.sigma_BN\n    densData = atmoLog.neutralDensity\n    np.set_printoptions(precision=16)\n\n    def checkFacetDragForce(dens, area, coeff, facet_dir, sigma_BN, inertial_vel):\n        dcm = rbk.MRP2C(sigma_BN)\n        vMag = np.linalg.norm(inertial_vel)\n        v_hat_B = dcm.dot(inertial_vel) / vMag\n        projArea = area * (facet_dir.dot(v_hat_B))\n        if projArea > 0:\n            drag_force = -0.5 * dens * projArea * coeff * vMag**2.0 * v_hat_B\n        else:\n            drag_force = np.zeros([3,])\n        return drag_force\n\n\n    #   Compare to expected values\n    accuracy = 1e-3\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    test_val = np.zeros([3,])\n    for i in range(len(scAreas)):\n        test_val += checkFacetDragForce(densData[i], scAreas[i], scCoeff[i], B_normals[i], attData[1], velData[1])\n\n    if len(densData) > 0:\n        if not unitTestSupport.isArrayEqualRelative(dragDataForce_B[1,1:4], test_val, 3,accuracy):\n            testFailCount += 1\n            testMessages.append(\n                \"FAILED:  FacetDragEffector failed force unit test at t=\" + str(dragDataForce_B[1,0]* macros.NANO2SEC) + \"sec with a value difference of \"+str(dragDataForce_B[1,1:]-test_val))\n    else:\n        testFailCount += 1\n        testMessages.append(\"FAILED:  ExpAtmo failed to pull any logged data\")\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"PASSED\")\n\n    return testFailCount, testMessages",
  "def TestShadowCalculation():\n\n    #   Init test support variables\n    testFailCount = 0\n    testMessages = []\n\n    ##   Simulation initialization\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n    simulationTimeStep = macros.sec2nano(10.)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    # initialize spacecraft object and set properties\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    simpleNavObj = simpleNav.SimpleNav()\n    simpleNavObj.scStateInMsg.subscribeTo(scObject.scStateOutMsg)\n\n    ##   Initialize new atmosphere and drag model, add them to task\n    newAtmo = exponentialAtmosphere.ExponentialAtmosphere()\n    newAtmo.ModelTag = \"ExpAtmo\"\n    newAtmo.addSpacecraftToModel(scObject.scStateOutMsg)\n\n    newDrag = facetDragDynamicEffector.FacetDragDynamicEffector()\n    newDrag.ModelTag = \"FacetDrag\"\n    newDrag.atmoDensInMsg.subscribeTo(newAtmo.envOutMsgs[0])\n\n    scObject.addDynamicEffector(newDrag)\n\n    try:\n        scAreas = [1.0, 1.0]\n        scCoeff = np.array([2.0, 2.0])\n        B_normals = [np.array([0, 0, -1]), np.array([0, -1, 0])]\n        B_locations = [np.array([0,0,0.1]), np.array([0,0.1,0])]\n\n        for ind in range(0,len(scAreas)):\n            newDrag.addFacet(scAreas[ind], scCoeff[ind], B_normals[ind], B_locations[ind])\n    except:\n        testFailCount += 1\n        testMessages.append(\"ERROR: FacetDrag unit test failed while setting facet parameters.\")\n        return testFailCount, testMessages\n\n    # clear prior gravitational body and SPICE setup definitions\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    planet = gravFactory.createEarth()\n\n    planet.isCentralBody = True          # ensure this is the central gravitational body\n    mu = planet.mu\n    # attach gravity model to spacecraft\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    #\n    #   setup orbit and simulation time\n    oe = orbitalMotion.ClassicElements()\n\n    r_eq = 6371*1000.0\n    refBaseDens = 1.217\n    refScaleHeight = 8500.0\n\n    #   Set base density, equitorial radius, scale height in Atmosphere\n    newAtmo.baseDensity = refBaseDens\n    newAtmo.scaleHeight = refScaleHeight\n    newAtmo.planetRadius = r_eq\n\n    rN = np.array([r_eq+200.0e3,0,0])\n    vN = np.array([0,7.788e3,0])\n    sig_BN = np.array([0,0,0])\n\n    #   initialize Spacecraft States with the initialization variables\n    scObject.hub.r_CN_NInit = rN  # m - r_CN_N\n    scObject.hub.v_CN_NInit = vN  # m - v_CN_N\n    scObject.hub.sigma_BNInit = sig_BN\n\n    simulationTime = macros.sec2nano(10.)\n    #\n    #   Setup data logging before the simulation is initialized\n    #\n    numDataPoints = 10\n\n    # add BSK objects to the simulation process\n    scSim.AddModelToTask(simTaskName, scObject)\n    scSim.AddModelToTask(simTaskName, newAtmo)\n    scSim.AddModelToTask(simTaskName, newDrag)\n\n    # setup logging\n    dataLog = scObject.scStateOutMsg.recorder()\n    scSim.AddModelToTask(simTaskName, dataLog)\n    atmoLog = newAtmo.envOutMsgs[0].recorder()\n    scSim.AddModelToTask(simTaskName, atmoLog)\n\n    #\n    #   initialize Simulation\n    #\n    scSim.InitializeSimulation()\n\n    scSim.AddVariableForLogging(newDrag.ModelTag + \".forceExternal_B\",\n                                simulationTimeStep, 0, 2, 'double')\n    scSim.AddVariableForLogging(newDrag.ModelTag + \".torqueExternalPntB_B\",\n                                simulationTimeStep, 0, 2, 'double')\n\n    #   configure a simulation stop time and execute the simulation run\n    #\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    #   Retrieve logged data\n    #dragDataForce_B = scSim.GetLogVariableData(newDrag.ModelTag + \".forceExternal_B\")\n    dragDataForce_B = scSim.GetLogVariableData(newDrag.ModelTag + \".forceExternal_B\")\n    dragTorqueData = scSim.GetLogVariableData(newDrag.ModelTag + \".torqueExternalPntB_B\")\n    posData = dataLog.r_BN_N\n    velData = dataLog.v_BN_N\n    attData = dataLog.sigma_BN\n    densData = atmoLog.neutralDensity\n    np.set_printoptions(precision=16)\n\n    #   Compare to expected values\n    accuracy = 1e-9\n    #unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    if len(densData) > 0:\n        for ind in range(1,len(densData)):\n            if not unitTestSupport.isArrayZero(dragDataForce_B[ind, 1:], 3,accuracy):\n                testFailCount += 1\n                testMessages.append(\n                    \"FAILED:  FacetDragEffector failed shadow unit test with a value difference of \"\n                    + str(dragDataForce_B[ind,1:]))\n    else:\n        testFailCount += 1\n        testMessages.append(\"FAILED:  ExpAtmo failed to pull any logged data\")\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"PASSED\")\n\n    return testFailCount, testMessages",
  "def checkFacetDragForce(dens, area, coeff, facet_dir, sigma_BN, inertial_vel):\n        dcm = rbk.MRP2C(sigma_BN)\n        vMag = np.linalg.norm(inertial_vel)\n        v_hat_B = dcm.dot(inertial_vel) / vMag\n        projArea = area * (facet_dir.dot(v_hat_B))\n        if projArea > 0:\n            drag_force = -0.5 * dens * projArea * coeff * vMag**2.0 * v_hat_B\n        else:\n            drag_force = np.zeros([3,])\n        return drag_force",
  "def test_scenarioIntegrators(show_plots, integratorCase):\n    \"\"\"This function is called by the py.test environment.\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(True,\n                                     show_plots, integratorCase)\n    assert testResults < 1, testMessage",
  "def run(doUnitTests, show_plots, integratorCase):\n    \"\"\"Call this routine directly to run the tutorial scenario.\"\"\"\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    # Create simulation variable names\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n\n    #  Create a sim module as an empty container\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    #\n    #  create the simulation process\n    #\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n\n    # create the dynamics task and specify the integration update time\n    simulationTimeStep = macros.sec2nano(120.)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    #\n    #   setup the simulation tasks/objects\n    #\n    # initialize spacecraft object and set properties\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    # default case, RK4 is automatically setup, no extra code is needed\n    if integratorCase == \"rkf45\":\n        integratorObject = svIntegrators.svIntegratorRKF45(scObject)\n        integratorObject.setRelativeTolerance(0)\n        integratorObject.setAbsoluteTolerance(0.01)\n        scObject.setIntegrator(integratorObject)\n    if integratorCase == \"rkf78\":\n        integratorObject = svIntegrators.svIntegratorRKF78(scObject)\n        integratorObject.setRelativeTolerance(0)\n        integratorObject.setAbsoluteTolerance(0.01)\n        scObject.setIntegrator(integratorObject)\n    elif integratorCase == \"euler\":\n        integratorObject = svIntegrators.svIntegratorEuler(scObject)\n        scObject.setIntegrator(integratorObject)\n    elif integratorCase == \"rk2\":\n        integratorObject = svIntegrators.svIntegratorRK2(scObject)\n        scObject.setIntegrator(integratorObject)\n    elif integratorCase == \"rk3\":\n        integratorObject = svIntegrators.svIntegratorRungeKutta(\n            scObject,\n            a_coefficients=[\n                [0,   0, 0],\n                [0.5, 0, 0],\n                [-1,  2, 0]\n            ],\n            b_coefficients=[1/6, 2/3, 1/6],\n            c_coefficients=[0, 0.5, 1]\n        )\n        scObject.setIntegrator(integratorObject)\n    elif integratorCase == \"bogackiShampine\":\n        integratorObject = svIntegrators.svIntegratorAdaptiveRungeKutta(\n            scObject,\n            largest_order=3,\n            a_coefficients=[\n                [0,   0,   0,   0],\n                [1/2, 0,   0,   0],\n                [0  , 3/4, 0,   0],\n                [2/9, 1/3, 4/9, 0]\n            ],\n            b_coefficients=[7/24, 1/4, 1/3, 1/8],\n            b_star_coefficients=[2/9, 1/3, 4/9, 0],\n            c_coefficients=[0, 1/2, 3/4, 1]\n        )\n        integratorObject.setRelativeTolerance(0)\n        integratorObject.setAbsoluteTolerance(0.0001)\n        scObject.setIntegrator(integratorObject)\n\n    # add spacecraft object to the simulation process\n    scSim.AddModelToTask(simTaskName, scObject)\n\n    # clear prior gravitational body and SPICE setup definitions\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n\n    earth = gravFactory.createEarth()\n    earth.isCentralBody = True  # ensure this is the central gravitational body\n    mu = earth.mu\n\n    # attach gravity model to spacecraft\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    #\n    #   setup orbit and simulation time\n    #\n    # setup the orbit using classical orbit elements\n    oe = orbitalMotion.ClassicElements()\n    rLEO = 7000. * 1000  # meters\n    oe.a = rLEO\n    oe.e = 0.0001\n    oe.i = 33.3 * macros.D2R\n    oe.Omega = 48.2 * macros.D2R\n    oe.omega = 347.8 * macros.D2R\n    oe.f = 85.3 * macros.D2R\n    rN, vN = orbitalMotion.elem2rv(mu, oe)\n    oe = orbitalMotion.rv2elem(mu, rN, vN)\n    #\n    #   initialize Spacecraft States with in the initialization variables\n    #\n    scObject.hub.r_CN_NInit = rN  # m - r_CN_N\n    scObject.hub.v_CN_NInit = vN  # m - v_CN_N\n\n    # set the simulation time\n    n = np.sqrt(mu / oe.a / oe.a / oe.a)\n    P = 2. * np.pi / n\n    simulationTime = macros.sec2nano(0.75 * P)\n\n    #\n    #   Setup data logging before the simulation is initialized\n    #\n    numDataPoints = 100\n    samplingTime = unitTestSupport.samplingTime(simulationTime, simulationTimeStep, numDataPoints)\n    dataLog = scObject.scStateOutMsg.recorder(samplingTime)\n    scSim.AddModelToTask(simTaskName, dataLog)\n\n    #\n    #   initialize Simulation\n    #\n    scSim.InitializeSimulation()\n\n    #\n    #   configure a simulation stop time and execute the simulation run\n    #\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    #\n    #   retrieve the logged data\n    #\n    posData = dataLog.r_BN_N\n    velData = dataLog.v_BN_N\n\n    #\n    #   plot the results\n    #\n    np.set_printoptions(precision=16)\n    fileNameString = filename[len(path) + 6:-3]\n    if integratorCase == \"rk4\":\n        plt.close(\"all\")  # clears out plots from earlier test runs\n\n    # draw orbit in perifocal frame\n    b = oe.a * np.sqrt(1 - oe.e * oe.e)\n    p = oe.a * (1 - oe.e * oe.e)\n    plt.figure(1, figsize=np.array((1.0, b / oe.a)) * 4.75, dpi=100)\n    plt.axis(np.array([-oe.rApoap, oe.rPeriap, -b, b]) / 1000 * 1.25)\n    # draw the planet\n    fig = plt.gcf()\n    ax = fig.gca()\n    planetColor = '#008800'\n    planetRadius = earth.radEquator / 1000\n    ax.add_artist(plt.Circle((0, 0), planetRadius, color=planetColor))\n    # draw the actual orbit\n    rData = []\n    fData = []\n    labelStrings = (\"rk4\", \"rkf45\", \"rkf78\", \"euler\", \"rk2\")\n    for idx in range(0, len(posData)):\n        oeData = orbitalMotion.rv2elem(mu, posData[idx], velData[idx])\n        rData.append(oeData.rmag)\n        fData.append(oeData.f + oeData.omega - oe.omega)\n    plt.plot(rData * np.cos(fData) / 1000, rData * np.sin(fData) / 1000\n             # , color=unitTestSupport.getLineColor(labelStrings.index(integratorCase) + 1, len(labelStrings))\n             , label=integratorCase\n             , linewidth=3.0\n             )\n    # draw the full osculating orbit from the initial conditions\n    fData = np.linspace(0, 2 * np.pi, 100)\n    rData = []\n    for idx in range(0, len(fData)):\n        rData.append(p / (1 + oe.e * np.cos(fData[idx])))\n    plt.plot(rData * np.cos(fData) / 1000, rData * np.sin(fData) / 1000\n             , '--'\n             , color='#555555'\n             )\n    plt.xlabel('$i_e$ Cord. [km]')\n    plt.ylabel('$i_p$ Cord. [km]')\n    plt.legend(loc='lower right')\n    plt.grid()\n    if doUnitTests:  # only save off the figure if doing a unit test run\n        # unitTestSupport.saveScenarioFigure(\n        #     fileNameString\n        #     , plt, path)\n        # unitTestSupport.saveFigurePDF(\n        #     fileNameString\n        #     , plt, path\n        # )\n        unitTestSupport.writeFigureLaTeX(\n            \"scenarioIntegrators\",\n            \"Illustration of the BSK integrated trajectories\",\n            plt,\n            \"\",\n            path)\n\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    # # close the plots being saved off to avoid over-writing old and new figures\n    # plt.close(\"all\")\n\n    #\n    #   the python code below is for the unit testing mode.  If you are studying the scenario\n    #   to learn how to run BSK, you can stop reading below this line.\n    #\n    if doUnitTests:\n        numTruthPoints = 5\n        skipValue = int(len(posData) / (numTruthPoints - 1))\n        dataPosRed = posData[::skipValue]\n\n        # setup truth data for unit test\n        if integratorCase == \"rk4\":\n            truePos = [\n                [-2.8168016010234915e6, 5.248174846916147e6, 3.677157264677297e6]\n                , [-6.379381726549218e6, -1.4688565370540658e6, 2.4807857675497606e6]\n                , [-2.230094305694789e6, -6.410420020364709e6, -1.7146277675541767e6]\n                , [4.614900659014343e6, -3.60224207689023e6, -3.837022825958977e6]\n                , [5.879095186201691e6, 3.561495655367985e6, -1.3195821703218794e6]\n            ]\n        if integratorCase in {\"rkf45\", \"rkf78\", \"bogackiShampine\"}:\n            truePos = [[ 5879286.370258273, 3561242.50810664, -1319786.625981673]]\n            dataPosRed = dataPosRed[-1,:][np.newaxis]\n        if integratorCase == \"euler\":\n            truePos = [\n                [-2.8168016010234915e6, 5.248174846916147e6, 3.677157264677297e6]\n                , [-7.061548530211288e6, -1.4488790844105487e6, 2.823580168201031e6]\n                , [-4.831279689590867e6, -8.015202650472983e6, -1.1434851461593418e6]\n                , [719606.5825106134, -1.0537603309084207e7, -4.966060248346598e6]\n                , [6.431097055190775e6, -9.795566286964862e6, -7.438012269629238e6]\n            ]\n        if integratorCase == \"rk2\":\n            truePos = [\n                [-2.8168016010234915e6, 5.248174846916147e6, 3.677157264677297e6]\n                , [-6.425636528569288e6, -1.466693214251768e6, 2.50438327358707e6]\n                , [-2.466642497083674e6, -6.509473992136429e6, -1.6421621818735446e6]\n                , [4.342561337924192e6, -4.1593822658140697e6, -3.947594705237753e6]\n                , [6.279757158711852e6, 2.8527385905952943e6, -1.8260959147806289e6]\n            ]\n        if integratorCase == \"rk3\":\n            truePos = [\n                [-2816801.601023492 ,  5248174.846916147 ,  3677157.2646772973],\n                [-6380014.419169294 , -1467304.5024778044,  2481775.1156921615],\n                [-2231193.424069216 , -6407257.277104054 , -1712704.800575082 ],\n                [ 4613563.820461048 , -3590442.718508557 , -3831202.081509318 ],\n                [ 5853794.060191272 ,  3579538.889746918 , -1299292.6887013493]\n            ]\n\n        # compare the results to the truth values\n        accuracy = 1.0  # meters\n\n        testFailCount, testMessages = unitTestSupport.compareArray(\n            truePos, dataPosRed, accuracy, \"r_BN_N Vector\",\n            testFailCount, testMessages)\n\n        #   print out success message if no error were found\n        if testFailCount == 0:\n            print(\"PASSED \")\n            passFailText = \"PASSED\"\n            colorText = 'ForestGreen'  # color to write auto-documented \"PASSED\" message in in LATEX\n            snippetContent = \"\"\n        else:\n            print(testFailCount)\n            print(testMessages)\n            passFailText = 'FAILED'\n            colorText = 'Red'  # color to write auto-documented \"FAILED\" message in in LATEX\n            snippetContent = r\"\\begin{verbatim}\"\n            for message in testMessages:\n                snippetContent += message\n            snippetContent += r\"\\end{verbatim}\"\n        snippetMsgName = fileNameString + 'Msg-' + integratorCase\n        unitTestSupport.writeTeXSnippet(snippetMsgName, snippetContent,\n                                        path)\n        snippetPassFailName = fileNameString + 'TestMsg-' + integratorCase\n        snippetContent = r'\\textcolor{' + colorText + '}{' + passFailText + '}'\n        unitTestSupport.writeTeXSnippet(snippetPassFailName, snippetContent,\n                                        path)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_PrescribedMotionTestFunction(show_plots, rotTest, thetaInit, theta_Ref, posInit, posRef, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    The unit test for this module is an integrated test with two flight software profiler modules. This is required\n    because the dynamics module must be connected to a flight software profiler module to define the states of the\n    prescribed secondary body that is connected to the rigid spacecraft hub. The integrated test for this module has\n    two simple scenarios it is testing. The first scenario prescribes a 1 DOF rotational attitude maneuver for the\n    prescribed body using the :ref:`prescribedRot1DOF` flight software module. The second scenario prescribes a\n    translational maneuver for the prescribed body using the :ref:`prescribedTrans` flight software module.\n\n    This unit test ensures that the profiled 1 DOF rotational attitude maneuver is properly computed for a series of\n    initial and reference PRV angles and maximum angular accelerations. The final prescribed attitude and angular\n    velocity magnitude are compared with the reference values. This unit test also ensures that the profiled\n    translational maneuver is properly computed for a series of initial and reference positions and maximum\n    accelerations. The final prescribed position and velocity magnitudes are compared with the reference values.\n    Additionally for each scenario, the conservation quantities of orbital angular momentum, rotational angular\n    momentum, and orbital energy are checked to validate the module dynamics.\n\n    **Test Parameters**\n\n    Args:\n        rotTest (bool): (True) Runs the rotational motion test. (False) Runs the translational motion test.\n        thetaInit (float): [rad] Initial PRV angle of the F frame with respect to the M frame\n        theta_Ref (float): [rad] Reference PRV angle of the F frame with respect to the M frame\n        thetaDDotMax (float): [rad/s^2] Maximum angular acceleration for the attitude maneuver\n        scalarPosInit (float): [m] Initial scalar position of the F frame with respect to the M frame\n        scalarPosRef (float): [m] Reference scalar position of the F frame with respect to the M frame\n        scalarAccelMax (float): [m/s^2] Maximum acceleration for the translational maneuver\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    This unit test ensures that the profiled 1 DOF rotational attitude maneuver is properly computed for a series of\n    initial and reference PRV angles and maximum angular accelerations. The final prescribed angle ``theta_FM_Final``\n    and angular velocity magnitude ``thetaDot_Final`` are compared with the reference values ``theta_Ref`` and\n    ``thetaDot_Ref``, respectively. This unit test also ensures that the profiled translational maneuver is properly\n    computed for a series of initial and reference positions and maximum accelerations. The final prescribed position\n    magnitude ``r_FM_M_Final`` and velocity magnitude ``rPrime_FM_M_Final`` are compared with the reference values\n    ``r_FM_M_Ref`` and ``rPrime_FM_M_Ref``, respectively. Additionally for each scenario, the conservation quantities\n    of orbital angular momentum, rotational angular momentum, and orbital energy are checked to validate the module\n    dynamics.\n    \"\"\"\n\n    [testResults, testMessage] = PrescribedMotionTestFunction(show_plots, rotTest, thetaInit, theta_Ref, posInit, posRef, accuracy)\n\n    assert testResults < 1, testMessage",
  "def PrescribedMotionTestFunction(show_plots, rotTest, thetaInit, theta_Ref, posInit, posRef, accuracy):\n    \"\"\"Call this routine directly to run the unit test.\"\"\"\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testIncrement = 0.1  # [s]\n    testProcessRate = macros.sec2nano(testIncrement)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Add the spacecraft module to test file\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    # Define the mass properties of the rigid spacecraft hub\n    scObject.hub.mHub = 750.0\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    # Set the initial inertial hub states\n    scObject.hub.r_CN_NInit = [[-4020338.690396649], [7490566.741852513], [5248299.211589362]]\n    scObject.hub.v_CN_NInit = [[-5199.77710904224], [-3436.681645356935], [1041.576797498721]]\n    scObject.hub.omega_BN_BInit = np.array([0.0, 0.0, 0.0])\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n\n    # Add the scObject to the runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    # Add the prescribedMotion dynamics module to test file\n    platform = prescribedMotionStateEffector.PrescribedMotionStateEffector()\n\n    # Define the state effector properties\n    transAxis_M = np.array([1.0, 0.0, 0.0])\n    rotAxis_M = np.array([1.0, 0.0, 0.0])\n    r_FM_M = posInit * transAxis_M\n    prvInit_FM = thetaInit * rotAxis_M\n    sigma_FM = rbk.PRV2MRP(prvInit_FM)\n\n    platform.mass = 100.0\n    platform.IPntFc_F = [[50.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    platform.r_MB_B = [0.0, 0.0, 0.0]\n    platform.r_FcF_F = [0.0, 0.0, 0.0]\n    platform.r_FM_M = r_FM_M\n    platform.rPrime_FM_M = np.array([0.0, 0.0, 0.0])\n    platform.rPrimePrime_FM_M = np.array([0.0, 0.0, 0.0])\n    platform.omega_FM_F = np.array([0.0, 0.0, 0.0])\n    platform.omegaPrime_FM_F = np.array([0.0, 0.0, 0.0])\n    platform.sigma_FM = sigma_FM\n    platform.omega_MB_B = [0.0, 0.0, 0.0]\n    platform.omegaPrime_MB_B = [0.0, 0.0, 0.0]\n    platform.sigma_MB = [0.0, 0.0, 0.0]\n    platform.ModelTag = \"Platform\"\n\n    # Add platform to spacecraft\n    scObject.addStateEffector(platform)\n\n    # Add the test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, platform)\n\n    if rotTest:\n    \n        # ** ** ** ** ** ROTATIONAL 1 DOF INTEGRATED TEST: ** ** ** ** **\n\n        # Create an instance of the prescribedRot1DOF module to be tested\n        PrescribedRot1DOF = prescribedRot1DOF.prescribedRot1DOF()\n        PrescribedRot1DOF.ModelTag = \"prescribedRot1DOF\"\n\n        # Add the prescribedRot1DOF test module to runtime call list\n        unitTestSim.AddModelToTask(unitTaskName, PrescribedRot1DOF)\n\n        # Initialize the prescribedRot1DOF test module configuration data\n        accelMax = 0.01  # [rad/s^2]\n        #accelMax = np.pi / 180  # [rad/s^2]\n        PrescribedRot1DOF.r_FM_M = r_FM_M\n        PrescribedRot1DOF.rPrime_FM_M = np.array([0.0, 0.0, 0.0])\n        PrescribedRot1DOF.rPrimePrime_FM_M = np.array([0.0, 0.0, 0.0])\n        PrescribedRot1DOF.rotAxis_M = rotAxis_M\n        PrescribedRot1DOF.thetaDDotMax = accelMax\n        PrescribedRot1DOF.omega_FM_F = np.array([0.0, 0.0, 0.0])\n        PrescribedRot1DOF.omegaPrime_FM_F = np.array([0.0, 0.0, 0.0])\n        PrescribedRot1DOF.sigma_FM = sigma_FM\n\n        # Create the prescribedRot1DOF input message\n        thetaDot_Ref = 0.0  # [rad/s]\n        SpinningBodyMessageData = messaging.HingedRigidBodyMsgPayload()\n        SpinningBodyMessageData.theta = theta_Ref\n        SpinningBodyMessageData.thetaDot = thetaDot_Ref\n        SpinningBodyMessage = messaging.HingedRigidBodyMsg().write(SpinningBodyMessageData)\n        PrescribedRot1DOF.spinningBodyInMsg.subscribeTo(SpinningBodyMessage)\n        \n        # Connect the PrescribedRot1DOF module's prescribedMotion output message to the prescribedMotion module's prescribedMotion input message\n        platform.prescribedMotionInMsg.subscribeTo(PrescribedRot1DOF.prescribedMotionOutMsg)\n\n        # Add Earth gravity to the simulation\n        earthGravBody = gravityEffector.GravBodyData()\n        earthGravBody.planetName = \"earth_planet_data\"\n        earthGravBody.mu = 0.3986004415E+15\n        earthGravBody.isCentralBody = True\n        earthGravBody.useSphericalHarmParams = False\n        scObject.gravField.gravBodies = spacecraft.GravBodyVector([earthGravBody])\n\n        # Add energy and momentum variables to log\n        unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n        unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n        unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n        unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n\n        # Add other states to log\n        scStateData = scObject.scStateOutMsg.recorder()\n        prescribedStateData = platform.prescribedMotionOutMsg.recorder()\n        dataLog = PrescribedRot1DOF.prescribedMotionOutMsg.recorder()\n        unitTestSim.AddModelToTask(unitTaskName, scStateData)\n        unitTestSim.AddModelToTask(unitTaskName, prescribedStateData)\n        unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n        # Initialize the simulation\n        unitTestSim.InitializeSimulation()\n\n        # Set the simulation time\n        simTime = np.sqrt(((0.5 * np.abs(theta_Ref - thetaInit)) * 8) / accelMax) + 3 * testIncrement\n        unitTestSim.ConfigureStopTime(macros.sec2nano(simTime))\n\n        # Begin the simulation\n        unitTestSim.ExecuteSimulation()\n\n        # Extract the logged data\n        orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbEnergy\")\n        orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n        rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n        rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n        omega_BN_B = scStateData.omega_BN_B\n        r_BN_N = scStateData.r_BN_N\n        sigma_BN = scStateData.sigma_BN\n        omega_FM_F = dataLog.omega_FM_F\n        omegaPrime_FM_F = dataLog.omegaPrime_FM_F\n        sigma_FM = dataLog.sigma_FM\n        timespan = dataLog.times()\n        thetaDot_Final = np.linalg.norm(omega_FM_F[-1, :])\n        sigma_FM_Final = sigma_FM[-1, :]\n        theta_FM_Final = 4 * np.arctan(np.linalg.norm(sigma_FM_Final))\n\n        # Setup the conservation quantities\n        initialOrbAngMom_N = [[orbAngMom_N[0, 1], orbAngMom_N[0, 2], orbAngMom_N[0, 3]]]\n        finalOrbAngMom = [orbAngMom_N[-1]]\n        initialRotAngMom_N = [[rotAngMom_N[0, 1], rotAngMom_N[0, 2], rotAngMom_N[0, 3]]]\n        finalRotAngMom = [rotAngMom_N[-1]]\n        initialOrbEnergy = [[orbEnergy[0, 1]]]\n        finalOrbEnergy = [orbEnergy[-1]]\n\n        # Convert the logged sigma_FM MRPs to a scalar theta_FM array\n        n = len(timespan)\n        theta_FM = []\n        for i in range(n):\n            theta_FM.append((180 / np.pi) * (4 * np.arctan(np.linalg.norm(sigma_FM[i, :]))))\n\n        plt.close(\"all\")\n\n        # Plot theta_FM\n        theta_Ref_plotting = np.ones(len(timespan)) * theta_Ref\n        thetaInit_plotting = np.ones(len(timespan)) * thetaInit\n        plt.figure()\n        plt.clf()\n        plt.plot(timespan * macros.NANO2SEC, theta_FM, label=r'$\\Phi$')\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * theta_Ref_plotting, '--', label=r'$\\Phi_{Ref}$')\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * thetaInit_plotting, '--', label=r'$\\Phi_{0}$')\n        plt.title(r'$\\Phi_{\\mathcal{F}/\\mathcal{M}}$ Profiled Trajectory', fontsize=14)\n        plt.ylabel('(deg)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n        plt.legend(loc='center right', prop={'size': 16})\n\n        # Plot omega_FM_F\n        plt.figure()\n        plt.clf()\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omega_FM_F[:, 0], label=r'$\\omega_{1}$')\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omega_FM_F[:, 1], label=r'$\\omega_{2}$')\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omega_FM_F[:, 2], label=r'$\\omega_{3}$')\n        plt.title(r'${}^\\mathcal{F} \\omega_{\\mathcal{F}/\\mathcal{M}}$ Profiled Trajectory', fontsize=14)\n        plt.ylabel('(deg/s)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n        plt.legend(loc='upper right', prop={'size': 16})\n\n        # Plotting omegaPrime_FM_F\n        plt.figure()\n        plt.clf()\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omegaPrime_FM_F[:, 0], label='1')\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omegaPrime_FM_F[:, 1], label='2')\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omegaPrime_FM_F[:, 2], label='3')\n        plt.title(r'${}^\\mathcal{F} \\omega Prime_{\\mathcal{F}/\\mathcal{M}}$ Profiled Angular Acceleration', fontsize=14)\n        plt.ylabel(r'(deg/$s^2$)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n        plt.legend(loc='upper right', prop={'size': 16})\n\n        # Plot r_BN_N\n        plt.figure()\n        plt.clf()\n        plt.plot(timespan * macros.NANO2SEC, r_BN_N[:, 0], label=r'$r_{1}$')\n        plt.plot(timespan * macros.NANO2SEC, r_BN_N[:, 1], label=r'$r_{2}$')\n        plt.plot(timespan * macros.NANO2SEC, r_BN_N[:, 2], label=r'$r_{3}$')\n        plt.title(r'${}^\\mathcal{N} r_{\\mathcal{B}/\\mathcal{N}}$ Spacecraft Inertial Trajectory', fontsize=14)\n        plt.ylabel('(m)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n        plt.legend(loc='center left', prop={'size': 16})\n\n        # Plot sigma_BN\n        plt.figure()\n        plt.clf()\n        plt.plot(timespan * macros.NANO2SEC, sigma_BN[:, 0], label=r'$\\sigma_{1}$')\n        plt.plot(timespan * macros.NANO2SEC, sigma_BN[:, 1], label=r'$\\sigma_{2}$')\n        plt.plot(timespan * macros.NANO2SEC, sigma_BN[:, 2], label=r'$\\sigma_{3}$')\n        plt.title(r'$\\sigma_{\\mathcal{B}/\\mathcal{N}}$ Spacecraft Inertial MRP Attitude', fontsize=14)\n        plt.ylabel('', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n        plt.legend(loc='center left', prop={'size': 16})\n\n        # Plot omega_BN_B\n        plt.figure()\n        plt.clf()\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omega_BN_B[:, 0], label=r'$\\omega_{1}$')\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omega_BN_B[:, 1], label=r'$\\omega_{2}$')\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omega_BN_B[:, 2], label=r'$\\omega_{3}$')\n        plt.title(r'Spacecraft Hub Angular Velocity ${}^\\mathcal{B} \\omega_{\\mathcal{B}/\\mathcal{N}}$', fontsize=14)\n        plt.xlabel('Time (s)', fontsize=16)\n        plt.ylabel('(deg/s)', fontsize=16)\n        plt.legend(loc='lower right', prop={'size': 16})\n\n        # Plotting: Conservation quantities\n        plt.figure()\n        plt.clf()\n        plt.plot(orbAngMom_N[:, 0] * macros.NANO2SEC, (orbAngMom_N[:, 1] - orbAngMom_N[0, 1]) / orbAngMom_N[0, 1],\n                 orbAngMom_N[:, 0] * macros.NANO2SEC, (orbAngMom_N[:, 2] - orbAngMom_N[0, 2]) / orbAngMom_N[0, 2],\n                 orbAngMom_N[:, 0] * macros.NANO2SEC, (orbAngMom_N[:, 3] - orbAngMom_N[0, 3]) / orbAngMom_N[0, 3])\n        plt.title('Orbital Angular Momentum Relative Difference', fontsize=14)\n        plt.ylabel('(Nms)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n\n        plt.figure()\n        plt.clf()\n        plt.plot(orbEnergy[:, 0] * macros.NANO2SEC, (orbEnergy[:, 1] - orbEnergy[0, 1]) / orbEnergy[0, 1])\n        plt.title('Orbital Energy Relative Difference', fontsize=14)\n        plt.ylabel('Energy (J)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n\n        plt.figure()\n        plt.clf()\n        plt.plot(rotAngMom_N[:, 0] * macros.NANO2SEC, (rotAngMom_N[:, 1] - rotAngMom_N[0, 1]),\n                 rotAngMom_N[:, 0] * macros.NANO2SEC, (rotAngMom_N[:, 2] - rotAngMom_N[0, 2]),\n                 rotAngMom_N[:, 0] * macros.NANO2SEC, (rotAngMom_N[:, 3] - rotAngMom_N[0, 3]))\n        plt.title('Rotational Angular Momentum Difference', fontsize=14)\n        plt.ylabel('(Nms)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n\n        plt.figure()\n        plt.clf()\n        plt.plot(rotEnergy[:, 0] * macros.NANO2SEC, (rotEnergy[:, 1] - rotEnergy[0, 1]))\n        plt.title('Total Energy Difference', fontsize=14)\n        plt.ylabel('Energy (J)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n\n        if show_plots:\n            plt.show()\n        plt.close(\"all\")\n\n        # Begin the test analysis\n        finalOrbAngMom = np.delete(finalOrbAngMom, 0, axis=1)  # remove the time column\n        finalRotAngMom = np.delete(finalRotAngMom, 0, axis=1)  # remove the time column\n        finalOrbEnergy = np.delete(finalOrbEnergy, 0, axis=1)  # remove the time column\n\n        for i in range(0, len(initialOrbAngMom_N)):\n            if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i], initialOrbAngMom_N[i], 3, accuracy):\n                testFailCount += 1\n                testMessages.append(\n                    \"FAILED: Prescribed Motion integrated test failed orbital angular momentum unit test\")\n\n        for i in range(0, len(initialRotAngMom_N)):\n            if not unitTestSupport.isArrayEqual(finalRotAngMom[i], initialRotAngMom_N[i], 3, accuracy):\n                testFailCount += 1\n                testMessages.append(\n                    \"FAILED: Prescribed Motion integrated test failed rotational angular momentum unit test\")\n\n        for i in range(0, len(initialOrbEnergy)):\n            if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i], initialOrbEnergy[i], 1, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: Prescribed Motion integrated test failed orbital energy unit test\")\n\n        # Check to ensure the initial angle rate converged to the reference angle rate\n        if not unitTestSupport.isDoubleEqual(thetaDot_Final, thetaDot_Ref, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + PrescribedRot1DOF.ModelTag + \"thetaDot_Final and thetaDot_Ref do not match\")\n\n        # Check to ensure the initial angle converged to the reference angle\n        if not unitTestSupport.isDoubleEqual(theta_FM_Final, theta_Ref, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + PrescribedRot1DOF.ModelTag + \"theta_FM_Final and theta_Ref do not match\")\n            # testMessages.append(\"theta_FM_Final: \" + str(theta_FM_Final) + \" theta_Ref: \" + str(theta_Ref))\n\n        if testFailCount == 0:\n            print(\"PASSED: \" + \"prescribedMotion and prescribedRot1DOF integrated test\")\n\n    else:\n\n        # ** ** ** ** ** TRANSLATIONAL INTEGRATED TEST ** ** ** ** **\n\n        # Create an instance of the prescribedTrans module to be tested\n        PrescribedTrans = prescribedTrans.prescribedTrans()\n        PrescribedTrans.ModelTag = \"prescribedTrans\"\n\n        # Add the prescribedTrans test module to runtime call list\n        unitTestSim.AddModelToTask(unitTaskName, PrescribedTrans)\n\n        # Initialize the prescribedTrans test module configuration data\n        accelMax = 0.005  # [m/s^2]\n        PrescribedTrans.r_FM_M = r_FM_M\n        PrescribedTrans.rPrime_FM_M = np.array([0.0, 0.0, 0.0])\n        PrescribedTrans.rPrimePrime_FM_M = np.array([0.0, 0.0, 0.0])\n        PrescribedTrans.transAxis_M = transAxis_M\n        PrescribedTrans.scalarAccelMax = accelMax\n        PrescribedTrans.omega_FM_F = np.array([0.0, 0.0, 0.0])\n        PrescribedTrans.omegaPrime_FM_F = np.array([0.0, 0.0, 0.0])\n        PrescribedTrans.sigma_FM = sigma_FM\n\n        # Create the prescribedTrans input message\n        velRef = 0.0  # [m/s]\n        PrescribedTransMessageData = messaging.PrescribedTransMsgPayload()\n        PrescribedTransMessageData.scalarPos = posRef\n        PrescribedTransMessageData.scalarVel = velRef\n        PrescribedTransMessage = messaging.PrescribedTransMsg().write(PrescribedTransMessageData)\n        PrescribedTrans.prescribedTransInMsg.subscribeTo(PrescribedTransMessage)\n\n        # Connect the PrescribedTrans module's prescribedMotion output message to the prescribedMotion module's prescribedMotion input message\n        platform.prescribedMotionInMsg.subscribeTo(PrescribedTrans.prescribedMotionOutMsg)\n\n        # Add Earth gravity to the simulation\n        earthGravBody = gravityEffector.GravBodyData()\n        earthGravBody.planetName = \"earth_planet_data\"\n        earthGravBody.mu = 0.3986004415E+15\n        earthGravBody.isCentralBody = True\n        earthGravBody.useSphericalHarmParams = False\n        scObject.gravField.gravBodies = spacecraft.GravBodyVector([earthGravBody])\n\n        # Add energy and momentum variables to log\n        unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n        unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n        unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n        unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n\n        # Add other states to log\n        scStateData = scObject.scStateOutMsg.recorder()\n        prescribedStateData = platform.prescribedMotionOutMsg.recorder()\n        dataLog = PrescribedTrans.prescribedMotionOutMsg.recorder()\n        unitTestSim.AddModelToTask(unitTaskName, scStateData)\n        unitTestSim.AddModelToTask(unitTaskName, prescribedStateData)\n        unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n        # Initialize the simulation\n        unitTestSim.InitializeSimulation()\n\n        # Set the simulation time\n        simTime = np.sqrt(((0.5 * np.abs(posRef - posInit)) * 8) / accelMax) + 3 * testIncrement\n        unitTestSim.ConfigureStopTime(macros.sec2nano(simTime))\n\n        # Begin the simulation\n        unitTestSim.ExecuteSimulation()\n\n        # Extract the logged data\n        orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbEnergy\")\n        orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n        rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n        rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n        r_BN_N = scStateData.r_BN_N\n        sigma_BN = scStateData.sigma_BN\n        omega_BN_B = scStateData.omega_BN_B\n        r_FM_M = dataLog.r_FM_M\n        rPrime_FM_M = dataLog.rPrime_FM_M\n        rPrimePrime_FM_M = dataLog.rPrimePrime_FM_M\n        timespan = dataLog.times()\n        r_FM_M_Final = r_FM_M[-1, :]\n        rPrime_FM_M_Final = rPrime_FM_M[-1, :]\n\n        # Setup the conservation quantities\n        initialOrbAngMom_N = [[orbAngMom_N[0, 1], orbAngMom_N[0, 2], orbAngMom_N[0, 3]]]\n        finalOrbAngMom = [orbAngMom_N[-1]]\n        initialRotAngMom_N = [[rotAngMom_N[0, 1], rotAngMom_N[0, 2], rotAngMom_N[0, 3]]]\n        finalRotAngMom = [rotAngMom_N[-1]]\n        initialOrbEnergy = [[orbEnergy[0, 1]]]\n        finalOrbEnergy = [orbEnergy[-1]]\n        initialRotEnergy = [[rotEnergy[0, 1]]]\n        finalRotEnergy = [rotEnergy[-1]]\n\n        # Plot r_FM_F\n        r_FM_M_Ref = posRef * transAxis_M\n        r_FM_M_1_Ref = np.ones(len(timespan)) * r_FM_M_Ref[0]\n        r_FM_M_2_Ref = np.ones(len(timespan)) * r_FM_M_Ref[1]\n        r_FM_M_3_Ref = np.ones(len(timespan)) * r_FM_M_Ref[2]\n\n        plt.figure()\n        plt.clf()\n        plt.plot(timespan * macros.NANO2SEC, r_FM_M[:, 0], label=r'$r_{1}$')\n        plt.plot(timespan * macros.NANO2SEC, r_FM_M[:, 1], label=r'$r_{2}$')\n        plt.plot(timespan * macros.NANO2SEC, r_FM_M[:, 2], label=r'$r_{3}$')\n        plt.plot(timespan * macros.NANO2SEC, r_FM_M_1_Ref, '--', label=r'$r_{1 Ref}$')\n        plt.plot(timespan * macros.NANO2SEC, r_FM_M_2_Ref, '--', label=r'$r_{2 Ref}$')\n        plt.plot(timespan * macros.NANO2SEC, r_FM_M_3_Ref, '--', label=r'$r_{3 Ref}$')\n        plt.title(r'${}^\\mathcal{M} r_{\\mathcal{F}/\\mathcal{M}}$ Profiled Trajectory', fontsize=14)\n        plt.ylabel('(m)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n        plt.legend(loc='center left', prop={'size': 16})\n\n        # Plot rPrime_FM_F\n        plt.figure()\n        plt.clf()\n        plt.plot(timespan * macros.NANO2SEC, rPrime_FM_M[:, 0], label='1')\n        plt.plot(timespan * macros.NANO2SEC, rPrime_FM_M[:, 1], label='2')\n        plt.plot(timespan * macros.NANO2SEC, rPrime_FM_M[:, 2], label='3')\n        plt.title(r'${}^\\mathcal{M} rPrime_{\\mathcal{F}/\\mathcal{M}}$ Profiled Trajectory', fontsize=14)\n        plt.ylabel('(m/s)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n        plt.legend(loc='upper left', prop={'size': 16})\n\n        # Plotting rPrimePrime_FM_M\n        plt.figure()\n        plt.clf()\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * rPrimePrime_FM_M[:, 0], label='1')\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * rPrimePrime_FM_M[:, 1], label='2')\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * rPrimePrime_FM_M[:, 2], label='3')\n        plt.title(r'${}^\\mathcal{M} rPrimePrime_{\\mathcal{F}/\\mathcal{M}}$ Profiled Acceleration', fontsize=14)\n        plt.ylabel(r'(m/s$^2$)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n        plt.legend(loc='lower left', prop={'size': 16})\n\n        # Plot r_BN_N\n        plt.figure()\n        plt.clf()\n        plt.plot(timespan * macros.NANO2SEC, r_BN_N[:, 0], label=r'$r_{1}$')\n        plt.plot(timespan * macros.NANO2SEC, r_BN_N[:, 1], label=r'$r_{2}$')\n        plt.plot(timespan * macros.NANO2SEC, r_BN_N[:, 2], label=r'$r_{3}$')\n        plt.title(r'${}^\\mathcal{N} r_{\\mathcal{B}/\\mathcal{N}}$ Spacecraft Inertial Trajectory', fontsize=14)\n        plt.ylabel('(m)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n        plt.legend(loc='center left', prop={'size': 16})\n\n        # Plot sigma_BN\n        plt.figure()\n        plt.clf()\n        plt.plot(timespan * macros.NANO2SEC, sigma_BN[:, 0], label=r'$\\sigma_{1}$')\n        plt.plot(timespan * macros.NANO2SEC, sigma_BN[:, 1], label=r'$\\sigma_{2}$')\n        plt.plot(timespan * macros.NANO2SEC, sigma_BN[:, 2], label=r'$\\sigma_{3}$')\n        plt.title(r'$\\sigma_{\\mathcal{B}/\\mathcal{N}}$ Spacecraft Inertial MRP Attitude', fontsize=14)\n        plt.ylabel('', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n        plt.legend(loc='lower left', prop={'size': 16})\n\n        # Plot omega_BN_B\n        plt.figure()\n        plt.clf()\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omega_BN_B[:, 0], label=r'$\\omega_{1}$')\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omega_BN_B[:, 1], label=r'$\\omega_{2}$')\n        plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omega_BN_B[:, 2], label=r'$\\omega_{3}$')\n        plt.title(r'Spacecraft Hub Angular Velocity ${}^\\mathcal{B} \\omega_{\\mathcal{B}/\\mathcal{N}}$', fontsize=14)\n        plt.ylabel('(deg/s)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n        plt.legend(loc='lower left', prop={'size': 16})\n\n        # Plotting: Conservation quantities\n        plt.figure()\n        plt.clf()\n        plt.plot(orbAngMom_N[:, 0] * macros.NANO2SEC, (orbAngMom_N[:, 1] - orbAngMom_N[0, 1]) / orbAngMom_N[0, 1],\n                 orbAngMom_N[:, 0] * macros.NANO2SEC, (orbAngMom_N[:, 2] - orbAngMom_N[0, 2]) / orbAngMom_N[0, 2],\n                 orbAngMom_N[:, 0] * macros.NANO2SEC, (orbAngMom_N[:, 3] - orbAngMom_N[0, 3]) / orbAngMom_N[0, 3])\n        plt.title('Orbital Angular Momentum Relative Difference', fontsize=14)\n        plt.ylabel('(Nms)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n\n        plt.figure()\n        plt.clf()\n        plt.plot(orbEnergy[:, 0] * macros.NANO2SEC, (orbEnergy[:, 1] - orbEnergy[0, 1]) / orbEnergy[0, 1])\n        plt.title('Orbital Energy Relative Difference', fontsize=14)\n        plt.ylabel('Energy (J)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n\n        plt.figure()\n        plt.clf()\n        plt.plot(rotAngMom_N[:, 0] * macros.NANO2SEC, (rotAngMom_N[:, 1] - rotAngMom_N[0, 1]),\n                 rotAngMom_N[:, 0] * macros.NANO2SEC, (rotAngMom_N[:, 2] - rotAngMom_N[0, 2]),\n                 rotAngMom_N[:, 0] * macros.NANO2SEC, (rotAngMom_N[:, 3] - rotAngMom_N[0, 3]))\n        plt.title('Rotational Angular Momentum Difference', fontsize=14)\n        plt.ylabel('(Nms)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n\n        plt.figure()\n        plt.clf()\n        plt.plot(rotEnergy[:, 0] * macros.NANO2SEC, (rotEnergy[:, 1] - rotEnergy[0, 1]))\n        plt.title('Total Energy Difference', fontsize=14)\n        plt.ylabel('Energy (J)', fontsize=16)\n        plt.xlabel('Time (s)', fontsize=16)\n\n        if show_plots:\n            plt.show()\n        plt.close(\"all\")\n\n        # Begin the test analysis\n        finalOrbAngMom = np.delete(finalOrbAngMom, 0, axis=1)  # remove the time column\n        finalRotAngMom = np.delete(finalRotAngMom, 0, axis=1)  # remove the time column\n        finalOrbEnergy = np.delete(finalOrbEnergy, 0, axis=1)  # remove the time column\n\n        for i in range(0, len(initialOrbAngMom_N)):\n            if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i], initialOrbAngMom_N[i], 3, accuracy):\n                testFailCount += 1\n                testMessages.append(\n                    \"FAILED: Prescribed Motion integrated test failed orbital angular momentum unit test\")\n\n        for i in range(0, len(initialRotAngMom_N)):\n            if not unitTestSupport.isArrayEqual(finalRotAngMom[i], initialRotAngMom_N[i], 3, accuracy):\n                testFailCount += 1\n                testMessages.append(\n                    \"FAILED: Prescribed Motion integrated test failed rotational angular momentum unit test\")\n\n        for i in range(0, len(initialOrbEnergy)):\n            if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i], initialOrbEnergy[i], 1, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: Prescribed Motion integrated test failed orbital energy unit test\")\n\n        # Check to ensure the initial velocity converged to the reference velocity\n        rPrime_FM_M_Ref = np.array([0.0, 0.0, 0.0])\n        if not unitTestSupport.isArrayEqual(rPrime_FM_M_Final, rPrime_FM_M_Ref, 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + PrescribedTrans.ModelTag + \"rPrime_FM_M_Final and rPrime_FM_M_Ref do not match\")\n            testMessages.append(\"rPrime_FM_M_Final: \" + str(rPrime_FM_M_Final) + \" rPrime_FM_M_Ref: \" + str(rPrime_FM_M_Ref))\n\n        # Check to ensure the initial position converged to the reference position\n        r_FM_M_Ref = np.array([posRef, 0.0, 0.0])\n        if not unitTestSupport.isArrayEqual(r_FM_M_Final, r_FM_M_Ref, 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + PrescribedTrans.ModelTag + \"r_FM_M_Final and r_FM_M_Ref do not match\")\n            testMessages.append(\"r_FM_M_Final: \" + str(r_FM_M_Final) + \" r_FM_M_Ref: \" + str(r_FM_M_Ref))\n\n        if testFailCount == 0:\n            print(\"PASSED: \" + \"prescribedMotion and prescribedTrans integrated test\")\n\n    return [testFailCount, ''.join(testMessages)]",
  "def addTimeColumn(time, data):\n    return numpy.transpose(numpy.vstack([[time], numpy.transpose(data)]))",
  "def test_spacecraftAllTest(show_plots, function):\n    \"\"\"Module Unit Test\"\"\"\n    if function == \"scOptionalRef\":\n        [testResults, testMessage] = eval(function + '(show_plots, 1e-3)')\n    elif function == \"scAccumDV\":\n        [testResults, testMessage] = eval(function + '()')\n    else:\n        [testResults, testMessage] = eval(function + '(show_plots)')\n    assert testResults < 1, testMessage",
  "def SCTranslation(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.01)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n    unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n    unitTestSim.earthGravBody.mu = 0.3986004415E+15 # meters!\n    unitTestSim.earthGravBody.isCentralBody = True\n    unitTestSim.earthGravBody.useSphericalHarmParams = False\n\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector([unitTestSim.earthGravBody])\n\n    dataLog = scObject.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Define initial conditions of the spacecraft\n    scObject.hub.mHub = 100\n    scObject.hub.r_CN_NInit = [[-4020338.690396649],\t[7490566.741852513],\t[5248299.211589362]]\n    scObject.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n\n    unitTestSim.InitializeSimulation()\n    accuracy = 1e-3\n    if not unitTestSupport.isArrayEqual(scObject.scStateOutMsg.read().r_BN_N,\n                                        [item for sublist in scObject.hub.r_CN_NInit for item in sublist],\n                                        3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: SCHub Translation test failed init pos msg unit test\")\n    if not unitTestSupport.isArrayEqual(scObject.scStateOutMsg.read().v_BN_N,\n                                        [item for sublist in scObject.hub.v_CN_NInit for item in sublist],\n                                        3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: SCHub Translation test failed init pos msg unit test\")\n\n\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n\n    stopTime = 10.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n    orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbEnergy\")\n\n    plt.close(\"all\")\n    plt.figure()\n    plt.clf()\n    plt.plot(orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,1] - orbAngMom_N[0,1])/orbAngMom_N[0,1], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,2] - orbAngMom_N[0,2])/orbAngMom_N[0,2], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,3] - orbAngMom_N[0,3])/orbAngMom_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    unitTestSupport.writeFigureLaTeX(\"scPlusChangeInOrbitalAngularMomentumTranslationOnly\", \"Change in Orbital Angular Momentum Translation Only\", plt, r\"width=0.8\\textwidth\", path)\n    plt.figure()\n    plt.clf()\n    plt.plot(orbEnergy[:,0]*1e-9, (orbEnergy[:,1] - orbEnergy[0,1])/orbEnergy[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    unitTestSupport.writeFigureLaTeX(\"scPlusChangeInOrbitalEnergyTranslationOnly\", \"Change in Orbital Energy Translation Only\", plt, r\"width=0.8\\textwidth\", path)\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    moduleOutput = dataLog.r_BN_N\n\n    truePos = [\n                [-4072255.7737936215, 7456050.4649078, 5258610.029627514]\n                ]\n\n    initialOrbAngMom_N = [\n                [orbAngMom_N[0,1], orbAngMom_N[0,2], orbAngMom_N[0,3]]\n                ]\n\n    finalOrbAngMom = [\n                [orbAngMom_N[-1,1], orbAngMom_N[-1,2], orbAngMom_N[-1,3]]\n                 ]\n\n    initialOrbEnergy = [\n                [orbEnergy[0,1]]\n                ]\n\n    finalOrbEnergy = [\n                [orbEnergy[-1,1]]\n                 ]\n\n    accuracy = 1e-10\n    for i in range(0,len(truePos)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(moduleOutput[-1,:],truePos[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: SCHub Translation test failed pos unit test\")\n\n    for i in range(0,len(initialOrbAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i],initialOrbAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: SCHub Translation test failed orbital angular momentum unit test\")\n\n    for i in range(0,len(initialOrbEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i],initialOrbEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: SCHub Translation test failed orbital energy unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" SCHub Translation Integrated Sim Test\")\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def SCTransAndRotation(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.001)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n    unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n    unitTestSim.earthGravBody.mu = 0.3986004415E+15  # meters!\n    unitTestSim.earthGravBody.isCentralBody = True\n    unitTestSim.earthGravBody.useSphericalHarmParams = False\n\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector([unitTestSim.earthGravBody])\n\n    dataLog = scObject.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Define initial conditions of the spacecraft\n    scObject.hub.mHub = 100\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    scObject.hub.r_CN_NInit = [[-4020338.690396649],\t[7490566.741852513],\t[5248299.211589362]]\n    scObject.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.omega_BN_BInit = [[0.5], [-0.4], [0.7]]\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n\n    stopTime = 10.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbEnergy\")\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n\n    r_BN_NOutput = dataLog.r_BN_N\n    sigma_BNOutput = dataLog.sigma_BN\n\n    truePos = [\n                [-4072255.7737936215, 7456050.4649078, 5258610.029627514]\n                ]\n\n    trueSigma = [\n                [3.73034285e-01,  -2.39564413e-03,   2.08570797e-01]\n                ]\n\n    initialOrbAngMom_N = [\n                [orbAngMom_N[0,1], orbAngMom_N[0,2], orbAngMom_N[0,3]]\n                ]\n\n    finalOrbAngMom = [\n                [orbAngMom_N[-1,1], orbAngMom_N[-1,2], orbAngMom_N[-1,3]]\n                 ]\n\n    initialRotAngMom_N = [\n                [rotAngMom_N[0,1], rotAngMom_N[0,2], rotAngMom_N[0,3]]\n                ]\n\n    finalRotAngMom = [\n                [rotAngMom_N[-1,1], rotAngMom_N[-1,2], rotAngMom_N[-1,3]]\n                 ]\n\n    initialOrbEnergy = [\n                [orbEnergy[0,1]]\n                ]\n\n    finalOrbEnergy = [\n                [orbEnergy[-1,1]]\n                 ]\n\n    initialRotEnergy = [\n                [rotEnergy[0,1]]\n                ]\n\n    finalRotEnergy = [\n                [rotEnergy[-1,1]]\n                 ]\n\n    plt.close('all')\n    plt.figure()\n    plt.clf()\n    plt.plot(orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,1] - orbAngMom_N[0,1])/orbAngMom_N[0,1], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,2] - orbAngMom_N[0,2])/orbAngMom_N[0,2], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,3] - orbAngMom_N[0,3])/orbAngMom_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    unitTestSupport.writeFigureLaTeX(\"scPlusChangeInOrbitalAngularMomentumTranslationAndRotation\", \"Change in Orbital Angular Momentum Translation And Rotation\", plt, r\"width=0.8\\textwidth\", path)\n    plt.figure()\n    plt.clf()\n    plt.plot(orbEnergy[:,0]*1e-9, (orbEnergy[:,1] - orbEnergy[0,1])/orbEnergy[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    unitTestSupport.writeFigureLaTeX(\"scPlusChangeInOrbitalEnergyTranslationAndRotation\", \"Change in Orbital Energy Translation And Rotation\", plt, r\"width=0.8\\textwidth\", path)\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,1] - rotAngMom_N[0,1])/rotAngMom_N[0,1], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,2] - rotAngMom_N[0,2])/rotAngMom_N[0,2], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,3] - rotAngMom_N[0,3])/rotAngMom_N[0,3])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    unitTestSupport.writeFigureLaTeX(\"scPlusChangeInRotationalAngularMomentumTranslationAndRotation\", \"Change in Rotational Angular Momentum Translation And Rotation\", plt, r\"width=0.8\\textwidth\", path)\n    plt.figure()\n    plt.clf()\n    plt.plot(rotEnergy[:,0]*1e-9, (rotEnergy[:,1] - rotEnergy[0,1])/rotEnergy[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    unitTestSupport.writeFigureLaTeX(\"scPlusChangeInRotationalEnergyTranslationAndRotation\", \"Change in Rotational Energy Translation And Rotation\", plt, r\"width=0.8\\textwidth\", path)\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    accuracy = 1e-8\n    for i in range(0,len(truePos)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(r_BN_NOutput[-1,:],truePos[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed pos unit test\")\n\n    for i in range(0,len(trueSigma)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(sigma_BNOutput[-1,:],trueSigma[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed attitude unit test\")\n\n    accuracy = 1e-10\n    for i in range(0,len(initialOrbAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i],initialOrbAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed orbital angular momentum unit test\")\n\n    for i in range(0,len(initialRotAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i],initialRotAngMom_N[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed rotational angular momentum unit test\")\n\n    for i in range(0,len(initialRotEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotEnergy[i],initialRotEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed rotational energy unit test\")\n\n    for i in range(0,len(initialOrbEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i],initialOrbEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed orbital energy unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Spacecraft Translation and Rotation Integrated Sim Test\")\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def SCRotation(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    timeStep = 0.001\n    testProcessRate = macros.sec2nano(timeStep)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    dataLog = scObject.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Define initial conditions of the spacecraft\n    scObject.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    scObject.hub.omega_BN_BInit = [[0.5], [-0.4], [0.7]]\n\n    # BOE for rotational dynamics\n    h = numpy.dot(numpy.asarray(scObject.hub.IHubPntBc_B),numpy.asarray(scObject.hub.omega_BN_BInit).flatten())\n    H = numpy.linalg.norm(h)\n    n3_B = -h/H\n\n    # Find DCM\n    n2_B = numpy.zeros(3)\n    n2_B[1] = 0.1\n    n2_B[0] = -n2_B[1]*n3_B[1]/n3_B[0]\n    n2_B = n2_B/numpy.linalg.norm(n2_B)\n    n1_B = numpy.cross(n2_B,n3_B)\n    n1_B = n1_B/(numpy.linalg.norm(n1_B))\n    dcm_BN = numpy.zeros([3,3])\n    dcm_BN[:,0] = n1_B\n    dcm_BN[:,1] = n2_B\n    dcm_BN[:,2] = n3_B\n    h3_N = numpy.array([0,0,-H])\n    h3_B = numpy.dot(dcm_BN,h3_N)\n    h3_Ncheck = numpy.dot(dcm_BN.transpose(),h3_B)\n    sigmaCalc = RigidBodyKinematics.C2MRP(dcm_BN)\n    scObject.hub.sigma_BNInit = [[sigmaCalc[0]], [sigmaCalc[1]], [sigmaCalc[2]]]\n\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n\n    stopTime = 10.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n    rotAngMomMag = numpy.zeros(len(rotAngMom_N))\n    for i in range(0,len(rotAngMom_N)):\n        rotAngMomMag[i] = numpy.linalg.norm(numpy.asarray(rotAngMom_N[i,1:4]))\n\n    trueSigma = [\n                [5.72693314e-01,   5.10734375e-01,  -3.07377611e-01]\n                ]\n\n    initialRotAngMom_N = [\n                [numpy.linalg.norm(numpy.asarray(rotAngMom_N[0,1:4]))]\n                ]\n\n    finalRotAngMom = [\n                [numpy.linalg.norm(numpy.asarray(rotAngMom_N[-1,1:4]))]\n                 ]\n\n    initialRotEnergy = [\n                [rotEnergy[0,1]]\n                ]\n\n    finalRotEnergy = [\n                [rotEnergy[-1,1]]\n                 ]\n\n    moduleOutput = addTimeColumn(dataLog.times(), dataLog.sigma_BN)\n    omega_BNOutput = addTimeColumn(dataLog.times(), dataLog.omega_BN_B)\n\n    check = 0\n    for i in range(0,len(moduleOutput)):\n        if check == 0 and moduleOutput[i+1,2] < moduleOutput[i,2]:\n            check = 1\n        if check == 1 and moduleOutput[i+1,2] > moduleOutput[i,2]:\n            check = 2\n            index = i+1\n            break\n\n    sigmaBeforeSwitch = moduleOutput[index-1,1:4]\n    sigmaBeforeBefore = moduleOutput[index-2,1:4]\n    sigmaAfterSwitch = moduleOutput[index,:]\n    deltaT = (moduleOutput[index-1,0] - moduleOutput[index-2,0])*1e-9\n    yPrime = (sigmaBeforeSwitch - sigmaBeforeBefore)/deltaT\n    sigmaGhost = sigmaBeforeSwitch + yPrime*deltaT\n    sigmaAfterAnalytical = - sigmaGhost/numpy.dot(numpy.linalg.norm(numpy.asarray(sigmaGhost)),numpy.linalg.norm(numpy.asarray(sigmaGhost)))\n\n    timeArray = numpy.zeros(5)\n    sigmaArray = numpy.zeros([3,5])\n    omegaAnalyticalArray = numpy.zeros([3,5])\n    omegaArray = numpy.zeros([4,5])\n    for i in range(0, 5):\n        idx = int(stopTime/timeStep*(i+1)/5)\n        timeArray[i] = moduleOutput[idx, 0]\n        sigmaArray[:, i] = moduleOutput[idx, 1:4]\n        sigma = sigmaArray[:, i]\n        sigmaNorm = numpy.linalg.norm(sigma)\n        sigma1 = sigma[0]\n        sigma2 = sigma[1]\n        sigma3 = sigma[2]\n        omegaArray[:,i] = omega_BNOutput[idx, :]\n        omegaAnalyticalArray[0,i] = -H/(1 + sigmaNorm**2)**2*(8*sigma1*sigma3 - 4*sigma2*(1 - sigmaNorm**2))/scObject.hub.IHubPntBc_B[0][0]\n        omegaAnalyticalArray[1,i] = -H/(1 + sigmaNorm**2)**2*(8*sigma2*sigma3 + 4*sigma1*(1 - sigmaNorm**2))/scObject.hub.IHubPntBc_B[1][1]\n        omegaAnalyticalArray[2,i] = -H/(1 + sigmaNorm**2)**2*(4*(-sigma1**2 - sigma2**2 + sigma3**2) + (1 - sigmaNorm**2)**2)/scObject.hub.IHubPntBc_B[2][2]\n\n    plt.close(\"all\")    # clear out earlier figures\n\n    plt.figure()\n    plt.clf()\n    plt.plot(moduleOutput[:,0]*1e-9, moduleOutput[:,1], moduleOutput[:,0]*1e-9, moduleOutput[:,2], moduleOutput[:,0]*1e-9, moduleOutput[:,3])\n    plt.plot(moduleOutput[index,0]*1e-9, moduleOutput[index,1],'bo')\n    plt.plot(moduleOutput[index,0]*1e-9, sigmaGhost[0],'yo')\n    plt.plot(moduleOutput[index-1,0]*1e-9, moduleOutput[index-1,1],'bo')\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"MRPs\")\n    unitTestSupport.writeFigureLaTeX(\"scPlusMRPs\", \"Attitude of Spacecraft in MRPs\", plt, r\"width=0.8\\textwidth\", path)\n    plt.figure()\n    plt.clf()\n    plt.plot(moduleOutput[index - 3: index + 3,0]*1e-9, moduleOutput[index - 3: index + 3,1],\"b\")\n    plt.plot(moduleOutput[index-1,0]*1e-9, moduleOutput[index-1,1],'bo', label = \"Basilisk \" + r\"$\\sigma_{1,t-1}$\")\n    plt.plot(moduleOutput[index,0]*1e-9, moduleOutput[index,1],'ro', label = \"Basilisk \" + r\"$\\sigma_{1,t}$\")\n    plt.plot(moduleOutput[index,0]*1e-9, sigmaGhost[0],'ko', label = \"Basilisk \" + r\"$\\sigma_{1,0}$\")\n    plt.plot([moduleOutput[index-1,0]*1e-9, moduleOutput[index,0]*1e-9], [moduleOutput[index-1,1], sigmaGhost[0]],'--k')\n    axes = plt.gca()\n    axes.set_ylim([-0.5,0.5])\n    plt.legend(loc ='upper right',numpoints = 1)\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"MRPs\")\n    unitTestSupport.writeFigureLaTeX(\"scPlusMRPSwitching\", \"MRP Switching\", plt, r\"width=0.8\\textwidth\", path)\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom_N[:,0]*1e-9, (rotAngMomMag - rotAngMomMag[0])/rotAngMomMag[0])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    unitTestSupport.writeFigureLaTeX(\"scPlusChangeInRotationalAngularMomentumRotationOnly\", \"Change in Rotational Angular Momentum Rotation Only\", plt, r\"width=0.8\\textwidth\", path)\n    plt.figure()\n    plt.clf()\n    plt.plot(rotEnergy[:,0]*1e-9, (rotEnergy[:,1] - rotEnergy[0,1])/rotEnergy[0,1])\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Relative Difference\")\n    unitTestSupport.writeFigureLaTeX(\"scPlusChangeInRotationalEnergyRotationOnly\", \"Change in Rotational Energy Rotation Only\", plt, r\"width=0.8\\textwidth\", path)\n    plt.figure()\n    plt.clf()\n    plt.plot(omega_BNOutput[:,0]*1e-9,omega_BNOutput[:,1],label = r\"$\\omega_1$\" + \" Basilisk\")\n    plt.plot(omega_BNOutput[:,0]*1e-9,omega_BNOutput[:,2],label = r\"$\\omega_2$\" + \" Basilisk\")\n    plt.plot(omega_BNOutput[:,0]*1e-9,omega_BNOutput[:,3], label = r\"$\\omega_3$\" + \" Basilisk\")\n    plt.plot(timeArray*1e-9,omegaAnalyticalArray[0,:],'bo', label = r\"$\\omega_1$\" + \" BOE\")\n    plt.plot(timeArray*1e-9,omegaAnalyticalArray[1,:],'go', label = r\"$\\omega_2$\" + \" BOE\")\n    plt.plot(timeArray*1e-9,omegaAnalyticalArray[2,:],'ro', label = r\"$\\omega_3$\" + \" BOE\")\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Angular Velocity (rad/s)\")\n    plt.legend(loc ='lower right',numpoints = 1, prop = {'size': 6.5})\n    unitTestSupport.writeFigureLaTeX(\"scPlusBasiliskVsBOECalcForRotation\", \"Basilisk Vs BOE Calc For Rotation\", plt, r\"width=0.8\\textwidth\", path)\n    if show_plots:\n        plt.show()\n        plt.close(\"all\")\n\n    moduleOutput = dataLog.sigma_BN\n    accuracy = 1e-8\n    for i in range(0,len(trueSigma)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(moduleOutput[-1],trueSigma[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed attitude unit test\")\n\n    accuracy = 1e-10\n    for i in range(0,len(initialRotAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i],initialRotAngMom_N[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation and Rotation Integrated test failed rotational angular momentum unit test\")\n\n    for i in range(0,len(initialRotEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotEnergy[i],initialRotEnergy[i],1,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Rotation Integrated test failed rotational energy unit test\")\n\n    omegaArray = (numpy.delete(omegaArray, 0, 0)).transpose()\n    omegaAnalyticalArray = omegaAnalyticalArray.transpose()\n    for i in range(0,len(omegaAnalyticalArray)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(omegaArray[i],omegaAnalyticalArray[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Rotation Integrated test Rotational BOE unit test\")\n\n    accuracy = 1e-5\n    if not unitTestSupport.isArrayEqualRelative(numpy.delete(sigmaAfterSwitch, 0,), sigmaAfterAnalytical,1,accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: Spacecraft Rotation Integrated test failed MRP Switching unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"Spacecraft Rotation Integrated test\")\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def SCTransBOE(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    timeStep = 0.1\n    testProcessRate = macros.sec2nano(timeStep)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    # Define conditions for the forces and times\n    F1 = 3.\n    F2 = -7.\n    t1 = 3.\n    t2 = 6.\n    t3 = 10.\n\n    # Add external force and torque\n    extFTObject = extForceTorque.ExtForceTorque()\n    extFTObject.ModelTag = \"externalDisturbance\"\n    extFTObject.extTorquePntB_B = [[0], [0], [0]]\n    extFTObject.extForce_B = [[F1], [0], [0]]\n    scObject.addDynamicEffector(extFTObject)\n    unitTestSim.AddModelToTask(unitTaskName, extFTObject)\n\n    dataLog = scObject.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Define initial conditions of the spacecraft\n    scObject.hub.mHub = 100\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    # Set the initial values for the states\n    scObject.hub.r_CN_NInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.v_CN_NInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.omega_BN_BInit = [[0.0], [0.0], [0.0]]\n\n    unitTestSim.InitializeSimulation()\n\n    stopTime = t1\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    extFTObject.extTorquePntB_B = [[0], [0], [0]]\n    extFTObject.extForce_B = [[0], [0], [0]]\n\n    stopTime = t2\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    extFTObject.extTorquePntB_B = [[0], [0], [0]]\n    extFTObject.extForce_B = [[F2], [0], [0]]\n\n    stopTime = t3\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    r_BN_NOutput = addTimeColumn(dataLog.times(), dataLog.r_BN_N)\n    v_BN_NOutput = addTimeColumn(dataLog.times(), dataLog.v_BN_N)\n\n    # BOE calcs\n    a1 = F1/scObject.hub.mHub\n    a2 = F2/scObject.hub.mHub\n    v1 = a1*t1\n    v2 = v1\n    v3 = v2 + a2*(t3-t2)\n    x1 = 0.5*v1*t1\n    x2 = x1 + v2*(t2-t1)\n    t0 = t2 - v2/a2\n    x3 = x2 + 0.5*v2*(t0-t2) + 0.5*v3*(t3-t0)\n\n    # truth and Basilisk\n    truthV = [v1, v2, v3]\n    truthX = [x1, x2, x3]\n\n    basiliskV = [v_BN_NOutput[int(t1/timeStep), 1], v_BN_NOutput[int(t2/timeStep), 1], v_BN_NOutput[int(t3/timeStep), 1]]\n    basiliskX = [r_BN_NOutput[int(t1/timeStep), 1], r_BN_NOutput[int(t2/timeStep), 1], r_BN_NOutput[int(t3/timeStep), 1]]\n\n    plt.close('all')\n    plt.figure()\n    plt.clf()\n    plt.plot(r_BN_NOutput[:,0]*1e-9, r_BN_NOutput[:,1],'-b',label = \"Basilisk\")\n    plt.plot([t1, t2, t3], [x1, x2, x3],'ro',markersize = 6.5,label = \"BOE\")\n    plt.xlabel('time (s)')\n    plt.ylabel('X (m)')\n    plt.legend(loc ='upper left',numpoints = 1)\n    PlotName = \"scPlusTranslationPositionBOE\"\n    PlotTitle = \"Translation Position BOE\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(v_BN_NOutput[:,0]*1e-9, v_BN_NOutput[:,1],'-b',label = \"Basilisk\")\n    plt.plot([t1, t2, t3], [v1, v2, v3],'ro',markersize = 6.5,label = \"BOE\")\n    plt.xlabel('time (s)')\n    plt.ylabel('X velocity (m/s)')\n    plt.legend(loc ='lower left',numpoints = 1)\n    PlotName = \"scPlusTranslationVelocityBOE\"\n    PlotTitle = \"Translation Velocity BOE\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    accuracy = 1e-10\n    for i in range(0,3):\n        # check a vector values\n        if abs((truthX[i] - basiliskX[i])/truthX[i]) > accuracy:\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation BOE Integrated test failed pos unit test\")\n\n    for i in range(0,3):\n        # check a vector values\n        if abs((truthV[i] - basiliskV[i])/truthV[i]) > accuracy:\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Translation BOE Integrated test failed velocity unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Spacecraft Translation BOE Integrated Sim Test\")\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def SCPointBVsPointC(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.01)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    # Define location of force\n    rFBc_B = numpy.array([0.3, -0.7, 0.4])\n    force_B = numpy.array([0.5, 0.6, -0.2])\n    torquePntC_B = numpy.cross(rFBc_B,force_B)\n\n    # Add external force and torque\n    extFTObject = extForceTorque.ExtForceTorque()\n    extFTObject.ModelTag = \"externalDisturbance\"\n    extFTObject.extTorquePntB_B = [[torquePntC_B[0]], [torquePntC_B[1]], [torquePntC_B[2]]]\n    extFTObject.extForce_B = [[force_B[0]], [force_B[1]], [force_B[2]]]\n    scObject.addDynamicEffector(extFTObject)\n    unitTestSim.AddModelToTask(unitTaskName, extFTObject)\n\n    dataLog = scObject.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Define initial conditions of the spacecraft\n    scObject.hub.mHub = 100\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    scObject.hub.r_CN_NInit = [[0.0],\t[0.0],\t[0.0]]\n    scObject.hub.v_CN_NInit = [[0.0],\t[0.0],\t[0.0]]\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.omega_BN_BInit = [[0.5], [-0.4], [0.7]]\n\n    unitTestSim.InitializeSimulation()\n\n    stopTime = 10.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    r_CN_NOutput1 = addTimeColumn(dataLog.times(), dataLog.r_CN_N)\n    sigma_BNOutput1 = addTimeColumn(dataLog.times(), dataLog.sigma_BN)\n\n    ####################\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.01)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    # Define location of force\n    rBcB_B = numpy.array([0.4, 0.5, 0.2])\n    rFB_B = rBcB_B + rFBc_B\n    torquePntB_B = numpy.cross(rFB_B,force_B)\n\n    # Add external force and torque\n    extFTObject = extForceTorque.ExtForceTorque()\n    extFTObject.ModelTag = \"externalDisturbance\"\n    extFTObject.extTorquePntB_B = [[torquePntB_B[0]], [torquePntB_B[1]], [torquePntB_B[2]]]\n    extFTObject.extForce_B = [[force_B[0]], [force_B[1]], [force_B[2]]]\n    scObject.addDynamicEffector(extFTObject)\n    unitTestSim.AddModelToTask(unitTaskName, extFTObject)\n\n    dataLog2 = scObject.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog2)\n\n    # Define initial conditions of the spacecraft\n    scObject.hub.mHub = 100\n    scObject.hub.r_BcB_B = [[rBcB_B[0]], [rBcB_B[1]], [rBcB_B[2]]]\n    scObject.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    scObject.hub.r_CN_NInit = [[0.0],\t[0.0],\t[0.0]]\n    scObject.hub.v_CN_NInit = [[0.0],\t[0.0],\t[0.0]]\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.omega_BN_BInit = [[0.5], [-0.4], [0.7]]\n\n    unitTestSim.InitializeSimulation()\n\n    stopTime = 10.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    r_CN_NOutput2 = addTimeColumn(dataLog2.times(), dataLog2.r_CN_N)\n    sigma_BNOutput2 = addTimeColumn(dataLog2.times(), dataLog2.sigma_BN)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(r_CN_NOutput1[:,0]*1e-9, r_CN_NOutput1[:,1], 'k', label = 'Torque About Point C', linewidth=3.0)\n    plt.plot(r_CN_NOutput1[:,0]*1e-9,r_CN_NOutput1[:,2], 'k', r_CN_NOutput1[:,0]*1e-9, r_CN_NOutput1[:,3], 'k', linewidth=3.0)\n    plt.plot(r_CN_NOutput2[:,0]*1e-9, r_CN_NOutput2[:,1], '--c', label = 'Torque About Point B')\n    plt.plot(r_CN_NOutput2[:,0]*1e-9,r_CN_NOutput2[:,2], '--c', r_CN_NOutput2[:,0]*1e-9, r_CN_NOutput1[:,3], '--c')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Inertial Position (m)')\n    plt.legend(loc ='upper left', handlelength=3.5)\n    PlotName = \"scPlusPointBVsPointCTranslation\"\n    PlotTitle = \"PointB Vs PointC Translation\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n\n    plt.figure()\n    plt.clf()\n    plt.plot(sigma_BNOutput1[:,0]*1e-9, sigma_BNOutput1[:,1], 'k', label = 'Torque About Point C', linewidth=3.0)\n    plt.plot(sigma_BNOutput1[:,0]*1e-9, sigma_BNOutput1[:,2], 'k', sigma_BNOutput1[:,0]*1e-9, sigma_BNOutput1[:,3], 'k', linewidth=3.0)\n    plt.plot(sigma_BNOutput2[:,0]*1e-9, sigma_BNOutput2[:,1], '--c', label = 'Torque About Point B')\n    plt.plot(sigma_BNOutput2[:,0]*1e-9, sigma_BNOutput2[:,2], '--c', sigma_BNOutput2[:,0]*1e-9, sigma_BNOutput2[:,3], '--c')\n    plt.xlabel('Time (s)')\n    plt.ylabel('MRPs')\n    plt.legend(loc ='upper right', handlelength=3.5)\n    PlotName = \"scPlusPointBVsPointCAttitude\"\n    PlotTitle = \"PointB Vs PointC Attitude\"\n    format = r\"width=0.8\\textwidth\"\n    unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    accuracy = 1e-8\n    if not unitTestSupport.isArrayEqualRelative(r_CN_NOutput1[-1,1:4],r_CN_NOutput2[-1,1:4],3,accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: Spacecraft Point B Vs Point C test failed pos unit test\")\n\n    if not unitTestSupport.isArrayEqualRelative(sigma_BNOutput1[-1,1:4],sigma_BNOutput2[-1,1:4],3,accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: Spacecraft Point B Vs Point C test failed attitude unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Spacecraft Point B Vs Point C Integrated Sim Test\")\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def scOptionalRef(show_plots, accuracy):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    timeStep = 0.1\n    testProcessRate = macros.sec2nano(timeStep)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    dataLog = scObject.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # add Earth\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    earth = gravFactory.createEarth()\n    earth.isCentralBody = True  # ensure this is the central gravitational body\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    # add gravity gradient effector\n    ggEff = GravityGradientEffector.GravityGradientEffector()\n    ggEff.ModelTag = scObject.ModelTag\n    ggEff.addPlanetName(earth.planetName)\n    scObject.addDynamicEffector(ggEff)\n    unitTestSim.AddModelToTask(unitTaskName, ggEff)\n\n    # Define initial conditions of the spacecraft\n    scObject.hub.mHub = 100\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    scObject.hub.r_CN_NInit = [[7000000.0],\t[0.0],\t[0.0]]\n    scObject.hub.v_CN_NInit = [[7000.0],\t[0.0],\t[0.0]]\n    scObject.hub.sigma_BNInit = [[0.5], [0.4], [0.3]]\n    scObject.hub.sigma_BNInit = [[0.], [0.], [1.0]]\n    scObject.hub.omega_BN_BInit = [[0.5], [-0.4], [0.7]]\n\n    # write attitude reference message\n    attRef = messaging.AttRefMsgPayload()\n    attRef.sigma_RN = [0.0, 0.0, 1.0]\n    attRef.omega_RN_N = [0.0001, 0.0002, 0.0003]\n    attRefMsg = messaging.AttRefMsg().write(attRef)\n    scObject.attRefInMsg.subscribeTo(attRefMsg)\n\n    # write translational reference message\n    transRef = messaging.TransRefMsgPayload()\n    transRef.r_RN_N = [1000000, 2000000, 3000000]\n    transRef.v_RN_N = [2000, 3000, 4000]\n    transRefMsg = messaging.TransRefMsg().write(transRef)\n    scObject.transRefInMsg.subscribeTo(transRefMsg)\n\n    unitTestSim.InitializeSimulation()\n\n    stopTime = 0.2\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    omegaOut = dataLog.omega_BN_B\n    sigmaOut = dataLog.sigma_BN\n    r_RN_Out = dataLog.r_BN_N\n    v_RN_Out = dataLog.v_BN_N\n\n    trueSigma = [attRef.sigma_RN]*3\n    trueOmega = [[-0.0001, -0.0002, 0.0003]]*3\n    truer_RN_N = [transRef.r_RN_N]*3\n    truev_RN_N = [transRef.v_RN_N]*3\n\n    testFailCount, testMessages = unitTestSupport.compareArray(trueSigma, sigmaOut,\n                                                               accuracy, \"sigma_BN\",\n                                                               testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArray(trueOmega, omegaOut,\n                                                               accuracy, \"omega_BN_B\",\n                                                               testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArray(truer_RN_N, r_RN_Out,\n                                                               accuracy, \"r_RN_N\",\n                                                               testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArray(truev_RN_N, v_RN_Out,\n                                                               accuracy, \"v_RN_N\",\n                                                               testFailCount, testMessages)\n\n    if testFailCount == 0:\n        print(\"PASSED: scPlus setting optional reference state input message\")\n    else:\n        print(\"FAILED: scPlus setting optional reference state input message\")\n\n    assert testFailCount < 1, testMessages\n\n    return [testFailCount, ''.join(testMessages)]",
  "def scAccumDV():\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    timeStep = 0.1\n    testProcessRate = macros.sec2nano(timeStep)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    dataLog = scObject.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # add Earth\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    earth = gravFactory.createEarth()\n    earth.isCentralBody = True  # ensure this is the central gravitational body\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    # Define initial conditions of the spacecraft\n    scObject.hub.mHub = 100\n    scObject.hub.r_BcB_B = [[0.0], [100.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[500, 0.0, 0.0], [0.0, 200, 0.0], [0.0, 0.0, 300]]\n    scObject.hub.r_CN_NInit = [[-7000000.0],\t[0.0],\t[0.0]]\n    scObject.hub.v_CN_NInit = [[0.0],\t[7000.0],\t[0.0]]\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.omega_BN_BInit = [[0.0], [0.0], [numpy.pi/180]]\n\n    unitTestSim.InitializeSimulation()\n\n    stopTime = 0.5\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    dataAccumDV_CN_B = dataLog.TotalAccumDVBdy\n    dataAccumDV_BN_B = dataLog.TotalAccumDV_BN_B\n\n    accuracy = 1e-10\n    truth_dataAccumDV_CN_B = [0.0, 0.0, 0.0]\n    v_r = numpy.cross(numpy.array(scObject.hub.omega_BN_BInit).T, -numpy.array(scObject.hub.r_BcB_B).T)[0]\n    truth_dataAccumDV_BN_B = numpy.zeros(3)\n    for i in range(len(dataLog.times())-1):\n        if not unitTestSupport.isArrayEqual(dataAccumDV_CN_B[i+1],truth_dataAccumDV_CN_B,3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Point C Accumulated DV test failed pos unit test\")\n\n        truth_dataAccumDV_BN_B += numpy.matmul(RigidBodyKinematics.MRP2C(dataLog.sigma_BN[i+1]),\n                                              numpy.matmul(RigidBodyKinematics.MRP2C(dataLog.sigma_BN[i+1]).T,v_r) -\n                                              numpy.matmul(RigidBodyKinematics.MRP2C(dataLog.sigma_BN[i]).T,v_r))\n        if not unitTestSupport.isArrayEqual(dataAccumDV_BN_B[i+1],truth_dataAccumDV_BN_B,3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spacecraft Point B Accumulated DV test failed pos unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: Spacecraft Accumulated DV tests with offset CoM\")\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, offCount):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(\n            show_plots, offCount)\n    assert testResults < 1, testMessage",
  "def run(show_plots, offCount):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"testProcess\"\n\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    #\n    #  create the dynamics simulation process\n    #\n\n    dynProcess = scSim.CreateNewProcess(unitProcessName)\n    # create the dynamics task and specify the integration update time\n    dynProcess.addTask(scSim.CreateNewTask(unitTaskName, macros.sec2nano(0.1)))\n\n    testObject = ExtPulsedTorque.ExtPulsedTorque()\n    testObject.ModelTag = \"externalPulsedTorque\"\n\n    # These don't do anything. They are here to confirm they don't do anything\n    testObject.readInputMessages()\n    testObject.writeOutputMessages(0)\n\n    testObject.pulsedTorqueExternalPntB_B = [[-1], [1],[ -1]]\n    testObject.countOnPulse = 1\n    testObject.countOff = offCount\n\n    scSim.AddModelToTask(unitTaskName, testObject)\n\n    #\n    #   initialize the simulation\n    #\n    scSim.InitializeSimulation()\n\n    #\n    #   Setup data logging\n    #\n    DT = 0.1\n    testProcessRate = macros.sec2nano(DT)\n    variableTorque = \"torqueExternalPntB_B\"       # name the module variable to be logged\n    scSim.AddVariableForLogging (testObject.ModelTag + \".\" + variableTorque, testProcessRate, 0, 2, 'double')\n\n    #\n    #   run the simulation\n    #\n    for tStop in range(1, 11):\n        scSim.ConfigureStopTime(macros.sec2nano(tStop*DT))\n        scSim.ExecuteSimulation()\n        testObject.computeForceTorque(scSim.TotalSim.CurrentNanos, testProcessRate)\n        scSim.TotalSim.SingleStepProcesses()\n        scSim.RecordLogVars()\n\n    # log the data\n    dataTorque = scSim.GetLogVariableData(testObject.ModelTag+\".\"+variableTorque)\n\n    np.set_printoptions(precision=16)\n\n    # Remove time zero from list\n    dataTorque = dataTorque[1:len(dataTorque),:]\n    dataTorque = np.delete(dataTorque, 0, axis=1)  # remove time column\n\n    #\n    #   set true position information\n    #\n    if (offCount == 3):\n        trueTorque_B = [\n                  [0.0, 0.0, 0.0]\n                , [-1.0, 1.0, -1.0]\n                , [1.0, -1.0, 1.0]\n                , [0.0, 0.0, 0.0]\n                , [0.0, 0.0, 0.0]\n                , [0.0, 0.0, 0.0]\n                , [-1.0, 1.0, -1.0]\n                , [1.0, -1.0, 1.0]\n                , [0.0, 0.0, 0.0]\n                , [0.0, 0.0, 0.0]\n                , [0.0, 0.0, 0.0]\n        ]\n    if (offCount == 0):\n        trueTorque_B = [\n                  [0.0, 0.0, 0.0]\n                , [-1.0, 1.0, -1.0]\n                , [1.0, -1.0, 1.0]\n                , [-1.0, 1.0, -1.0]\n                , [1.0, -1.0, 1.0]\n                , [-1.0, 1.0, -1.0]\n                , [1.0, -1.0, 1.0]\n                , [-1.0, 1.0, -1.0]\n                , [1.0, -1.0, 1.0]\n                , [-1.0, 1.0, -1.0]\n                , [1.0, -1.0, 1.0]\n        ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n\n    if (len(trueTorque_B) != len(dataTorque)):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  ExtPulsedTorque failed torque unit test (unequal array sizes)\\n\")\n    else:\n        for i in range(0,len(trueTorque_B)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqual(dataTorque[i],trueTorque_B[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED:  ExtPulsedTorque failed torque unit test at t=\" + str(dataTorque[i,0]*macros.NANO2SEC) + \"sec\\n\")\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED \")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_scenarioSphericalPendulum(show_plots, useFlag, testCase):\n    \"\"\"This function is called by the py.test environment.\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = sphericalPendulumTest(show_plots, useFlag, testCase)\n    assert testResults < 1, testMessage",
  "def sphericalPendulumTest(show_plots, useFlag,testCase):\n    \"\"\"Call this routine directly to run the test scenario.\"\"\"\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n\n    if testCase == 1 or testCase ==  3:\n        timeStep = 0.01\n    if testCase == 2:\n        timeStep = 0.001\n\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n    # create simulation\n    scSim=SimulationBaseClass.SimBaseClass()\n    # close possible other simulation\n    #crete a dynamical process\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n    simulationTimeStep = macros.sec2nano(timeStep)\n    # add task to the dynamical process\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    #  create spacecraft object\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    scSim.AddModelToTask(simTaskName, scObject)\n\n    # Pendulum 1\n    scSim.pendulum1 = sphericalPendulum.SphericalPendulum()\n    # Define Variables for pendulum 1\n    scSim.pendulum1.pendulumRadius = 0.3  #  m/s\n    scSim.pendulum1.d = [[0.1], [0.1], [0.1]] # m\n    scSim.pendulum1.D = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]] # N*s/m\n    scSim.pendulum1.phiDotInit = 0.01 # rad/s\n    scSim.pendulum1.thetaDotInit = 0.05 # rad/s\n    scSim.pendulum1.massInit = 20.0 # kg\n    scSim.pendulum1.pHat_01=[[np.sqrt(2)/2], [0] , [np.sqrt(2)/2]] # first unit vector of the Pendulum frame\n    scSim.pendulum1.pHat_02=[[0],[1],[0]]\t\t\t               # second unit vector of the Pendulum frame\n    scSim.pendulum1.pHat_03=[[-np.sqrt(2)/2],[0],[np.sqrt(2)/2]]   # third unit vector of the Pendulum frame\n\n    # Pendulum 2\n    scSim.pendulum2 = sphericalPendulum.SphericalPendulum()\n    # Define Variables for pendulum 2\n    scSim.pendulum2.pendulumRadius = 0.4  #  m/s\n    scSim.pendulum2.d = [[0.1], [0.1], [0.1]] # m\n    scSim.pendulum2.D = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]] # N*s/m\n    scSim.pendulum2.phiDotInit = 0.1 # rad/s\n    scSim.pendulum2.thetaDotInit = 0.5 # rad/s\n    scSim.pendulum2.massInit =40.0 # kg\n    # Pendulum frame same as Body frame\n\n    if testCase == 3:\n        # add thruster devices\n        thFactory = simIncludeThruster.thrusterFactory()\n        thFactory.create('MOOG_Monarc_445',\n                                  [1,0,0],                # location in S frame\n                                  [0,1,0]                 # direction in S frame\n                                  )\n\n\n        # create thruster object container and tie to spacecraft object\n        thrustersDynamicEffector = thrusterDynamicEffector.ThrusterDynamicEffector()\n        thFactory.addToSpacecraft(\"Thrusters\",\n                                  thrustersDynamicEffector,\n                                  scObject)\n\n        scSim.fuelTankStateEffector = fuelTank.FuelTank()\n        scSim.fuelTankStateEffector.setTankModel(fuelTank.TANK_MODEL_CONSTANT_VOLUME)\n        tankModel = fuelTank.cvar.FuelTankModelConstantVolume\n        tankModel.propMassInit = 40.0\n        tankModel.r_TcT_TInit = [[0.0],[0.0],[0.0]]\n        scSim.fuelTankStateEffector.r_TB_B = [[0.0],[0.0],[0.0]]\n        tankModel.radiusTankInit = 46.0 / 2.0 / 3.2808399 / 12.0\n\n        # Add tank and thruster\n        scObject.addStateEffector(scSim.fuelTankStateEffector)\n        scSim.fuelTankStateEffector.addThrusterSet(thrustersDynamicEffector)\n\n        # set thruster commands\n        ThrustMessage = messaging.THRArrayOnTimeCmdMsgPayload()\n        ThrustMessage.OnTimeRequest = [5.0]\n        thrCmdMsg = messaging.THRArrayOnTimeCmdMsg().write(ThrustMessage)\n        thrustersDynamicEffector.cmdsInMsg.subscribeTo(thrCmdMsg)\n\n        # Add test module to runtime call list\n        scSim.AddModelToTask(simTaskName, scSim.fuelTankStateEffector)\n        scSim.AddModelToTask(simTaskName, thrustersDynamicEffector)\n\n        fuelLog = scSim.fuelTankStateEffector.fuelTankOutMsg.recorder()\n        scSim.AddModelToTask(simTaskName, fuelLog)\n\n        # Add particles to tank to activate mass depletion\n        scSim.fuelTankStateEffector.pushFuelSloshParticle(scSim.pendulum1)\n        scSim.fuelTankStateEffector.pushFuelSloshParticle(scSim.pendulum2)\n\n    # define hub properties\n    scObject.hub.mHub = 1500 # kg\n    scObject.hub.r_BcB_B = [[1.0], [0.5], [0.1]] # m\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]] # kg*m^2\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]] # rad\n    scObject.hub.omega_BN_BInit = [[1.0], [0.5], [0.1]] # rad/s\n\n    # Add fuel slosh to spacecraft\n    scObject.addStateEffector(scSim.pendulum1)\n    scObject.addStateEffector(scSim.pendulum2)\n\n    # call for a fresh copy of the gravitational body factory\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    planet = gravFactory.createEarth()\n    planet.isCentralBody = True  # ensure this is the central gravitational body\n\n    planetRadius = planet.radEquator\n    mu = planet.mu\n\n    # attach gravity to the spacecraft\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    # initialize orbital elements\n    oe = orbitalMotion.ClassicElements()\n    oe.a=6700.0*1000\n    oe.e=0.01\n    oe.omega=100.0*macros.D2R\n    oe.Omega=100.0*macros.D2R\n    oe.i=30.0*macros.D2R\n    oe.f=0.0\n    # convert them in position and velocity\n    rN, vN = orbitalMotion.elem2rv(mu, oe)\n\n    # attach the state to the spacecraft\n    scObject.hub.r_CN_NInit = rN  # m   - r_BN_N\n    scObject.hub.v_CN_NInit = vN  # m/s - v_BN_N\n\n    simulationTime = macros.sec2nano(10)\n\n    #\n    #   Setup data logging before the simulation is initialized\n    #\n    numDataPoints = 100\n    samplingTime = unitTestSupport.samplingTime(simulationTime, simulationTimeStep, numDataPoints)\n    dataLog = scObject.scStateOutMsg.recorder(samplingTime)\n    scSim.AddModelToTask(simTaskName, dataLog)\n\n    #   initialize Simulation:  This function clears the simulation log, and runs the self_init()\n    #   cross_init() and reset() routines on each module.\n    #   If the routine InitializeSimulationAndDiscover() is run instead of InitializeSimulation(),\n    #   then the all messages are auto-discovered that are shared across different BSK threads.\n    #\n    scSim.InitializeSimulation()\n\n    scSim.AddVariableForLogging(scObject.ModelTag + \".totOrbEnergy\", simulationTimeStep, 0, 0, 'double')\n    scSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", simulationTimeStep, 0, 2, 'double')\n    scSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", simulationTimeStep, 0, 2, 'double')\n    scSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", simulationTimeStep, 0, 0, 'double')\n    scSim.AddVariableForLogging(\"spacecraftBody.dynManager.getStateObject('sphericalPendulumPhi1').getState()\", simulationTimeStep, 0, 0, 'double')\n    scSim.AddVariableForLogging(\"spacecraftBody.dynManager.getStateObject('sphericalPendulumTheta1').getState()\", simulationTimeStep, 0, 0, 'double')\n    scSim.AddVariableForLogging(\"spacecraftBody.dynManager.getStateObject('sphericalPendulumThetaDot1').getState()\", simulationTimeStep, 0, 0, 'double')\n    scSim.AddVariableForLogging(\"spacecraftBody.dynManager.getStateObject('sphericalPendulumPhiDot1').getState()\", simulationTimeStep, 0, 0, 'double')\n    if testCase == 3:\n        scSim.AddVariableForLogging(\n            \"spacecraftBody.dynManager.getStateObject('sphericalPendulumMass1').getState()\", simulationTimeStep, 0, 0, 'double')\n        scSim.AddVariableForLogging(\n            \"spacecraftBody.dynManager.getStateObject('sphericalPendulumMass2').getState()\", simulationTimeStep, 0, 0, 'double')\n\n    #\n    #   configure a simulation stop time and execute the simulation run\n    #\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    if testCase == 3:\n        fuelMass = fuelLog.fuelMass\n        fuelMassDot = fuelLog.fuelMassDot\n        mass1Out = scSim.GetLogVariableData(\n            \"spacecraftBody.dynManager.getStateObject('sphericalPendulumMass1').getState()\")\n        mass2Out = scSim.GetLogVariableData(\n            \"spacecraftBody.dynManager.getStateObject('sphericalPendulumMass2').getState()\")\n\n    # request energy and momentum\n    orbEnergy = scSim.GetLogVariableData(scObject.ModelTag + \".totOrbEnergy\")\n    orbAngMom_N = scSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = scSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n    rotEnergy = scSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n\n    if timeStep == 0.01:\n        testCaseName = \"OneHundredth\"\n    if timeStep == 0.001:\n        testCaseName = \"OneThousandth\"\n\n    plt.close(\"all\")  # clears out plots from earlier test runs\n\n    if testCase != 3:\n        plt.figure(1,figsize=(5,4))\n        plt.plot(orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,1] - orbAngMom_N[0,1])/orbAngMom_N[0,1], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,2] - orbAngMom_N[0,2])/orbAngMom_N[0,2], orbAngMom_N[:,0]*1e-9, (orbAngMom_N[:,3] - orbAngMom_N[0,3])/orbAngMom_N[0,3])\n        plt.xlabel('Time (s)')\n        plt.ylabel('Relative Orbital Angular Momentum Variation')\n        unitTestSupport.writeFigureLaTeX(\"ChangeInOrbitalAngularMomentum\" + testCaseName, \"Change in Orbital Angular Momentum \" + testCaseName, plt, r\"width=0.8\\textwidth\", path)\n\n        plt.figure(2,figsize=(5,4))\n        plt.plot(orbEnergy[:,0]*1e-9, (orbEnergy[:,1] - orbEnergy[0,1])/orbEnergy[0,1])\n        plt.xlabel('Time (s)')\n        plt.ylabel('Relative Orbital Energy Variation')\n        unitTestSupport.writeFigureLaTeX(\"ChangeInOrbitalEnergy\" + testCaseName, \"Change in Orbital Energy \" + testCaseName, plt, r\"width=0.8\\textwidth\", path)\n\n        plt.figure(3,figsize=(5,4))\n        plt.plot(rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,1] - rotAngMom_N[0,1])/rotAngMom_N[0,1], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,2] - rotAngMom_N[0,2])/rotAngMom_N[0,2], rotAngMom_N[:,0]*1e-9, (rotAngMom_N[:,3] - rotAngMom_N[0,3])/rotAngMom_N[0,3])\n        plt.xlabel('Time (s)')\n        plt.ylabel('Relative Rotational Angular Momentum Variation')\n        unitTestSupport.writeFigureLaTeX(\"ChangeInRotationalAngularMomentum\" + testCaseName, \"Change in Rotational Angular Momentum \" + testCaseName, plt, r\"width=0.8\\textwidth\", path)\n\n        plt.figure(4,figsize=(5,4))\n        plt.plot(rotEnergy[:,0]*1e-9, (rotEnergy[:,1] - rotEnergy[0,1])/rotEnergy[0,1])\n        plt.xlabel('Time (s)')\n        plt.ylabel('Relative Rotational Energy Variation')\n        unitTestSupport.writeFigureLaTeX(\"ChangeInRotationalEnergy\" + testCaseName, \"Change in Rotational Energy \" + testCaseName, plt, r\"width=0.8\\textwidth\", path)\n    if testCase == 3:\n        plt.figure()\n        plt.plot(fuelLog.times()*1e-9, fuelMass)\n        plt.title(\"Tank Fuel Mass\")\n        plt.figure()\n        plt.plot(fuelLog.times()*1e-9, fuelMassDot)\n        plt.title(\"Tank Fuel Mass Dot\")\n        plt.figure()\n        plt.plot(mass1Out[:,0]*1e-9, mass1Out[:,1])\n        plt.title(\"Fuel Particle 1 Mass\")\n        plt.figure()\n        plt.plot(mass2Out[:,0]*1e-9, mass2Out[:,1])\n        plt.title(\"Fuel Particle 2 Mass\")\n        mDotFuel = -0.19392039093\n        mDotParicle1True = mDotFuel*(20./100.)\n        mDotParicle2True = mDotFuel*(40./100.)\n        mDotParicle1Data = [0,(mass1Out[2,1] - mass1Out[1,1])/((mass1Out[2,0] - mass1Out[1,0])*1e-9)]\n        mDotParicle2Data = [0,(mass2Out[2,1] - mass2Out[1,1])/((mass2Out[2,0] - mass2Out[1,0])*1e-9)]\n\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    if testCase != 3:\n        accuracy = 1e-8\n        for k in range(len((rotAngMom_N[:,1]))):\n            if abs((rotAngMom_N[k,1] - rotAngMom_N[0,1])/rotAngMom_N[0,1])>accuracy:\n                testFailCount += 1\n                testMessages.append(\"FAILED: SphericalPendulum does not conserve Rotational Angular Momentum around x axes (timeStep={}s)\".format(timeStep))\n            if abs((rotAngMom_N[k,2] - rotAngMom_N[0,2])/rotAngMom_N[0,2])>accuracy:\n                testFailCount += 1\n                testMessages.append(\"FAILED: SphericalPendulum does not conserve Rotational Angular Momentum around y axes (timeStep={}s)\".format(timeStep))\n            if abs((rotAngMom_N[k,3] - rotAngMom_N[0,3])/rotAngMom_N[0,3])>accuracy:\n                testFailCount += 1\n                testMessages.append(\"FAILED: SphericalPendulum does not conserve Rotational Angular Momentum around z axes (timeStep={}s)\".format(timeStep))\n            if abs((orbAngMom_N[k,1] - orbAngMom_N[0,1])/orbAngMom_N[0,1])>accuracy:\n                testFailCount += 1\n                testMessages.append(\"FAILED: SphericalPendulum does not conserve Orbital Angular Momentum around x axes (timeStep={}s)\".format(timeStep))\n            if abs((orbAngMom_N[k,2] - orbAngMom_N[0,2])/orbAngMom_N[0,2])>accuracy:\n                testFailCount += 1\n                testMessages.append(\"FAILED: SphericalPendulum does not conserve Orbital Angular Momentum around y axes (timeStep={}s)\".format(timeStep))\n            if abs((orbAngMom_N[k,3] - orbAngMom_N[0,3])/orbAngMom_N[0,3])>accuracy:\n                testFailCount += 1\n                testMessages.append(\"FAILED: SphericalPendulum does not conserve Orbital Angular Momentum around z axes (timeStep={}s)\".format(timeStep))\n            if abs((rotEnergy[k,1] - rotEnergy[0,1])/rotEnergy[0,1])>accuracy:\n                testFailCount += 1\n                testMessages.append(\"FAILED: SphericalPendulum does not conserve Rotational Energy (timeStep={}s)\".format(timeStep))\n            if abs((orbEnergy[k,1] - orbEnergy[0,1])/orbEnergy[0,1])>accuracy:\n                testFailCount += 1\n                testMessages.append(\"FAILED: SphericalPendulum does not conserve Orbital Energy (timeStep={}s)\".format(timeStep))\n    if testCase == 3:\n        accuracy = 1e-4\n        if not unitTestSupport.isDoubleEqual(mDotParicle1Data[1],mDotParicle1True,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Linear Spring Mass Damper unit test failed mass 1 dot test\")\n        if not unitTestSupport.isDoubleEqual(mDotParicle2Data[1],mDotParicle2True,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Linear Spring Mass Damper unit test failed mass 2 dot test\")\n\n    if testFailCount == 0:\n        print(\"PASSED \")\n    else:\n        print(testFailCount)\n        print(testMessages)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def loadGravFromFile(fileName, spherHarm, maxDeg=2):\n\n    with open(fileName, 'r') as csvfile:\n        gravReader = csv.reader(csvfile, delimiter=',')\n        firstRow = next(gravReader)\n        clmList = []\n        slmList = []\n        try:\n            valCurr = int(firstRow[0])\n        except ValueError:\n            spherHarm.muBody = float(firstRow[1])\n            spherHarm.radEquator = float(firstRow[0])\n\n        clmRow = []\n        slmRow = []\n        currDeg = 0\n        for gravRow in gravReader:\n           while int(gravRow[0]) > currDeg:\n               if( len(clmRow) < currDeg+1):\n                   clmRow.extend([0.0]*(currDeg+1 - len(clmRow)))\n                   slmRow.extend([0.0]*(currDeg+1 - len(slmRow)))\n               clmList.append(clmRow)\n               slmList.append(slmRow)\n               clmRow = []\n               slmRow = []\n               currDeg += 1\n           clmRow.append(float(gravRow[2]))\n           slmRow.append(float(gravRow[3]))\n\n        spherHarm.cBar = sim_model.MultiArray(clmList)\n        spherHarm.sBar = sim_model.MultiArray(slmList)\n        spherHarm.maxDeg = maxDeg",
  "def loadGravFromFileToList(fileName, maxDeg=2):\n    with open(fileName, 'r') as csvfile:\n        gravReader = csv.reader(csvfile, delimiter=',')\n        firstRow = next(gravReader)\n        clmList = []\n        slmList = []\n        try:\n            valCurr = int(firstRow[0])\n        except ValueError:\n            mu = float(firstRow[1])\n            radEquator = float(firstRow[0])\n\n        clmRow = []\n        slmRow = []\n        currDeg = 0\n        for gravRow in gravReader:\n            while int(gravRow[0]) > currDeg:\n                if (len(clmRow) < currDeg + 1):\n                    clmRow.extend([0.0] * (currDeg + 1 - len(clmRow)))\n                    slmRow.extend([0.0] * (currDeg + 1 - len(slmRow)))\n                clmList.append(clmRow)\n                slmList.append(slmRow)\n                clmRow = []\n                slmRow = []\n                currDeg += 1\n            clmRow.append(float(gravRow[2]))\n            slmRow.append(float(gravRow[3]))\n\n        return [clmList, slmList, mu, radEquator]",
  "def loadPolyFromFile(fileName, poly):\n    with open(fileName) as polyFile:\n        if fileName.endswith('.tab'):\n            try:\n                nVertex, nFacet = [int(x) for x in next(polyFile).split()] # read first line\n                fileType = 'gaskell'\n            except:\n                polyFile.seek(0)\n                fileType = 'pds3'\n\n            vertList = []\n            faceList = []\n            if fileType == 'gaskell':\n                contLines = 0\n                for line in polyFile:\n                    arrtemp = []\n\n                    for x in line.split():\n                        arrtemp.append(float(x))\n\n                    if contLines < nVertex:\n                        vertList.append([float(arrtemp[1]*1e3),float(arrtemp[2]*1e3),float(arrtemp[3]*1e3)])\n                    else:\n                        faceList.append([int(arrtemp[1]),int(arrtemp[2]),int(arrtemp[3])])\n\n                    contLines += 1\n            elif fileType == 'pds3':\n                nVertex = 0\n                nFacet = 0\n                vertList = []\n                faceList = []\n                for line in polyFile:\n                    arrtemp = line.split()\n                    if arrtemp:\n                        if arrtemp[0] == 'v':\n                            nVertex += 1\n                            vertList.append([float(arrtemp[1])*1e3, float(arrtemp[2])*1e3, float(arrtemp[3])*1e3])\n                        elif arrtemp[0] == 'f':\n                            nFacet += 1\n                            faceList.append([int(arrtemp[1])+1, int(arrtemp[2])+1, int(arrtemp[3])+1])\n        elif fileName.endswith('.obj'):\n            nVertex = 0\n            nFacet = 0\n            vertList = []\n            faceList = []\n            for line in polyFile:\n                arrtemp = line.split()\n                if arrtemp:\n                    if arrtemp[0] == 'v':\n                        nVertex += 1\n                        vertList.append([float(arrtemp[1])*1e3, float(arrtemp[2])*1e3, float(arrtemp[3])*1e3])\n                    elif arrtemp[0] == 'f':\n                        nFacet += 1\n                        faceList.append([int(arrtemp[1]), int(arrtemp[2]), int(arrtemp[3])])\n        elif fileName.endswith('.txt'):\n            nVertex, nFacet = [int(x) for x in next(polyFile).split()] # read first line\n            vertList = []\n            faceList = []\n\n            contLines = 0\n            for line in polyFile:\n                arrtemp = []\n\n                for x in line.split():\n                    arrtemp.append(float(x))\n\n                if contLines < nVertex:\n                    vertList.append([float(arrtemp[0]*1e3),float(arrtemp[1]*1e3),float(arrtemp[2]*1e3)])\n                else:\n                    faceList.append([int(arrtemp[0]),int(arrtemp[1]),int(arrtemp[2])])\n\n                contLines += 1\n\n        poly.nVertex = nVertex\n        poly.nFacet = nFacet\n        poly.xyzVertex = vertList\n        poly.orderFacet = faceList",
  "def loadPolyFromFileToList(fileName):\n    with open(fileName) as polyFile:\n        if fileName.endswith('.tab'):\n            try:\n                nVertex, nFacet = [int(x) for x in next(polyFile).split()] # read first line\n                fileType = 'gaskell'\n            except:\n                polyFile.seek(0)\n                fileType = 'pds3'\n\n            if fileType == 'gaskell':\n                vertList = []\n                faceList = []\n\n                contLines = 0\n                for line in polyFile:\n                    arrtemp = []\n\n                    for x in line.split():\n                        arrtemp.append(float(x))\n\n                    if contLines < nVertex:\n                        vertList.append([float(arrtemp[1]*1e3),float(arrtemp[2]*1e3),float(arrtemp[3]*1e3)])\n                    else:\n                        faceList.append([int(arrtemp[1]),int(arrtemp[2]),int(arrtemp[3])])\n\n                    contLines += 1\n            elif fileType == 'pds3':\n                nVertex = 0\n                nFacet = 0\n                vertList = []\n                faceList = []\n                for line in polyFile:\n                    arrtemp = line.split()\n                    if arrtemp:\n                        if arrtemp[0] == 'v':\n                            nVertex += 1\n                            vertList.append([float(arrtemp[1])*1e3, float(arrtemp[2])*1e3, float(arrtemp[3])*1e3])\n                        elif arrtemp[0] == 'f':\n                            nFacet += 1\n                            faceList.append([int(arrtemp[1])+1, int(arrtemp[2])+1, int(arrtemp[3])+1])\n        elif fileName.endswith('.obj'):\n            nVertex = 0\n            nFacet = 0\n            vertList = []\n            faceList = []\n            for line in polyFile:\n                arrtemp = line.split()\n                if arrtemp:\n                    if arrtemp[0] == 'v':\n                        nVertex += 1\n                        vertList.append([float(arrtemp[1])*1e3, float(arrtemp[2])*1e3, float(arrtemp[3])*1e3])\n                    elif arrtemp[0] == 'f':\n                        nFacet += 1\n                        faceList.append([int(arrtemp[1]), int(arrtemp[2]), int(arrtemp[3])])\n        elif fileName.endswith('.txt'):\n            nVertex, nFacet = [int(x) for x in next(polyFile).split()] # read first line\n            vertList = []\n            faceList = []\n\n            contLines = 0\n            for line in polyFile:\n                arrtemp = []\n\n                for x in line.split():\n                    arrtemp.append(float(x))\n\n                if contLines < nVertex:\n                    vertList.append([float(arrtemp[0]*1e3),float(arrtemp[1]*1e3),float(arrtemp[2]*1e3)])\n                else:\n                    faceList.append([int(arrtemp[0]),int(arrtemp[1]),int(arrtemp[2])])\n\n                contLines += 1\n\n        return [vertList, faceList, nVertex, nFacet]",
  "def computeGravityTo20(positionVector):\n    #This code follows the formulation in Vallado, page 521, second edition and uses data from UTexas CSR for\n    #gravitation harmonics parameters\n    #Written 201780807 by Scott Carnahan\n    #AVS Lab | CU Boulder\n\n    #INPUTS\n    #positionVector - [x,y,z] coordinates list of spacecraft in [m] in earth body frame so that lat, long can be calculated\n\n    def legendres(degree, alpha):\n        P = np.zeros((degree+1,degree+1))\n        P[0,0] = 1\n        P[1,0] = alpha\n        cosPhi = np.sqrt(1-alpha**2)\n        P[1,1] = cosPhi\n\n        for l in range(2,degree+1):\n            for m in range(0,l+1):\n                if m == 0 and l >= 2:\n                    P[l,m] = ((2*l-1)*alpha*P[l-1,0]-(l-1)*P[l-2,0]) / l\n                elif m != 0 and m < l:\n                    P[l, m] = (P[l-2, m]+(2*l-1)*cosPhi*P[l-1,m-1])\n                elif m == l and l != 0:\n                    P[l,m] = (2*l-1)*cosPhi*P[l-1,m-1]\n                else:\n                    print(l,\", \", m)\n        return P\n\n    maxDegree = 20\n    cList = np.zeros(maxDegree+2)\n    sList = np.zeros(maxDegree+2)\n    muEarth = 0.\n    radEarth = 0.\n    [cList, sList, muEarth, radEarth]  = loadGravFromFileToList(path + '/GGM03S.txt', maxDegree+2)\n\n    r = np.linalg.norm(positionVector)\n    rHat = positionVector / r\n    gHat = rHat\n    grav0 = -gHat * muEarth / r**2\n\n    rI = positionVector[0]\n    rJ = positionVector[1]\n    rK = positionVector[2]\n\n    rIJ = np.sqrt(rI**2 + rJ**2)\n    if rIJ != 0.:\n        phi = math.atan(rK / rIJ) #latitude in radians\n    else:\n        phi = math.copysign(np.pi/2., rK)\n    if rI != 0.:\n        lambdaSat = math.atan(rJ / rI) #longitude in radians\n    else:\n        lambdaSat = math.copysign(np.pi/2., rJ)\n\n    P = legendres(maxDegree+1,np.sin(phi))\n\n    dUdr = 0.\n    dUdphi = 0.\n    dUdlambda = 0.\n\n    for l in range(0, maxDegree+1):\n        for m in range(0,l+1):\n            if m == 0:\n                k = 1\n            else:\n                k = 2\n            num = math.factorial(l+m)\n            den = math.factorial(l-m)*k*(2*l+1)\n            PI = np.sqrt(float(num)/float(den))\n            cList[l][m] = cList[l][m] / PI\n            sList[l][m] = sList[l][m] / PI\n\n    for l in range(2,maxDegree+1): #can only do for max degree minus 1\n        for m in range(0,l+1):\n            dUdr = dUdr + (((radEarth/r)**l)*(l+1)*P[l,m]) * (cList[l][m]*np.cos(m*lambdaSat)+sList[l][m]*np.sin(m*lambdaSat))\n            dUdphi = dUdphi + (((radEarth/r)**l)*P[l,m+1] - m*np.tan(phi)*P[l,m]) * (cList[l][m]*np.cos(m*lambdaSat) + sList[l][m]*np.sin(m*lambdaSat))\n            dUdlambda = dUdlambda + (((radEarth/r)**l)*m*P[l,m]) * (sList[l][m]*np.cos(m*lambdaSat) - cList[l][m]*np.sin(m*lambdaSat))\n\n    dUdr = -muEarth * dUdr / r**2\n    dUdphi = muEarth * dUdphi / r\n    dUdlambda = muEarth * dUdlambda / r\n\n\n    if rI != 0. and rJ != 0.:\n        accelerationI = (dUdr/r - rK*dUdphi/(r**2)/((rI**2+rJ**2)**0.5))*rI - (dUdlambda/(rI**2+rJ**2))*rJ + grav0[0]\n        accelerationJ = (dUdr/r - rK*dUdphi/(r**2)/((rI**2+rJ**2)**0.5))*rJ + (dUdlambda/(rI**2+rJ**2))*rI + grav0[1]\n    else:\n        accelerationI = dUdr/r + grav0[0]\n        accelerationJ = dUdr/r + grav0[1]\n    accelerationK = (dUdr/r)*rK + (((rI**2+rJ**2)**0.5)*dUdphi/(r**2)) + grav0[2]\n\n    accelerationVector = [accelerationI, accelerationJ, accelerationK]\n\n    return accelerationVector",
  "def test_gravityEffectorAllTest(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = independentSphericalHarmonics(show_plots)\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = sphericalHarmonics(show_plots)\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = singleGravityBody(show_plots)\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = multiBodyGravity(show_plots)\n    assert testResults < 1, testMessage",
  "def independentSphericalHarmonics(show_plots):\n    testCase = \"independentCheck\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    spherHarm = gravityEffector.SphericalHarmonics()\n\n    gravityEffector.loadGravFromFile(path + '/GGM03S.txt', spherHarm, 20)\n    gravCheck = computeGravityTo20([15000., 10000., 6378.1363E3])\n    spherHarm.initializeParameters()\n    gravOut = spherHarm.computeField([[15000.0], [10000.0], [(6378.1363) * 1.0E3]], 20, True)\n    gravOutMag = np.linalg.norm(gravOut)\n    gravCheckMag = np.linalg.norm(gravCheck)\n\n    accuracy = 1e-12\n    relative = (gravCheckMag-gravOutMag)/gravCheckMag\n    if abs(relative) > accuracy:\n        testFailCount += 1\n        testMessages.append(\"Failed independent spherical harmonics check\")\n    snippetName = testCase + 'Accuracy'\n    snippetContent = '{:1.1e}'.format(accuracy)  # write formatted LATEX string to file to be used by auto-documentation.\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent,\n                                    path)  # write formatted LATEX string to file to be used by auto-documentation.\n\n    if testFailCount == 0:\n        passFailText = 'PASSED'\n        print(\"PASSED: \" + testCase)\n        colorText = 'ForestGreen'  # color to write auto-documented \"PASSED\" message in in LATEX.\n        snippetName = testCase + 'FailMsg'\n        snippetContent = \"\"\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent,\n                                        path)  # write formatted LATEX string to file to be used by auto-documentation.\n    else:\n        passFailText = 'FAILED'\n        colorText = 'Red'  # color to write auto-documented \"FAILED\" message in in LATEX\n        snippetName = testCase + 'FailMsg'\n        snippetContent = passFailText\n        for message in testMessages:\n            snippetContent += \". \" + message\n        snippetContent += \".\"\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent,\n                                        path)  # write formatted LATEX string to file to be used by auto-documentation.\n    snippetName = testCase + 'PassFail'  # name of file to be written for auto-documentation which specifies if this test was passed or failed.\n    snippetContent = r'\\textcolor{' + colorText + '}{' + passFailText + '}'  # write formatted LATEX string to file to be used by auto-documentation.\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent,\n                                    path)  # write formatted LATEX string to file to be used by auto-documentation.\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def sphericalHarmonics(show_plots):\n    testCase = 'sphericalHarmonics'\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    spherHarm = gravityEffector.SphericalHarmonics()\n\n    testHarm = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n\n    spherHarm.cBar = gravityEffector.MultiArray(testHarm)\n\n    vecCheckSuccess = True\n    for i in range(len(spherHarm.cBar)):\n        for j in range(len(spherHarm.cBar[i])):\n            if spherHarm.cBar[i][j] != testHarm[i][j]:\n                vecCheckSuccess = False\n\n\n    if(vecCheckSuccess != True):\n        testFailCount += 1\n        testMessages.append(\"2D vector not input appropriately to spherical harmonics\")\n\n    gravityEffector.loadGravFromFile(path + '/GGM03S.txt', spherHarm, 20)\n    spherHarm.initializeParameters()\n    gravOut = spherHarm.computeField([[0.0], [0.0], [(6378.1363)*1.0E3]], 20, True)\n    gravMag = np.linalg.norm(np.array(gravOut))\n\n    accuracy = 0.1\n    gravExpected = 9.8\n    if gravMag > (gravExpected + accuracy) or gravMag < (gravExpected - accuracy):\n        testFailCount += 1\n        testMessages.append(\"Gravity magnitude not within allowable tolerance\")\n    snippetName = testCase + 'Accuracy'\n    snippetContent = '{:1.1e}'.format(accuracy)  # write formatted LATEX string to file to be used by auto-documentation.\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path) #write formatted LATEX string to file to be used by auto-documentation.\n\n    gravOutMax = spherHarm.computeField([[0.0], [0.0], [(6378.1363)*1.0E3]], 100, True)\n    if gravOutMax != gravOut:\n        testFailCount += 1\n        testMessages.append(\"Gravity ceiling not enforced correctly\")\n\n    if testFailCount == 0:\n        passFailText = 'PASSED'\n        print(\"PASSED: \" + \" Spherical Harmonics\")\n        colorText = 'ForestGreen'  # color to write auto-documented \"PASSED\" message in in LATEX.\n        snippetName = testCase + 'FailMsg'\n        snippetContent = \"\"\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)  # write formatted LATEX string to file to be used by auto-documentation.\n    else:\n        passFailText = 'FAILED'\n        colorText = 'Red'  # color to write auto-documented \"FAILED\" message in in LATEX\n        snippetName = testCase + 'FailMsg'\n        snippetContent = passFailText\n        for message in testMessages:\n            snippetContent += \". \" + message\n        snippetContent += \".\"\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)  # write formatted LATEX string to file to be used by auto-documentation.\n    snippetName = testCase + 'PassFail'  # name of file to be written for auto-documentation which specifies if this test was passed or failed.\n    snippetContent = r'\\textcolor{' + colorText + '}{' + passFailText + '}' #write formatted LATEX string to file to be used by auto-documentation.\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path) #write formatted LATEX string to file to be used by auto-documentation.\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def singleGravityBody(show_plots):\n    testCase = 'singleBody'\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    # Create a sim module as an empty container\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n    DateSpice = \"2015 February 10, 00:00:00.0 TDB\"\n\n    # Create a sim module as an empty container\n    TotalSim = SimulationBaseClass.SimBaseClass()\n\n    DynUnitTestProc = TotalSim.CreateNewProcess(unitProcessName)\n    # create the dynamics task and specify the integration update time\n    DynUnitTestProc.addTask(TotalSim.CreateNewTask(unitTaskName, macros.sec2nano(0.1)))\n\n    # Initialize the modules that we are using.\n    SpiceObject = spiceInterface.SpiceInterface()\n\n    SpiceObject.ModelTag = \"SpiceInterfaceData\"\n    SpiceObject.SPICEDataPath = bskPath + '/supportData/EphemerisData/'\n    SpiceObject.addPlanetNames(spiceInterface.StringVector([\"earth\", \"mars barycenter\", \"sun\"]))\n    SpiceObject.UTCCalInit = DateSpice\n    TotalSim.AddModelToTask(unitTaskName, SpiceObject)\n    SpiceObject.UTCCalInit = \"1994 JAN 26 00:02:00.184\"\n\n    gravBody1 = gravityEffector.GravBodyData()\n    gravBody1.planetName = \"earth_planet_data\"\n    gravBody1.isCentralBody = False\n    gravBody1.useSphericalHarmParams = True\n    gravityEffector.loadGravFromFile(path + '/GGM03S.txt', gravBody1.spherHarm, 60)\n    gravBody1.planetBodyInMsg.subscribeTo(SpiceObject.planetStateOutMsgs[0])\n\n    # Use the python spice utility to load in spacecraft SPICE ephemeris data\n    # Note: this following SPICE data only lives in the Python environment, and is\n    #       separate from the earlier SPICE setup that was loaded to BSK.  This is why\n    #       all required SPICE libraries must be included when setting up and loading\n    #       SPICE kernals in Python.\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/de430.bsp')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/naif0012.tls')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/de-403-masses.tpc')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/pck00010.tpc')\n    pyswice.furnsh_c(path + '/hst_edited.bsp')\n\n    SpiceObject.UTCCalInit = \"2012 MAY 1 00:02:00.184\"\n    stringCurrent = SpiceObject.UTCCalInit\n    et = pyswice.new_doubleArray(1)\n    dt = 1.0\n    pyswice.str2et_c(stringCurrent, et)\n    etCurr = pyswice.doubleArray_getitem(et, 0)\n    normVec = []\n    gravErrNorm = []\n    SpiceObject.UTCCalInit = stringCurrent\n    TotalSim.InitializeSimulation()\n    gravBody1.initBody(0)\n    newManager = stateArchitecture.DynParamManager()\n    gravBody1.registerProperties(newManager)\n    SpiceObject.UpdateState(0)\n\n    for i in range(2*3600):\n        stateOut = spkRead('HUBBLE SPACE TELESCOPE', stringCurrent, 'J2000', 'EARTH')\n        etPrev =etCurr - 2.0\n        stringPrev = pyswice.et2utc_c(etPrev, 'C', 4, 1024, \"Yo\")\n        statePrev = spkRead('HUBBLE SPACE TELESCOPE', stringPrev, 'J2000', 'EARTH')\n        etNext =etCurr + 2.0\n        stringNext = pyswice.et2utc_c(etNext, 'C', 4, 1024, \"Yo\")\n        stateNext = spkRead('HUBBLE SPACE TELESCOPE', stringNext, 'J2000', 'EARTH')\n        gravVec = (stateNext[3:6] - statePrev[3:6])/(etNext - etPrev)\n        normVec.append(np.linalg.norm(stateOut[0:3]))\n\n        stateOut*=1000.0\n        SpiceObject.J2000Current = etCurr;SpiceObject.UpdateState(0)\n        gravBody1.loadEphemeris()\n        gravOut = gravBody1.computeGravityInertial(stateOut[0:3].reshape(3,1).tolist(), 0)\n        gravErrNorm.append(np.linalg.norm(gravVec*1000.0 - np.array(gravOut).reshape(3))/\n            np.linalg.norm(gravVec*1000.0))\n\n        pyswice.str2et_c(stringCurrent, et)\n        etCurr = pyswice.doubleArray_getitem(et, 0)\n        etCurr += dt;\n        stringCurrent = pyswice.et2utc_c(etCurr, 'C', 4, 1024, \"Yo\")\n\n    accuracy = 1.0e-4\n    for gravErr in gravErrNorm:\n        if gravErr > accuracy:\n            testFailCount += 1\n            testMessages.append(\"Gravity numerical error too high for kernel comparison\")\n            break\n    snippetName = testCase + 'Accuracy'\n    snippetContent = '{:1.1e}'.format(accuracy)  # write formatted LATEX string to file to be used by auto-documentation.\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path) #write formatted LATEX string to file to be used by auto-documentation.\n\n    pyswice.unload_c(bskPath + '/supportData/EphemerisData/de430.bsp')\n    pyswice.unload_c(bskPath + '/supportData/EphemerisData/naif0012.tls')\n    pyswice.unload_c(bskPath + '/supportData/EphemerisData/de-403-masses.tpc')\n    pyswice.unload_c(bskPath + '/supportData/EphemerisData/pck00010.tpc')\n    pyswice.unload_c(path + '/hst_edited.bsp')\n\n\n    if testFailCount == 0:\n        passFailText = 'PASSED'\n        print(\"PASSED: \" + \"Single-body with Spherical Harmonics\")\n        colorText = 'ForestGreen'  # color to write auto-documented \"PASSED\" message in in LATEX\n        snippetName = testCase + 'FailMsg'\n        snippetContent = \"\"\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)  # write formatted LATEX string to file to be used by auto-documentation.\n    else:\n        passFailText = 'FAILED'\n        colorText = 'Red'  # color to write auto-documented \"FAILED\" message in in LATEX\n        snippetName = testCase + 'FailMsg'\n        snippetContent = passFailText\n        for message in testMessages:\n            snippetContent += \". \" + message\n        snippetContent += \".\"\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)  # write formatted LATEX string to file to be used by auto-documentation.\n    snippetName = testCase + 'PassFail'  # name of file to be written for auto-documentation which specifies if this test was passed or failed.\n    snippetContent = r'\\textcolor{' + colorText + '}{' + passFailText + '}' #write formatted LATEX string to file to be used by auto-documentation.\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path) #write formatted LATEX string to file to be used by auto-documentation.\n\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n\n    return [testFailCount, ''.join(testMessages)]",
  "def register(manager):\n    \"\"\"\n    populates the state engines dynParamManager with nominal values\n\n    :param manager:\n    :return: posVelSig, posVelSig\n    \"\"\"\n    positionName = \"hubPosition\"\n    stateDim = [3, 1]\n    posState = manager.registerState(stateDim[0], stateDim[1], positionName)\n    posVelSig = [[0.], [0.], [0.]]\n    posState.setState(posVelSig)\n    velocityName = \"hubVelocity\"\n    stateDim = [3, 1]\n    velState = manager.registerState(stateDim[0], stateDim[1], velocityName)\n    velState.setState(posVelSig)\n    sigmaName = \"hubSigma\"\n    stateDim = [3, 1]\n    sigmaState = manager.registerState(stateDim[0], stateDim[1], sigmaName)\n    sigmaState.setState(posVelSig)\n    initC_B = [[0.0], [0.0], [0.0]]\n    manager.createProperty(\"centerOfMassSC\", initC_B)\n    manager.createProperty(\"systemTime\", [[0], [0.0]])\n\n    return",
  "def multiBodyGravity(show_plots):\n    testCase = 'multiBody' #for AutoTeX stuff\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    #\n    # # Create a sim module as an empty container\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n    # DateSpice = \"2015 February 10, 00:00:00.0 TDB\"\n    #\n    # # Create a sim module as an empty container\n    multiSim = SimulationBaseClass.SimBaseClass()\n    #\n    DynUnitTestProc = multiSim.CreateNewProcess(unitProcessName)\n    # # create the dynamics task and specify the integration update time\n    DynUnitTestProc.addTask(multiSim.CreateNewTask(unitTaskName, macros.sec2nano(1000.0)))\n\n    #Create dynParamManager to feed fake spacecraft data to so that the gravityEffector can access it.\n    #This places the spacecraft at the coordinate frame origin so that planets can be placed around it.\n    #velocity and attitude are just set to zero.\n    #center of mass and time are set to zero.\n    newManager = stateArchitecture.DynParamManager()\n    register(newManager)\n\n\n    #Create a message struct to place gravBody1 where it is wanted\n    localPlanetEditor = messaging.SpicePlanetStateMsgPayload()\n    localPlanetEditor.PositionVector = [om.AU/10., 0., 0.]\n    localPlanetEditor.VelocityVector = [0., 0., 0.]\n\n    #Grav Body 1 is twice the size of the other two\n    gravBody1 = gravityEffector.GravBodyData()\n    gravBody1.planetName = \"gravBody1_planet_data\"\n    gravBody1.mu = 1000000.\n    gravBody1.radEquator = 6500.\n    gravBody1.isCentralBody = False\n    gravBody1.useSphericalHarmParams = False\n    gravBody1.localPlanet = localPlanetEditor\n\n    #This is the gravityEffector which will actually compute the gravitational acceleration\n    allGrav = gravityEffector.GravityEffector()\n    allGrav.gravBodies = gravityEffector.GravBodyVector([gravBody1])\n    allGrav.linkInStates(newManager)\n    allGrav.registerProperties(newManager)\n    multiSim.AddModelToTask(unitTaskName, allGrav)\n    posVelSig = [[0.], [0.], [0.]]\n    allGrav.computeGravityField(posVelSig, posVelSig) #compute acceleration only considering the first body.\n    step1 = newManager.getPropertyReference(\"g_N\") #retrieve total gravitational acceleration in inertial frame\n\n    #Create a message struct to place gravBody2&3 where they are wanted.\n    localPlanetEditor.PositionVector = [-om.AU/10., 0., 0.]\n    localPlanetEditor.VelocityVector = [0., 0., 0.]\n\n    #grav Body 2 and 3 are coincident with each other, half the mass of gravBody1 and are in the opposite direction of gravBody1\n    gravBody2 = gravityEffector.GravBodyData()\n    gravBody2.planetName = \"gravBody2_planet_data\"\n    gravBody2.mu = gravBody1.mu/2.\n    gravBody2.radEquator = 6500.\n    gravBody2.isCentralBody = False\n    gravBody2.useSphericalHarmParams = False\n    gravBody2.localPlanet = localPlanetEditor\n\n    #This is the gravityEffector which will actually compute the gravitational acceleration\n    newManager = stateArchitecture.DynParamManager()\n    register(newManager)\n    allGrav2 = gravityEffector.GravityEffector()\n    allGrav2.gravBodies = gravityEffector.GravBodyVector([gravBody1, gravBody2])\n    allGrav2.linkInStates(newManager)\n    allGrav2.registerProperties(newManager)\n    multiSim.AddModelToTask(unitTaskName, allGrav2)\n    allGrav2.computeGravityField(posVelSig, posVelSig) #compute acceleration considering the first and second bodies.\n    step2 = newManager.getPropertyReference(\"g_N\") #retrieve total gravitational acceleration in inertial frame\n    # grav Body 2 and 3 are coincident with each other, half the mass of gravBody1 and are in the opposite direction of gravBody1\n    gravBody3 = gravityEffector.GravBodyData()\n    gravBody3.planetName = \"gravBody3_planet_data\"\n    gravBody3.mu = gravBody2.mu\n    gravBody3.radEquator = 6500.\n    gravBody3.isCentralBody = False\n    gravBody3.useSphericalHarmParams = False\n    gravBody3.localPlanet = localPlanetEditor\n\n    #This is the gravityEffector which will actually compute the gravitational acceleration\n    newManager = stateArchitecture.DynParamManager()\n    register(newManager)\n    allGrav3 = gravityEffector.GravityEffector()\n    allGrav3.gravBodies = gravityEffector.GravBodyVector([gravBody1, gravBody2, gravBody3])\n    allGrav3.linkInStates(newManager)\n    allGrav3.registerProperties(newManager)\n    multiSim.AddModelToTask(unitTaskName, allGrav3)\n    allGrav3.computeGravityField(posVelSig, posVelSig) #comput acceleration considering all three bodies\n    step3 = newManager.getPropertyReference(\"g_N\") #retrieve total gravitational acceleration in inertial frame\n\n    step3 = [0., step3[0][0], step3[1][0], step3[2][0]] #add a first (time) column to use isArrayZero\n\n    #Test results for accuracy\n    accuracy = 1e-12\n    snippetName = testCase + 'Accuracy'\n    snippetContent = '{:1.1e}'.format(accuracy)  # write formatted LATEX string to file to be used by auto-documentation.\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path) #write formatted LATEX string to file to be used by auto-documentation.\n    if not unitTestSupport.isDoubleEqualRelative(step2[0][0]/step1[0][0], 0.5, accuracy): #if the second grav body doesn't cancel exactly half of the first body's acceleration.\n        testFailCount += 1\n        passFailText = \"Step 2 was not half of step 1\"\n        testMessages.append(passFailText)\n    elif not unitTestSupport.isArrayZero(step3, 3, accuracy): #if the net acceleration is not now 0.\n        testFailCount += 1\n        passFailText = \"Step 3 did not cause gravity to return to 0\"\n        testMessages.append(passFailText)\n\n    #Record test results to LaTeX\n    if testFailCount == 0:\n        passFailText = 'PASSED'\n        print(\"PASSED: \" + \" Multi-Body\")\n        colorText = 'ForestGreen'  # color to write auto-documented \"PASSED\" message in in LATEX\n        snippetName = testCase + 'FailMsg'\n        snippetContent = \"\"\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)  # write formatted LATEX string to file to be used by auto-documentation.\n    else:\n        passFailText = 'FAILED'\n        colorText = 'Red'  # color to write auto-documented \"FAILED\" message in in LATEX\n        snippetName = testCase + 'FailMsg'\n        snippetContent = passFailText\n        for message in testMessages:\n            snippetContent += \". \" + message\n        snippetContent += \".\"\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)  # write formatted LATEX string to file to be used by auto-documentation.\n    snippetName = testCase + 'PassFail'  # name of file to be written for auto-documentation which specifies if this test was passed or failed.\n    snippetContent = r'\\textcolor{' + colorText + '}{' + passFailText + '}' #write formatted LATEX string to file to be used by auto-documentation.\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path) #write formatted LATEX string to file to be used by auto-documentation.\n\n    return [testFailCount, ''.join(testMessages)]",
  "def legendres(degree, alpha):\n        P = np.zeros((degree+1,degree+1))\n        P[0,0] = 1\n        P[1,0] = alpha\n        cosPhi = np.sqrt(1-alpha**2)\n        P[1,1] = cosPhi\n\n        for l in range(2,degree+1):\n            for m in range(0,l+1):\n                if m == 0 and l >= 2:\n                    P[l,m] = ((2*l-1)*alpha*P[l-1,0]-(l-1)*P[l-2,0]) / l\n                elif m != 0 and m < l:\n                    P[l, m] = (P[l-2, m]+(2*l-1)*cosPhi*P[l-1,m-1])\n                elif m == l and l != 0:\n                    P[l,m] = (2*l-1)*cosPhi*P[l-1,m-1]\n                else:\n                    print(l,\", \", m)\n        return P",
  "def test_gravityEffectorAllTest(show_plots, function):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = eval(function + '(show_plots)')\n    assert testResults < 1, testMessage",
  "def singleGravityBody(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    # Create a sim module as an empty container\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    DynUnitTestProc = unitTestSim.CreateNewProcess(unitProcessName)\n    # create the dynamics task and specify the integration update time\n    DynUnitTestProc.addTask(unitTestSim.CreateNewTask(unitTaskName, macros.sec2nano(10.0)))\n\n\n    # setup Gravity Bodies\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    gravBodies = gravFactory.createBodies(['earth', 'sun', 'moon', 'jupiter barycenter'])\n    gravBodies['earth'].isCentralBody = True\n    gravBodies['earth'].useSphericalHarmParams = True\n    simIncludeGravBody.loadGravFromFile(path + '/../_UnitTest/GGM03S.txt'\n                                        , gravBodies['earth'].spherHarm\n                                        , 40\n                                        )\n    stringCurrent = \"2016 MAY 1 00:32:30.0\"\n    gravFactory.createSpiceInterface(bskPath +'/supportData/EphemerisData/', stringCurrent)\n    gravFactory.spiceObject.zeroBase = 'Earth'\n\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    unitTestSim.AddModelToTask(unitTaskName, gravFactory.spiceObject, 10)\n\n    # Use the python spice utility to load in spacecraft SPICE ephemeris data\n    # Note: this following SPICE data only lives in the Python environment, and is\n    #       separate from the earlier SPICE setup that was loaded to BSK.  This is why\n    #       all required SPICE libraries must be included when setting up and loading\n    #       SPICE kernels in Python.\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/de430.bsp')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/naif0012.tls')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/de-403-masses.tpc')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/pck00010.tpc')\n    pyswice.furnsh_c(path + '/../_UnitTest/hst_edited.bsp')\n\n    unitTestSim.AddModelToTask(unitTaskName, scObject, 9)\n\n    stateOut = spkRead('HUBBLE SPACE TELESCOPE', stringCurrent, 'J2000', 'EARTH')\n\n    scObject.hub.mHub = 100\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n\n    scObject.hub.r_CN_NInit = (1000.0*stateOut[0:3].reshape(3,1)).tolist()\n    velStart = 1000.0*stateOut[3:6]\n    scObject.hub.v_CN_NInit = (velStart.reshape(3,1)).tolist()\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.omega_BN_BInit = [[0.001], [-0.002], [0.003]]\n\n    unitTestSim.InitializeSimulation()\n\n    posRef = scObject.dynManager.getStateObject(\"hubPosition\")\n    velRef = scObject.dynManager.getStateObject(\"hubVelocity\")\n\n    scObject.hub.mHub = 100\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n\n    dt = 50.0\n    totalTime = 20000.0\n    currentTime = 0.0\n    posArray = []\n    velArray = []\n    posError = []\n    while(currentTime < totalTime):\n        unitTestSim.ConfigureStopTime(macros.sec2nano(currentTime + dt))\n        unitTestSim.ExecuteSimulation()\n        stateOut = spkRead('HUBBLE SPACE TELESCOPE', gravFactory.spiceObject.getCurrentTimeString(), 'J2000', 'EARTH')\n        posCurr = posRef.getState()\n        posCurr = [y for x in posCurr for y in x]\n        posArray.append(posCurr)\n        velCurr = velRef.getState()\n        velCurr = [y for x in velCurr for y in x]\n        velArray.append(velCurr)\n        posDiff = numpy.array(posCurr) - stateOut[0:3]*1000.0\n        posRow = [unitTestSim.TotalSim.CurrentNanos*1.0E-9]\n        posRow.extend(posDiff.tolist())\n        posError.append(posRow)\n        assert numpy.linalg.norm(posDiff) < 1000.0\n\n        currentTime += dt\n\n    stateOut = spkRead('HUBBLE SPACE TELESCOPE', gravFactory.spiceObject.getCurrentTimeString(), 'J2000', 'EARTH')\n    posArray = numpy.array(posArray)\n    posError = numpy.array(posError)\n\n    gravFactory.unloadSpiceKernels()\n    pyswice.unload_c(bskPath + '/supportData/EphemerisData/de430.bsp')\n    pyswice.unload_c(bskPath + '/supportData/EphemerisData/naif0012.tls')\n    pyswice.unload_c(bskPath + '/supportData/EphemerisData/de-403-masses.tpc')\n    pyswice.unload_c(bskPath + '/supportData/EphemerisData/pck00010.tpc')\n    pyswice.unload_c(path + '/../_UnitTest/hst_edited.bsp')\n\n    print(numpy.max(abs(posError[:,1:4])))\n\n    if show_plots:\n        plt.close(\"all\")\n        plt.figure()\n        plt.plot(posError[:, 0], posError[:, 1:4])\n        plt.xlabel('Time (s)')\n        plt.ylabel('Position Difference (m)')\n        plt.show()\n        plt.close(\"all\")\n\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Single body with spherical harmonics\")\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n\n    return [testFailCount, ''.join(testMessages)]",
  "def multiBodyGravity(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    # Create a sim module as an empty container\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    DynUnitTestProc = unitTestSim.CreateNewProcess(unitProcessName)\n    # create the dynamics task and specify the integration update time\n    DynUnitTestProc.addTask(unitTestSim.CreateNewTask(unitTaskName, macros.sec2nano(5.0)))\n\n    # setup Gravity Bodies\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    gravBodies = gravFactory.createBodies(['earth', 'mars barycenter', 'sun', 'moon', 'jupiter barycenter'])\n    gravBodies['sun'].isCentralBody = True\n\n    stringCurrent = \"2008 September 19, 04:00:00.0\"\n    gravFactory.createSpiceInterface(bskPath +'/supportData/EphemerisData/', stringCurrent)\n    gravFactory.spiceObject.zeroBase = 'Earth'\n\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    unitTestSim.AddModelToTask(unitTaskName, gravFactory.spiceObject, 10)\n\n    # Use the python spice utility to load in spacecraft SPICE ephemeris data\n    # Note: this following SPICE data only lives in the Python environment, and is\n    #       separate from the earlier SPICE setup that was loaded to BSK.  This is why\n    #       all required SPICE libraries must be included when setting up and loading\n    #       SPICE kernels in Python.\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/de430.bsp')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/naif0012.tls')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/de-403-masses.tpc')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/pck00010.tpc')\n    pyswice.furnsh_c(path + '/../_UnitTest/nh_pred_od077.bsp')\n\n    unitTestSim.AddModelToTask(unitTaskName, scObject, 9)\n\n    stateOut = spkRead('NEW HORIZONS', stringCurrent, 'J2000', 'SUN')\n\n    scObject.hub.mHub = 100\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    scObject.hub.r_CN_NInit = (1000.0*stateOut[0:3].reshape(3,1)).tolist()\n    velStart = 1000.0*stateOut[3:6]\n    scObject.hub.v_CN_NInit = (velStart.reshape(3,1)).tolist()\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.omega_BN_BInit = [[0.001], [-0.002], [0.003]]\n\n    unitTestSim.InitializeSimulation()\n\n    posRef = scObject.dynManager.getStateObject(\"hubPosition\")\n    velRef = scObject.dynManager.getStateObject(\"hubVelocity\")\n\n    dt = 50.0\n    totalTime = 20000.0\n    currentTime = 0.0\n    posArray = []\n    velArray = []\n    posError = []\n    posInc = []\n    while currentTime < totalTime:\n        unitTestSim.ConfigureStopTime(macros.sec2nano(currentTime + dt))\n        unitTestSim.ExecuteSimulation()\n        timeString = pyswice.et2utc_c(gravFactory.spiceObject.J2000Current, 'C', 4, 1024, \"Yo\")\n        stateOut = spkRead('NEW HORIZONS', timeString, 'J2000', 'SUN')\n        posCurr = posRef.getState()\n        posCurr = [y for x in posCurr for y in x]\n        posArray.append(posCurr)\n        velCurr = velRef.getState()\n        velCurr = [y for x in velCurr for y in x]\n        velArray.append(velCurr)\n        posDiff = numpy.array(posCurr) - stateOut[0:3]*1000.0\n        posRow = [unitTestSim.TotalSim.CurrentNanos*1.0E-9]\n        posRow.extend(posDiff.tolist())\n        posError.append(posRow)\n        assert numpy.linalg.norm(posDiff) < 1000.0\n        if currentTime > 0.0 + dt/2.0:\n            posJump = stateOut[0:3]*1000.0 - numpy.array(posPrevious)\n            posInc.append(posJump.tolist())\n        posPrevious = stateOut[0:3]*1000.0\n        currentTime += dt\n\n    stateOut = spkRead('NEW HORIZONS', gravFactory.spiceObject.getCurrentTimeString(), 'J2000', 'SUN')\n    posArray = numpy.array(posArray)\n    posError = numpy.array(posError)\n    posInc = numpy.array(posInc)\n\n    gravFactory.unloadSpiceKernels()\n    pyswice.unload_c(bskPath + '/supportData/EphemerisData/de430.bsp')\n    pyswice.unload_c(bskPath + '/supportData/EphemerisData/naif0012.tls')\n    pyswice.unload_c(bskPath + '/supportData/EphemerisData/de-403-masses.tpc')\n    pyswice.unload_c(bskPath + '/supportData/EphemerisData/pck00010.tpc')\n    pyswice.unload_c(path + '/../_UnitTest/nh_pred_od077.bsp')\n\n    plt.close(\"all\")\n    plt.figure()\n    plt.plot(posError[:,0], posError[:,1:4])\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position Difference (m)')\n\n    if(show_plots):\n        plt.show()\n        plt.close('all')\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" multi-point source bodies\")\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n\n    return [testFailCount, ''.join(testMessages)]",
  "def polyGravityBody(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    # Obtain validation data (simulation with tight integration tolerances in MATLAB)\n    valData = numpy.genfromtxt(path + '/../_UnitTest/polyTestData.csv', delimiter=',')\n    tVal = numpy.array(valData[:,0])\n    posVal = numpy.array(valData[:,1:4])\n    velVal = numpy.array(valData[:,4:7])\n\n    # Create a sim module as an empty container\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    DynUnitTestProc = unitTestSim.CreateNewProcess(unitProcessName)\n    # create the dynamics task and specify the integration update time\n    intTime = 30.0\n    DynUnitTestProc.addTask(unitTestSim.CreateNewTask(unitTaskName, macros.sec2nano(intTime)))\n\n    # specify orbit of polyhedral body\n    oePolyBody = planetEphemeris.ClassicElementsMsgPayload()\n    oePolyBody.a = 2.3612 * orbitalMotion.AU * 1000\n    oePolyBody.e = 0\n    oePolyBody.i = 0*macros.D2R\n    oePolyBody.Omega = 0*macros.D2R\n    oePolyBody.omega = 0*macros.D2R\n    oePolyBody.f = 0*macros.D2R\n\n    raPolyBody = 0 * macros.D2R\n    decPolyBody = 90 * macros.D2R\n    lst0PolyBody = 0 * macros.D2R\n    rotPeriodPolyBody = 5.27 * 3600\n\n    # setup celestial object ephemeris module\n    polyBodyEphem = planetEphemeris.PlanetEphemeris()\n    polyBodyEphem.ModelTag = 'erosEphemeris'\n    polyBodyEphem.setPlanetNames(planetEphemeris.StringVector([\"eros\"]))\n\n    # specify celestial objects orbit\n    polyBodyEphem.planetElements = planetEphemeris.classicElementVector([oePolyBody])\n\n    # specify celestial object orientation\n    polyBodyEphem.rightAscension = planetEphemeris.DoubleVector([raPolyBody])\n    polyBodyEphem.declination = planetEphemeris.DoubleVector([decPolyBody])\n    polyBodyEphem.lst0 = planetEphemeris.DoubleVector([lst0PolyBody])\n    polyBodyEphem.rotRate = planetEphemeris.DoubleVector([360 * macros.D2R / rotPeriodPolyBody])\n\n    # setup polyhedral gravity body\n    mu = 4.46275472004 * 1e5\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    polyBody = gravFactory.createCustomGravObject('eros', mu=mu)\n    polyBody.isCentralBody = True\n    polyBody.usePolyhedral = True\n    simIncludeGravBody.loadPolyFromFile(path + '/../_UnitTest/EROS856Vert1708Fac.txt', polyBody.poly)\n    polyBody.planetBodyInMsg.subscribeTo(polyBodyEphem.planetOutMsgs[0])\n\n    # create an ephemeris converter\n    polyBodyEphemConverter = ephemerisConverter.EphemerisConverter()\n    polyBodyEphemConverter.ModelTag = \"erosEphemConverter\"\n    polyBodyEphemConverter.addSpiceInputMsg(polyBodyEphem.planetOutMsgs[0])\n\n    # create spacecraft and attach polyhedral body\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraft\"\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    # set initial conditions for spacecraft\n    angvelPolyBody = np.array([0,0,360 * macros.D2R / rotPeriodPolyBody])\n    posInit = posVal[0,0:3]\n    velInit = velVal[0,0:3] + np.cross(angvelPolyBody, posInit)\n    scObject.hub.r_CN_NInit = posInit.tolist()\n    scObject.hub.v_CN_NInit = velInit.tolist()\n\n    # add models to task\n    unitTestSim.AddModelToTask(unitTaskName, polyBodyEphem, ModelPriority=10)\n    unitTestSim.AddModelToTask(unitTaskName, polyBodyEphemConverter, ModelPriority=9)\n    unitTestSim.AddModelToTask(unitTaskName, scObject, ModelPriority=8)\n\n    totalTime = 24*3600\n\n    samplingTime = 300\n    scRec = scObject.scStateOutMsg.recorder(macros.sec2nano(samplingTime))\n    polyBodyRec = polyBodyEphemConverter.ephemOutMsgs[0].recorder(macros.sec2nano(samplingTime))\n    unitTestSim.AddModelToTask(unitTaskName, scRec)\n    unitTestSim.AddModelToTask(unitTaskName, polyBodyRec)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(totalTime))\n    unitTestSim.ExecuteSimulation()\n\n    # retrieve logged variables\n    time = scRec.times() * macros.NANO2SEC\n    N_points = len(time)\n    r_BN_N = scRec.r_BN_N\n    r_AN_N = polyBodyRec.r_BdyZero_N\n    sigma_AN = polyBodyRec.sigma_BN\n\n    # obtain position in small body centered fixed frame\n    posArray = numpy.zeros((N_points, 3))\n    for ii in range(N_points):\n        # obtain rotation matrix\n        R_AN = RigidBodyKinematics.MRP2C(sigma_AN[ii][0:3])\n\n        # rotate position and velocity\n        posArray[ii,0:3] = R_AN.dot(numpy.subtract(r_BN_N[ii],r_AN_N[ii]))\n\n    # compute error in position and assert max error\n    posError = numpy.linalg.norm(posArray - posVal,axis=1)\n    assert max(posError) < 10\n    print(max(posError))\n\n    plt.close(\"all\")\n    plt.figure()\n    plt.plot(tVal, posArray - posVal)\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position Difference (m)')\n\n    if(show_plots):\n        plt.show()\n        plt.close('all')\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Single body with polyhedral shape\")\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_unitDynamicsModes(show_plots, torqueInput, forceNInput, forceBInput):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitDynamicsModesTestFunction(\n            show_plots, torqueInput, forceNInput, forceBInput)\n    assert testResults < 1, testMessage",
  "def unitDynamicsModesTestFunction(show_plots, torqueInput, forceNInput, forceBInput):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"testProcess\"\n\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    #\n    #  create the dynamics simulation process\n    #\n\n    dynProcess = scSim.CreateNewProcess(unitProcessName)\n    # create the dynamics task and specify the integration update time\n    dynProcess.addTask(scSim.CreateNewTask(unitTaskName, macros.sec2nano(0.1)))\n\n    extFTObject = extForceTorque.ExtForceTorque()\n    extFTObject.ModelTag = \"externalDisturbance\"\n\n    if torqueInput==1 or torqueInput==3:\n        extFTObject.extTorquePntB_B = [[-1], [1],[ -1]]\n    if torqueInput==2 or torqueInput==3:\n        msgData = messaging.CmdTorqueBodyMsgPayload()\n        msgData.torqueRequestBody = [-1.0, 1.0, -1.0]\n        cmdTorqueMsg = messaging.CmdTorqueBodyMsg().write(msgData)\n        extFTObject.cmdTorqueInMsg.subscribeTo(cmdTorqueMsg)\n\n    if forceNInput==1 or forceNInput==3:\n        extFTObject.extForce_N = [[-10.], [-5.], [5.]]\n    if forceNInput==2 or forceNInput==3:\n        msgData = messaging.CmdForceInertialMsgPayload()\n        msgData.forceRequestInertial = [-10.0, -5.0, 5.0]\n        cmdForceInertialMsg = messaging.CmdForceInertialMsg().write(msgData)\n        extFTObject.cmdForceInertialInMsg.subscribeTo(cmdForceInertialMsg)\n\n    if forceBInput==1 or forceBInput==3:\n        extFTObject.extForce_B = [[10.], [20.], [30.]]\n    if forceBInput==2 or forceBInput==3:\n        msgData = messaging.CmdForceBodyMsgPayload()\n        msgData.forceRequestBody = [10.0, 20.0, 30.0]\n        cmdForceBodyMsg = messaging.CmdForceBodyMsg().write(msgData)\n        extFTObject.cmdForceBodyInMsg.subscribeTo(cmdForceBodyMsg)\n\n    scSim.AddModelToTask(unitTaskName, extFTObject)\n\n    #\n    #   initialize the simulation\n    #\n    scSim.InitializeSimulation()\n    scSim.ConfigureStopTime(macros.sec2nano(0.001))\n\n\n    #\n    #   Setup data logging\n    #\n    testProcessRate = macros.sec2nano(0.1)\n    variableForceN = \"forceExternal_N\"            # name the module variable to be logged\n    scSim.AddVariableForLogging (extFTObject.ModelTag + \".\" + variableForceN, testProcessRate, 0, 2, 'double')\n    variableForceB = \"forceExternal_B\"            # name the module variable to be logged\n    scSim.AddVariableForLogging (extFTObject.ModelTag + \".\" + variableForceB, testProcessRate, 0, 2, 'double')\n    variableTorque = \"torqueExternalPntB_B\"       # name the module variable to be logged\n    scSim.AddVariableForLogging (extFTObject.ModelTag + \".\" + variableTorque, testProcessRate, 0, 2, 'double')\n\n    #\n    #   run the simulation\n    #\n    scSim.ExecuteSimulation()\n\n    extFTObject.computeForceTorque(scSim.TotalSim.CurrentNanos, macros.sec2nano(0.1))\n    scSim.TotalSim.SingleStepProcesses()\n    scSim.RecordLogVars()\n\n\n    # log the data\n    dataForceN = (scSim.GetLogVariableData(extFTObject.ModelTag+\".\"+variableForceN))[-1]\n    dataForceB = (scSim.GetLogVariableData(extFTObject.ModelTag+\".\"+variableForceB))[-1]\n    dataTorque = (scSim.GetLogVariableData(extFTObject.ModelTag+\".\"+variableTorque))[-1]\n\n    np.set_printoptions(precision=16)\n\n    # Remove time zero from list\n    dataForceN = [dataForceN[1:len(dataForceN)]]\n    dataForceB = [dataForceB[1:len(dataForceB)]]\n    dataTorque = [dataTorque[1:len(dataTorque)]]\n\n    #\n    #   set true position information\n    #\n\n    if torqueInput == 3:\n        trueTorque_B = [\n              [-2., 2., -2.]\n        ]\n    elif torqueInput>0:\n        trueTorque_B = [\n            [-1., 1., -1.]\n        ]\n    else:\n        trueTorque_B = [\n            [0, 0, 0]\n        ]\n\n    if forceBInput == 3:\n        trueForceB = [\n            [20, 40, 60]\n        ]\n    elif forceBInput>0:\n        trueForceB = [\n            [10, 20, 30]\n        ]\n    else:\n        trueForceB = [\n            [0, 0, 0]\n        ]\n\n    if forceNInput == 3:\n        trueForceN = [\n            [-20., -10., 10.]\n        ]\n    elif forceNInput > 0:\n        trueForceN = [\n            [-10., -5., 5.]\n        ]\n    else:\n        trueForceN = [\n            [0, 0, 0]\n        ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    if (len(trueTorque_B) != len(dataTorque)):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  ExtForceTorque failed torque unit test (unequal array sizes)\\n\")\n    else:\n        for i in range(0,len(trueTorque_B)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqual(dataTorque[i],trueTorque_B[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED:  ExtForceTorque failed torque unit test at t=\" + str(dataTorque[i,0]*macros.NANO2SEC) + \"sec\\n\")\n\n    if (len(trueForceN) != len(dataForceN)):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  ExtForceTorque failed force_N unit test (unequal array sizes)\\n\")\n    else:\n        for i in range(0,len(trueForceN)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqual(dataForceN[i],trueForceN[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED:  ExtForceTorque failed force_N unit test at t=\" + str(dataForceN[i,0]*macros.NANO2SEC) + \"sec\\n\")\n\n    if (len(trueForceB) != len(dataForceB)):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  ExtForceTorque failed force_B unit test (unequal array sizes)\\n\")\n    else:\n        for i in range(0, len(trueForceB)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqual(dataForceB[i], trueForceB[i], 3, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED:  ExtForceTorque failed force_B unit test at t=\"+str(\n                    dataForceB[i, 0]*macros.NANO2SEC)+\"sec\\n\")\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED \")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_ForceBodyAndTorqueAllTest(show_plots, function):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = eval(function + '()')\n    assert testResults < 1, testMessage",
  "def extForceBodyAndTorque():\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.1)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n    unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n    unitTestSim.earthGravBody.mu = 0.3986004415E+15 # meters!\n    unitTestSim.earthGravBody.isCentralBody = True\n    unitTestSim.earthGravBody.useSphericalHarmParams = False\n\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector([unitTestSim.earthGravBody])\n\n    # Define initial conditions\n    scObject.hub.mHub = 750.0\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n    scObject.hub.r_CN_NInit = [[-4020338.690396649],\t[7490566.741852513],\t[5248299.211589362]]\n    scObject.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n    scObject.hub.sigma_BNInit = [[0.1], [0.2], [-0.3]]\n    scObject.hub.omega_BN_BInit = [[0.001], [-0.01], [0.03]]\n\n    unitTestSim.InitializeSimulation()\n\n    extFTObject = extForceTorque.ExtForceTorque()\n    extFTObject.ModelTag = \"externalDisturbance\"\n    extFTObject.extTorquePntB_B = [[-1], [1], [-1]]\n    extFTObject.extForce_B = [[1], [2], [3]]\n    scObject.addDynamicEffector(extFTObject)\n    unitTestSim.AddModelToTask(unitTaskName, extFTObject)\n\n    posRef = scObject.dynManager.getStateObject(\"hubPosition\")\n    sigmaRef = scObject.dynManager.getStateObject(\"hubSigma\")\n\n    stopTime = 60.0*10.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    dataPos = posRef.getState()\n    dataSigma = sigmaRef.getState()\n    dataPos = [[dataPos[0][0], dataPos[1][0], dataPos[2][0]]]\n    dataSigma = [[dataSigma[0][0], dataSigma[1][0], dataSigma[2][0]]]\n\n    truePos = [\n                [-6.78136423e+06, 4.94628599e+06, 5.48655395e+06]\n                ]\n\n    trueSigma = [\n                [4.91025978e-01, -4.21586707e-01,  3.61459503e-01]\n                ]\n\n    accuracy = 1e-8\n    for i in range(0,len(truePos)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(dataPos[i],truePos[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: External Body Force and Torque failed pos unit test\")\n\n    for i in range(0,len(trueSigma)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(dataSigma[i],trueSigma[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: External Body Force and Torque failed attitude unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" External Body Force and Torque Inegrated Sim Test\")\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def extForceInertialAndTorque():\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.1)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n    unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n    unitTestSim.earthGravBody.mu = 0.3986004415E+15  # meters!\n    unitTestSim.earthGravBody.isCentralBody = True\n    unitTestSim.earthGravBody.useSphericalHarmParams = False\n\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector([unitTestSim.earthGravBody])\n\n    # Define initial conditions of the spacecraft\n    scObject.hub.mHub = 750.0\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n    scObject.hub.r_CN_NInit = [[-4020338.690396649],\t[7490566.741852513],\t[5248299.211589362]]\n    scObject.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n    scObject.hub.sigma_BNInit = [[0.1], [0.2], [-0.3]]\n    scObject.hub.omega_BN_BInit = [[0.001], [-0.01], [0.03]]\n\n    unitTestSim.InitializeSimulation()\n\n    extFTObject = extForceTorque.ExtForceTorque()\n    extFTObject.ModelTag = \"externalDisturbance\"\n    extFTObject.extTorquePntB_B = [[-1], [1], [-1]]\n    extFTObject.extForce_N = [[-1], [-0.5], [0.5]]\n    scObject.addDynamicEffector(extFTObject)\n    unitTestSim.AddModelToTask(unitTaskName, extFTObject)\n\n    posRef = scObject.dynManager.getStateObject(\"hubPosition\")\n    sigmaRef = scObject.dynManager.getStateObject(\"hubSigma\")\n\n    stopTime = 60.0*10.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    dataPos = posRef.getState()\n    dataSigma = sigmaRef.getState()\n    dataPos = [[dataPos[0][0], dataPos[1][0], dataPos[2][0]]]\n    dataSigma = [[dataSigma[0][0], dataSigma[1][0], dataSigma[2][0]]]\n\n    truePos = [\n                [-6.78183900e+06, 4.94674963e+06, 5.48686274e+06]\n                ]\n\n    trueSigma = [\n                [4.91025978e-01, -4.21586707e-01,  3.61459503e-01]\n                ]\n\n    accuracy = 1e-8\n    for i in range(0,len(truePos)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(dataPos[i],truePos[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: External Inertial Force and Torque failed pos unit test\")\n\n    for i in range(0,len(trueSigma)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(dataSigma[i],trueSigma[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: External Inertial Force and Torque failed attitude unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" External Inertial Force and Torque Inegrated Sim Test\")\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "class ResultsStore:\n    def __init__(self):\n        self.PassFail = []\n\n    def texSnippet(self):\n        for i in range(len(self.PassFail)):\n            snippetName = 'Result' + str(i)\n            if self.PassFail[i] == 'PASSED':\n                textColor = 'ForestGreen'\n            elif self.PassFail[i] == 'FAILED':\n                textColor = 'Red'\n            texSnippet = r'\\textcolor{' + textColor + '}{' + self.PassFail[i] + '}'\n            unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)",
  "def testFixture():\n    listRes = ResultsStore()\n    yield listRes\n    listRes.texSnippet()",
  "def thrusterEffectorAllTests(show_plots):\n    [testResults, testMessage] = test_unitThrusters(show_plots)",
  "def test_unitThrusters(testFixture, show_plots, thrustNumber, initialConditions, duration, long_angle, lat_angle, location, swirlTorque, rate, attachBody):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test script tests the stateEffector implementation of thrusters. It sets up the thruster module and runs\n    a combination of 6 different scenarios. Each scenario uses either one or two thrusters, while also changing the\n    thruster's locations and whether thruster 1 is firing or not.\n\n    For information on how the thruster module works and what the closed-form solution for the ``thrustFactor`` variable\n    is, see :ref:`thrusterStateEffector`. Given the ``thrustFactor`` :math:`\\kappa`, the thrust is computed as follows:\n\n    .. math::\n        \\textbf{F} = \\kappa \\cdot F_{\\mathrm{max}} \\cdot \\hat{n}\n\n    where :math:`\\hat{n}` is the thruster's direction vector. The torque is computed by:\n\n    .. math::\n        \\textbf{T} = \\textbf{r}\\times\\textbf{F} + \\kappa \\cdot T_{\\mathrm{maxSwirl}} \\cdot \\hat{n}\n\n    where :math:`\\textbf{r}` corresponds to the thruster's position relative to the spacecraft's center of mass and the\n    second term represents the swirl torque. The mass flow rate is given by:\n\n    .. math::\n        \\dot{m} = \\dfrac{F}{g\\cdot I_{sp}}\n\n    where :math:`g` is Earth's gravitational acceleration and :math:`I_{sp}` is the thruster's specific impulse.\n\n    **Test Parameters**\n\n    Args:\n        thrustNumber (int): number of thrusters used in the simulation\n        initialConditions (float): initial value of the ``thrustFactor`` variable for thruster 1. Thruster always starts\n        off.\n        duration (float): duration of the thrust in seconds.\n        long_angle (float): longitude angle in degrees for thruster 1. Thruster 2 is also impacted by this value.\n        lat_angle (float): latitude angle in degrees for thruster 1. Thruster 2 is also impacted by this value.\n        location (float): location of thruster 1.\n        swirlTorque (float): maximum value of the swirl torque on the thruster.\n        rate (int): simulation rate in nanoseconds.\n        attachBody (flag): whether the thruster is attached to the hub or to a different body.\n\n    **Description of Variables Being Tested**\n\n    In this file we are checking the values of the variables\n\n    - ``thrForce``\n    - ``thrTorque``\n    - ``mDot``\n\n    All these variables are compared to the true values from the closed-form expressions given in :ref:`thrusterStateEffector`.\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitThrusters(testFixture, show_plots, thrustNumber, initialConditions, duration, long_angle,\n                                               lat_angle, location, swirlTorque, rate, attachBody)\n    assert testResults < 1, testMessage",
  "def unitThrusters(testFixture, show_plots, thrustNumber, initialConditions, duration, long_angle, lat_angle, location, swirlTorque, rate, attachBody):\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    #  Create a simulation and set the rate\n    TotalSim = SimulationBaseClass.SimBaseClass()\n    testRate = int(rate)  # Parametrized rate of test\n\n    # breakpoint()\n\n    # Create the process and task\n    unitTaskName1 = \"unitTask1\"  # arbitrary name (don't change)\n    unitTaskName2 = \"unitTask2\"  # arbitrary name (don't change)\n    unitTaskName3 = \"unitTask3\"  # arbitrary name (don't change)\n    unitProcessName1 = \"TestProcess1\"  # arbitrary name (don't change)\n    unitProcessName2 = \"TestProcess2\"  # arbitrary name (don't change)\n    unitProcessName3 = \"TestProcess3\"  # arbitrary name (don't change)\n    testProc1 = TotalSim.CreateNewProcess(unitProcessName1, 10)\n    testProc1.addTask(TotalSim.CreateNewTask(unitTaskName1, testRate))\n    testProc2 = TotalSim.CreateNewProcess(unitProcessName2, 0)\n    testProc2.addTask(TotalSim.CreateNewTask(unitTaskName2, testRate))\n    testProc3 = TotalSim.CreateNewProcess(unitProcessName3, 5)\n    testProc3.addTask(TotalSim.CreateNewTask(unitTaskName3, testRate))\n\n    # Create the spacecraft object\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    # Define initial conditions of the spacecraft\n    scObject.hub.mHub = 750.0\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n    scObject.hub.r_CN_NInit = [[-4020338.690396649], [7490566.741852513], [5248299.211589362]]\n    scObject.hub.v_CN_NInit = [[-5199.77710904224], [-3436.681645356935], [1041.576797498721]]\n    scObject.hub.sigma_BNInit = [[0.1], [0.2], [-0.3]]\n    scObject.hub.omega_BN_BInit = [[0.001], [-0.01], [0.03]]\n\n    # Constants for thruster creation\n    g = 9.80665\n    Isp = 226.7\n\n    #  Create the thrusters\n    thrusterSet = thrusterStateEffector.ThrusterStateEffector()\n    thrusterSet.ModelTag = \"ACSThrusterDynamics\"\n\n    #  Create thruster characteristic parameters (position, angle thrust, ISP, time of thrust) for thruster 1\n    long_angle_deg = long_angle  # Parametrized angle of thrust\n    lat_angle_deg = lat_angle\n    long_angle_rad = long_angle_deg * math.pi / 180.0\n    lat_angle_rad = lat_angle_deg * math.pi / 180.0\n    thruster1 = thrusterStateEffector.THRSimConfig()\n    thruster1.thrLoc_B = location  # Parametrized location for thruster\n    thruster1.thrDir_B = [[math.cos(long_angle_rad) * math.cos(lat_angle_rad)],\n                          [math.sin(long_angle_rad) * math.cos(lat_angle_rad)], [math.sin(lat_angle_rad)]]\n    thruster1.MaxThrust = 10.0\n    thruster1.steadyIsp = 226.7\n    thruster1.MinOnTime = 0.006\n    thruster1.cutoffFrequency = 5\n    thruster1.MaxSwirlTorque = swirlTorque\n    thrusterSet.addThruster(thruster1)\n\n    loc1 = np.array([thruster1.thrLoc_B[0][0], thruster1.thrLoc_B[1][0], thruster1.thrLoc_B[2][0]])\n    dir1 = np.array([thruster1.thrDir_B[0][0], thruster1.thrDir_B[1][0], thruster1.thrDir_B[2][0]])\n\n    #  Create thruster characteristic parameters for thruster 2\n    if thrustNumber == 2:\n        thruster2 = thrusterStateEffector.THRSimConfig()\n        thruster2.thrLoc_B = np.array([[1.], [0.0], [0.0]]).reshape([3, 1])\n        thruster2.thrDir_B = np.array(\n            [[math.cos(long_angle_rad + math.pi / 4.) * math.cos(lat_angle_rad - math.pi / 4.)],\n             [math.sin(long_angle_rad + math.pi / 4.) * math.cos(lat_angle_rad - math.pi / 4.)],\n             [math.sin(lat_angle_rad - math.pi / 4.)]]).reshape([3, 1])\n        thruster2.MaxThrust = 20.0\n        thruster2.steadyIsp = 226.7\n        thruster2.MinOnTime = 0.006\n        thruster2.cutoffFrequency = 2\n\n        loc2 = np.array([thruster2.thrLoc_B[0][0], thruster2.thrLoc_B[1][0], thruster2.thrLoc_B[2][0]])\n        dir2 = np.array([thruster2.thrDir_B[0][0], thruster2.thrDir_B[1][0], thruster2.thrDir_B[2][0]])\n\n        if attachBody == \"ON\":\n            # Set up the dcm and location\n            dcm_BF = np.array([[-1, 0, 0], [0, 1, 0], [0, 0, -1]])\n            r_FB_B = [0, 0, 1]\n\n            # Create the module\n            pyModule = attachedBodyModule(dcm_BF, r_FB_B, True, 100)\n            pyModule.ModelTag = \"attachedBody\"\n            TotalSim.AddModelToTask(unitTaskName3, pyModule)\n\n            # Attach messages\n            pyModule.scInMsg.subscribeTo(scObject.scStateOutMsg)\n\n            # Update the direction and location of the thruster\n            dir2 = dcm_BF.dot(dir2)\n            loc2 = dcm_BF.dot(loc2) + r_FB_B\n\n            # Attach thruster\n            thrusterSet.addThruster(thruster2, pyModule.bodyOutMsg)\n        else:\n            thrusterSet.addThruster(thruster2)\n\n    # Set the initial conditions\n    thrusterSet.kappaInit = messaging.DoubleVector([initialConditions])\n\n    # Attach thrusters and add the effector to the spacecraft\n    scObject.addStateEffector(thrusterSet)\n\n    # Save state\n    dataRec = thrusterSet.thrusterOutMsgs[0].recorder(testRate)\n\n    # Add both modules and the recorder to tasks\n    TotalSim.AddModelToTask(unitTaskName1, scObject)\n    TotalSim.AddModelToTask(unitTaskName2, thrusterSet)\n    TotalSim.AddModelToTask(unitTaskName2, dataRec)\n\n    #  Define the start of the thrust and its duration\n    thrDurationTime = macros.sec2nano(2.0)\n\n    # Log variables of interest\n    TotalSim.AddVariableForLogging('ACSThrusterDynamics.forceOnBody_B', testRate, 0, 2)\n    TotalSim.AddVariableForLogging('ACSThrusterDynamics.torqueOnBodyPntB_B', testRate, 0, 2)\n    TotalSim.AddVariableForLogging('ACSThrusterDynamics.mDotTotal', testRate, 0, 0)\n\n    #  Configure a single thruster firing, create a message for it\n    ThrustMessage = messaging.THRArrayOnTimeCmdMsgPayload()\n    if thrustNumber == 1:\n        ThrustMessage.OnTimeRequest = [duration]\n    if thrustNumber == 2:\n        ThrustMessage.OnTimeRequest = [duration, 2.]\n    thrCmdMsg = messaging.THRArrayOnTimeCmdMsg().write(ThrustMessage)\n    thrusterSet.cmdsInMsg.subscribeTo(thrCmdMsg)\n\n    # Initialize the simulation\n    TotalSim.InitializeSimulation()\n\n    # Close all plots\n    plt.close(\"all\")\n\n    # Run the simulation\n    TotalSim.ConfigureStopTime(TotalSim.TotalSim.CurrentNanos + int(thrDurationTime))\n    TotalSim.ExecuteSimulation()\n\n    # Plot the thrust factor if needed\n    dataThrustFactor = dataRec.thrustFactor\n    plt.figure(1)\n    plt.plot(dataRec.times() * macros.NANO2SEC, dataThrustFactor)\n    plt.xlabel('Time [s]')\n    plt.ylabel('Thrust Factor')\n    if show_plots:\n        plt.show()\n\n    # Gather the Force, Torque and Mass Rate results\n    thrForce = TotalSim.GetLogVariableData('ACSThrusterDynamics.forceOnBody_B')\n    thrTorque = TotalSim.GetLogVariableData('ACSThrusterDynamics.torqueOnBodyPntB_B')\n    mDot = TotalSim.GetLogVariableData('ACSThrusterDynamics.mDotTotal')\n\n    # Save the time vector\n    timeSec = dataRec.times() * macros.NANO2SEC\n\n    # Generate the truth data (force, torque and mass rate)\n    expectedThrustData = np.zeros([3, np.shape(thrForce)[0]])\n    expectedTorqueData = np.zeros([3, np.shape(thrTorque)[0]])\n    expectedMDot = np.zeros([1, np.shape(mDot)[0]])\n    for i in range(np.shape(thrForce)[0]):\n        if thrustNumber == 1:\n            # Compute the thrust force\n            if duration == 0.:\n                thrustFactor1 = initialConditions * np.exp(- thruster1.cutoffFrequency * timeSec[i])\n                force1 = thrustFactor1 * thruster1.MaxThrust * dir1\n                expectedThrustData[0:3, i] = force1\n            else:\n                thrustFactor1 = (1.0 + (initialConditions - 1.0) * np.exp(- thruster1.cutoffFrequency * timeSec[i]))\n                force1 = thrustFactor1 * thruster1.MaxThrust * dir1\n                expectedThrustData[0:3, i] = force1\n            # Compute the torque\n            expectedTorqueData[0:3, i] = np.cross(loc1, force1) + thrustFactor1 * swirlTorque * dir1\n            # Compute the mass flow rate\n            expectedMDot[0, i] = thruster1.MaxThrust / (g * Isp)\n        else:\n            # Compute the thrust force\n            if duration == 0.:\n                thrustFactor1 = initialConditions * np.exp(- thruster1.cutoffFrequency * timeSec[i])\n                thrustFactor2 = (1.0 - np.exp(- thruster2.cutoffFrequency * timeSec[i]))\n                force1 = thrustFactor1 * thruster1.MaxThrust * dir1\n                force2 = thrustFactor2 * thruster2.MaxThrust * dir2\n                expectedThrustData[0:3, i] = force1 + force2\n            else:\n                thrustFactor1 = (1.0 + (initialConditions - 1.0) * np.exp(- thruster1.cutoffFrequency * timeSec[i]))\n                thrustFactor2 = (1.0 - np.exp(- thruster2.cutoffFrequency * timeSec[i]))\n                force1 = thrustFactor1 * thruster1.MaxThrust * dir1\n                force2 = thrustFactor2 * thruster2.MaxThrust * dir2\n                expectedThrustData[0:3, i] = force1 + force2\n            # Compute the torque\n            expectedTorqueData[0:3, i] = np.cross(loc1, force1) + thrustFactor1 * swirlTorque * dir1 + np.cross(loc2, force2)\n            # Compute the mass flow rate\n            expectedMDot[0, i] = (thruster1.MaxThrust + thruster2.MaxThrust) / (g * Isp)\n\n    # Modify expected values for comparison and define errorTolerance\n    TruthForce = np.transpose(expectedThrustData)\n    TruthTorque = np.transpose(expectedTorqueData)\n    TruthMDot = np.transpose(expectedMDot)\n    ErrTolerance = 1E-3\n\n    # Compare Force values (exclude first element because of python process priority)\n    thrForce = np.delete(thrForce, 0, axis=1)  # remove time column\n    testFailCount, testMessages = unitTestSupport.compareArray(TruthForce[1:, :], thrForce[1:, :], ErrTolerance, \"Force\",\n                                                               testFailCount, testMessages)\n\n    # Compare Torque values (exclude first element because of python process priority)\n    thrTorque = np.delete(thrTorque, 0, axis=1)  # remove time column\n    testFailCount, testMessages = unitTestSupport.compareArray(TruthTorque[1:, :], thrTorque[1:, :], ErrTolerance, \"Torque\",\n                                                               testFailCount, testMessages)\n\n    # Compare mass flow rate values\n    mDot = np.delete(mDot, 0, axis=1)\n    ErrTolerance = 1E-6\n    testFailCount, testMessages = unitTestSupport.compareArray(np.transpose(TruthMDot), np.transpose(mDot), ErrTolerance, \"MDot\",\n                                                               testFailCount, testMessages)\n\n    if testFailCount == 0:\n        print(\"PASSED\")\n        testFixture.PassFail.append(\"PASSED\")\n    else:\n        testFixture.PassFail.append(\"FAILED\")\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "class attachedBodyModule(sysModel.SysModel):\n    def __init__(self, dcm_BF, r_FB_B, modelActive=True, modelPriority=-1):\n        super(attachedBodyModule, self).__init__()\n\n        # Input spacecraft state structure message\n        self.scInMsg = messaging.SCStatesMsgReader()\n        self.scMsgBuffer = None\n\n        # Output body state message\n        self.bodyOutMsg = messaging.SCStatesMsg()\n\n        # Save dcm and location\n        self.dcm_BF = dcm_BF\n        self.r_FB_B = r_FB_B\n\n    def UpdateState(self, CurrentSimNanos):\n        # Read input message\n        self.scMsgBuffer = self.scInMsg()\n\n        # Write output message\n        self.writeOutputMsg(CurrentSimNanos)\n\n    def writeOutputMsg(self, CurrentSimNanos):\n        # Create output message buffer\n        bodyOutMsgBuffer = messaging.SCStatesMsgPayload()\n\n        # Grab the spacecraft hub states\n        sigma_BN = self.scMsgBuffer.sigma_BN\n        dcm_BN = rbk.MRP2C(sigma_BN)\n        omega_BN_B = self.scMsgBuffer.omega_BN_B\n        r_BN_N = self.scMsgBuffer.r_BN_N\n\n        # Compute the attached body states relative to the hub\n        dcm_FB = np.transpose(self.dcm_BF)\n        sigma_FB = rbk.C2MRP(dcm_FB)\n        sigma_FN = rbk.addMRP(np.array(sigma_BN), sigma_FB)\n        omega_FB_F = dcm_FB.dot(omega_BN_B)\n        r_FN_N = r_BN_N + np.transpose(dcm_BN).dot(np.array(self.r_FB_B))\n\n        # Write the output message information\n        bodyOutMsgBuffer.sigma_BN = sigma_FN\n        bodyOutMsgBuffer.omega_BN_B = omega_FB_F\n        bodyOutMsgBuffer.r_BN_N = r_FN_N\n        self.bodyOutMsg.write(bodyOutMsgBuffer, CurrentSimNanos, self.moduleID)",
  "def __init__(self):\n        self.PassFail = []",
  "def texSnippet(self):\n        for i in range(len(self.PassFail)):\n            snippetName = 'Result' + str(i)\n            if self.PassFail[i] == 'PASSED':\n                textColor = 'ForestGreen'\n            elif self.PassFail[i] == 'FAILED':\n                textColor = 'Red'\n            texSnippet = r'\\textcolor{' + textColor + '}{' + self.PassFail[i] + '}'\n            unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)",
  "def __init__(self, dcm_BF, r_FB_B, modelActive=True, modelPriority=-1):\n        super(attachedBodyModule, self).__init__()\n\n        # Input spacecraft state structure message\n        self.scInMsg = messaging.SCStatesMsgReader()\n        self.scMsgBuffer = None\n\n        # Output body state message\n        self.bodyOutMsg = messaging.SCStatesMsg()\n\n        # Save dcm and location\n        self.dcm_BF = dcm_BF\n        self.r_FB_B = r_FB_B",
  "def UpdateState(self, CurrentSimNanos):\n        # Read input message\n        self.scMsgBuffer = self.scInMsg()\n\n        # Write output message\n        self.writeOutputMsg(CurrentSimNanos)",
  "def writeOutputMsg(self, CurrentSimNanos):\n        # Create output message buffer\n        bodyOutMsgBuffer = messaging.SCStatesMsgPayload()\n\n        # Grab the spacecraft hub states\n        sigma_BN = self.scMsgBuffer.sigma_BN\n        dcm_BN = rbk.MRP2C(sigma_BN)\n        omega_BN_B = self.scMsgBuffer.omega_BN_B\n        r_BN_N = self.scMsgBuffer.r_BN_N\n\n        # Compute the attached body states relative to the hub\n        dcm_FB = np.transpose(self.dcm_BF)\n        sigma_FB = rbk.C2MRP(dcm_FB)\n        sigma_FN = rbk.addMRP(np.array(sigma_BN), sigma_FB)\n        omega_FB_F = dcm_FB.dot(omega_BN_B)\n        r_FN_N = r_BN_N + np.transpose(dcm_BN).dot(np.array(self.r_FB_B))\n\n        # Write the output message information\n        bodyOutMsgBuffer.sigma_BN = sigma_FN\n        bodyOutMsgBuffer.omega_BN_B = omega_FB_F\n        bodyOutMsgBuffer.r_BN_N = r_FN_N\n        self.bodyOutMsg.write(bodyOutMsgBuffer, CurrentSimNanos, self.moduleID)",
  "class ResultsStore:\n    def __init__(self):\n        self.PassFail = []\n    def texSnippet(self):\n        for i in range(len(self.PassFail)):\n            snippetName = 'Result' + str(i)\n            if self.PassFail[i] == 'PASSED':\n                textColor = 'ForestGreen'\n            elif self.PassFail[i] == 'FAILED':\n                textColor = 'Red'\n            texSnippet =  r'\\textcolor{' + textColor + '}{'+ self.PassFail[i] + '}'\n            unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)",
  "def testFixture():\n    listRes = ResultsStore()\n    yield listRes\n    listRes.texSnippet()",
  "def thrusterEffectorAllTests(show_plots):\n   [testResults, testMessage] = test_unitThrusters(show_plots)",
  "def executeSimRun(simContainer, thrusterSet, simRate, totalTime):\n    newStopTime = simContainer.TotalSim.CurrentNanos + totalTime\n    while(simContainer.TotalSim.CurrentNanos < newStopTime):\n        simContainer.ConfigureStopTime(simContainer.TotalSim.CurrentNanos + simRate)\n        simContainer.ExecuteSimulation()\n\n        timeStep = 1.0  # not explicity used in this test\n        thrusterSet.computeForceTorque(simContainer.TotalSim.CurrentNanos*macros.NANO2SEC, timeStep)\n        thrusterSet.computeForceTorque(simContainer.TotalSim.CurrentNanos*macros.NANO2SEC + simRate*macros.NANO2SEC/2.0, timeStep)\n        thrusterSet.computeForceTorque(simContainer.TotalSim.CurrentNanos * macros.NANO2SEC + simRate * macros.NANO2SEC / 2.0, timeStep)\n        thrusterSet.computeForceTorque(simContainer.TotalSim.CurrentNanos*macros.NANO2SEC + simRate*macros.NANO2SEC, timeStep)\n\n        thrusterSet.computeStateContribution(simContainer.TotalSim.CurrentNanos * macros.NANO2SEC)\n        thrusterSet.computeStateContribution(\n            simContainer.TotalSim.CurrentNanos * macros.NANO2SEC + simRate * macros.NANO2SEC / 2.0)\n        thrusterSet.computeStateContribution(\n            simContainer.TotalSim.CurrentNanos * macros.NANO2SEC + simRate * macros.NANO2SEC / 2.0)\n        thrusterSet.computeStateContribution(\n            simContainer.TotalSim.CurrentNanos * macros.NANO2SEC + simRate * macros.NANO2SEC)",
  "def test_unitThrusters(testFixture, show_plots, ramp, thrustNumber , duration ,  long_angle, lat_angle,  location, rate, cutoff, rampDown, swirlTorque):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitThrusters(testFixture, show_plots, ramp, thrustNumber , duration  ,  long_angle, lat_angle , location, rate, cutoff, rampDown, swirlTorque)\n    assert testResults < 1, testMessage",
  "def unitThrusters(testFixture, show_plots, ramp, thrustNumber , duration  ,  long_angle, lat_angle, location, rate, cutoff, rampDown, swirlTorque):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Constants\n    g = 9.80665\n    Isp = 226.7\n\n    #  Create thrusters\n    thrusterSet = thrusterDynamicEffector.ThrusterDynamicEffector()\n    thrusterSet.ModelTag = \"ACSThrusterDynamics\"\n\n    #  Create thruster characteristic parameters (position, angle thrust, ISP, time of thrust)\n    angledeg_long = long_angle # Parametrized angle of thrust\n    angledeg_lat = lat_angle\n    anglerad_long = angledeg_long * math.pi/180.0\n    anglerad_lat = angledeg_lat * math.pi / 180.0\n    thruster1 = thrusterDynamicEffector.THRSimConfig()\n    thruster1.thrLoc_B = location # Parametrized location for thruster\n    thruster1.thrDir_B = [[math.cos(anglerad_long)*math.cos(anglerad_lat)], [math.sin(anglerad_long)*math.cos(anglerad_lat)], [math.sin(anglerad_lat)]]\n    thruster1.MaxThrust = 1.0\n    thruster1.steadyIsp = 226.7\n    thruster1.MinOnTime = 0.006\n    thruster1.MaxSwirlTorque = swirlTorque\n    thrusterSet.addThruster(thruster1)\n\n    loc1 = np.array([thruster1.thrLoc_B[0][0],thruster1.thrLoc_B[1][0],thruster1.thrLoc_B[2][0]])\n    dir1 = np.array([thruster1.thrDir_B[0][0], thruster1.thrDir_B[1][0], thruster1.thrDir_B[2][0]])\n\n    if thrustNumber==2:\n        thruster2 = thrusterDynamicEffector.THRSimConfig()\n        thruster2.thrLoc_B =np.array([[1.], [0.0], [0.0]]).reshape([3,1])\n        thruster2.thrDir_B = np.array([[math.cos(anglerad_long+math.pi/4.)*math.cos(anglerad_lat-math.pi/4.)], [math.sin(anglerad_long+math.pi/4.)*math.cos(anglerad_lat-math.pi/4.)], [math.sin(anglerad_lat-math.pi/4.)]]).reshape([3,1])\n        thruster2.MaxThrust = 1.0\n        thruster2.steadyIsp = 226.7\n        thruster2.MinOnTime = 0.006\n        thrusterSet.addThruster(thruster2)\n\n        loc2 = np.array([thruster2.thrLoc_B[0][0],thruster2.thrLoc_B[1][0],thruster2.thrLoc_B[2][0]])\n        dir2 = np.array([thruster2.thrDir_B[0][0], thruster2.thrDir_B[1][0], thruster2.thrDir_B[2][0]])\n\n    #  Create a Simulation\n    testRate = int(rate) # Parametrized rate of test\n    TotalSim = SimulationBaseClass.SimBaseClass()\n\n    # Create a new process for the unit test task and add the module to tasking\n    testProc = TotalSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(TotalSim.CreateNewTask(unitTaskName, testRate))\n    TotalSim.AddModelToTask(unitTaskName, thrusterSet)\n    TotalSim.scObject = spacecraft.Spacecraft()\n    TotalSim.scObject.ModelTag = \"spacecraftBody\"\n\n    #  Create a task manager\n    TotalSim.newManager = stateArchitecture.DynParamManager()\n    # TotalSim.AddModelToTask(unitTaskName, TotalSim.scObject)\n\n    #  Define the start of the thrust and it's duration\n    sparetime = 3.*1./macros.NANO2SEC\n    thrStartTime=sparetime\n    thrDurationTime=duration*1./macros.NANO2SEC # Parametrized thrust duration\n\n    #Configure a single thruster firing, create a message for it\n    TotalSim.AddVariableForLogging('ACSThrusterDynamics.forceExternal_B', testRate, 0, 2)\n    TotalSim.AddVariableForLogging('ACSThrusterDynamics.torqueExternalPntB_B', testRate, 0, 2)\n    TotalSim.AddVariableForLogging('ACSThrusterDynamics.mDotTotal', testRate, 0, 0)\n\n    ThrustMessage = messaging.THRArrayOnTimeCmdMsgPayload()\n    if thrustNumber==1:\n        ThrustMessage.OnTimeRequest = [0.]\n    if thrustNumber==2:\n        ThrustMessage.OnTimeRequest = [0., 0.]\n    thrCmdMsg = messaging.THRArrayOnTimeCmdMsg().write(ThrustMessage)\n    thrusterSet.cmdsInMsg.subscribeTo(thrCmdMsg)\n\n    TotalSim.InitializeSimulation()\n\n    #Configure the hub and link states\n    TotalSim.newManager.createProperty(\"r_BN_N\", [[0], [0], [0]])  # manually create the property\n    TotalSim.scObject.hub.registerStates(TotalSim.newManager)\n    thrusterSet.linkInStates(TotalSim.newManager)\n\n    plt.close(\"all\")\n    if ramp == \"OFF\":\n        # Run the simulation\n        executeSimRun(TotalSim, thrusterSet, testRate, int(thrStartTime))\n        if thrustNumber==1:\n            ThrustMessage.OnTimeRequest = [thrDurationTime*macros.NANO2SEC]\n        if thrustNumber==2:\n            ThrustMessage.OnTimeRequest = [thrDurationTime * macros.NANO2SEC, thrDurationTime * macros.NANO2SEC]\n        thrCmdMsg.write(ThrustMessage, TotalSim.TotalSim.CurrentNanos+testRate)\n        executeSimRun(TotalSim, thrusterSet, testRate, int(thrDurationTime+sparetime))\n\n        # Gather the Force and Torque results\n        thrForce = TotalSim.GetLogVariableData('ACSThrusterDynamics.forceExternal_B')\n        thrTorque = TotalSim.GetLogVariableData('ACSThrusterDynamics.torqueExternalPntB_B')\n        mDotData = TotalSim.GetLogVariableData('ACSThrusterDynamics.mDotTotal')\n\n        # Auto Generate LaTex Figures\n        format = r\"width=0.8\\textwidth\"\n\n        snippetName = \"Snippet\" + str(thrustNumber) + \"Thrusters_\" +  str(int(duration))+ \"s_\" +\\\n                      str(int(long_angle))+\"deg_\"+ \"Loc\"+ str(int(loc1[2])) + \"_Rate\"+str(int(1./(testRate*macros.NANO2SEC)))\n        if thrustNumber==1:\n            texSnippet = \"The thruster is set at \" +str(int(long_angle))+r\"$^\\circ$ off the x-axis \" +str(int(lat_angle))+r\"$^\\circ$ off the z-axis, in the position $\\bm r = \\left(\"+\\\n                         str(loc1[0])+\",\"+str(loc1[1])+\",\" +str(loc1[2])+ \\\n                         r\"\\right)$. The test is launched using \" + str(thrustNumber) + \" thruster, for \" + \\\n                         str(duration)+ \" seconds. The test rate is \" + str(int(1./(testRate*macros.NANO2SEC))) + \" steps per second\"\n        if thrustNumber==2:\n            texSnippet = \"The first thruster is set at \" + str(int(long_angle)) + r\"$^\\circ$ off the x-axis \" + str(\n                int(lat_angle)) + r\"$^\\circ$ off the z-axis, in the position $\\bm r = \\left(\" + \\\n                         str(loc1[0]) + \",\" + str(loc1[1]) + \",\" + str(loc1[2]) + \\\n                         r\"\\right)$. The second thruster is set at \" + str(int(long_angle+45)) + r\"$^\\circ$ off the x-axis \" + str(\n                int(lat_angle+45)) + r\"$^\\circ$ off the z-axis, in the position $\\bm r = \\left(\" + \\\n                         str(loc2[0]) + \",\" + str(loc2[1]) + \",\" + str(loc2[2]) + \\\n                         r\"\\right)$. The test uses these \" + str(thrustNumber) + \" thrusters for \" + \\\n                         str(duration) + \" seconds. The test rate is \" + str(\n                int(1. / (testRate * macros.NANO2SEC))) + \" steps per second\"\n        unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)\n\n        PlotName = \"Force_\" +  str(thrustNumber) + \"Thrusters_\" +  str(int(duration))+ \"s_\" +str(int(long_angle))+\"deg_\"+ \"Loc\"+str(int(location[2][0]))+ \"_Rate\"+str(int(1./(testRate*macros.NANO2SEC)))\n        PlotTitle = \"Force on Y with \" + str(thrustNumber) + \" thrusters, for \"  +  str(int(duration))+ \" sec at \" +str(int(long_angle))+\" deg \"+ \"Rate\"+str(int(1./(testRate*macros.NANO2SEC)))\n\n        plt.close(\"all\")\n        plt.figure(1)\n        plt.clf()\n        plt.plot(thrForce[:,0]*macros.NANO2SEC, thrForce[:,2])\n        plt.xlabel('Time(s)')\n        plt.ylabel('Thrust Factor (N)')\n        plt.ylim(-0.2,1)\n        unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n        if show_plots==True:\n            plt.show()\n            plt.close('all')\n\n        PlotName = \"Torque_\" +  str(thrustNumber) + \"Thrusters_\" +  str(int(duration))+ \"s_\" + str(int(long_angle))+\"deg_\"+ \"Loc\"+str(int(location[2][0]))+ \"_Rate\"+str(int(1./(testRate*macros.NANO2SEC)))\n        PlotTitle = \"Torque on X with \" + str(thrustNumber) + \" thrusters, for \"  +  str(int(duration))+ \" sec at \" + str(int(long_angle))+\" deg \" + \"Rate\"+str(int(1./(testRate*macros.NANO2SEC)))\n\n        plt.figure(11)\n        plt.clf()\n        plt.plot(thrForce[:,0]*macros.NANO2SEC, thrTorque[:,1])\n        plt.xlabel('Time(s)')\n        plt.ylabel('Thrust Torque (Nm)')\n        plt.ylim(-1.5, 2)\n        unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n        if show_plots==True:\n            plt.show()\n            plt.close('all')\n\n        PlotName =  str(thrustNumber) + \"Thrusters_\" +  str(int(duration))+ \"s_\" + str(int(long_angle))+\"deg_\"+ \"Loc\"+str(int(location[2][0]))+ \"_Rate\"+str(int(1./(testRate*macros.NANO2SEC)))\n        PlotTitle = \"All Forces and Torques \" + str(thrustNumber) + \" thrusters, for \"  +  str(int(duration))+ \" sec at \" + str(int(long_angle))+\" deg \"+ \"Rate\"+str(int(1./(testRate*macros.NANO2SEC)))\n\n        plt.figure(22)\n        plt.clf()\n        plt.plot(thrForce[:,0]*1.0E-9, thrForce[:,1], 'b', label='x Force')\n        plt.plot(thrTorque[:,0]*1.0E-9, thrTorque[:,1], 'b--', label='x Torque')\n        plt.plot(thrForce[:,0]*1.0E-9, thrForce[:,2], 'g', label='y Force')\n        plt.plot(thrTorque[:,0]*1.0E-9, thrTorque[:,2], 'g--', label='y Torque')\n        plt.plot(thrForce[:,0]*1.0E-9, thrForce[:,3], 'r', label = 'z Force')\n        plt.plot(thrTorque[:,0]*1.0E-9, thrTorque[:,3], 'r--', label='z Torque')\n        plt.legend(loc='upper right')\n        plt.xlabel('Time(s)')\n        plt.ylim(-1.5, 2)\n        plt.legend(loc='upper right')\n        unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n        if show_plots==True:\n            plt.show()\n            plt.close('all')\n\n        # Create expected Force to test against thrForce\n        expMDot = np.zeros([np.shape(np.array(mDotData))[0],1])\n        mDotData = np.delete(mDotData, 0, axis=1)\n        for i in range(np.shape(np.array(mDotData))[0]):\n            if (i > 0 and i < int(round((thrDurationTime) / testRate)) + 1):\n                expMDot[i, 0] = thrustNumber / (g * Isp)\n\n        expectedpoints=np.zeros([3,np.shape(thrForce)[0]])\n        for i in range(np.shape(thrForce)[0]):# Thrust fires 2 times steps after the pause of sim and restart\n            if (i>int(round(thrStartTime/ testRate)) + 1 and i<int(round((thrStartTime+thrDurationTime)/ testRate)) + 2):\n                if thrustNumber == 1:\n                    expectedpoints[0:3,i] = dir1\n                else:\n                    expectedpoints[0:3, i] = dir1 + dir2\n\n        # Modify expected values for comparison and define errorTolerance\n        TruthForce = np.transpose(expectedpoints)\n        ErrTolerance = 10E-9\n\n        # Compare Force values\n        thrForce = np.delete(thrForce, 0, axis=1)  # remove time column\n        testFailCount, testMessages = unitTestSupport.compareArray(TruthForce, thrForce, ErrTolerance, \"Force\", testFailCount, testMessages)\n\n        for i in range(0, len(np.array(mDotData))):\n            if not unitTestSupport.isArrayEqual(np.array(mDotData)[i,:], expMDot[i,:], 1, ErrTolerance):\n                testFailCount+=1\n                testMessages.append('M dot failure')\n\n        # Create expected Torque to test against thrTorque\n        expectedpointstor = np.zeros([3, np.shape(thrTorque)[0]])\n        for i in range(np.shape(thrForce)[0]): # Thrust fires 2 times steps after the pause of sim and restart\n            if (i>int(round(thrStartTime/ testRate)) + 1 and i<int(round((thrStartTime+thrDurationTime)/ testRate)) + 2):\n                if thrustNumber == 1:\n                    expectedpointstor[0:3, i] = np.cross(loc1, dir1) + swirlTorque * dir1\n                else:\n                    expectedpointstor[0:3, i] = np.cross(loc1, dir1)  + swirlTorque * dir1 + np.cross(loc2, dir2)\n\n        # Define errorTolerance\n        TruthTorque = np.transpose(expectedpointstor)\n        ErrTolerance = 10E-9\n\n        # Compare Torque values\n        # Compare Force values\n        thrTorque = np.delete(thrTorque, 0, axis=1)  # remove time column\n        testFailCount, testMessages = unitTestSupport.compareArray(TruthTorque, thrTorque, ErrTolerance, \"Torque\", testFailCount, testMessages)\n\n    if ramp == \"ON\":\n        format = r\"width=0.8\\textwidth\"\n        rampsteps = 10\n        sparetime = 3.*1/macros.NANO2SEC\n        thrStartTime = sparetime - 1.*1/macros.NANO2SEC\n\n        # Setup thruster ramp on and ramp off configuration\n        rampOnList = []\n        rampOffList = []\n        # Note that this ramp is totally linear and ramps up 30 ms using 30 steps\n        for i in range(rampsteps):\n            newElement = thrusterDynamicEffector.THRTimePair()\n            newElement.TimeDelta = (i + 1.) * 0.1\n            newElement.ThrustFactor = (i + 1.0) / 10.0\n            newElement.IspFactor = (i + 1.0) / 10.0\n            rampOnList.append(newElement)\n            newElement = thrusterDynamicEffector.THRTimePair()\n            newElement.TimeDelta = (i + 1) * 0.1\n            newElement.ThrustFactor = 1.0 - (i + 1.0) / 10.0\n            newElement.IspFactor = newElement.ThrustFactor\n            rampOffList.append(newElement)\n\n        # Set up the ramps\n        thrusterSet.thrusterData[0].ThrusterOnRamp = \\\n            thrusterDynamicEffector.ThrusterTimeVector(rampOnList)\n        thrusterSet.thrusterData[0].ThrusterOffRamp = \\\n            thrusterDynamicEffector.ThrusterTimeVector(rampOffList)\n\n        if rampDown == \"OFF\":\n            if cutoff == \"OFF\":\n                # Execute a new firing that will use the thruster ramps\n                executeSimRun(TotalSim, thrusterSet, testRate, int(thrStartTime))\n                ThrustMessage.OnTimeRequest =  [thrDurationTime*macros.NANO2SEC]\n                thrCmdMsg.write(ThrustMessage, TotalSim.TotalSim.CurrentNanos+testRate)\n                executeSimRun(TotalSim, thrusterSet, testRate, int(thrDurationTime+sparetime))\n\n                # Extract log variables and plot the results\n                thrForce = TotalSim.GetLogVariableData('ACSThrusterDynamics.forceExternal_B')\n                thrTorque = TotalSim.GetLogVariableData('ACSThrusterDynamics.torqueExternalPntB_B')\n                mDotData = TotalSim.GetLogVariableData('ACSThrusterDynamics.mDotTotal')\n\n                snippetName = \"Snippet\" + \"Ramp_\" + str(rampsteps) +\"steps_\" + str(int(duration)) + \"s\"+  \"_Cutoff\" + cutoff + \"_Rate\" + str(\n                    int(1. / (testRate * macros.NANO2SEC))) + \"_Cutoff\" + cutoff\n                texSnippet = \"We test the ramped thrust with \" + str(rampsteps) + \" incremental steps. The single thruster is set at the default \" +str(int(long_angle))+r\"$^\\circ$ off the x-axis \" +str(int(lat_angle))+r\"$^\\circ$ off the z-axis, at $\\bm r = \\left(\" + \\\n                             str(loc1[0]) + \",\" + str(loc1[1]) + \",\" + str(loc1[2]) + \\\n                             r\"\\right)$. The thrust is set for \" + \\\n                             str(duration) + \" seconds with a test rate of \" + str(\n                    int(1. / (testRate * macros.NANO2SEC))) + \" steps per second. The Cutoff test is \" + cutoff\n                unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)\n\n                PlotName = \"Ramp_\" + str(rampsteps) + \"steps_Cutoff\" + cutoff +\"_\" + str(int(duration)) + \"s\"+\"_testRate\" + str(\n                int(1. / (testRate * macros.NANO2SEC)))\n                PlotTitle = \"All Forces and Torques with \" + str(rampsteps) + \" step Ramp, thrust for \" + str(int(duration)) + \"s. Cutoff \" + cutoff+\", testRate\" + str(\n                int(1. / (testRate * macros.NANO2SEC)))\n\n                plt.figure(22)\n                plt.clf()\n                plt.plot(thrForce[:, 0] * 1.0E-9, thrForce[:, 1], 'b', label='x Force')\n                plt.plot(thrTorque[:, 0] * 1.0E-9, thrTorque[:, 1], 'b--', label='x Torque')\n                plt.plot(thrForce[:, 0] * 1.0E-9, thrForce[:, 2], 'g', label='y Force')\n                plt.plot(thrTorque[:, 0] * 1.0E-9, thrTorque[:, 2], 'g--', label='y Torque')\n                plt.plot(thrForce[:, 0] * 1.0E-9, thrForce[:, 3], 'r', label='z Force')\n                plt.plot(thrTorque[:, 0] * 1.0E-9, thrTorque[:, 3], 'r--', label='z Torque')\n                plt.legend(loc='upper right')\n                plt.xlabel('Time(s)')\n                plt.ylim(-1.5, 2)\n                plt.legend(loc='upper left')\n                unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n                if show_plots == True:\n                    plt.show()\n                    plt.close('all')\n\n                # Create expected Force to test against thrForce\n                expectedpoints = np.zeros([3, np.shape(thrForce)[0]])\n                RampFunction= np.zeros([np.shape(thrForce)[0]])\n                ramplength = 1.\n                if ramplength < thrDurationTime*macros.NANO2SEC:\n                    for i in range(np.shape(thrForce)[0]):\n                        if i<int(round(thrStartTime / testRate)) + 2:\n                            RampFunction[i] = 0.0\n                        if (i > int(round(thrStartTime / testRate)) + 1 and i < int(round((thrStartTime + ramplength*1.0/macros.NANO2SEC)/ testRate)) + 2) : #ramp up\n                            RampFunction[i] = (i-int(round(thrStartTime / testRate)) - 2 + 1.0) * (macros.NANO2SEC*testRate)\n                        if (i > int(round((thrStartTime + ramplength*1.0/macros.NANO2SEC)/ testRate)) + 1 and i < int(round((thrStartTime + thrDurationTime) / testRate)) + 2):\n                            RampFunction[i]=1.0\n                        if (i > int(round((thrStartTime + thrDurationTime) / testRate)) + 1 and i < int(round((thrStartTime + thrDurationTime+ ramplength*1.0/macros.NANO2SEC) / testRate)) + 2):\n                            RampFunction[i] = 1.0 - (i - int(round((thrStartTime + thrDurationTime) / testRate))-2 + 1.0) *(macros.NANO2SEC*testRate)\n                        if (i > int(round((thrStartTime + thrDurationTime+ ramplength*1.0/macros.NANO2SEC) / testRate)) + 1):\n                            RampFunction[i] = 0.\n                else:\n                    for i in range(np.shape(thrForce)[0]):\n                        if i<int(round(thrStartTime / testRate)) + 2:\n                            RampFunction[i] = 0.0\n                        if (i > int(round(thrStartTime / testRate)) + 1 and i < int(round((thrStartTime + thrDurationTime)/ testRate)) + 2) : #ramp up\n                            RampFunction[i] = (i-int(round(thrStartTime / testRate)) - 2 + 1.0) * (macros.NANO2SEC*testRate)\n                        if (i > int(round((thrStartTime + thrDurationTime) / testRate)) + 1 and i < int(round((thrStartTime + 2*thrDurationTime) / testRate)) + 2):\n                            RampFunction[i] = RampFunction[int(round((thrStartTime + thrDurationTime) / testRate)) + 1] - (i - int(round((thrStartTime + thrDurationTime) / testRate))-2 + 1.0) *(macros.NANO2SEC*testRate)\n                        if (i > int(round((thrStartTime + thrDurationTime+ ramplength*1.0/macros.NANO2SEC) / testRate)) + 1):\n                            RampFunction[i] = 0.\n\n\n                # Create expected Force to test against thrForce\n                expMDot = np.zeros([np.shape(np.array(mDotData))[0], 1])\n                for i in range(np.shape(RampFunction)[0]- (int(round(thrStartTime/testRate))+1)):\n                    if (i>0 and RampFunction[i + int(round(thrStartTime/testRate))+1]!=0.):\n                        expMDot[i, 0] = thrustNumber / (g * Isp)\n\n                for i in range(np.shape(thrForce)[0]): # Thrust fires 2 times steps after the pause of sim and restart\n                    if (i > int(round(thrStartTime / testRate)) + 1 and i < int(round((thrStartTime + thrDurationTime+ ramplength*1.0/macros.NANO2SEC) / testRate)) + 2):\n                        expectedpoints[0:3, i] = dir1*RampFunction[i]\n\n                # Modify expected values for comparison and define errorTolerance\n                TruthForce = np.transpose(expectedpoints)\n                ErrTolerance = 10E-9\n\n                # Compare Force values and M-dot\n                thrForce = np.delete(thrForce, 0, axis=1)  # remove time column\n                testFailCount, testMessages = unitTestSupport.compareArray(TruthForce, thrForce, ErrTolerance, \"Force\",\n                                                                           testFailCount, testMessages)\n                mDotData = np.delete(mDotData, 0, axis=1)  # remove time column\n                for i in range(0, len(np.array(mDotData))):\n                    if not unitTestSupport.isArrayEqual(np.array(mDotData)[i, :], expMDot[i, :], 1, ErrTolerance):\n                        testFailCount += 1\n                        testMessages.append('M dot failure')\n\n                # Create expected Torque to test against thrTorque\n                expectedpointstor = np.zeros([3, np.shape(thrTorque)[0]])\n                for i in range(np.shape(thrForce)[0]):  # Thrust fires 2 times steps after the pause of sim and restart\n                    if (i > int(round(thrStartTime / testRate)) + 1 and i < int(round((thrStartTime + thrDurationTime+ ramplength*1.0/macros.NANO2SEC) / testRate)) + 2):\n                            expectedpointstor[0:3, i] = (np.cross(loc1,dir1) + swirlTorque * dir1) * RampFunction[i]\n\n                # Define errorTolerance\n                TruthTorque = np.transpose(expectedpointstor)\n                ErrTolerance = 10E-9\n\n                # Compare Torque values\n                # Compare Force values\n                thrTorque = np.delete(thrTorque, 0, axis=1)  # remove time column\n                testFailCount, testMessages = unitTestSupport.compareArray(TruthTorque, thrTorque, ErrTolerance,\n                                                                           \"Torque\", testFailCount, testMessages)\n            if cutoff == \"ON\":\n                COtime = 0.2\n                COrestart = 0.3\n\n                executeSimRun(TotalSim, thrusterSet, testRate, int(thrStartTime))\n                ThrustMessage.OnTimeRequest = [COtime * 10.]\n                thrCmdMsg.write(ThrustMessage, TotalSim.TotalSim.CurrentNanos+testRate)\n                executeSimRun(TotalSim, thrusterSet, testRate, int(COtime * 1.0 / macros.NANO2SEC))\n                ThrustMessage.OnTimeRequest = [COrestart]\n                thrCmdMsg.write(ThrustMessage, TotalSim.TotalSim.CurrentNanos+testRate)\n                executeSimRun(TotalSim, thrusterSet, testRate, int(COrestart * 1.0 / macros.NANO2SEC + sparetime))\n\n                # Extract log variables and plot the results\n                thrForce = TotalSim.GetLogVariableData('ACSThrusterDynamics.forceExternal_B')\n                thrTorque = TotalSim.GetLogVariableData('ACSThrusterDynamics.torqueExternalPntB_B')\n                mDotData = TotalSim.GetLogVariableData('ACSThrusterDynamics.mDotTotal')\n\n                PlotName = \"Ramp_\" + str(rampsteps) + \"steps_Cutoff\" + cutoff +\"_\" + str(int(duration)) + \"s\"+\"_testRate\" + str(\n                int(1. / (testRate * macros.NANO2SEC)))\n                PlotTitle = \"All Forces and Torques, with a \"  + str(rampsteps) + \" step Ramp, thrust for \" + str(int(duration)) + \"s. Cutoff \" + cutoff+\", testRate\" + str(\n                int(1. / (testRate * macros.NANO2SEC)))\n\n                snippetName = \"Snippet\" + \"Ramp_\" + str(rampsteps) + \"steps_Cutoff\" + cutoff + \"_Rate\" + str(\n                    int(1. / (testRate * macros.NANO2SEC)))  + \"_Cutoff\" + cutoff\n                texSnippet = \"We test the ramped thrust with \" + str(rampsteps) + \" incremental steps. The single thruster is set at the default \" +str(int(long_angle))+r\"$^\\circ$ off the x-axis \" +str(int(lat_angle))+r\"$^\\circ$ off the z-axis, at $\\bm r = \\left(\" + \\\n                             str(loc1[0]) + \",\" + str(loc1[1]) + \",\" + str(loc1[2]) + \\\n                             r\"\\right)$. The thrust is set for \" + \\\n                             str(duration) + \" seconds with a test rate of \" + str(\n                    int(1. / (testRate * macros.NANO2SEC))) + \" steps per second. The Cutoff test is \" + cutoff\n                unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)\n\n                plt.figure(55)\n                plt.clf()\n                plt.plot(thrForce[:, 0] * 1.0E-9, thrForce[:, 1], 'b', label='x Force')\n                plt.plot(thrTorque[:, 0] * 1.0E-9, thrTorque[:, 1], 'b--', label='x Torque')\n                plt.plot(thrForce[:, 0] * 1.0E-9, thrForce[:, 2], 'g', label='y Force')\n                plt.plot(thrTorque[:, 0] * 1.0E-9, thrTorque[:, 2], 'g--', label='y Torque')\n                plt.plot(thrForce[:, 0] * 1.0E-9, thrForce[:, 3], 'r', label='z Force')\n                plt.plot(thrTorque[:, 0] * 1.0E-9, thrTorque[:, 3], 'r--', label='z Torque')\n                plt.legend(loc='upper right')\n                plt.xlabel('Time(s)')\n                plt.ylim(-1.5, 2)\n                plt.legend(loc='upper left')\n                unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n                if show_plots == True:\n                    plt.show()\n                    plt.close('all')\n\n                # Create expected Force to test against thrForce\n                expectedpoints = np.zeros([3, np.shape(thrForce)[0]])\n                RampFunction= np.zeros([np.shape(thrForce)[0]])\n                ramplength = 0.5\n\n                for i in range(np.shape(thrForce)[0]):\n                    if i<int(round(thrStartTime / testRate)) + 2:\n                        RampFunction[i] = 0.0\n                    if (i > int(round(thrStartTime / testRate)) + 1 and i < int(round((thrStartTime + ramplength*1.0/macros.NANO2SEC)/ testRate)) + 2) : #ramp up\n                        RampFunction[i] = (i-int(round(thrStartTime / testRate)) - 2 + 1.0) * (macros.NANO2SEC*testRate)\n                    if (i > int(round((thrStartTime + ramplength*1.0/macros.NANO2SEC) / testRate)) + 1 and i < int(round((thrStartTime + 2*ramplength*1.0/macros.NANO2SEC) / testRate)) + 2):\n                        RampFunction[i] = RampFunction[int(round((thrStartTime + ramplength*1.0/macros.NANO2SEC) / testRate)) + 1] - (i - int(round((thrStartTime + ramplength*1.0/macros.NANO2SEC) / testRate))-2 + 1.0) *(macros.NANO2SEC*testRate)\n                    if (i > int(round((thrStartTime + 2*ramplength*1.0/macros.NANO2SEC) / testRate)) + 1):\n                        RampFunction[i] = 0.\n\n                # Create expected Force to test against thrForce\n                expMDot = np.zeros([np.shape(np.array(mDotData))[0], 1])\n                for i in range(np.shape(RampFunction)[0]- (int(round(thrStartTime/testRate))+1)):\n                    if (i>0 and RampFunction[i + int(round(thrStartTime/testRate))+1]!=0.):\n                        expMDot[i, 0] = thrustNumber / (g * Isp)\n\n                for i in range(np.shape(thrForce)[0]):# Thrust fires 2 times steps after the pause of sim and restart\n                    if (i > int(round(thrStartTime / testRate)) + 1 and i < int(round((thrStartTime + thrDurationTime+ ramplength*1.0/macros.NANO2SEC) / testRate)) + 2):\n                        expectedpoints[0:3, i] = dir1*RampFunction[i]\n\n                # Modify expected values for comparison and define errorTolerance\n                TruthForce = np.transpose(expectedpoints)\n                ErrTolerance = 10E-9\n\n                # Compare Force values\n                thrForce = np.delete(thrForce, 0, axis=1)  # remove time column\n                testFailCount, testMessages = unitTestSupport.compareArray(TruthForce, thrForce, ErrTolerance, \"Force\",\n                                                                           testFailCount, testMessages)\n                mDotData = np.delete(mDotData, 0, axis=1)  # remove time column\n                for i in range(0, len(np.array(mDotData))):\n                    if not unitTestSupport.isArrayEqual(np.array(mDotData)[i, :], expMDot[i, :], 1, ErrTolerance):\n                        testFailCount += 1\n                        testMessages.append('M dot failure')\n\n                # Create expected Torque to test against thrTorque\n                expectedpointstor = np.zeros([3, np.shape(thrTorque)[0]])\n                for i in range(np.shape(thrForce)[0]): # Thrust fires 2 times steps after the pause of sim and restart\n                    if (i > int(round(thrStartTime / testRate)) + 1 and i < int(round((thrStartTime + thrDurationTime+ ramplength*1.0/macros.NANO2SEC) / testRate)) + 2):\n                            expectedpointstor[0:3, i] = (np.cross(loc1,dir1) + swirlTorque * dir1) * RampFunction[i]\n\n                # Define errorTolerance\n                TruthTorque = np.transpose(expectedpointstor)\n                ErrTolerance = 10E-9\n\n                # Compare Torque values\n                # Compare Force values\n                thrTorque = np.delete(thrTorque, 0, axis=1)  # remove time column\n                testFailCount, testMessages = unitTestSupport.compareArray(TruthTorque, thrTorque, ErrTolerance,\n                                                                           \"Torque\", testFailCount, testMessages)\n\n        if rampDown == \"ON\":\n            RDrestart = 0.2\n            RDstart = 0.5\n            RDlength = 1.5\n\n            executeSimRun(TotalSim, thrusterSet, testRate, int(thrStartTime))\n            ThrustMessage.OnTimeRequest = [RDstart]\n            thrCmdMsg.write(ThrustMessage, TotalSim.TotalSim.CurrentNanos+testRate)\n            executeSimRun(TotalSim, thrusterSet, testRate, int((RDstart+ RDrestart) * 1.0 / macros.NANO2SEC))\n            ThrustMessage.OnTimeRequest = [RDlength]\n            thrCmdMsg.write(ThrustMessage, TotalSim.TotalSim.CurrentNanos+testRate)\n            executeSimRun(TotalSim, thrusterSet, testRate, int(RDlength * 1.0 / macros.NANO2SEC + sparetime))\n\n            # Extract log variables and plot the results\n            thrForce = TotalSim.GetLogVariableData('ACSThrusterDynamics.forceExternal_B')\n            thrTorque = TotalSim.GetLogVariableData('ACSThrusterDynamics.torqueExternalPntB_B')\n            mDotData = TotalSim.GetLogVariableData('ACSThrusterDynamics.mDotTotal')\n\n            PlotName = \"Ramp_\" + str(rampsteps) + \"steps_Cutoff\" + cutoff + \"rampDown\" + rampDown+\"_testRate\" + str(\n                int(1. / (testRate * macros.NANO2SEC)))\n            PlotTitle = \"All Forces and Torques, with a \" + str(rampsteps) + \" step Ramp, Cutoff \" + cutoff + \", RampDown\" + rampDown +\" testRate\" + str(\n                int(1. / (testRate * macros.NANO2SEC)))\n\n            snippetName = \"Snippet\" + \"Ramp_\" + str(rampsteps) + \"steps_Cutoff\" + cutoff + \"_Rate\" + str(\n                int(1. / (testRate * macros.NANO2SEC)))+ \"rampDown\" + rampDown\n            texSnippet = \"We test the ramped thrust with \" + str(\n                rampsteps) + \" incremental steps. The single thruster is set at the default \"+str(int(long_angle))+r\"$^\\circ$ off the x-axis \" +str(int(lat_angle))+r\"$^\\circ$ off the z-axis, at $\\bm r = \\left(\" + \\\n                         str(loc1[0]) + \",\" + str(loc1[1]) + \",\" + str(loc1[2]) + \\\n                         r\"\\right)$. The thrust is set for \" + \\\n                         str(RDstart) + \" seconds initially with a test rate of \" + str(\n                int(1. / (testRate * macros.NANO2SEC))) + \" steps per second. The Cutoff test is \" + cutoff + \\\n                        \" the RampDown test is \" + rampDown + \".\"\n            unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)\n\n            plt.figure(55)\n            plt.clf()\n            plt.plot(thrForce[:, 0] * 1.0E-9, thrForce[:, 1], 'b', label='x Force')\n            plt.plot(thrTorque[:, 0] * 1.0E-9, thrTorque[:, 1], 'b--', label='x Torque')\n            plt.plot(thrForce[:, 0] * 1.0E-9, thrForce[:, 2], 'g', label='y Force')\n            plt.plot(thrTorque[:, 0] * 1.0E-9, thrTorque[:, 2], 'g--', label='y Torque')\n            plt.plot(thrForce[:, 0] * 1.0E-9, thrForce[:, 3], 'r', label='z Force')\n            plt.plot(thrTorque[:, 0] * 1.0E-9, thrTorque[:, 3], 'r--', label='z Torque')\n            plt.legend(loc='upper right')\n            plt.xlabel('Time(s)')\n            plt.ylim(-1.5, 2)\n            plt.legend(loc='upper left')\n            unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n            if show_plots == True:\n                plt.show()\n                plt.close('all')\n\n            # Create expected Force to test against thrForce\n            expectedpoints = np.zeros([3, np.shape(thrForce)[0]])\n            RampFunction = np.zeros([np.shape(thrForce)[0]])\n            ramplength = 1.\n            for i in range(np.shape(thrForce)[0]):\n                if i < int(round(thrStartTime / testRate)) + 2:\n                    RampFunction[i] = 0.0\n                if (i > int(round(thrStartTime / testRate)) + 1 and i < int(round((thrStartTime + RDstart * 1.0 / macros.NANO2SEC) / testRate)) + 2):  # ramp up\n                    RampFunction[i] = (i - int(round(thrStartTime / testRate)) - 2 + 1.0) * (macros.NANO2SEC * testRate)\n                if (i > int(round((thrStartTime + RDstart * 1.0 / macros.NANO2SEC) / testRate)) + 1 and i < int(round((thrStartTime + (RDstart+RDrestart) * 1.0 / macros.NANO2SEC) / testRate)) + 2):\n                    RampFunction[i] = RampFunction[int(round((thrStartTime + RDstart * 1.0 / macros.NANO2SEC) / testRate)) + 1] - (i - int(round((thrStartTime + (RDstart) * 1.0 / macros.NANO2SEC) / testRate)) - 2 + 1.0) * (macros.NANO2SEC * testRate)\n                if (i > int(round((thrStartTime + (RDstart+RDrestart) * 1.0 / macros.NANO2SEC) / testRate)) + 1 and i < int(round((thrStartTime + (RDstart+RDrestart+(1. -RDstart+RDrestart)) * 1.0 / macros.NANO2SEC) / testRate)) + 2):  # ramp up\n                    RampFunction[i] = RampFunction[int(round((thrStartTime + (RDstart+RDrestart) * 1.0 / macros.NANO2SEC) / testRate)) + 1]+ (i - int(round((thrStartTime+ (RDstart+RDrestart)* 1.0 / macros.NANO2SEC) / testRate)) - 2 + 1.0) * (macros.NANO2SEC * testRate)\n                if (i > int(round((thrStartTime +  (RDstart+RDrestart+(1. -RDstart+RDrestart)) * 1.0 / macros.NANO2SEC) / testRate)) + 1 and i < int(round((thrStartTime + (RDstart+RDrestart + RDlength) * 1.0 / macros.NANO2SEC) / testRate)) + 2):\n                    RampFunction[i] = 1.0\n                if (i > int(round((thrStartTime + (RDstart+RDrestart + RDlength) * 1.0 / macros.NANO2SEC) / testRate)) + 1 and i < int(round((thrStartTime + (RDstart+RDrestart + RDlength+1) * 1.0 / macros.NANO2SEC) / testRate)) + 2):\n                    RampFunction[i] = 1.0 - (i - int(round((thrStartTime + (RDstart+RDrestart + RDlength) * 1.0 / macros.NANO2SEC) / testRate)) - 2 + 1.0) * (macros.NANO2SEC * testRate)\n                if (i > int(round((thrStartTime + (RDstart+RDrestart + RDlength+ ramplength) * 1.0 / macros.NANO2SEC) / testRate)) + 1):\n                    RampFunction[i] = 0.\n\n            # Create expected Force to test against thrForce\n            expMDot = np.zeros([np.shape(np.array(mDotData))[0], 1])\n            for i in range(1,np.shape(RampFunction)[0] - (int(round(thrStartTime / testRate))+1)):\n                if (RampFunction[i + int(round(thrStartTime / testRate))+1] != 0.):\n                    expMDot[i, 0] = thrustNumber / (g * Isp)\n                    expMDot[i+1, 0] = thrustNumber / (g * Isp) # The way the last ramp is set up, we need another mdot value\n\n            PlotName = \"Ramp_function\"\n            PlotTitle = \"Example of ramp function\"\n\n            plt.figure(11)\n            plt.clf()\n            plt.plot(thrForce[:, 0] * macros.NANO2SEC, RampFunction)\n            plt.xlabel('Time(s)')\n            plt.ylabel('Ramp(-)')\n            plt.ylim(-1.5, 2)\n            unitTestSupport.writeFigureLaTeX(PlotName, PlotTitle, plt, format, path)\n            if show_plots == True:\n                plt.show()\n                plt.close('all')\n\n            for i in range(np.shape(thrForce)[0]): # Thrust fires 2 times steps after the pause of sim and restart\n                if (i > int(round(thrStartTime / testRate)) + 1 and i < int(\n                        round((thrStartTime + thrDurationTime + ramplength * 1.0 / macros.NANO2SEC) / testRate)) + 2):\n                    expectedpoints[0:3, i] = dir1*RampFunction[i]\n\n\n            # Modify expected values for comparison and define errorTolerance\n            TruthForce = np.transpose(expectedpoints)\n            ErrTolerance = 10E-9\n\n            # Compare Force values\n            thrForce = np.delete(thrForce, 0, axis=1)  # remove time column\n            testFailCount, testMessages = unitTestSupport.compareArray(TruthForce, thrForce, ErrTolerance, \"Force\",\n                                                                       testFailCount, testMessages)\n            mDotData = np.delete(mDotData, 0, axis=1)  # remove time column\n            for i in range(0, len(np.array(mDotData))):\n                if not unitTestSupport.isArrayEqual(np.array(mDotData)[i, :], expMDot[i, :], 1, ErrTolerance):\n                    testFailCount += 1\n                    testMessages.append('M dot failure')\n\n            # Create expected Torque to test against thrTorque\n            expectedpointstor = np.zeros([3, np.shape(thrTorque)[0]])\n            for i in range(np.shape(thrForce)[0]): # Thrust fires 2 times steps after the pause of sim and restart\n                if (i > int(round(thrStartTime / testRate)) + 1 and i < int(\n                        round((thrStartTime + thrDurationTime + ramplength * 1.0 / macros.NANO2SEC) / testRate)) + 2):\n                    expectedpointstor[0:3, i] = (np.cross(loc1, dir1) + swirlTorque * dir1) * RampFunction[i]\n\n\n            # Define errorTolerance\n            TruthTorque = np.transpose(expectedpointstor)\n            ErrTolerance = 10E-9\n\n            # Compare Torque values\n            # Compare Force values\n            thrTorque = np.delete(thrTorque, 0, axis=1)  # remove time column\n            testFailCount, testMessages = unitTestSupport.compareArray(TruthTorque, thrTorque, ErrTolerance,\n                                                                       \"Torque\", testFailCount, testMessages)\n\n\n\n    if testFailCount == 0:\n        print(\"PASSED\")\n        testFixture.PassFail.append(\"PASSED\")\n    else:\n        testFixture.PassFail.append(\"FAILED\")\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def __init__(self):\n        self.PassFail = []",
  "def texSnippet(self):\n        for i in range(len(self.PassFail)):\n            snippetName = 'Result' + str(i)\n            if self.PassFail[i] == 'PASSED':\n                textColor = 'ForestGreen'\n            elif self.PassFail[i] == 'FAILED':\n                textColor = 'Red'\n            texSnippet =  r'\\textcolor{' + textColor + '}{'+ self.PassFail[i] + '}'\n            unitTestSupport.writeTeXSnippet(snippetName, texSnippet, path)",
  "def test_thrusterIntegratedTest(show_plots):\n    [testResults, testMessage] = thrusterIntegratedTest(show_plots)\n    assert testResults < 1, testMessage",
  "def thrusterIntegratedTest(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    \n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n    \n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    \n    # Create test thread\n    testProcessRate = macros.sec2nano(0.1)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # add thruster devices\n    thFactory = simIncludeThruster.thrusterFactory()\n    TH1 = thFactory.create(\n        'MOOG_Monarc_1',\n        [1,0,0],                # location in B-frame\n        [0,1,0]                 # thruster force direction in B-frame\n    )\n\n    # create thruster object container and tie to spacecraft object\n    thrustersDynamicEffector = thrusterDynamicEffector.ThrusterDynamicEffector()\n    thFactory.addToSpacecraft(\"Thrusters\",\n                              thrustersDynamicEffector,\n                              scObject)\n\n    # create tank object container\n    unitTestSim.fuelTankStateEffector = fuelTank.FuelTank()\n    unitTestSim.fuelTankStateEffector.setTankModel(fuelTank.TANK_MODEL_CONSTANT_VOLUME)\n    tankModel = fuelTank.cvar.FuelTankModelConstantVolume\n    tankModel.propMassInit = 40.0\n    tankModel.r_TcT_TInit = [[0.0],[0.0],[0.0]]\n    unitTestSim.fuelTankStateEffector.r_TB_B = [[0.0],[0.0],[0.0]]\n    tankModel.radiusTankInit = 46.0 / 2.0 / 3.2808399 / 12.0\n\n    unitTestSim.fuelTankStateEffector.addThrusterSet(thrustersDynamicEffector)\n    scObject.addStateEffector(unitTestSim.fuelTankStateEffector)\n\n    # set thruster commands\n    ThrustMessage = messaging.THRArrayOnTimeCmdMsgPayload()\n    ThrustMessage.OnTimeRequest = [9.9]\n    thrCmdMsg = messaging.THRArrayOnTimeCmdMsg().write(ThrustMessage)\n    thrustersDynamicEffector.cmdsInMsg.subscribeTo(thrCmdMsg)\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, thrustersDynamicEffector)\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n    \n    unitTestSim.earthGravBody = gravityEffector.GravBodyData()\n    unitTestSim.earthGravBody.planetName = \"earth_planet_data\"\n    unitTestSim.earthGravBody.mu = 0.3986004415E+15 # meters!\n    unitTestSim.earthGravBody.isCentralBody = True\n    unitTestSim.earthGravBody.useSphericalHarmParams = False\n\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector([unitTestSim.earthGravBody])\n\n    # Define initial conditions of the spacecraft\n    scObject.hub.mHub = 750.0\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n    scObject.hub.r_CN_NInit = [[-4020338.690396649],\t[7490566.741852513],\t[5248299.211589362]]\n    scObject.hub.v_CN_NInit = [[-5199.77710904224],\t[-3436.681645356935],\t[1041.576797498721]]\n    scObject.hub.sigma_BNInit = [[0.1], [0.2], [-0.3]]\n    scObject.hub.omega_BN_BInit = [[0.001], [-0.01], [0.03]]\n\n    unitTestSim.InitializeSimulation()\n\n    # Get access to dynManager's translational state\n    posRef = scObject.dynManager.getStateObject(\"hubPosition\")\n    sigmaRef = scObject.dynManager.getStateObject(\"hubSigma\")\n\n\n    stopTime = 60.0*10.0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(stopTime))\n    unitTestSim.ExecuteSimulation()\n\n    dataPos = posRef.getState()\n    dataSigma = sigmaRef.getState()\n    dataPos = [[dataPos[0][0], dataPos[1][0], dataPos[2][0]]]\n    dataSigma = [[dataSigma[0][0], dataSigma[1][0], dataSigma[2][0]]]\n\n    truePos = [\n                [-6.7815933935338277e+06, 4.9468685979815889e+06, 5.4867416696776701e+06]\n                ]\n\n    trueSigma = [\n                [1.4401781243854264e-01, -6.4168702021364002e-02, 3.0166086824900967e-01]\n                ]\n\n    accuracy = 1e-8\n    for i in range(0,len(truePos)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(dataPos[i],truePos[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Thruster Integrated Test failed pos unit test\")\n\n    accuracy = 1e-7\n    for i in range(0,len(trueSigma)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(dataSigma[i],trueSigma[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Thruster Integrated Test failed attitude unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Thruster Integrated Sim Test\")\n\n    assert testFailCount < 1, testMessages\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def thrusterEffectorAllTests(show_plots):\n    [testResults, testMessage] = test_unitThrusters(show_plots)",
  "def test_unitThrusters(show_plots, long_angle, lat_angle, location, rate):\n    r\"\"\"\n    This unit test checks the functionality of attaching a dynamic thruster to a body other than the hub. Although the\n    attached body is fixed with respect to the hub, the point where the thruster is attached now has an additional\n    offset and a different orientation.\n\n    The unit test sets up the thruster as normal, but then converts the direction and location to take into account the\n    attached body for testing purposes. The thruster is set to fire for the first half of the simulation, and then turn\n    off.\n\n    As with the other tests, the expected forces and torques are compared with the values from the module to check that\n    everything matches accordingly.\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitThrusters(show_plots, long_angle, lat_angle, location, rate)\n    assert testResults < 1, testMessage",
  "def unitThrusters(show_plots, long_angle, lat_angle, location, rate):\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    #  Create a simulation and set the rate\n    TotalSim = SimulationBaseClass.SimBaseClass()\n    testRate = int(rate)  # Parametrized rate of test\n\n    # Create the process and task\n    unitTaskName1 = \"unitTask1\"  # arbitrary name (don't change)\n    unitTaskName2 = \"unitTask2\"  # arbitrary name (don't change)\n    unitTaskName3 = \"unitTask3\"  # arbitrary name (don't change)\n    unitProcessName1 = \"TestProcess1\"  # arbitrary name (don't change)\n    unitProcessName2 = \"TestProcess2\"  # arbitrary name (don't change)\n    unitProcessName3 = \"TestProcess3\"  # arbitrary name (don't change)\n    testProc1 = TotalSim.CreateNewProcess(unitProcessName1, 10)\n    testProc1.addTask(TotalSim.CreateNewTask(unitTaskName1, testRate))\n    testProc2 = TotalSim.CreateNewProcess(unitProcessName2, 0)\n    testProc2.addTask(TotalSim.CreateNewTask(unitTaskName2, testRate))\n    testProc3 = TotalSim.CreateNewProcess(unitProcessName3, 5)\n    testProc3.addTask(TotalSim.CreateNewTask(unitTaskName3, testRate))\n\n    # Create the spacecraft object\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    # Define initial conditions of the spacecraft\n    scObject.hub.mHub = 750.0\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [0.0]]\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n    scObject.hub.r_CN_NInit = [[-4020338.690396649], [7490566.741852513], [5248299.211589362]]\n    scObject.hub.v_CN_NInit = [[-5199.77710904224], [-3436.681645356935], [1041.576797498721]]\n    scObject.hub.sigma_BNInit = [[0.1], [0.2], [-0.3]]\n    scObject.hub.omega_BN_BInit = [[0.001], [-0.01], [0.03]]\n\n    # Constants for thruster creation\n    g = 9.80665\n    Isp = 226.7\n\n    #  Create the thrusters\n    thrusterSet = thrusterDynamicEffector.ThrusterDynamicEffector()\n    thrusterSet.ModelTag = \"ACSThrusterDynamics\"\n\n    #  Create thruster characteristic parameters (position, angle thrust, ISP, time of thrust) for thruster 1\n    long_angle_deg = long_angle  # Parametrized angle of thrust\n    lat_angle_deg = lat_angle\n    long_angle_rad = long_angle_deg * math.pi / 180.0\n    lat_angle_rad = lat_angle_deg * math.pi / 180.0\n    thruster = thrusterDynamicEffector.THRSimConfig()\n    thruster.thrLoc_B = location  # Parametrized location for thruster\n    thruster.thrDir_B = [[math.cos(long_angle_rad) * math.cos(lat_angle_rad)],\n                         [math.sin(long_angle_rad) * math.cos(lat_angle_rad)], [math.sin(lat_angle_rad)]]\n    thruster.MaxThrust = 10.0\n    thruster.steadyIsp = 226.7\n    thruster.MinOnTime = 0.006\n    thruster.cutoffFrequency = 5\n    thruster.MaxSwirlTorque = 0.0\n\n    # Set up the dcm and location\n    dcm_BF = np.array([[-1, 0, 0], [0, 1, 0], [0, 0, -1]])\n    r_FB_B = [0, 0, 1]\n\n    # Create the module\n    pyModule = attachedBodyModule(dcm_BF, r_FB_B, True, 100)\n    pyModule.ModelTag = \"attachedBody\"\n    TotalSim.AddModelToTask(unitTaskName3, pyModule)\n\n    # Attach messages\n    pyModule.scInMsg.subscribeTo(scObject.scStateOutMsg)\n    thrusterSet.addThruster(thruster, pyModule.bodyOutMsg)\n\n    # Define the location and direction with respect to the platform\n    loc = np.array([thruster.thrLoc_B[0][0], thruster.thrLoc_B[1][0], thruster.thrLoc_B[2][0]])\n    dir = np.array([thruster.thrDir_B[0][0], thruster.thrDir_B[1][0], thruster.thrDir_B[2][0]])\n\n    # Update the direction and location of the thruster to the hub\n    dir = dcm_BF.dot(dir)\n    loc = dcm_BF.dot(loc) + r_FB_B\n\n    # Add the thrusters to the spacecraft\n    scObject.addDynamicEffector(thrusterSet)\n\n    # Save state\n    dataRec = thrusterSet.thrusterOutMsgs[0].recorder(testRate)\n\n    # Add both modules and the recorder to tasks\n    TotalSim.AddModelToTask(unitTaskName1, scObject)\n    TotalSim.AddModelToTask(unitTaskName2, thrusterSet)\n    TotalSim.AddModelToTask(unitTaskName2, dataRec)\n\n    #  Define the start of the thrust and its duration\n    testDurationTime = 2.0\n\n    # Log variables of interest\n    TotalSim.AddVariableForLogging('ACSThrusterDynamics.forceExternal_B', testRate, 0, 2)\n    TotalSim.AddVariableForLogging('ACSThrusterDynamics.torqueExternalPntB_B', testRate, 0, 2)\n\n    # Initialize the simulation\n    TotalSim.InitializeSimulation()\n\n    # Close all plots\n    plt.close(\"all\")\n\n    #  Configure a single thruster firing, create a message for it\n    ThrustMessage = messaging.THRArrayOnTimeCmdMsgPayload()\n    thrDuration = testDurationTime / 2\n    ThrustMessage.OnTimeRequest = [thrDuration]\n    thrCmdMsg = messaging.THRArrayOnTimeCmdMsg().write(ThrustMessage)\n    thrusterSet.cmdsInMsg.subscribeTo(thrCmdMsg)\n\n    # Run the simulation\n    TotalSim.ConfigureStopTime(macros.sec2nano(testDurationTime))\n    TotalSim.ExecuteSimulation()\n\n    # Gather the Force, Torque and Mass Rate results\n    thrForce = TotalSim.GetLogVariableData('ACSThrusterDynamics.forceExternal_B')\n    thrTorque = TotalSim.GetLogVariableData('ACSThrusterDynamics.torqueExternalPntB_B')\n\n    # Generate the truth data (force, torque and mass rate)\n    expectedThrustData = np.zeros([3, np.shape(thrForce)[0]])\n    expectedTorqueData = np.zeros([3, np.shape(thrTorque)[0]])\n    for i in range(np.shape(thrForce)[0]):\n        # Compute the thrust force (zero at the first time step)\n        if i < int(round(macros.sec2nano(thrDuration) / testRate)) + 1 and i != 0:\n            thrustFactor = 1\n        else:\n            thrustFactor = 0\n        force = thrustFactor * thruster.MaxThrust * dir\n        expectedThrustData[0:3, i] = force\n        # Compute the torque\n        expectedTorqueData[0:3, i] = np.cross(loc, force)\n\n    # Modify expected values for comparison and define errorTolerance\n    TruthForce = np.transpose(expectedThrustData)\n    TruthTorque = np.transpose(expectedTorqueData)\n    ErrTolerance = 1E-3\n\n    # Compare Force values\n    thrForce = np.delete(thrForce, 0, axis=1)  # remove time column\n    testFailCount, testMessages = unitTestSupport.compareArray(TruthForce, thrForce, ErrTolerance, \"Force\",\n                                                               testFailCount, testMessages)\n\n    # Compare Torque values\n    thrTorque = np.delete(thrTorque, 0, axis=1)  # remove time column\n    testFailCount, testMessages = unitTestSupport.compareArray(TruthTorque, thrTorque, ErrTolerance, \"Torque\",\n                                                               testFailCount, testMessages)\n\n    if testFailCount == 0:\n        print(\"PASSED\")\n    else:\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "class attachedBodyModule(sysModel.SysModel):\n    def __init__(self, dcm_BF, r_FB_B, modelActive=True, modelPriority=-1):\n        super(attachedBodyModule, self).__init__()\n\n        # Input spacecraft state structure message\n        self.scInMsg = messaging.SCStatesMsgReader()\n        self.scMsgBuffer = None\n\n        # Output body state message\n        self.bodyOutMsg = messaging.SCStatesMsg()\n\n        # Save dcm and location\n        self.dcm_BF = dcm_BF\n        self.r_FB_B = r_FB_B\n\n    def UpdateState(self, CurrentSimNanos):\n        # Read input message\n        self.scMsgBuffer = self.scInMsg()\n\n        # Write output message\n        self.writeOutputMsg(CurrentSimNanos)\n\n    def writeOutputMsg(self, CurrentSimNanos):\n        # Create output message buffer\n        bodyOutMsgBuffer = messaging.SCStatesMsgPayload()\n\n        # Grab the spacecraft hub states\n        sigma_BN = self.scMsgBuffer.sigma_BN\n        dcm_BN = rbk.MRP2C(sigma_BN)\n        omega_BN_B = self.scMsgBuffer.omega_BN_B\n        r_BN_N = self.scMsgBuffer.r_BN_N\n\n        # Compute the attached body states relative to the hub\n        dcm_FB = np.transpose(self.dcm_BF)\n        sigma_FB = rbk.C2MRP(dcm_FB)\n        sigma_FN = rbk.addMRP(np.array(sigma_BN), sigma_FB)\n        omega_FB_F = dcm_FB.dot(omega_BN_B)\n        r_FN_N = r_BN_N + np.transpose(dcm_BN).dot(np.array(self.r_FB_B))\n\n        # Write the output message information\n        bodyOutMsgBuffer.sigma_BN = sigma_FN\n        bodyOutMsgBuffer.omega_BN_B = omega_FB_F\n        bodyOutMsgBuffer.r_BN_N = r_FN_N\n        self.bodyOutMsg.write(bodyOutMsgBuffer, CurrentSimNanos, self.moduleID)",
  "def __init__(self, dcm_BF, r_FB_B, modelActive=True, modelPriority=-1):\n        super(attachedBodyModule, self).__init__()\n\n        # Input spacecraft state structure message\n        self.scInMsg = messaging.SCStatesMsgReader()\n        self.scMsgBuffer = None\n\n        # Output body state message\n        self.bodyOutMsg = messaging.SCStatesMsg()\n\n        # Save dcm and location\n        self.dcm_BF = dcm_BF\n        self.r_FB_B = r_FB_B",
  "def UpdateState(self, CurrentSimNanos):\n        # Read input message\n        self.scMsgBuffer = self.scInMsg()\n\n        # Write output message\n        self.writeOutputMsg(CurrentSimNanos)",
  "def writeOutputMsg(self, CurrentSimNanos):\n        # Create output message buffer\n        bodyOutMsgBuffer = messaging.SCStatesMsgPayload()\n\n        # Grab the spacecraft hub states\n        sigma_BN = self.scMsgBuffer.sigma_BN\n        dcm_BN = rbk.MRP2C(sigma_BN)\n        omega_BN_B = self.scMsgBuffer.omega_BN_B\n        r_BN_N = self.scMsgBuffer.r_BN_N\n\n        # Compute the attached body states relative to the hub\n        dcm_FB = np.transpose(self.dcm_BF)\n        sigma_FB = rbk.C2MRP(dcm_FB)\n        sigma_FN = rbk.addMRP(np.array(sigma_BN), sigma_FB)\n        omega_FB_F = dcm_FB.dot(omega_BN_B)\n        r_FN_N = r_BN_N + np.transpose(dcm_BN).dot(np.array(self.r_FB_B))\n\n        # Write the output message information\n        bodyOutMsgBuffer.sigma_BN = sigma_FN\n        bodyOutMsgBuffer.omega_BN_B = omega_FB_F\n        bodyOutMsgBuffer.r_BN_N = r_FN_N\n        self.bodyOutMsg.write(bodyOutMsgBuffer, CurrentSimNanos, self.moduleID)",
  "class SRPLookupTableHandler:\n    \"\"\"Class to handle an SRP Lookup table\"\"\"\n    def __init__(self):\n        self.sHatBLookup = np.zeros([1, 3])\n        self.forceBLookup = np.zeros([1, 3])\n        self.torqueBLookup = np.zeros([1, 3])\n\n    def parseAndLoadXML(self, filePath):\n        document = ElementTree.parse(filePath)\n\n        sHatBTree = document.find('sHatBValues')\n        forceBTree = document.find('forceBValues')\n        torqueBTree = document.find('torqueBValues')\n\n        self.sHatBLookup.resize([len(list(sHatBTree)), 3])\n        self.forceBLookup.resize([len(list(forceBTree)), 3])\n        self.torqueBLookup.resize([len(list(torqueBTree)), 3])\n\n        for node in list(sHatBTree):\n            idx = int(node.attrib['index'])\n            for value in list(node):\n                if value.tag == 'value_1':\n                    self.sHatBLookup[idx, 0] = value.text\n                if value.tag == 'value_2':\n                    self.sHatBLookup[idx, 1] = value.text\n                if value.tag == 'value_3':\n                    self.sHatBLookup[idx, 2] = value.text\n\n        for node in list(forceBTree):\n            idx = int(node.attrib['index'])\n            for value in list(node):\n                if value.tag == 'value_1':\n                    self.forceBLookup[idx, 0] = value.text\n                if value.tag == 'value_2':\n                    self.forceBLookup[idx, 1] = value.text\n                if value.tag == 'value_3':\n                    self.forceBLookup[idx, 2] = value.text\n\n        for node in list(torqueBTree):\n            idx = int(node.attrib['index'])\n            for value in list(node):\n                if value.tag == 'value_1':\n                    self.torqueBLookup[idx, 0] = value.text\n                if value.tag == 'value_2':\n                    self.torqueBLookup[idx, 1] = value.text\n                if value.tag == 'value_3':\n                    self.torqueBLookup[idx, 2] = value.text",
  "def __init__(self):\n        self.sHatBLookup = np.zeros([1, 3])\n        self.forceBLookup = np.zeros([1, 3])\n        self.torqueBLookup = np.zeros([1, 3])",
  "def parseAndLoadXML(self, filePath):\n        document = ElementTree.parse(filePath)\n\n        sHatBTree = document.find('sHatBValues')\n        forceBTree = document.find('forceBValues')\n        torqueBTree = document.find('torqueBValues')\n\n        self.sHatBLookup.resize([len(list(sHatBTree)), 3])\n        self.forceBLookup.resize([len(list(forceBTree)), 3])\n        self.torqueBLookup.resize([len(list(torqueBTree)), 3])\n\n        for node in list(sHatBTree):\n            idx = int(node.attrib['index'])\n            for value in list(node):\n                if value.tag == 'value_1':\n                    self.sHatBLookup[idx, 0] = value.text\n                if value.tag == 'value_2':\n                    self.sHatBLookup[idx, 1] = value.text\n                if value.tag == 'value_3':\n                    self.sHatBLookup[idx, 2] = value.text\n\n        for node in list(forceBTree):\n            idx = int(node.attrib['index'])\n            for value in list(node):\n                if value.tag == 'value_1':\n                    self.forceBLookup[idx, 0] = value.text\n                if value.tag == 'value_2':\n                    self.forceBLookup[idx, 1] = value.text\n                if value.tag == 'value_3':\n                    self.forceBLookup[idx, 2] = value.text\n\n        for node in list(torqueBTree):\n            idx = int(node.attrib['index'])\n            for value in list(node):\n                if value.tag == 'value_1':\n                    self.torqueBLookup[idx, 0] = value.text\n                if value.tag == 'value_2':\n                    self.torqueBLookup[idx, 1] = value.text\n                if value.tag == 'value_3':\n                    self.torqueBLookup[idx, 2] = value.text",
  "def test_radiationPressureIntegratedTest(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = radiationPressureIntegratedTest(show_plots)\n    assert testResults < 1, testMessage",
  "def radiationPressureIntegratedTest(show_plots):\n    # Create simulation variable names\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n\n    #  Create a sim module as an empty container\n    sim = SimulationBaseClass.SimBaseClass()\n\n    dynProcess = sim.CreateNewProcess(simProcessName)\n\n    # create the dynamics task and specify the integration update time\n    simulationTimeStep = macros.sec2nano(10.0)\n    dynProcess.addTask(sim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    # initialize spacecraft object and set properties\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n    sim.AddModelToTask(simTaskName, scObject)\n\n    srp = radiationPressure.RadiationPressure()  # default model is the SRP_CANNONBALL_MODEL\n    srp.area = 1.0\n    srp.coefficientReflection = 1.3\n    sim.AddModelToTask(simTaskName, srp, -1)\n    scObject.addDynamicEffector(srp)\n\n    # setup Gravity Body\n    gravFactory = gravBodyFactory()\n    planet = gravFactory.createEarth()\n    planet.isCentralBody = True\n    mu = planet.mu\n    gravFactory.createSun()\n    spice_path = bskPath + '/supportData/EphemerisData/'\n    gravFactory.createSpiceInterface(spice_path, '2021 MAY 04 07:47:49.965 (UTC)')\n    gravFactory.spiceObject.zeroBase = 'Earth'\n    sim.AddModelToTask(simTaskName, gravFactory.spiceObject, -1)\n    srp.sunEphmInMsg.subscribeTo(gravFactory.spiceObject.planetStateOutMsgs[1])\n\n    # attach gravity model to spacecraft\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    # setup the orbit using classical orbit elements\n    oe = orbitalMotion.ClassicElements()\n    rGEO = 42000. * 1000     # meters\n    oe.a = rGEO\n    oe.e = 0.00001\n    oe.i = 0.0 * macros.D2R\n    oe.Omega = 48.2 * macros.D2R\n    oe.omega = 347.8 * macros.D2R\n    oe.f = 85.3 * macros.D2R\n    rN, vN = orbitalMotion.elem2rv(mu, oe)\n    oe = orbitalMotion.rv2elem(mu, rN, vN)      # this stores consistent initial orbit elements\n    # with circular or equatorial orbit, some angles are arbitrary\n    print(rN)\n\n    #\n    #   initialize Spacecraft States with the initialization variables\n    #\n    scObject.hub.r_CN_NInit = rN  # m   - r_BN_N\n    scObject.hub.v_CN_NInit = vN  # m/s - v_BN_N\n\n    # set the simulation time\n    n = np.sqrt(mu / oe.a / oe.a / oe.a)\n    P = 2. * np.pi / n\n    simulationTime = macros.sec2nano(P)\n\n    #   Setup data logging before the simulation is initialized\n    numDataPoints = 100\n    samplingTime = simulationTime // (numDataPoints - 1)\n    dataLog = scObject.scStateOutMsg.recorder()\n    earthLog = gravFactory.spiceObject.planetStateOutMsgs[0].recorder()\n    logTaskName = \"logTask\"\n    dynProcess.addTask(sim.CreateNewTask(logTaskName, samplingTime))\n    sim.AddModelToTask(logTaskName, dataLog)\n    sim.AddModelToTask(logTaskName, earthLog)\n\n    #\n    #   initialize Simulation:  This function clears the simulation log, and runs the self_init()\n    #   cross_init() and reset() routines on each module.\n    #   If the routine InitializeSimulationAndDiscover() is run instead of InitializeSimulation(),\n    #   then the all messages are auto-discovered that are shared across different BSK threads.\n    #\n    sim.InitializeSimulation()\n\n    #\n    #   configure a simulation stop time and execute the simulation run\n    #\n    sim.ConfigureStopTime(simulationTime)\n    sim.ExecuteSimulation()\n\n    # unload spice kernels\n    gravFactory.unloadSpiceKernels()\n\n    #\n    #   retrieve the logged data\n    #\n    earthEphm = earthLog.PositionVector\n    posData = dataLog.r_BN_N\n\n    pos_rel_earth = posData[:, 0:3] - earthEphm[:, 0:3]\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    numTruthPoints = 10\n    skipValue = int(len(pos_rel_earth) / (numTruthPoints - 1))\n    pos_rel_earth_parse = pos_rel_earth[::skipValue]\n\n    # true position for un perturbed 2 body GEO orbit with cannonball SRP\n    true_pos = np.array([[-2.18197848e+07,  3.58872415e+07,  0.00000000e+00]\n                        ,[-3.97753183e+07,  1.34888783e+07, -7.34006882e+01]\n                        ,[-3.91389821e+07, -1.52401394e+07, -3.06392342e+02]\n                        ,[-2.01837904e+07, -3.68366949e+07, -6.37825333e+02]\n                        ,[ 8.21685433e+06, -4.11950336e+07, -9.13451012e+02]\n                        ,[ 3.27532829e+07, -2.63023741e+07, -9.57894936e+02]\n                        ,[ 4.19944582e+07,  9.02560169e+05, -6.78189034e+02]\n                        ,[ 3.15827901e+07,  2.76842665e+07, -1.40584587e+02]\n                        ,[ 6.38612441e+06,  4.15047641e+07,  4.29547195e+02]\n                        ,[-2.18007315e+07,  3.58874482e+07,  7.40749634e+02]])\n\n    # compare the results to the truth values\n    accuracy = 1.0  # meters\n\n    testFailCount, testMessages = unitTestSupport.compareArray(\n        true_pos, pos_rel_earth_parse, accuracy, \"r_BN_N Vector\",\n        testFailCount, testMessages)\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED \")\n    else:\n        print(testFailCount)\n        print(testMessages)\n\n    plt.close(\"all\")  # clears out plots from earlier test runs\n    plt.figure(1)\n    fig = plt.gcf()\n    ax = fig.gca()\n    ax.ticklabel_format(useOffset=False, style='plain')\n    for idx in range(0, 3):\n        plt.plot(dataLog.times() * macros.NANO2SEC / P, pos_rel_earth[:, idx] / 1000.,\n                 color=unitTestSupport.getLineColor(idx, 3),\n                 label='$r_{BN,' + str(idx) + '}$')\n\n    plt.legend(loc='lower right')\n    plt.xlabel('Time [orbits]')\n    plt.ylabel('Inertial Position [km]')\n    plt.title('Position Relative To Earth')\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    figureList = {}\n    fileName = os.path.basename(os.path.splitext(__file__)[0])\n    pltName = fileName + \"srp_integrated\"\n    figureList[pltName] = plt.figure(1)\n\n    return testFailCount, testMessages",
  "def test_unitRadiationPressure(show_plots, modelType, eclipseOn):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = unitRadiationPressure(show_plots, modelType, eclipseOn)\n    assert testResults < 1, testMessage",
  "def unitRadiationPressure(show_plots, modelType, eclipseOn):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0\n    testMessages = []\n    testTaskName = \"unitTestTask\"\n    testProcessName = \"unitTestProcess\"\n    testTaskRate = macros.sec2nano(0.1)\n    simulationTime = 0.2\n    r_N = [-16937711153.5, -138435806556.0, -60051616256.6]  # [m]\n    sun_r_N = [507128401.716, 22652490.9092, -14854379.6232]  # [m]\n    sigma_BN = [0.1, 0.2, -0.3]\n\n    # Create a simulation container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    # Ensure simulation is empty\n    testProc = unitTestSim.CreateNewProcess(testProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(testTaskName, testTaskRate))\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraft\"\n    unitTestSim.AddModelToTask(testTaskName, scObject)\n\n\n    srpDynEffector = radiationPressure.RadiationPressure()\n    srpDynEffector.ModelTag = \"RadiationPressure\"\n    srpDynEffector2 = radiationPressure.RadiationPressure()\n    srpDynEffector2.ModelTag = \"RadiationPressure2\"\n    scObject.addDynamicEffector(srpDynEffector)\n    scObject.addDynamicEffector(srpDynEffector2)\n\n    if modelType == \"cannonball\":\n        srpDynEffector.setUseCannonballModel()\n        srpDynEffector.area = 4\n        srpDynEffector.coefficientReflection = 1.2\n    elif modelType == \"lookup\":\n        srpDynEffector.setUseFacetedCPUModel()\n        handler = radiationPressure.SRPLookupTableHandler()\n        handler.parseAndLoadXML(os.path.dirname(__file__) + \"/cube_lookup.xml\")\n        for i in range(0, len(handler.forceBLookup)):\n            srpDynEffector.addForceLookupBEntry(handler.forceBLookup[i, :])\n            srpDynEffector.addTorqueLookupBEntry(handler.torqueBLookup[i, :])\n            srpDynEffector.addSHatLookupBEntry(handler.sHatBLookup[i, :])\n    elif modelType == \"cannonballLookup\":\n        srpDynEffector.setUseFacetedCPUModel()\n        handler = radiationPressure.SRPLookupTableHandler()\n        handler.parseAndLoadXML(os.path.dirname(__file__) + \"/cannonballLookup.xml\")\n        for i in range(0, len(handler.forceBLookup)):\n            srpDynEffector.addForceLookupBEntry(handler.forceBLookup[i, :])\n            srpDynEffector.addTorqueLookupBEntry(handler.torqueBLookup[i, :])\n            srpDynEffector.addSHatLookupBEntry(handler.sHatBLookup[i, :])\n        srpDynEffector2.setUseCannonballModel()\n        srpDynEffector2.area = 182018.072141393 #set to give a force of 1N at 1AU to make spherical table generation easy\n        srpDynEffector2.coefficientReflection = 1.2\n        r_N = [np.sin(np.pi/4.)*np.cos(np.pi/4.)*10.*om.AU*1000., np.sin(np.pi/4.)*np.sin(np.pi/4.)*10.*om.AU*1000., np.cos(np.pi/4.)*10.*om.AU*1000.]  # [m]\n        sun_r_N = [0., 0., 0.]  # [m]\n        sigma_BN = [0., 0., 0.]\n\n    if eclipseOn:\n        sunEclipseMsgData = messaging.EclipseMsgPayload()\n        sunEclipseMsgData.shadowFactor = 0.5\n        sunEclMsg = messaging.EclipseMsg().write(sunEclipseMsgData)\n        srpDynEffector.sunEclipseInMsg.subscribeTo(sunEclMsg)\n        srpDynEffector2.sunEclipseInMsg.subscribeTo(sunEclMsg)\n\n    unitTestSim.AddModelToTask(testTaskName, srpDynEffector, 3)\n    unitTestSim.AddModelToTask(testTaskName, srpDynEffector2, 3)\n\n    scObject.hub.r_CN_NInit = r_N\n    scObject.hub.sigma_BNInit = sigma_BN\n\n\n    sunSpiceMsg = messaging.SpicePlanetStateMsgPayload()\n    sunSpiceMsg.PositionVector = sun_r_N\n    sunMsg = messaging.SpicePlanetStateMsg().write(sunSpiceMsg)\n    srpDynEffector.sunEphmInMsg.subscribeTo(sunMsg)\n    srpDynEffector2.sunEphmInMsg.subscribeTo(sunMsg)\n\n    unitTestSim.AddVariableForLogging(srpDynEffector.ModelTag + \".forceExternal_B\",\n                                      simulationTime, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(srpDynEffector.ModelTag + \".forceExternal_N\",\n                                      simulationTime, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(srpDynEffector.ModelTag + \".torqueExternalPntB_B\",\n                                      simulationTime, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(srpDynEffector2.ModelTag + \".forceExternal_B\",\n                                      simulationTime, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(srpDynEffector2.ModelTag + \".forceExternal_N\",\n                                      simulationTime, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(srpDynEffector2.ModelTag + \".torqueExternalPntB_B\",\n                                      simulationTime, 0, 2, 'double')\n\n    unitTestSim.InitializeSimulation()\n\n    # Configure a simulation stop time and execute the simulation run\n    unitTestSim.ConfigureStopTime(simulationTime)\n    unitTestSim.ExecuteSimulation()\n    srpDynEffector.computeForceTorque(unitTestSim.TotalSim.CurrentNanos, testTaskRate)\n    srpDynEffector2.computeForceTorque(unitTestSim.TotalSim.CurrentNanos, testTaskRate)\n    unitTestSim.TotalSim.SingleStepProcesses()\n    unitTestSim.RecordLogVars()\n\n    srpDataForce_B = unitTestSim.GetLogVariableData(srpDynEffector.ModelTag + \".forceExternal_B\")\n    srpDataForce_N = unitTestSim.GetLogVariableData(srpDynEffector.ModelTag + \".forceExternal_N\")\n    srpTorqueData = unitTestSim.GetLogVariableData(srpDynEffector.ModelTag + \".torqueExternalPntB_B\")\n\n    srp2DataForce_B = unitTestSim.GetLogVariableData(srpDynEffector2.ModelTag + \".forceExternal_B\")\n    srp2DataForce_N = unitTestSim.GetLogVariableData(srpDynEffector2.ModelTag + \".forceExternal_N\")\n    srp2TorqueData = unitTestSim.GetLogVariableData(srpDynEffector2.ModelTag + \".torqueExternalPntB_B\")\n\n    errTol = 1E-12\n    if modelType == \"cannonball\":\n        truthForceExternal_B = [0, 0, 0]\n        truthForceExternal_N = [-2.44694525395e-06, -1.94212316004e-05, -8.42121070088e-06]\n        truthTorqueExternalPntB_B = [0, 0, 0]\n        testFailCount, testMessages = unitTestSupport.compareVector(truthForceExternal_B,\n                                                                    srpDataForce_B[1,1:],\n                                                                    errTol,\n                                                                    \"Force_B\",\n                                                                    testFailCount,\n                                                                    testMessages)\n        testFailCount, testMessages = unitTestSupport.compareVector(truthForceExternal_N,\n                                                                srpDataForce_N[1, 1:],\n                                                                errTol,\n                                                                \"Force_N\",\n                                                                testFailCount,\n                                                                testMessages)\n        testFailCount, testMessages = unitTestSupport.compareVector(truthTorqueExternalPntB_B,\n                                                                srpTorqueData[1, 1:],\n                                                                errTol,\n                                                                \"Torque\",\n                                                                testFailCount,\n                                                                testMessages)\n    if modelType == \"lookup\":\n        errTolTorque = errTol/100\n        truthForceExternal_B = [0.26720220706099184E-04, - 0.13596079145805012E-04, 0.93948649829282319E-05]\n        truthForceExternal_N = [0, 0, 0]\n        truthTorqueExternalPntB_B = [-0.80492463017846114E-12, 0.50888380426172319E-12, 0.10249431804585393E-11]\n        if eclipseOn:\n            truthForceExternal_B = sunEclipseMsgData.shadowFactor*np.array(truthForceExternal_B)\n            truthTorqueExternalPntB_B = sunEclipseMsgData.shadowFactor * np.array(truthTorqueExternalPntB_B)\n        testFailCount, testMessages = unitTestSupport.compareVector(truthForceExternal_B,\n                                                                    srpDataForce_B[1, 1:],\n                                                                    errTol,\n                                                                    \"Force_B\",\n                                                                    testFailCount,\n                                                                    testMessages)\n        testFailCount, testMessages = unitTestSupport.compareVector(truthForceExternal_N,\n                                                                    srpDataForce_N[1, 1:],\n                                                                    errTol,\n                                                                    \"Force_N\",\n                                                                    testFailCount,\n                                                                    testMessages)\n        testFailCount, testMessages = unitTestSupport.compareVector(truthTorqueExternalPntB_B,\n                                                                    srpTorqueData[1, 1:],\n                                                                    errTolTorque,\n                                                                    \"Torque\",\n                                                                    testFailCount,\n                                                                    testMessages)\n    if modelType == \"cannonballLookup\":\n        errTolTorque = errTol/100\n        testFailCount, testMessages = unitTestSupport.compareVector(srp2DataForce_N[1, 1:],\n                                                                    srpDataForce_B[1, 1:],\n                                                                    errTol,\n                                                                    \"Force_B\",\n                                                                    testFailCount,\n                                                                    testMessages)\n        testFailCount, testMessages = unitTestSupport.compareVector(srp2DataForce_B[1, 1:],\n                                                                    srpDataForce_N[1, 1:],\n                                                                    errTol,\n                                                                    \"Force_N\",\n                                                                    testFailCount,\n                                                                    testMessages)\n        testFailCount, testMessages = unitTestSupport.compareVector(srp2TorqueData[1, 1:],\n                                                                    srpTorqueData[1, 1:],\n                                                                    errTolTorque,\n                                                                    \"Torque\",\n                                                                    testFailCount,\n                                                                    testMessages)\n\n\n    if eclipseOn:\n        modelType = modelType + 'WithEclipse'   #Do this so that the AutoTeX messages are clearly distinguishable.\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + modelType)\n        passFailText = \"PASSED\"\n        colorText = 'ForestGreen'  # color to write auto-documented \"PASSED\" message in in LATEX\n        snippetName = modelType + 'FailMsg'\n        snippetContent = \"\"\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)  # write formatted LATEX string to file to be used by auto-documentation.\n    else:\n        passFailText = 'FAILED'\n        colorText = 'Red'  # color to write auto-documented \"FAILED\" message in in LATEX\n        snippetName = modelType + 'FailMsg'\n        snippetContent = passFailText\n        for message in testMessages:\n            snippetContent += \". \" + message\n        snippetContent += \".\"\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)  # write formatted LATEX string to file to be used by auto-documentation.\n    snippetName = modelType + 'PassFail'  # name of file to be written for auto-documentation which specifies if this test was passed or failed.\n    snippetContent = r'\\textcolor{' + colorText + '}{' + passFailText + '}' #write formatted LATEX string to file to be used by auto-documentation.\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path) #write formatted LATEX string to file to be used by auto-documentation.\n\n    # write test accuracy to LATEX file for AutoTex\n    snippetName = modelType + 'Accuracy'\n    snippetContent = '{:1.1e}'.format(errTol)#write formatted LATEX string to file to be used by auto-documentation.\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path) #write formatted LATEX string to file to be used by auto-documentation.\n    if modelType == 'lookupWithEclipse' or modelType == 'lookup' or modelType == 'cannonballLookup':\n        snippetName = modelType + 'TorqueAccuracy'\n        snippetContent = '{:1.1e}'.format(errTolTorque)  # write formatted LATEX string to file to be used by auto-documentation.\n        unitTestSupport.writeTeXSnippet(snippetName, snippetContent,\n                                        path)  # write formatted LATEX string to file to be used by auto-documentation.\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"PASSED\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "class unitVectorXYZ():\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z",
  "def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z",
  "def test_spinningBody(show_plots, cmdTorque1, lock1, cmdTorque2, lock2):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test sets up a spacecraft with a single-axis rotating rigid body attached to a rigid hub. The spinning\n    body's center of mass is off-center from the spinning axis and the position of the axis is arbitrary. The scenario\n    includes gravity acting on both the spacecraft and the effector.\n\n    **Description of Variables Being Tested**\n\n    In this file we are checking the principles of conservation of energy and angular momentum. Both the orbital and\n    rotational energy and angular momentum must be maintained when conservative forces like gravity are present.\n    Therefore, the values of the variables\n\n    - ``finalOrbAngMom``\n    - ``finalOrbEnergy``\n    - ``finalRotAngMom``\n    - ``finalRotEnergy``\n\n    against their initial values.\n    \"\"\"\n    [testResults, testMessage] = spinningBody(show_plots, cmdTorque1, lock1, cmdTorque2, lock2)\n    assert testResults < 1, testMessage",
  "def spinningBody(show_plots, cmdTorque1, lock1, cmdTorque2, lock2):\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.0001)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Create two hinged rigid bodies\n    spinningBody = spinningBodyTwoDOFStateEffector.SpinningBodyTwoDOFStateEffector()\n\n    # Define properties of spinning body\n    spinningBody.mass1 = 100.0\n    spinningBody.mass2 = 50.0\n    spinningBody.IS1PntSc1_S1 = [[100.0, 0.0, 0.0], [0.0, 50.0, 0.0], [0.0, 0.0, 50.0]]\n    spinningBody.IS2PntSc2_S2 = [[50.0, 0.0, 0.0], [0.0, 30.0, 0.0], [0.0, 0.0, 40.0]]\n    spinningBody.dcm_S10B = [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]\n    spinningBody.dcm_S20S1 = [[0.0, -1.0, 0.0], [0.0, .0, -1.0], [1.0, 0.0, 0.0]]\n    spinningBody.r_Sc1S1_S1 = [[2.0], [-0.5], [0.0]]\n    spinningBody.r_Sc2S2_S2 = [[1.0], [0.0], [-1.0]]\n    spinningBody.r_S1B_B = [[-2.0], [0.5], [-1.0]]\n    spinningBody.r_S2S1_S1 = [[0.5], [-1.5], [-0.5]]\n    spinningBody.s1Hat_S1 = [[0], [0], [1]]\n    spinningBody.s2Hat_S2 = [[0], [-1], [0]]\n    spinningBody.theta1Init = 0 * macros.D2R\n    spinningBody.theta2Init = 5 * macros.D2R\n    spinningBody.k1 = 1.0\n    spinningBody.k2 = 2.0\n    if lock1:\n        spinningBody.theta1DotInit = 0 * macros.D2R\n    else:\n        spinningBody.theta1DotInit = 2.0 * macros.D2R\n    if lock2:\n        spinningBody.theta2DotInit = 0 * macros.D2R\n    else:\n        spinningBody.theta2DotInit = -1.0 * macros.D2R\n    spinningBody.ModelTag = \"SpinningBody\"\n\n    # Add spinning body to spacecraft\n    scObject.addStateEffector(spinningBody)\n\n    # Create the torque message\n    cmdArray = messaging.ArrayMotorTorqueMsgPayload()\n    cmdArray.motorTorque = [cmdTorque1, cmdTorque2]  # [Nm]\n    cmdMsg = messaging.ArrayMotorTorqueMsg().write(cmdArray)\n    spinningBody.motorTorqueInMsg.subscribeTo(cmdMsg)\n\n    # Create the locking message\n    lockArray = messaging.ArrayEffectorLockMsgPayload()\n    lockFlag = [0, 0]\n    if lock1:\n        lockFlag[0] = 1\n    if lock2:\n        lockFlag[1] = 1\n    lockArray.effectorLockFlag = lockFlag\n    lockMsg = messaging.ArrayEffectorLockMsg().write(lockArray)\n    spinningBody.motorLockInMsg.subscribeTo(lockMsg)\n\n    # Define mass properties of the rigid hub of the spacecraft\n    scObject.hub.mHub = 750.0\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [1.0]]\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    # Set the initial values for the states\n    scObject.hub.r_CN_NInit = [[-4020338.690396649], [7490566.741852513], [5248299.211589362]]\n    scObject.hub.v_CN_NInit = [[-5199.77710904224], [-3436.681645356935], [1041.576797498721]]\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.omega_BN_BInit = [[0.1], [-0.1], [0.1]]\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, spinningBody)\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    # Add Earth gravity to the simulation\n    earthGravBody = gravityEffector.GravBodyData()\n    earthGravBody.planetName = \"earth_planet_data\"\n    earthGravBody.mu = 0.3986004415E+15  # meters!\n    earthGravBody.isCentralBody = True\n    earthGravBody.useSphericalHarmParams = False\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector([earthGravBody])\n\n    # Log the spacecraft state message\n    datLog = scObject.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, datLog)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n\n    # Add energy and momentum variables to log\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n\n    # Add states to log\n    theta1Data = spinningBody.spinningBodyOutMsgs[0].recorder()\n    theta2Data = spinningBody.spinningBodyOutMsgs[1].recorder()\n    unitTestSim.AddModelToTask(unitTaskName, theta1Data)\n    unitTestSim.AddModelToTask(unitTaskName, theta2Data)\n\n    # Setup and run the simulation\n    stopTime = 25000*testProcessRate\n    unitTestSim.ConfigureStopTime(stopTime)\n    unitTestSim.ExecuteSimulation()\n\n    # Extract the logged variables\n    orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbEnergy\")\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n    theta1 = theta1Data.theta\n    theta1Dot = theta1Data.thetaDot\n    theta2 = theta2Data.theta\n    theta2Dot = theta2Data.thetaDot\n\n    # Setup the conservation quantities\n    initialOrbAngMom_N = [[orbAngMom_N[0, 1], orbAngMom_N[0, 2], orbAngMom_N[0, 3]]]\n    finalOrbAngMom = [orbAngMom_N[-1]]\n    initialRotAngMom_N = [[rotAngMom_N[0, 1], rotAngMom_N[0, 2], rotAngMom_N[0, 3]]]\n    finalRotAngMom = [rotAngMom_N[-1]]\n    initialOrbEnergy = [[orbEnergy[0, 1]]]\n    finalOrbEnergy = [orbEnergy[-1]]\n    initialRotEnergy = [[rotEnergy[0, 1]]]\n    finalRotEnergy = [rotEnergy[-1]]\n\n    # Plotting\n    plt.close(\"all\")\n    plt.figure()\n    plt.clf()\n    plt.plot(orbAngMom_N[:, 0] * 1e-9, (orbAngMom_N[:, 1] - orbAngMom_N[0, 1]) / orbAngMom_N[0, 1],\n             orbAngMom_N[:, 0] * 1e-9, (orbAngMom_N[:, 2] - orbAngMom_N[0, 2]) / orbAngMom_N[0, 2],\n             orbAngMom_N[:, 0] * 1e-9, (orbAngMom_N[:, 3] - orbAngMom_N[0, 3]) / orbAngMom_N[0, 3])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    plt.title('Orbital Angular Momentum')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(orbEnergy[:, 0] * 1e-9, (orbEnergy[:, 1] - orbEnergy[0, 1]) / orbEnergy[0, 1])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    plt.title('Orbital Energy')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom_N[:, 0] * 1e-9, (rotAngMom_N[:, 1] - rotAngMom_N[0, 1]) / rotAngMom_N[0, 1],\n             rotAngMom_N[:, 0] * 1e-9, (rotAngMom_N[:, 2] - rotAngMom_N[0, 2]) / rotAngMom_N[0, 2],\n             rotAngMom_N[:, 0] * 1e-9, (rotAngMom_N[:, 3] - rotAngMom_N[0, 3]) / rotAngMom_N[0, 3])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    plt.title('Rotational Angular Momentum')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotEnergy[:, 0] * 1e-9, (rotEnergy[:, 1] - rotEnergy[0, 1]) / rotEnergy[0, 1])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    plt.title('Rotational Energy')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(theta1Data.times() * 1e-9, theta1)\n    plt.xlabel('time (s)')\n    plt.ylabel('theta1')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(theta1Data.times() * 1e-9, theta1Dot)\n    plt.xlabel('time (s)')\n    plt.ylabel('theta1Dot')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(theta2Data.times() * 1e-9, theta2)\n    plt.xlabel('time (s)')\n    plt.ylabel('theta2')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(theta2Data.times() * 1e-9, theta2Dot)\n    plt.xlabel('time (s)')\n    plt.ylabel('theta2Dot')\n\n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n    # Testing setup\n    accuracy = 1e-12\n    finalOrbAngMom = numpy.delete(finalOrbAngMom, 0, axis=1)  # remove time column\n    finalRotAngMom = numpy.delete(finalRotAngMom, 0, axis=1)  # remove time column\n    finalRotEnergy = numpy.delete(finalRotEnergy, 0, axis=1)  # remove time column\n    finalOrbEnergy = numpy.delete(finalOrbEnergy, 0, axis=1)  # remove time column\n\n    for i in range(0, len(initialOrbAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i], initialOrbAngMom_N[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\n                \"FAILED: Spinning Body integrated test failed orbital angular momentum unit test\")\n\n    for i in range(0, len(initialRotAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i], initialRotAngMom_N[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\n                \"FAILED: Spinning Body integrated test failed rotational angular momentum unit test\")\n\n    if cmdTorque1 == 0 and cmdTorque2 == 0:\n        for i in range(0, len(initialRotEnergy)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(finalRotEnergy[i], initialRotEnergy[i], 1, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: Spinning Body integrated test failed rotational energy unit test\")\n\n    for i in range(0, len(initialOrbEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i], initialOrbEnergy[i], 1, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spinning Body integrated test failed orbital energy unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Spinning Body gravity integrated test\")\n\n    assert testFailCount < 1, testMessages\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def test_spinningBody(show_plots, cmdTorque, lock):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test sets up a spacecraft with a single-axis rotating rigid body attached to a rigid hub. The spinning\n    body's center of mass is off-center from the spinning axis and the position of the axis is arbitrary. The scenario\n    includes gravity acting on both the spacecraft and the effector.\n\n    **Description of Variables Being Tested**\n\n    In this file we are checking the principles of conservation of energy and angular momentum. Both the orbital and\n    rotational energy and angular momentum must be maintained when conservative forces like gravity are present.\n    Therefore, the values of the variables\n\n    - ``finalOrbAngMom``\n    - ``finalOrbEnergy``\n    - ``finalRotAngMom``\n    - ``finalRotEnergy``\n\n    against their initial values.\n    \"\"\"\n    [testResults, testMessage] = spinningBody(show_plots, cmdTorque, lock)\n    assert testResults < 1, testMessage",
  "def spinningBody(show_plots, cmdTorque, lock):\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.0001)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Create the spacecraft module\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    # Define mass properties of the rigid hub of the spacecraft\n    scObject.hub.mHub = 750.0\n    scObject.hub.r_BcB_B = [[0.0], [0.0], [1.0]]\n    scObject.hub.IHubPntBc_B = [[900.0, 0.0, 0.0], [0.0, 800.0, 0.0], [0.0, 0.0, 600.0]]\n\n    # Set the initial values for the states\n    scObject.hub.r_CN_NInit = [[-4020338.690396649], [7490566.741852513], [5248299.211589362]]\n    scObject.hub.v_CN_NInit = [[-5199.77710904224], [-3436.681645356935], [1041.576797498721]]\n    scObject.hub.sigma_BNInit = [[0.0], [0.0], [0.0]]\n    scObject.hub.omega_BN_BInit = [[0.1], [-0.1], [0.1]]\n\n    # Create two hinged rigid bodies\n    spinningBody = spinningBodyOneDOFStateEffector.SpinningBodyOneDOFStateEffector()\n\n    # Define properties of spinning body\n    spinningBody.mass = 50.0\n    spinningBody.IPntSc_S = [[50.0, 0.0, 0.0], [0.0, 30.0, 0.0], [0.0, 0.0, 40.0]]\n    spinningBody.dcm_S0B = [[0.0, -1.0, 0.0], [0.0, .0, -1.0], [1.0, 0.0, 0.0]]\n    spinningBody.r_ScS_S = [[1.0], [0.0], [-1.0]]\n    spinningBody.r_SB_B = [[0.5], [-1.5], [-0.5]]\n    spinningBody.sHat_S = [[0], [-1], [0]]\n    spinningBody.thetaInit = 5.0 * macros.D2R\n    spinningBody.thetaDotInit = -1.0 * macros.D2R\n    spinningBody.k = 1.0\n    if lock:\n        spinningBody.thetaDotInit = 0.0\n    spinningBody.ModelTag = \"SpinningBody\"\n\n    # Add spinning body to spacecraft\n    scObject.addStateEffector(spinningBody)\n\n    # Create the torque message\n    cmdArray = messaging.ArrayMotorTorqueMsgPayload()\n    cmdArray.motorTorque = [cmdTorque]  # [Nm]\n    cmdMsg = messaging.ArrayMotorTorqueMsg().write(cmdArray)\n    spinningBody.motorTorqueInMsg.subscribeTo(cmdMsg)\n\n    # Create the locking message\n    if lock:\n        lockArray = messaging.ArrayEffectorLockMsgPayload()\n        lockArray.effectorLockFlag = [1]\n        lockMsg = messaging.ArrayEffectorLockMsg().write(lockArray)\n        spinningBody.motorLockInMsg.subscribeTo(lockMsg)\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, spinningBody)\n    unitTestSim.AddModelToTask(unitTaskName, scObject)\n\n    # Add Earth gravity to the simulation\n    earthGravBody = gravityEffector.GravBodyData()\n    earthGravBody.planetName = \"earth_planet_data\"\n    earthGravBody.mu = 0.3986004415E+15  # meters!\n    earthGravBody.isCentralBody = True\n    earthGravBody.useSphericalHarmParams = False\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector([earthGravBody])\n\n    # Log the spacecraft state message\n    datLog = scObject.scStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, datLog)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n\n    # Add energy and momentum variables to log\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotEnergy\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbEnergy\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totOrbAngMomPntN_N\", testProcessRate, 0, 2, 'double')\n    unitTestSim.AddVariableForLogging(scObject.ModelTag + \".totRotAngMomPntC_N\", testProcessRate, 0, 2, 'double')\n\n    # Add states to log\n    thetaData = spinningBody.spinningBodyOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, thetaData)\n\n    # Setup and run the simulation\n    stopTime = 25000 * testProcessRate\n    unitTestSim.ConfigureStopTime(stopTime)\n    unitTestSim.ExecuteSimulation()\n\n    # Extract the logged variables\n    orbEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbEnergy\")\n    orbAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totOrbAngMomPntN_N\")\n    rotAngMom_N = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotAngMomPntC_N\")\n    rotEnergy = unitTestSim.GetLogVariableData(scObject.ModelTag + \".totRotEnergy\")\n    theta = thetaData.theta\n    thetaDot = thetaData.thetaDot\n\n    # Setup the conservation quantities\n    initialOrbAngMom_N = [[orbAngMom_N[0, 1], orbAngMom_N[0, 2], orbAngMom_N[0, 3]]]\n    finalOrbAngMom = [orbAngMom_N[-1]]\n    initialRotAngMom_N = [[rotAngMom_N[0, 1], rotAngMom_N[0, 2], rotAngMom_N[0, 3]]]\n    finalRotAngMom = [rotAngMom_N[-1]]\n    initialOrbEnergy = [[orbEnergy[0, 1]]]\n    finalOrbEnergy = [orbEnergy[-1]]\n    initialRotEnergy = [[rotEnergy[0, 1]]]\n    finalRotEnergy = [rotEnergy[-1]]\n\n    # Plotting\n    plt.close(\"all\")\n    plt.figure()\n    plt.clf()\n    plt.plot(orbAngMom_N[:, 0] * 1e-9, (orbAngMom_N[:, 1] - orbAngMom_N[0, 1]) / orbAngMom_N[0, 1],\n             orbAngMom_N[:, 0] * 1e-9, (orbAngMom_N[:, 2] - orbAngMom_N[0, 2]) / orbAngMom_N[0, 2],\n             orbAngMom_N[:, 0] * 1e-9, (orbAngMom_N[:, 3] - orbAngMom_N[0, 3]) / orbAngMom_N[0, 3])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    plt.title('Orbital Angular Momentum')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(orbEnergy[:, 0] * 1e-9, (orbEnergy[:, 1] - orbEnergy[0, 1]) / orbEnergy[0, 1])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    plt.title('Orbital Energy')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotAngMom_N[:, 0] * 1e-9, (rotAngMom_N[:, 1] - rotAngMom_N[0, 1]) / rotAngMom_N[0, 1],\n             rotAngMom_N[:, 0] * 1e-9, (rotAngMom_N[:, 2] - rotAngMom_N[0, 2]) / rotAngMom_N[0, 2],\n             rotAngMom_N[:, 0] * 1e-9, (rotAngMom_N[:, 3] - rotAngMom_N[0, 3]) / rotAngMom_N[0, 3])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    plt.title('Rotational Angular Momentum')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(rotEnergy[:, 0] * 1e-9, (rotEnergy[:, 1] - rotEnergy[0, 1]) / rotEnergy[0, 1])\n    plt.xlabel('time (s)')\n    plt.ylabel('Relative Difference')\n    plt.title('Rotational Energy')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(thetaData.times() * 1e-9, theta)\n    plt.xlabel('time (s)')\n    plt.ylabel('theta')\n\n    plt.figure()\n    plt.clf()\n    plt.plot(thetaData.times() * 1e-9, thetaDot)\n    plt.xlabel('time (s)')\n    plt.ylabel('thetaDot')\n\n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n    # Testing setup\n    accuracy = 1e-12\n    finalOrbAngMom = numpy.delete(finalOrbAngMom, 0, axis=1)  # remove time column\n    finalRotAngMom = numpy.delete(finalRotAngMom, 0, axis=1)  # remove time column\n    finalRotEnergy = numpy.delete(finalRotEnergy, 0, axis=1)  # remove time column\n    finalOrbEnergy = numpy.delete(finalOrbEnergy, 0, axis=1)  # remove time column\n\n    for i in range(0, len(initialOrbAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbAngMom[i], initialOrbAngMom_N[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\n                \"FAILED: Spinning Body integrated test failed orbital angular momentum unit test\")\n\n    for i in range(0, len(initialRotAngMom_N)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalRotAngMom[i], initialRotAngMom_N[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\n                \"FAILED: Spinning Body integrated test failed rotational angular momentum unit test\")\n\n    # Only check rotational energy if no torques are applied\n    if cmdTorque == 0.0:\n        for i in range(0, len(initialRotEnergy)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqualRelative(finalRotEnergy[i], initialRotEnergy[i], 1, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: Spinning Body integrated test failed rotational energy unit test\")\n\n    for i in range(0, len(initialOrbEnergy)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqualRelative(finalOrbEnergy[i], initialOrbEnergy[i], 1, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Spinning Body integrated test failed orbital energy unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Spinning Body gravity integrated test\")\n\n    assert testFailCount < 1, testMessages\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def test_visibility():\n    \"\"\"\n    Tests whether pinholeCamera:\n\n    1. Computes correctly pixels for center and corners.\n    2. Detects correctly that some landmarks are not within field of view.\n\n    :return:\n    \"\"\"\n    simTime = 1.\n\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n    scSim = SimulationBaseClass.SimBaseClass()\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n    simulationTime = macros.sec2nano(simTime)\n    simulationTimeStep = macros.sec2nano(1.)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    # Set the landmarks distribution to be tested\n    # The first five landmarks shall correspond to center and corners of the image (for the prescribed situation)\n    # The last five landmarks shall be detected as not within FOV\n    FOVx = 38.17124015837933 * np.pi/180  # this is the horizontal FOV, check camera.FOVx\n    FOVy = 29.094758030219015 * np.pi/180  # this is the vertical FOV, check camera.FOVy\n    n_lmk = 10\n    pos_lmk = np.array([[-16*1e3, 0, 0],                        # Image center\n                        [-16*1e3, 18*1e3 * np.tan(FOVy/2), 0],  # Image corner (18 km = horizontal distance sc-lmk)\n                        [-16*1e3, -18*1e3*np.tan(FOVy/2), 0],   # Image corner\n                        [-16*1e3, 0, 18*1e3*np.tan(FOVx/2)],    # Image corner\n                        [-16*1e3, 0, -18*1e3*np.tan(FOVx/2)],   # Image corner\n                        [16*1e3, 0, 0],                         # Not visible\n                        [0, 16*1e3, 0],                         # Not visible\n                        [0, -16*1e3, 0],                        # Not visible\n                        [0, 0, 16*1e3],                         # Not visible\n                        [0, 0, -16*1e3]])                       # Not visible\n    normal_lmk = np.array([[-1, 0, 0],\n                           [-1, 0, 0],                          # Mock to ensure visibility\n                           [-1, 0, 0],                          # Mock to ensure visibility\n                           [-1, 0, 0],                          # Mock to ensure visibility\n                           [-1, 0, 0],                          # Mock to ensure visibility\n                           [1, 0, 0],\n                           [0, 1, 0],\n                           [0, -1, 0],\n                           [0, 0, 1],\n                           [0, 0, -1]])\n\n    # Set the pinhole camera module\n    camera = pinholeCamera.PinholeCamera()\n    camera.f = 25*1e-3\n    camera.nxPixel = 2048\n    camera.nyPixel = 1536\n    camera.wPixel = (17.3*1e-3) / 2048\n    dcm_CB = np.array([[0, 0, -1],\n                       [0, 1, 0],\n                       [1, 0, 0]])\n    camera.dcm_CB = dcm_CB.tolist()\n    for i in range(n_lmk):\n        camera.addLandmark(pos_lmk[i, 0:3], normal_lmk[i, 0:3])\n    scSim.AddModelToTask(simTaskName, camera)\n\n    # Write out mock planet ephemeris message\n    planet_message = messaging.EphemerisMsgPayload()\n    aP = 1.4583 * 149597870.7*1e3\n    r_PN_N = np.array([aP, 0, 0])\n    v_PN_N = np.array([0, np.sqrt(orbitalMotion.MU_SUN/aP), 0])\n    dcm_PN = np.identity(3)\n    mrp_PN = rbk.C2MRP(dcm_PN)\n    planet_message.r_BdyZero_N = r_PN_N\n    planet_message.v_BdyZero_N = v_PN_N\n    planet_message.sigma_BN = mrp_PN\n    planetMsg = messaging.EphemerisMsg().write(planet_message)\n    camera.ephemerisInMsg.subscribeTo(planetMsg)\n\n    # Write out mock spacecraft message (pointing towards planet shall be ensured)\n    a = 34 * 1e3\n    mu = 4.4631 * 1e5\n    r_BP_P = np.array([-a, 0, 0])\n    v_BP_P = np.array([0, -np.sqrt(mu/a), 0])\n    r_BN_N = r_BP_P + r_PN_N\n    v_BN_N = v_BP_P + v_PN_N\n    ir = r_BP_P / np.linalg.norm(r_BP_P)\n    ih = np.cross(ir, v_BP_P/np.linalg.norm(v_BP_P))\n    it = np.cross(ir, ih)\n    dcm_BP = np.zeros((3, 3))\n    dcm_BP[0:3, 0] = -ir\n    dcm_BP[0:3, 1] = ih\n    dcm_BP[0:3, 2] = it\n    dcm_BN = np.matmul(dcm_BP, dcm_PN)\n    mrp_BN = rbk.C2MRP(dcm_BN)\n    sc1_message = messaging.SCStatesMsgPayload()\n    sc1_message.r_BN_N = r_BN_N\n    sc1_message.v_BN_N = v_BN_N\n    sc1_message.sigma_BN = mrp_BN\n    scMsg = messaging.SCStatesMsg().write(sc1_message)\n    camera.scStateInMsg.subscribeTo(scMsg)\n\n    # Log the landmark messages\n    numDataPoints = 2\n    samplingTime = unitTestSupport.samplingTime(simulationTime, simulationTimeStep, numDataPoints)\n    dataLog = []\n    for i in range(len(pos_lmk)):\n        dataLog.append(camera.landmarkOutMsgs[i].recorder(samplingTime))\n        scSim.AddModelToTask(simTaskName, dataLog[i])\n\n    # Run the sim\n    scSim.InitializeSimulation()\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    # Get the logged data\n    isvisibleLmk = np.zeros((2, n_lmk))\n    pixelLmk = np.zeros((2, n_lmk, 2))\n    for i in range(n_lmk):\n        isvisibleLmk[:, i] = dataLog[i].isVisible\n        pixelLmk[:, i, 0:2] = dataLog[i].pL\n\n    # Define expected values\n    # The corners shall correspond to the maximum pixel resolution\n    # The default behaviour for a point lying in the origin is +1\n    accuracy = 1e-8\n    ref_pixel = np.array([[1, 1],\n                         [1, 1536/2],\n                         [1, -1536/2],\n                         [-2048/2, 1],\n                         [2048/2, 1],\n                         [0, 0],\n                         [0, 0],\n                         [0, 0],\n                         [0, 0],\n                         [0, 0]])\n    ref_isvisible = np.array([1, 1, 1, 1, 1, 0, 0, 0, 0, 0])\n\n    # Compare to expected values\n    pixel_worked = pixelLmk[0, :, :] == pytest.approx(ref_pixel, accuracy)\n    isvisible_worked = isvisibleLmk[0, :] == pytest.approx(ref_isvisible, accuracy)\n\n    assert (pixel_worked and isvisible_worked)",
  "def listNorm(inputList):\n   normValue = 0.0\n   for elem in inputList:\n      normValue += elem*elem\n   normValue = math.sqrt(normValue)\n   i=0\n   while i<len(inputList):\n      inputList[i] = inputList[i]/normValue\n      i += 1",
  "def test_unitSimpleNav(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitSimpleNav(show_plots)\n    assert testResults < 1, testMessage",
  "def unitSimpleNav(show_plots):\n    path = os.path.dirname(os.path.abspath(__file__))\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    # Create a sim module as an empty container\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    unitTestProc = unitTestSim.CreateNewProcess(unitProcessName)\n    # create the task and specify the integration update time\n    unitTestProc.addTask(unitTestSim.CreateNewTask(unitTaskName, int(1E8)))\n\n    #Now initialize the modules that we are using.  I got a little better as I went along\n    sNavObject = simpleNav.SimpleNav()\n    unitTestSim.AddModelToTask(unitTaskName, sNavObject)\n\n    spiceMessage = messaging.SpicePlanetStateMsgPayload()\n    stateMessage = messaging.SCStatesMsgPayload()\n    vehPosition = [10000.0, 0.0, 0.0]\n    sunPosition = [10000.0, 1000.0, 0.0]\n\n    stateMessage.r_BN_N = vehPosition \n    spiceMessage.PositionVector = sunPosition\n    spiceMessage.PlanetName = \"sun\"\n\n    # Inertial State output Message\n    scStateMsg = messaging.SCStatesMsg().write(stateMessage)\n    sNavObject.scStateInMsg.subscribeTo(scStateMsg)\n\n    # Sun Planet Data Message\n    sunStateMsg = messaging.SpicePlanetStateMsg().write(spiceMessage)\n    sNavObject.sunStateInMsg.subscribeTo(sunStateMsg)\n\n    sNavObject.ModelTag = \"SimpleNavigation\"\n    posBound = numpy.array([1000.0] * 3)\n    velBound = numpy.array([1.0] * 3)\n    attBound = numpy.array([5E-3] * 3)\n    rateBound = numpy.array([0.02] * 3)\n    sunBound = numpy.array([5.0 * math.pi / 180.0] * 3)\n    dvBound = numpy.array([0.053] * 3)\n\n    posSigma = 5.0\n    velSigma = 0.035\n    attSigma = 1.0 / 360.0 * math.pi / 180.0\n    rateSigma = 0.05 * math.pi / 180.0\n    sunSigma = math.pi / 180.0\n    dvSigma = 0.1 * math.pi / 180.0\n\n    pMatrix = [[posSigma, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., posSigma, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., posSigma, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., velSigma, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., velSigma, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., velSigma, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., attSigma, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., attSigma, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., attSigma, 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., 0., rateSigma, 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., rateSigma, 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., rateSigma, 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., sunSigma, 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., sunSigma, 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., sunSigma, 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., dvSigma, 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., dvSigma, 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., dvSigma],\n               ]\n    errorBounds = [[1000.], [1000.], [1000.], [1.], [1.], [1.], [0.005], [0.005], [0.005], [0.02], [0.02], [0.02],\n                   [5.0 * math.pi / 180.0], [5.0 * math.pi / 180.0], [5.0 * math.pi / 180.0], [0.053], [0.053], [0.053]]\n\n    sNavObject.walkBounds = errorBounds\n    sNavObject.PMatrix = pMatrix\n    sNavObject.crossTrans = True\n    sNavObject.crossAtt = False\n\n    # setup logging\n    dataAttLog = sNavObject.attOutMsg.recorder()\n    dataTransLog = sNavObject.transOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataAttLog)\n    unitTestSim.AddModelToTask(unitTaskName, dataTransLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(int(60 * 144.0 * 1E9))\n    unitTestSim.ExecuteSimulation()\n\n\n    # pull simulation data\n    posNav = dataTransLog.r_BN_N\n    velNav = dataTransLog.v_BN_N\n    attNav = dataAttLog.sigma_BN\n    rateNav = dataAttLog.omega_BN_B\n    dvNav = dataTransLog.vehAccumDV\n    sunNav = dataAttLog.vehSunPntBdy\n\n    sunHatPred = numpy.array(sunPosition)-numpy.array(vehPosition)\n    listNorm(sunHatPred)\n\n    countAllow = posNav.shape[0] * 0.3/100.\n\n    posDiffCount = 0\n    velDiffCount = 0\n    attDiffCount = 0\n    rateDiffCount = 0\n    dvDiffCount = 0\n    sunDiffCount = 0\n    i=0\n    while i< posNav.shape[0]:\n        posVecDiff = posNav[i,0:] - vehPosition\n        velVecDiff = velNav[i,0:]\n        attVecDiff = attNav[i,0:]\n        rateVecDiff = rateNav[i,0:]\n        dvVecDiff = dvNav[i,0:]\n        sunVecDiff = math.acos(numpy.dot(sunNav[i, 0:], sunHatPred))\n        j=0\n        while j<3:\n            if(abs(posVecDiff[j]) > posBound[j]):\n                posDiffCount += 1\n            if(abs(velVecDiff[j]) > velBound[j]):\n                velDiffCount += 1\n            if(abs(attVecDiff[j]) > attBound[j]):\n                attDiffCount += 1\n            if(abs(rateVecDiff[j]) > rateBound[j]):\n                rateDiffCount += 1\n            if(abs(dvVecDiff[j]) > dvBound[j]):\n                dvDiffCount += 1\n            j+=1\n        if(abs(sunVecDiff) > 4.0*math.sqrt(3.0)*sunBound[0]):\n            sunDiffCount += 1\n        i+= 1\n\n    errorCounts = [posDiffCount, velDiffCount, attDiffCount, rateDiffCount,\n        dvDiffCount, sunDiffCount]\n\n    for count in errorCounts:\n        if count > countAllow:\n            testFailCount += 1\n            testMessages.append(\"FAILED: Too many error counts  -\" + str(count))\n\n    sigmaThreshold = 0.8\n    posDiffCount = 0\n    velDiffCount = 0\n    attDiffCount = 0\n    rateDiffCount = 0\n    dvDiffCount = 0\n    sunDiffCount = 0\n    i=0\n    while i< posNav.shape[0]:\n        posVecDiff = posNav[i,0:] - vehPosition\n        velVecDiff = velNav[i,0:]\n        attVecDiff = attNav[i,0:]\n        rateVecDiff = rateNav[i,0:]\n        dvVecDiff = dvNav[i,0:]\n        sunVecDiff = math.acos(numpy.dot(sunNav[i, 0:], sunHatPred))\n        j=0\n        while j<3:\n            if(abs(posVecDiff[j]) > posBound[j]*sigmaThreshold):\n                posDiffCount += 1\n            if(abs(velVecDiff[j]) > velBound[j]*sigmaThreshold):\n                velDiffCount += 1\n            if(abs(attVecDiff[j]) > attBound[j]*sigmaThreshold):\n                attDiffCount += 1\n            if(abs(rateVecDiff[j]) > rateBound[j]*sigmaThreshold):\n                rateDiffCount += 1\n            if(abs(dvVecDiff[j]) > dvBound[j]*sigmaThreshold):\n                dvDiffCount += 1\n            j+=1\n        if(abs(sunVecDiff) > 4.0*math.sqrt(3.0)*sunBound[0]*sigmaThreshold):\n            sunDiffCount += 1\n        i+= 1\n\n    errorCounts = [posDiffCount, velDiffCount, attDiffCount, rateDiffCount,\n        dvDiffCount, sunDiffCount]\n\n    for count in errorCounts:\n        if count < 1:\n            testFailCount += 1\n            testMessages.append(\"FAILED: Too few error counts -\" + str(count))\n\n    plt.figure(1)\n    plt.clf()\n    plt.figure(1, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(dataTransLog.times() * 1.0E-9, posNav[:,0], label='x-position')\n    plt.plot(dataTransLog.times() * 1.0E-9, posNav[:,1], label='y-position')\n    plt.plot(dataTransLog.times() * 1.0E-9, posNav[:,2], label='z-position')\n\n    plt.legend(loc='upper left')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position (m)')\n    unitTestSupport.writeFigureLaTeX('SimpleNavPos', 'Simple Navigation Position Signal', plt, r'height=0.4\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    plt.figure(2)\n    plt.clf()\n    plt.figure(2, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(dataAttLog.times() * 1.0E-9, attNav[:, 0], label='x-rotation')\n    plt.plot(dataAttLog.times() * 1.0E-9, attNav[:, 1], label='y-rotation')\n    plt.plot(dataAttLog.times() * 1.0E-9, attNav[:, 2], label='z-rotation')\n\n    plt.legend(loc='upper left')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Attitude (rad)')\n    unitTestSupport.writeFigureLaTeX('SimpleNavAtt', 'Simple Navigation Att Signal', plt, r'height=0.4\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    # Corner case usage\n    pMatrixBad = [[0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]]\n    # stateBoundsBad = [[0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.]]\n    stateBoundsBad = [[0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.]]\n    sNavObject.walkBounds = stateBoundsBad\n    sNavObject.PMatrix = pMatrixBad\n\n    # sNavObject.inputStateName = \"random_name\"\n    # sNavObject.inputSunName = \"weirdly_not_the_sun\"\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(int(1E8))\n    unitTestSim.ExecuteSimulation()\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED\")\n\n    assert testFailCount < 1, testMessages\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_planetHeading(show_plots=False, relTol=1e-8):\n    \"\"\"\n    **Test Description**\n\n    Test that a planet heading is properly calculated from a spacecraft and planet position and spacecraft attitude.\n    To test this, the earth is placed at the inertial origin. A spacecraft with inertial attitude is placed\n    at 1AU in the z-direction.  The heading is checked to be [0, 0, -1].\n    These values were chosen arbitrarily. They are checked to be accurate to within a relative tolerance of the\n    input ``relTol``, 1e-8 by default.\n\n    Args:\n        relTol (float): positive, the relative tolerance to which the result is checked.\n\n    **Variables Being Tested**\n\n    This test checks that ``headingOut`` stores the pulled log of the module ``bodyHeadingOutMsg``.\n\n\"\"\"\n    sim = SimulationBaseClass.SimBaseClass()\n    proc = sim.CreateNewProcess(\"proc\")\n    task = sim.CreateNewTask(\"task\", int(1e9))\n    proc.addTask(task)\n\n    earthPositionMessage = messaging.SpicePlanetStateMsgPayload()\n    earthPositionMessage.PositionVector = [0., 0., 0.]\n    plMsg = messaging.SpicePlanetStateMsg().write(earthPositionMessage)\n\n    scPositionMessage = messaging.SCStatesMsgPayload()\n    scPositionMessage.r_BN_N = [0., 0., om.AU*1000]\n    scMsg = messaging.SCStatesMsg().write(scPositionMessage)\n\n    ph = planetHeading.PlanetHeading()\n    ph.ModelTag = \"planetHeading\"\n    sim.AddModelToTask(task.Name, ph)\n\n    ph.planetPositionInMsg.subscribeTo(plMsg)\n    ph.spacecraftStateInMsg.subscribeTo(scMsg)\n\n    dataLog = ph.planetHeadingOutMsg.recorder()\n    sim.AddModelToTask(task.Name, dataLog)\n\n    sim.InitializeSimulation()\n    sim.TotalSim.SingleStepProcesses()\n    headingOut = dataLog.rHat_XB_B[-1]\n\n    assert headingOut == pytest.approx([0., 0., -1.], rel=relTol)",
  "def test_planetNav(show_plots):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test is designed to functionally test the simulation model outputs as well as get complete code\n    path coverage. The test design is broken up into three main parts:\n\n    1. Error Bound Enforcement: The simulation is run for 2.4 hours and the error bounds for all of the signals are\n       tested. This test length is long enough to see both the walk in the signal and the noise, all the while not\n       being so long as to slow down the test. The test ensures that the bounds are crossed no more than 30% of the\n       time.\n\n    2. Error Bound Usage:  The error signals are checked for all of the model parameters over the course of the\n       simulation to ensure that the error gets to at least 80% of its maximum error bound at least once, ensuring that\n       noise is indeed properly introduced.\n\n    3. Corner Case Check: The simulation is intentionally given bad inputs to ensure that it alerts the user and\n       does not crash.\n\n    **Test Parameters**\n\n    These tests are considered to pass if during the whole simulation time of 144 minutes, all the variables need to\n    stay within an allowable statistical error. This means that they must stay within their bounds 30% of the time.\n\n    At the same time, we want each of the errors to get to 80% of their respective error bounds at least once during\n    the run.\n\n    The test used for the planetNav module tests the statistics of the Gauss Markov process, making sure that we\n    are getting the variability we want. In order to do so, no specific scenario is necessary. Therefore the position of\n    the planet is set generically.  The planet position is [10000, 0, 0]^T\n    \"\"\"\n    [testResults, testMessage] = planetNavTestFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def planetNavTestFunction(show_plots):\n    \"\"\"Test method\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(0.1)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    module = planetNav.PlanetNav()\n    module.ModelTag = \"planetNavTag\"\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Configure blank module input messages\n    ephemerisInMsgData = messaging.EphemerisMsgPayload()\n    ephemerisInMsgData.r_BdyZero_N = [10000.0, 0.0, 0.0]\n    ephemerisInMsgData.v_BdyZero_N = [0., 0.0, 0.0]\n    ephemerisInMsgData.sigma_BN = [0.0, 0.0, 0.0]\n    ephemerisInMsgData.omega_BN_B = [0.0, 0.0, 0.0]\n    ephemerisInMsg = messaging.EphemerisMsg().write(ephemerisInMsgData)\n\n    # subscribe input messages to module\n    module.ephemerisInMsg.subscribeTo(ephemerisInMsg)\n\n    module.ModelTag = \"PlanetNavigation\"\n    posBound = numpy.array([1000.0] * 3)\n    velBound = numpy.array([1.0] * 3)\n    attBound = numpy.array([5E-3] * 3)\n    rateBound = numpy.array([0.02] * 3)\n\n    posSigma = 5.0\n    velSigma = 0.035\n    attSigma = 1.0 / 360.0 * math.pi / 180.0\n    rateSigma = 0.05 * math.pi / 180.0\n\n    pMatrix = [[posSigma, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., posSigma, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., posSigma, 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., velSigma, 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., velSigma, 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., velSigma, 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., attSigma, 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., attSigma, 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., attSigma, 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., 0., rateSigma, 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., rateSigma, 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., rateSigma]]\n\n    errorBounds = [[1000.], [1000.], [1000.], [1.], [1.], [1.], [0.005], [0.005], [0.005], [0.02], [0.02], [0.02]]\n\n    module.walkBounds = errorBounds\n    module.PMatrix = pMatrix\n    module.crossTrans = True\n    module.crossAtt = False\n\n    # setup output message recorder objects\n    ephemerisOutMsgRec = module.ephemerisOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, ephemerisOutMsgRec)\n\n    # Execute the simulation\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(int(60 * 144.0 * 1E9))\n    unitTestSim.ExecuteSimulation()\n\n    # Pull module data and make sure it is correct\n    r_BN_N = ephemerisOutMsgRec.r_BdyZero_N\n    v_BN_N = ephemerisOutMsgRec.v_BdyZero_N\n    sigma_BN = ephemerisOutMsgRec.sigma_BN\n    omega_BN_B = ephemerisOutMsgRec.omega_BN_B\n\n    countAllow = r_BN_N.shape[0] * 0.3/100.\n\n    posDiffCount = 0\n    velDiffCount = 0\n    attDiffCount = 0\n    rateDiffCount = 0\n    i = 0\n    while i < r_BN_N.shape[0]:\n        posVecDiff = r_BN_N[i, 0:] - ephemerisInMsgData.r_BdyZero_N\n        velVecDiff = v_BN_N[i, 0:] - ephemerisInMsgData.v_BdyZero_N\n        attVecDiff = sigma_BN[i, 0:] - ephemerisInMsgData.sigma_BN\n        rateVecDiff = omega_BN_B[i, 0:] - ephemerisInMsgData.omega_BN_B\n        j = 0\n        while j < 3:\n            if abs(posVecDiff[j]) > posBound[j]:\n                posDiffCount += 1\n            if abs(velVecDiff[j]) > velBound[j]:\n                velDiffCount += 1\n            if abs(attVecDiff[j]) > attBound[j]:\n                attDiffCount += 1\n            if abs(rateVecDiff[j]) > rateBound[j]:\n                rateDiffCount += 1\n            j += 1\n        i += 1\n\n    errorCounts = [posDiffCount, velDiffCount, attDiffCount, rateDiffCount]\n\n    for count in errorCounts:\n        if count > countAllow:\n            testFailCount += 1\n            testMessages.append(\"FAILED: Too many error counts  -\" + str(count))\n\n    sigmaThreshold = 0.8\n    posDiffCount = 0\n    velDiffCount = 0\n    attDiffCount = 0\n    rateDiffCount = 0\n    i = 0\n    while i < r_BN_N.shape[0]:\n        posVecDiff = r_BN_N[i,0:] - ephemerisInMsgData.r_BdyZero_N\n        velVecDiff = v_BN_N[i,0:] - ephemerisInMsgData.v_BdyZero_N\n        attVecDiff = sigma_BN[i,0:] - ephemerisInMsgData.sigma_BN\n        rateVecDiff = omega_BN_B[i,0:] - ephemerisInMsgData.omega_BN_B\n        j=0\n        while j<3:\n            if abs(posVecDiff[j]) > posBound[j]*sigmaThreshold:\n                posDiffCount += 1\n            if abs(velVecDiff[j]) > velBound[j]*sigmaThreshold:\n                velDiffCount += 1\n            if abs(attVecDiff[j]) > attBound[j]*sigmaThreshold:\n                attDiffCount += 1\n            if abs(rateVecDiff[j]) > rateBound[j]*sigmaThreshold:\n                rateDiffCount += 1\n            j += 1\n        i += 1\n\n    errorCounts = [posDiffCount, velDiffCount, attDiffCount, rateDiffCount]\n\n    for count in errorCounts:\n        if count < 1:\n            testFailCount += 1\n            testMessages.append(\"FAILED: Too few error counts - \" + str(count))\n\n    plt.figure(1)\n    plt.clf()\n    plt.figure(1, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(ephemerisOutMsgRec.times() * 1.0E-9, r_BN_N[:,0], label='x-position')\n    plt.plot(ephemerisOutMsgRec.times() * 1.0E-9, r_BN_N[:,1], label='y-position')\n    plt.plot(ephemerisOutMsgRec.times() * 1.0E-9, r_BN_N[:,2], label='z-position')\n\n    plt.legend(loc='upper left')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position (m)')\n\n    plt.figure(2)\n    plt.clf()\n    plt.figure(2, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(ephemerisOutMsgRec.times() * 1.0E-9, v_BN_N[:,0], label='x-velocity')\n    plt.plot(ephemerisOutMsgRec.times() * 1.0E-9, v_BN_N[:,1], label='y-velocity')\n    plt.plot(ephemerisOutMsgRec.times() * 1.0E-9, v_BN_N[:,2], label='z-velocity')\n\n    plt.legend(loc='upper left')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Velocity (m/s)')\n\n    plt.figure(3)\n    plt.clf()\n    plt.figure(3, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(ephemerisOutMsgRec.times() * 1.0E-9, sigma_BN[:, 0], label='x-rotation')\n    plt.plot(ephemerisOutMsgRec.times() * 1.0E-9, sigma_BN[:, 1], label='y-rotation')\n    plt.plot(ephemerisOutMsgRec.times() * 1.0E-9, sigma_BN[:, 2], label='z-rotation')\n\n    plt.legend(loc='upper left')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Attitude (rad)')\n\n    plt.figure(4)\n    plt.clf()\n    plt.figure(4, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(ephemerisOutMsgRec.times() * 1.0E-9, omega_BN_B[:, 0], label='x-angular vel.')\n    plt.plot(ephemerisOutMsgRec.times() * 1.0E-9, omega_BN_B[:, 1], label='y-angular vel.')\n    plt.plot(ephemerisOutMsgRec.times() * 1.0E-9, omega_BN_B[:, 2], label='z-angular vel.')\n\n    plt.legend(loc='upper left')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Attitude (rad)')\n\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    # Corner case usage\n    pMatrixBad = [[0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]]\n    stateBoundsBad = [[0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.]]\n    module.walkBounds = stateBoundsBad\n    module.PMatrix = pMatrixBad\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(int(1E8))\n    unitTestSim.ExecuteSimulation()\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED\")\n\n    assert testFailCount < 1, testMessages\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def addTimeColumn(time, data):\n    return np.transpose(np.vstack([[time], np.transpose(data)]))",
  "def v3vTmult(v1,v2):\n    output = [[0,0,0],[0,0,0],[0,0,0]]\n    for i in range(0,3):\n        for j in range(0,3):\n            output[i][j] = v1[i] * v2[j]\n    return output",
  "def skew(vector):\n    vector = np.array(vector)\n    skew_symmetric = np.array([[0, -vector.item(2), vector.item(1)],\n                     [vector.item(2), 0, -vector.item(0)],\n                     [-vector.item(1), vector.item(0), 0]])\n    return skew_symmetric",
  "def findSigmaDot(sigma, omega):\n    sigmaMag = np.linalg.norm(sigma)\n    B1 = 1 - sigmaMag ** 2\n    BI = np.identity(3)\n    sigmaTilde = skew(sigma)\n    B2 = np.dot(2, sigmaTilde)\n    B3 = np.dot(2, v3vTmult(sigma, sigma))\n    B = np.dot(B1, BI) + B2 + B3\n    sigmaDot = np.dot(0.25, np.dot(B, omega))\n    return sigmaDot",
  "def setRandomWalk(self,senRotNoiseStd = 0.0,senTransNoiseStd = 0.0,errorBoundsGyro = [1e6] * 3,errorBoundsAccel = [1e6] * 3):\n    # sets the random walk for IRU module\n    self.PMatrixAccel = np.eye(3) * senRotNoiseStd\n    self.walkBoundsAccel = np.array(errorBoundsAccel)\n    self.PMatrixGyro = np.eye(3) * senTransNoiseStd\n    self.walkBoundsGyro = np.array(errorBoundsGyro)",
  "def test_unitSimIMU(show_plots,   testCase,       stopTime,       procRate, gyroLSBIn,    accelLSBIn,   senRotMaxIn,    senTransMaxIn,  senRotNoiseStd,     senTransNoiseStd,   errorBoundsGyroIn,  errorBoundsAccelIn, senRotBiasIn,   senTransBiasIn, accuracy):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitSimIMU(show_plots,   testCase,       stopTime,       procRate, gyroLSBIn,    accelLSBIn,   senRotMaxIn,    senTransMaxIn,  senRotNoiseStd,     senTransNoiseStd,   errorBoundsGyroIn,  errorBoundsAccelIn, senRotBiasIn,   senTransBiasIn, accuracy)\n    assert testResults < 1, testMessage",
  "def unitSimIMU(show_plots,   testCase,       stopTime,       procRate, gyroLSBIn,    accelLSBIn,   senRotMaxIn,    senTransMaxIn,  senRotNoiseStd,     senTransNoiseStd,   errorBoundsGyroIn,  errorBoundsAccelIn, senRotBiasIn,   senTransBiasIn, accuracy):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # initialize SimulationBaseClass\n    unitSim = SimulationBaseClass.SimBaseClass()\n\n    # create the task and specify the integration update time\n    unitProcRate_s = procRate\n    unitProcRate = macros.sec2nano(unitProcRate_s)\n    unitProc = unitSim.CreateNewProcess(unitProcName)\n    unitTask = unitSim.CreateNewTask(unitTaskName, unitProcRate)\n    unitProc.addTask(unitTask)\n\n    # Set-up the fake kinematics vectors\n    # Note: No conservative accelerations are used in this test\n    # center of mass\n    rDotDot_CN_N = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) #acceleration of center of mass wrt inertial frame\n    rDotDot_CB_N = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) #acceleration of center of mass wrt body frame\n    rDot_CN_N = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) #velocity of center of mass wrt inertial frame\n    r_CN_N = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) #position of center of mass wrt to inertial frame\n    # body frame\n    rDotDot_BN_N = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) # acceleration of body frame wrt to inertial\n    rDot_BN_N = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) #velocity of body frame wrt to inertial\n    r_BN_N = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) #position of body frame wrt to inertial\n    omegaDot_BN_N = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) #angular acceleration of body frame wrt to inertial\n    omega_BN_N = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) # angular rate of body frame wrt to inertial\n    sigmaDot_BN = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) #MRP derivative, body wrt to inertial\n    sigma_BN = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) # MRP body wrt to inertial\n    # sensor\n    rDotDot_SN_N = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) #sensor sensed acceleration\n    rDot_SN_N = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) #sensor accumulated DV\n    r_SN_N = np.resize(np.array([0., 0., 0.]),(int(stopTime/unitProcRate_s+1),3)) #sensor position in body frame coordinates\n\n    # Set initial conditions for fake kinematics vectors\n    # Acceleration vectors\n    dataRows= np.shape(rDotDot_CN_N)[0]\n    for i in range(0, dataRows): #loops through acceleration vectors so that each element can be set individually (or, hopefully, as a function)\n        rDotDot_BN_N[i][0] = 1.\n        rDotDot_BN_N[i][1] = 1.\n        rDotDot_BN_N[i][2] = 1.\n        rDotDot_CB_N[i][0] = 0.05\n        rDotDot_CB_N[i][1] = 0.07\n        rDotDot_CB_N[i][2] = 0.06\n        rDotDot_CN_N[i][0] = rDotDot_BN_N[i][0] + rDotDot_CB_N[i][0]\n        rDotDot_CN_N[i][1] = rDotDot_BN_N[i][1] + rDotDot_CB_N[i][1]\n        rDotDot_CN_N[i][2] = rDotDot_BN_N[i][2] + rDotDot_CB_N[i][2]\n        omegaDot_BN_N[i][0] = 1.\n        omegaDot_BN_N[i][1] = 1.5\n        omegaDot_BN_N[i][2] = 1.25\n    # Center of Mass\n    rDot_CN_N[0][:] = [0.05, 0.07, 0.08]\n    r_CN_N[0][:] = [10000.5, 10000.7, 10000.5] # Some arbitrary location in space\n    # Body Frame Origin\n    rDot_BN_N[0][:] = [0.1, 0.2, -0.1]\n    r_BN_N[0][:] = [10000., 10000., 10000.] # leaves r_CN_N[0][i] with some offset\n    # Body Rotation\n    omega_BN_N[0][:] = [0.0, 0.15, 0.1] #omega_BN_N\n    sigma_BN[0][:] = [0.25, 0.1, 0.03] # note that unlabeled sigma is sigma_BN\n    # Sensor linear states (note that these initial conditions must be solved as functions of another initial conditions to maintain consistency\n    r_SB_B = np.array([1.0, 1.0, 2.0]) #constant. sensor position wrt to body frame origin\n    cDotDot_N = rDotDot_CN_N[0][:] - rDotDot_BN_N[0][:]\n    cDot_N = rDot_CN_N[0][:] - rDot_BN_N[0][:]\n    c_N =  r_CN_N[0][:] - r_BN_N[0][:]\n    cPrime_N = cDot_N - np.cross(omega_BN_N[0][:], c_N)\n    cPrimePrime_N = cDotDot_N - np.dot(2, np.cross(omega_BN_N[0][:], cPrime_N)) - np.cross(omegaDot_BN_N[0][:], c_N) - np.cross(omega_BN_N[0][:], np.cross(omega_BN_N[0][:], c_N))\n    dcm_BN = rbk.MRP2C(sigma_BN[0][:])\n    dcm_NB = np.transpose(dcm_BN)\n    sigmaDot_BN[0][:] = findSigmaDot(sigma_BN[0][:], np.dot(dcm_BN, omega_BN_N[0][:])) # sigmaDot_BN\n    r_SB_N = np.dot(dcm_NB, r_SB_B)\n    r_SC_N = r_BN_N[0][:] + r_SB_N - r_CN_N[0][:]\n    rDotDot_SN_N[0][:] = rDotDot_CN_N[0][:] - cPrimePrime_N - np.dot(2, np.cross(omega_BN_N[0][:], cPrime_N)) + np.cross(omegaDot_BN_N[0][:], r_SC_N) + np.cross(omega_BN_N[0][:], np.cross(omega_BN_N[0][:], r_SC_N))\n    rDot_SN_N[0][:] = rDot_CN_N[0][:] - cPrime_N + np.cross(omega_BN_N[0][:], r_SC_N)\n    r_SN_N[0][:] = r_SB_N + r_BN_N[0][:]\n\n    #Sensor Setup\n    ImuSensor = imuSensor.ImuSensor()\n    ImuSensor.ModelTag = \"imusensor\"\n    ImuSensor.sensorPos_B = np.array(r_SB_B) #must be set by user - no default. check if this works by giving an array - SJKC\n    yaw = 0.7854 #should be given as parameter [rad]\n    pitch = 1.0  # [rad]\n    roll = 0.1 # [rad]\n    dcm_PB = rbk.euler3212C([yaw,pitch,roll]) #done separately as a\n    dcm_PN = np.dot(dcm_PB, dcm_BN)\n    ImuSensor.setBodyToPlatformDCM(yaw, pitch, roll) # done separately as a check\n    errorBoundsGyro = [errorBoundsGyroIn] * 3\n    errorBoundsAccel = [errorBoundsAccelIn] * 3\n    setRandomWalk(ImuSensor, senRotNoiseStd, senTransNoiseStd, errorBoundsGyro, errorBoundsAccel)\n    ImuSensor.setLSBs(accelLSBIn, gyroLSBIn)\n    ImuSensor.senRotBias = np.array([senRotBiasIn] * 3)\n    ImuSensor.senTransBias = np.array([senTransBiasIn] * 3)\n    ImuSensor.senTransMax = senTransMaxIn\n    ImuSensor.senRotMax = senRotMaxIn\n    accelScale = [2.,2.,2.]\n    gyroScale = [1.,1.,1.]\n    ImuSensor.accelScale = np.array(accelScale)\n    ImuSensor.gyroScale = np.array(gyroScale)\n\n    accel_SN_P_disc = np.array([0., 0., 0.])\n    omega_SN_P_disc = np.array([0., 0., 0.])\n\n    # Set-up the sensor output truth vectors\n    rDotDot_SN_P = np.resize(np.array([0., 0., 0.]), (int(stopTime/unitProcRate_s+1), 3))  # sensor sensed acceleration in sensor platform frame coordinates\n    rDotDot_SN_P[0][:] = np.dot(dcm_PN, rDotDot_SN_N[0][:])\n    DVAccum_SN_P = np.resize(np.array([0., 0., 0.]), (int(stopTime/unitProcRate_s+1), 3))  # sensor accumulated delta V ouput in the platform frame\n    stepPRV_PN = np.resize(np.array([0., 0., 0.]), (int(stopTime/unitProcRate_s+1), 3))  # principal rotatation vector from time i-1 to time i in platform frame coordinates\n    omega_PN_P = np.resize(np.array([0., 0., 0.]), (int(stopTime/unitProcRate_s+1), 3))  # angular rate omega_BN_P = omega_PN_P\n    omega_PN_P[0][:] = np.dot(dcm_PN, omega_BN_N[0][:])\n\n    # configure spacecraft dummy message - Need to convert to B frame here first\n    StateCurrent = messaging.SCStatesMsgPayload()\n    StateCurrent.sigma_BN = sigma_BN[0][:]\n    StateCurrent.omega_BN_B = np.dot(dcm_BN, omega_BN_N[0][:]) #1 rpm around each axis\n    StateCurrent.nonConservativeAccelpntB_B = np.dot(dcm_BN, rDotDot_BN_N[0][:])\n    StateCurrent.omegaDot_BN_B = np.dot(dcm_BN, omegaDot_BN_N[0][:])\n    StateCurrent.TotalAccumDV_BN_B = np.array([0., 0., 0.])\n\n    # add module to the task\n    unitSim.AddModelToTask(unitTaskName, ImuSensor)\n\n    # configure inertial_state_output message\n    scStateMsg = messaging.SCStatesMsg().write(StateCurrent)\n    ImuSensor.scStateInMsg.subscribeTo(scStateMsg)\n\n    # log module output message\n    dataLog = ImuSensor.sensorOutMsg.recorder()\n    unitSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitSim.InitializeSimulation()\n\n    # loop through ExecuteSimulation() and propagate sigma, omega, DV\n    dt = unitProcRate_s\n    for i in range(1,int(stopTime/dt)+1):\n        # Step through the sim\n        unitSim.ConfigureStopTime(macros.sec2nano(unitProcRate_s*i))\n        unitSim.ExecuteSimulation()\n\n        # attitude kinematics\n        omega_BN_N[i][:] = omega_BN_N[i-1][:] + ((omegaDot_BN_N[i-1][:] + omegaDot_BN_N[i][:])/2)*dt\n\n        # iterate on sigma/sigmaDot\n        sigmaDot_BN[i][:] = sigmaDot_BN[i-1][:]\n        for j in range(0,10): #Seems to converge after a few iterations\n            sigma_BN[i][:] = sigma_BN[i-1][:] + ((sigmaDot_BN[i-1][:]+sigmaDot_BN[i][:])/2)*dt\n            dcm_BN_2 = rbk.MRP2C(sigma_BN[i][:])\n            sigmaDot_BN[i][:] = findSigmaDot(sigma_BN[i][:],np.dot(dcm_BN_2, omega_BN_N[i][:]))\n        sigma_BN[i][:] = sigma_BN[i-1][:] + ((sigmaDot_BN[i-1][:]+sigmaDot_BN[i][:])/2)*dt\n        dcm_BN_2 = rbk.MRP2C(sigma_BN[i][:])\n        dcm_NB = np.transpose(dcm_BN_2)\n        r_SB_N = np.dot(dcm_NB, r_SB_B)\n\n        # linear kinematcs\n        rDot_CN_N[i][:] = rDot_CN_N[i-1][:] + ((rDotDot_CN_N[i-1][:] + rDotDot_CN_N[i][:])/2)*dt\n        r_CN_N[i][:] = r_CN_N[i-1][:] + ((rDot_CN_N[i-1][:] + rDot_CN_N[i][:])/2)*dt\n\n        rDot_BN_N[i][:] = rDot_BN_N[i-1][:] + ((rDotDot_BN_N[i-1][:] + rDotDot_BN_N[i][:])/2)*dt\n        r_BN_N[i][:] = r_BN_N[i-1][:] + ((rDot_BN_N[i-1][:] + rDot_BN_N[i][:])/2)*dt\n\n        cDotDot_N = rDotDot_CN_N[i][:] - rDotDot_BN_N[i][:]\n        cDot_N = rDot_CN_N[i][:] - rDot_BN_N[i][:]\n        c_N = r_CN_N[i][:] - r_BN_N[i][:]\n\n        # center of mass calculations\n        cPrime_N = cDot_N - np.cross(omega_BN_N[i][:], c_N)\n        cPrimePrime_N = cDotDot_N - np.dot(2,np.cross(omega_BN_N[i][:], cPrime_N)) - np.cross(omegaDot_BN_N[i][:],c_N)-np.cross(omega_BN_N[i][:],np.cross(omega_BN_N[i][:],c_N))\n        r_SC_N = r_BN_N[i][:] + r_SB_N - r_CN_N[i][:]\n\n        # solving for sensor inertial states\n        rDotDot_SN_N[i][:] = rDotDot_CN_N[i][:] - cPrimePrime_N - np.dot(2,np.cross(omega_BN_N[i][:],cPrime_N)) + np.cross(omegaDot_BN_N[i][:],r_SC_N) +np.cross(omega_BN_N[i][:],np.cross(omega_BN_N[i][:],r_SC_N))\n        rDot_SN_N[i][:] = rDot_CN_N[i][:] - cPrime_N + np.cross(omega_BN_N[i][:],r_SC_N)\n\n        # Now create outputs which are (supposed to be) equivalent to the IMU output\n        # linear acceleration (non-conservative) in platform frame\n        dcm_BN_1 = rbk.MRP2C(sigma_BN[i-1][:])\n        dcm_PN_2 = np.dot(dcm_PB, dcm_BN_2)\n        dcm_PN_1 = np.dot(dcm_PB, dcm_BN_1)\n        dcm_NP_1 = np.transpose(dcm_PN_1)\n        dcm_PN_21 = np.dot(dcm_PN_2, dcm_NP_1)\n        rDotDot_SN_P[i][:] = np.multiply(np.dot(dcm_PN_2, rDotDot_SN_N[i][:]) + senTransBiasIn, accelScale) #This should match trueValues.AccelPlatform\n        # accumulated delta v (non-conservative) in platform frame\n        DVAccum_SN_P[i][:] = np.multiply(np.dot(dcm_PN_2, rDot_SN_N[i][:] - rDot_SN_N[i-1][:]) + senTransBiasIn*dt, accelScale)\n\n        # find PRV between before and now\n\n        stepPRV_PN[i][:] = np.multiply(rbk.MRP2PRV(rbk.C2MRP(dcm_PN_21)) + senRotBiasIn*dt, gyroScale)\n\n        # angular rate in platform frame\n        omega_PN_P[i][:] = np.multiply(np.dot(dcm_PN_2, omega_BN_N[i][:]) + senRotBiasIn, gyroScale)\n        #\n        # #discretization\n        if accelLSBIn > 0.0:\n            for k in [0,1,2]:\n                accel_SN_P_disc[k] = np.floor(np.abs(rDotDot_SN_P[i][k] / accelLSBIn)) * accelLSBIn * np.sign(rDotDot_SN_P[i][k])\n            accelDiscError = rDotDot_SN_P[i][:] - accel_SN_P_disc\n            rDotDot_SN_P[i][:] = accel_SN_P_disc\n            DVAccum_SN_P[i][:] -= accelDiscError * dt\n        if gyroLSBIn > 0.0:\n            for k in [0,1,2]:\n                omega_SN_P_disc[k] = np.floor(np.abs(omega_PN_P[i][k] / gyroLSBIn)) * gyroLSBIn * np.sign(omega_PN_P[i][k])\n            omegaDiscError = omega_PN_P[i][:] - omega_SN_P_disc\n            omega_PN_P[i][:] = omega_SN_P_disc\n            stepPRV_PN[i][:] -= omegaDiscError * dt\n\n        #saturation\n        for k in [0,1,2]:\n            if omega_PN_P[i][k] > senRotMaxIn:\n                omega_PN_P[i][k] = senRotMaxIn\n                stepPRV_PN[i][k] = senRotMaxIn*dt\n            elif omega_PN_P[i][k] < -senRotMaxIn:\n                omega_PN_P[i][k] = -senRotMaxIn\n                stepPRV_PN[i][k] = -senRotMaxIn*dt\n            if rDotDot_SN_P[i][k] > senTransMaxIn:\n                rDotDot_SN_P[i][k] = senTransMaxIn\n                DVAccum_SN_P[i][k] = rDotDot_SN_P[i][k] * dt\n            elif rDotDot_SN_P[i][k] < -senTransMaxIn:\n                rDotDot_SN_P[i][k] = -senTransMaxIn\n                DVAccum_SN_P[i][k] = rDotDot_SN_P[i][k] * dt\n\n        #Now update spacecraft states for the IMU:\n        StateCurrent = messaging.SCStatesMsgPayload()\n        StateCurrent.sigma_BN = sigma_BN[i][:]\n        StateCurrent.omega_BN_B = np.dot(dcm_BN_2, omega_BN_N[i][:])\n        StateCurrent.nonConservativeAccelpntB_B = np.dot(dcm_BN_2, rDotDot_BN_N[i][:])\n        StateCurrent.omegaDot_BN_B = np.dot(dcm_BN_2, omegaDot_BN_N[i][:])\n        StateCurrent.TotalAccumDV_BN_B = np.dot(dcm_BN_2, rDot_BN_N[i][:] - rDot_BN_N[0][:])\n        scStateMsg.write(StateCurrent, unitSim.TotalSim.CurrentNanos)\n\n    # Pull output time histories from messaging system\n    DRout = dataLog.DRFramePlatform\n    omegaOut = dataLog.AngVelPlatform\n    rDotDotOut = dataLog.AccelPlatform\n    DVout = dataLog.DVFramePlatform\n\n    # truth/output comparison plots and AutoTex output\n    time = dataLog.times()/1e9\n    plt.figure(1,figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.clf()\n    plt.plot(time, DRout[0:,0], linewidth = 6, color = 'black', label = \"output1\")\n    plt.plot(time, stepPRV_PN[:,0], linestyle = '--', color = 'cyan', label = \"truth1\")\n    plt.plot(time, DRout[0:,1], linewidth = 4, color = 'black', label = \"output2\")\n    plt.plot(time, stepPRV_PN[:,1], linestyle = '--', color = 'cyan', label = \"truth2\")\n    plt.plot(time, DRout[0:,2], linewidth = 2, color = 'black', label = \"output3\")\n    plt.plot(time, stepPRV_PN[:,2], linestyle = '--', color = 'cyan', label = \"truth3\")\n    plt.xlabel(\"Time[s]\")\n    plt.ylabel(\"Time Step PRV Component Magnitude [rad]\")\n    plt.title(\"PRV Comparison\")\n    myLegend = plt.legend()\n    myLegend.get_frame().set_facecolor('#909090')\n    unitTestSupport.writeFigureLaTeX(testCase + \"PRVcomparison\",\n                                     'Plot Comparing Time Step PRV Truth and Output for test: ' + testCase +'. Note that 1, 2, and 3 indicate the components of the principal rotation vector.', plt,\n                                     'height=0.7\\\\textwidth, keepaspectratio', path)\n    plt.figure(4,figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.clf()\n    plt.plot(time, omegaOut[:,0], linewidth = 6, color = 'black', label = \"output1\")\n    plt.plot(time, omega_PN_P[:,0], linestyle = '--', color = 'cyan', label = \"truth1\")\n    plt.plot(time, omegaOut[:,1], linewidth = 4, color = 'black', label = \"output2\")\n    plt.plot(time, omega_PN_P[:,1], linestyle = '--', color = 'cyan', label = \"truth2\")\n    plt.plot(time, omegaOut[:,2], linewidth = 2, color = 'black', label = \"output3\")\n    plt.plot(time, omega_PN_P[:,2], linestyle = '--', color = 'cyan', label = \"truth3\")\n    plt.xlabel(\"Time[s]\")\n    plt.ylabel(\"Angular Rate Component Magnitudes [rad/s]\")\n    plt.title(\"Angular Rate Comparison\")\n    myLegend = plt.legend()\n    myLegend.get_frame().set_facecolor('#909090')\n    unitTestSupport.writeFigureLaTeX(testCase + \"omegaComparison\",\n                                     'Plot Comparing Angular Rate Truth and Output for test: ' + testCase +'. Note that 1, 2, and 3 indicate the components of the angular rate.', plt,\n                                     'height=0.7\\\\textwidth, keepaspectratio', path)\n    plt.figure(7,figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.clf()\n    plt.plot(time, rDotDotOut[:,0], linewidth = 6, color = 'black', label = \"output1\")\n    plt.plot(time, rDotDot_SN_P[:,0], linestyle = '--', color = 'cyan', label = \"truth1\")\n    plt.plot(time, rDotDotOut[:,1], linewidth = 4, color = 'black', label = \"output2\")\n    plt.plot(time, rDotDot_SN_P[:,1], linestyle = '--', color = 'cyan', label = \"truth2\")\n    plt.plot(time, rDotDotOut[:,2], linewidth = 2, color = 'black', label = \"output3\")\n    plt.plot(time, rDotDot_SN_P[:,2], linestyle = '--', color = 'cyan', label = \"truth3\")\n    plt.xlabel(\"Time[s]\")\n    plt.ylabel(\"Linear Acceleration Component Magnitudes [m/s/s]\")\n    plt.title(\"Acceleration Comparison\")\n    myLegend = plt.legend()\n    myLegend.get_frame().set_facecolor('#909090')\n    unitTestSupport.writeFigureLaTeX(testCase + \"accelComparison\",\n                                     'Plot Comparing Sensor Linear Accelertaion Truth and Output for test: ' + testCase +'. Note that 1, 2, and 3 indicate the components of the acceleration.', plt,\n                                     'height=0.7\\\\textwidth, keepaspectratio', path)\n\n    plt.figure(10,figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.clf()\n    plt.plot(time, DVout[:,0], linewidth = 6, color = 'black', label = \"output1\")\n    plt.plot(time, DVAccum_SN_P[:,0], linestyle = '--', color = 'cyan', label = \"truth1\")\n    plt.plot(time, DVout[:,1], linewidth = 4, color = 'black', label = \"output2\")\n    plt.plot(time, DVAccum_SN_P[:,1], linestyle = '--', color = 'cyan', label = \"truth2\")\n    plt.plot(time, DVout[:,2], linewidth = 2, color = 'black', label = \"output3\")\n    plt.plot(time, DVAccum_SN_P[:,2], linestyle = '--', color = 'cyan', label = \"truth3\")\n    plt.xlabel(\"Time[s]\")\n    plt.ylabel(\"Step DV Magnitudes [m/s]\")\n    plt.title(\"DV Comparison\")\n    myLegend = plt.legend()\n    myLegend.get_frame().set_facecolor('#909090')\n    unitTestSupport.writeFigureLaTeX(testCase + \"DVcomparison\",\n                                     'Plot Comparing Time Step DV Truth and Output for test: ' + testCase +'. Note that 1, 2, and 3 indicate the components of the velocity delta.', plt,\n                                     'height=0.7\\\\textwidth, keepaspectratio', path)\n\n    if show_plots and testCase != \"noise\":\n        plt.show()\n        plt.close('all')\n\n    # test outputs\n    if testCase != 'noise':\n        for i in range(2,len(stepPRV_PN)-1):\n            if not unitTestSupport.isArrayEqualRelative(DRout[i+1][:], stepPRV_PN[i][:], 3, accuracy):\n                testMessages.append(\"FAILED DR @ i = \"+ str(i) + \". \\\\\\\\& &\")\n                testFailCount += 1\n            if not unitTestSupport.isArrayEqualRelative(omegaOut[i+1][:], omega_PN_P[i][:], 3, accuracy):\n                testMessages.append(\"FAILED OMEGA @ i = \"+ str(i) + \". \\\\\\\\& &\")\n                testFailCount += 1\n            if not (testCase == \"discretization\" and (i == 572 or i == 934)):\n                if not unitTestSupport.isArrayEqualRelative(DVout[i+1][:], DVAccum_SN_P[i][:], 3, accuracy):\n                    testMessages.append(\"FAILED DV @ i = \" + str(i) + \". \\\\\\\\& &\")\n                    testFailCount += 1\n            if not unitTestSupport.isArrayEqualRelative(rDotDotOut[i+1][:], rDotDot_SN_P[i][:], 3, accuracy):\n                testMessages.append(\"FAILED ACCEL @ i = \" + str(i) + \". \\\\\\\\& &\")\n                testFailCount += 1\n    else:\n        DRout = addTimeColumn(dataLog.times(), DRout)[1:,]\n        rDotDotOut = addTimeColumn(dataLog.times(), rDotDotOut)[1:,]\n        DVout = addTimeColumn(dataLog.times(), DVout)[1:,]\n        omegaOut = addTimeColumn(dataLog.times(), omegaOut)[1:,]\n\n        DRoutNoise = np.zeros((np.shape(DRout)[0], np.shape(DRout)[1]-1))\n        for i in range(3,len(stepPRV_PN)-1):\n            for j in [0,1,2]:\n                DRoutNoise[i][j] = DRout[i][j+1] - stepPRV_PN[i+1][j]\n        rDotDotOutNoise = np.zeros((np.shape(DRout)[0], np.shape(DRout)[1] - 1))\n        for i in range(3, len(stepPRV_PN) - 1):\n            for j in [0, 1, 2]:\n                rDotDotOutNoise[i, j] = rDotDotOut[i, j+1] - rDotDot_SN_P[i+1, j]\n        DVoutNoise = np.zeros((np.shape(DRout)[0], np.shape(DRout)[1] - 1))\n        for i in range(3, len(stepPRV_PN) - 1):\n            for j in [0, 1, 2]:\n                DVoutNoise[i, j] = DVout[i, j + 1] - DVAccum_SN_P[i + 1, j]\n        omegaOutNoise = np.zeros((np.shape(DRout)[0], np.shape(DRout)[1] - 1))\n        for i in range(3, len(stepPRV_PN)-1):\n            for j in [0, 1, 2]:\n                omegaOutNoise[i, j] = omegaOut[i, j + 1] - omega_PN_P[i + 1, j]\n\n        if not unitTestSupport.isDoubleEqualRelative(np.std(DRoutNoise[:,0]),senRotNoiseStd*dt/1.5,accuracy):\n            testMessages.append((\"FAILED DRnoise1. \\\\\\\\& &\"))\n            testFailCount += 1\n        if not unitTestSupport.isDoubleEqualRelative(np.std(DRoutNoise[:,1]),senRotNoiseStd*dt/1.5,accuracy):\n            testMessages.append((\"FAILED DRnoise2. \\\\\\\\& &\"))\n            testFailCount += 1\n        if not unitTestSupport.isDoubleEqualRelative(np.std(DRoutNoise[:,2]),senRotNoiseStd*dt/1.5,accuracy):\n            testMessages.append((\"FAILED DRnoise3. \\\\\\\\& &\"))\n            testFailCount += 1\n        if not unitTestSupport.isDoubleEqualRelative(np.std(DVoutNoise[:,0]),senTransNoiseStd*dt/1.5 * accelScale[0],accuracy):\n            testMessages.append((\"FAILED DVnoise1. \\\\\\\\& &\"))\n            testFailCount += 1\n        if not unitTestSupport.isDoubleEqualRelative(np.std(DVoutNoise[:,1]),senTransNoiseStd*dt/1.5 * accelScale[1],accuracy):\n            testMessages.append((\"FAILED DVnoise2. \\\\\\\\& &\"))\n            testFailCount += 1\n        if not unitTestSupport.isDoubleEqualRelative(np.std(DVoutNoise[:,2]),senTransNoiseStd*dt/1.5 * accelScale[2],accuracy):\n            testMessages.append((\"FAILED DVnoise3. \\\\\\\\& &\"))\n            testFailCount += 1\n        if not unitTestSupport.isDoubleEqualRelative(np.std(rDotDotOutNoise[:,0]),senTransNoiseStd/1.5 * accelScale[0],accuracy):\n            testMessages.append((\"FAILED AccelNoise1. \\\\\\\\& &\"))\n            testFailCount += 1\n        if not unitTestSupport.isDoubleEqualRelative(np.std(rDotDotOutNoise[:,1]),senTransNoiseStd/1.5 * accelScale[1],accuracy):\n            testMessages.append((\"FAILED AccelNoise2. \\\\\\\\& &\"))\n            testFailCount += 1\n        if not unitTestSupport.isDoubleEqualRelative(np.std(rDotDotOutNoise[:,2]),senTransNoiseStd/1.5 * accelScale[2],accuracy):\n            testMessages.append((\"FAILED AccelNoise3. \\\\\\\\& &\"))\n            testFailCount += 1\n        if not unitTestSupport.isDoubleEqualRelative(np.std(omegaOutNoise[:,0]),senRotNoiseStd/1.5,accuracy):\n            testMessages.append((\"FAILED omegaNoise1. \\\\\\\\& &\"))\n            testFailCount += 1\n        if not unitTestSupport.isDoubleEqualRelative(np.std(omegaOutNoise[:,1]),senRotNoiseStd/1.5,accuracy):\n            testMessages.append((\"FAILED oemgaNoise2. \\\\\\\\& &\"))\n            testFailCount += 1\n        if not unitTestSupport.isDoubleEqualRelative(np.std(omegaOutNoise[:,2]),senRotNoiseStd/1.5,accuracy):\n            testMessages.append((\"FAILED omegaNoise3. \\\\\\\\& &\"))\n            testFailCount += 1\n\n        # noise plots\n        plt.figure(1000, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n        plt.clf()\n        plt.plot(DRout[1:, 0]/1e9, DVoutNoise[1:,:])\n        plt.xlabel(\"Time[s]\")\n        plt.ylabel(\"DV Noise [um/s]\")\n        plt.title(\"DV Noise\")\n        unitTestSupport.writeFigureLaTeX(\"DVnoise\",\n                                         'Plot of DeltaV noise along each component for the noise test.',\n                                         plt,\n                                         'height=0.7\\\\textwidth, keepaspectratio', path)\n        plt.figure(1001, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n        plt.clf()\n        plt.plot(DRout[1:, 0]/1e9, rDotDotOutNoise[1:,:])\n        plt.xlabel(\"Time[s]\")\n        plt.ylabel(\"Acceleration Noise [m/s/s]\")\n        plt.title(\"Acceleration Noise\")\n        unitTestSupport.writeFigureLaTeX(\"AccelNoise\",\n                                         'Plot of acceleration noise along each component for the noise test.',\n                                         plt,\n                                         'height=0.7\\\\textwidth, keepaspectratio', path)\n        plt.figure(1002, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n        plt.clf()\n        plt.plot(DRout[1:, 0]/1e9, DRoutNoise[1:,:])\n        plt.xlabel(\"Time[s]\")\n        plt.ylabel(\"DR Noise [rad]\")\n        plt.title(\"DR Noise\")\n        unitTestSupport.writeFigureLaTeX(\"DRnoise\",\n                                         'Plot of PRV noise along each component for the noise test.',\n                                         plt,\n                                         'height=0.7\\\\textwidth, keepaspectratio', path)\n        plt.figure(1003, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n        plt.clf()\n        plt.plot(DRout[1:, 0]/1e9, omegaOutNoise[1:,:])\n        plt.xlabel(\"Time[s]\")\n        plt.ylabel(\"Angular Rate Noise [rad/s]\")\n        plt.title(\"Angular Rate Noise\")\n        unitTestSupport.writeFigureLaTeX(\"omegaNoise\",\n                                         'Plot of Angular Rate noise along each component for the noise test.',\n                                         plt,\n                                         'height=0.7\\\\textwidth, keepaspectratio', path)\n        if show_plots:\n            plt.show()\n            plt.close('all')\n\n    #\n    # Outputs to AutoTex\n    #\n    accuracySnippetName = testCase+\"accuracy\"\n    accuracySnippetContent = '{:1.0e}'.format(accuracy)\n    unitTestSupport.writeTeXSnippet(accuracySnippetName, accuracySnippetContent, path)\n\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        passedText = r'\\textcolor{' + colorText + '}{' + \"FAILED\" + '}'\n\n    passFailSnippetName = testCase+\"passFail\"\n    passFailSnippetContent = passedText\n    unitTestSupport.writeTeXSnippet(passFailSnippetName, passFailSnippetContent, path)\n\n    snippetName = testCase + \"gyroLSB\"\n    snippetContent = '{:1.0e}'.format(gyroLSBIn)\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n    snippetName = testCase + \"accelLSB\"\n    snippetContent = '{:1.0e}'.format(accelLSBIn)\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n    snippetName = testCase + \"rotMax\"\n    snippetContent = '{:1.1e}'.format(senRotMaxIn)\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n    snippetName = testCase + \"transMax\"\n    snippetContent = '{:1.1e}'.format(senTransMaxIn)\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n    snippetName = testCase + \"rotNoise\"\n    snippetContent = '{:0.1f}'.format(senRotNoiseStd)\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n    snippetName = testCase + \"transNoise\"\n    snippetContent = '{:0.1f}'.format(senTransNoiseStd)\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n    snippetName = testCase + \"rotBias\"\n    snippetContent = '{:1.1e}'.format(senRotBiasIn)\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n    snippetName = testCase + \"transBias\"\n    snippetContent = '{:1.1e}'.format(senTransBiasIn)\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"PASSED\")\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, useNoiseStd, useBias, useMinOut, useMaxOut, useScaleFactor, errTol):\n    \"\"\"\n    **Validation Test Description**\n\n    This section describes the specific unit tests conducted on this module.\n    The test contains 16 tests and is located at ``test_magnetometer.py``.\n    The success criteria is to match the outputs with the generated truth.\n\n    Args:\n\n        useNoiseStd (string): Defines if the standard deviation of the magnetometer measurements is used for this\n            parameterized unit test\n        useBias (string): Defines if the bias on the magnetometer measurements is used for this parameterized unit test\n        useMinOut (string): Defines if the minimum bound for the measurement saturation is used for this\n            parameterized unit test\n        useMaxOut (string): Defines if the maximum bound for the measurement saturation is used for this\n            parameterized unit test\n        useScaleFactor (string): Defines if the scaling on the measurement is used for this parameterized unit test\n        errTol (double): Defines the error tolerance for this parameterized unit test\n\n    **Description of Variables Being Tested**\n\n    In this file, we are checking the values of the variable:\n\n    ``tamData[3]``\n\n    which is pulled from the log data to see if they match with the expected truth values.\n\n    \"\"\"\n\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(show_plots, useNoiseStd, useBias, useMinOut, useMaxOut, useScaleFactor, errTol)\n    assert testResults < 1, testMessage",
  "def run(show_plots, useNoiseStd, useBias, useMinOut, useMaxOut, useScaleFactor, errTol):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate_s = 0.01\n    testProcessRate = macros.sec2nano(testProcessRate_s)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    testModule = magnetometer.Magnetometer()\n    testModule.ModelTag = \"TAM_sensor\"\n    NoiseStd = [3e-9, 3e-9, 3e-9]  # Tesla\n    bias = [1e-6, 1e-6, 1e-5]  # Tesla\n    minOut = -1e-4  # Tesla\n    maxOut = 1e-4  # Tesla\n\n    if useNoiseStd:\n        testModule.senNoiseStd = NoiseStd\n    if useBias:\n        testModule.senBias = bias\n    if useScaleFactor:\n        testModule.scaleFactor = 2\n    if useMinOut & useMaxOut:\n        testModule.minOutput = minOut\n        testModule.maxOutput = maxOut\n\n    # Add module to the task\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    # Set-up fake magnetic field\n    magFieldMsg = messaging.MagneticFieldMsgPayload()\n    trueMagField = [1e-5, 2e-5, 1.5e-5]  # [T] true magnetic field outputs in inertial frame\n    magFieldMsg.magField_N = trueMagField\n    magMsg = messaging.MagneticFieldMsg().write(magFieldMsg)\n    testModule.magInMsg.subscribeTo(magMsg)\n\n    # Set-up fake attitude\n    satelliteStateMsg = messaging.SCStatesMsgPayload()\n    angles = np.linspace(0., 2 * np.pi, 59000)\n    sigmas = np.zeros(len(angles))\n    for i in range(len(sigmas)):  # convert rotation angle about 3rd axis to MRP\n        sigmas[i] = np.tan(angles[i] / 4.)  # This is iterated through in the execution for loop\n        satelliteStateMsg.sigma_BN = [0.3, 0.2, sigmas[i]]\n    scMsg = messaging.SCStatesMsg().write(satelliteStateMsg)\n    testModule.stateInMsg.subscribeTo(scMsg)\n    dcm_BN = rbk.MRP2C(satelliteStateMsg.sigma_BN)\n\n    # Sensor set-up\n    yaw = 0.7854  # [rad]\n    pitch = 1.0  # [rad]\n    roll = 0.1  # [rad]\n    dcm_SB_py = rbk.euler3212C([yaw, pitch, roll])  # for checking the dcm_SB\n    dcm_SB = testModule.setBodyToSensorDCM(yaw, pitch, roll)\n    dcm_SN = np.dot(dcm_SB, dcm_BN)\n    trueTam_S =  np.dot(dcm_SN, trueMagField)\n\n    if useBias:\n        trueTam_S += bias  # Tesla\n    if useScaleFactor:\n        trueTam_S *= 2\n\n    for i in range(len(trueTam_S)):\n        if useMinOut & useMaxOut:\n            if trueTam_S[i] < minOut:\n                trueTam_S[i] = minOut\n            if trueTam_S[i] > maxOut:\n                trueTam_S[i] = maxOut\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = testModule.tamDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.TotalSim.SingleStepProcesses()\n\n    # This pulls the actual data log from the simulation run.\n    tamData = dataLog.tam_S\n    print(tamData)\n    print(trueTam_S)\n\n    if not unitTestSupport.isArrayEqualRelative(tamData[0], trueTam_S, 3, errTol):\n        testFailCount += 1\n\n    #   print out success or failure message\n    if testFailCount == 0:\n        print(\"PASSED: \" + testModule.ModelTag)\n    else:\n        print(\"Failed: \" + testModule.ModelTag)\n    print(\"This test uses a relative accuracy value of \" + str(errTol*100) + \" percent\")\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_coarseSunSensor(show_plots, useConstellation, visibilityFactor, fov, kelly, scaleFactor, bias, noiseStd,\n                         albedoValue, sunDistInput, minIn, maxIn, errTol, name, zLevel, lineWide):\n    '''This function is called by the py.test environment.'''\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(show_plots, useConstellation, visibilityFactor, fov, kelly, scaleFactor, bias,\n                                     noiseStd, albedoValue, sunDistInput, minIn, maxIn, errTol, name, zLevel, lineWide)\n    assert testResults < 1, testMessage\n\n    __tracebackhide__ = True",
  "def run(show_plots, useConstellation, visibilityFactor, fov, kelly, scaleFactor, bias, noiseStd, albedoValue,\n        sunDistInput, minIn, maxIn, errTol, name, zLevel, lineWide):\n    #\n    #   Sim Setup\n    #\n    testFailCount = 0\n    testMessages = []\n    testTaskName = \"unitTestTask\"\n    testProcessName = \"unitTestProcess\"\n    testTaskRate = macros.sec2nano(0.1)\n\n    # Create a simulation container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    # Ensure simulation is empty\n    testProc = unitTestSim.CreateNewProcess(testProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(testTaskName, testTaskRate))\n\n    #\n    #   Input Message Setup\n    #   Creates inputs from sun, spacecraft, and eclipse so that those modules don't have to be included\n    # Create dummy sun message\n    sunPositionMsg = messaging.SpicePlanetStateMsgPayload()\n    sunPositionMsg.PositionVector = [om.AU * 1000. * sunDistInput, 0.0, 0.0]\n    sunMsg = messaging.SpicePlanetStateMsg().write(sunPositionMsg)\n\n    # Create dummy spacecraft message\n    satelliteStateMsg = messaging.SCStatesMsgPayload()\n    satelliteStateMsg.r_BN_N = [0.0, 0.0, 0.0]\n    angles = np.linspace(0., 2 * np.pi, 360)\n    sigmas = np.zeros(len(angles))\n    truthVector = np.cos(angles)  # set truth vector initially, modify below based on inputs\n    for i in range(len(sigmas)):  # convert rotation angle about 3rd axis to MRP\n        sigmas[i] = np.tan(angles[i] / 4.)  # This is iterated through in the execution for loop\n    satelliteStateMsg.sigma_BN = [0., 0., sigmas[0]]\n    scMsg = messaging.SCStatesMsg().write(satelliteStateMsg)\n\n    # Calculate sun distance factor\n    r_Sun_Sc = [0.0, 0.0, 0.0]\n    r_Sun_Sc[0] = sunPositionMsg.PositionVector[0] - satelliteStateMsg.r_BN_N[0]\n    r_Sun_Sc[1] = sunPositionMsg.PositionVector[1] - satelliteStateMsg.r_BN_N[1]\n    r_Sun_Sc[2] = sunPositionMsg.PositionVector[2] - satelliteStateMsg.r_BN_N[2]\n    sunDist = np.linalg.norm(r_Sun_Sc)\n    sunDistanceFactor = ((om.AU * 1000.0) ** 2) / (sunDist ** 2)\n\n    # create dummy eclipse message\n    eclipseMsg = messaging.EclipseMsgPayload()\n    eclipseMsg.shadowFactor = visibilityFactor\n    ecMsg = messaging.EclipseMsg().write(eclipseMsg)\n\n    def setupCSS(CSS):\n        CSS.fov = fov\n        CSS.kellyFactor = kelly\n        CSS.scaleFactor = scaleFactor\n        CSS.senBias = bias\n        CSS.senNoiseStd = noiseStd\n        CSS.albedoValue = albedoValue\n        CSS.minOutput = minIn\n        CSS.maxOutput = maxIn\n        CSS.nHat_B = np.array([1., 0., 0.])\n        CSS.sunInMsg.subscribeTo(sunMsg)\n        CSS.stateInMsg.subscribeTo(scMsg)\n        CSS.sunEclipseInMsg.subscribeTo(ecMsg)\n\n    #\n    #   Single CSS Setup\n    #   Sets up a single CSS with inputs from the pytest parameterization\n    singleCss = coarseSunSensor.CoarseSunSensor()\n    singleCss.ModelTag = \"singleCss\"\n    setupCSS(singleCss)\n    unitTestSim.AddModelToTask(testTaskName, singleCss)\n\n    #\n    #   CSS Constellation Setup\n    #   Sets up two identical constellations (P1 and P2) but uses different methods to establish nHat_B for the sensors.\n    if useConstellation:\n        cssP11 = coarseSunSensor.CoarseSunSensor()\n        cssP11.ModelTag = \"cssP11\"\n        setupCSS(cssP11)\n        cssP12 = coarseSunSensor.CoarseSunSensor()\n        cssP12.ModelTag = \"cssP12\"\n        setupCSS(cssP12)\n        cssP13 = coarseSunSensor.CoarseSunSensor()\n        cssP13.ModelTag = \"cssP13\"\n        setupCSS(cssP13)\n        cssP14 = coarseSunSensor.CoarseSunSensor()\n        cssP14.ModelTag = \"cssP14\"\n        setupCSS(cssP14)\n        cssP21 = coarseSunSensor.CoarseSunSensor()\n        cssP21.ModelTag = \"cssP21\"\n        setupCSS(cssP21)\n        cssP22 = coarseSunSensor.CoarseSunSensor()\n        cssP22.ModelTag = \"cssP22\"\n        setupCSS(cssP22)\n        cssP23 = coarseSunSensor.CoarseSunSensor()\n        cssP23.ModelTag = \"cssP23\"\n        setupCSS(cssP23)\n        cssP24 = coarseSunSensor.CoarseSunSensor()\n        cssP24.ModelTag = \"cssP24\"\n        setupCSS(cssP24)\n\n        # all sensors on a 45 degree, four sided pyramid mount\n        cssP11.nHat_B = [1. / np.sqrt(2.), 0., -1. / np.sqrt(2.)]\n        cssP12.nHat_B = [1. / np.sqrt(2.), 1. / np.sqrt(2.), 0.]\n        cssP13.nHat_B = [1. / np.sqrt(2.), 0., 1. / np.sqrt(2)]\n        cssP14.nHat_B = [1. / np.sqrt(2.), -1. / np.sqrt(2.), 0.]\n\n        # all except cssP24 given non-zero platform frame. B4 is not changed so that the default is tested.\n        cssP21.setBodyToPlatformDCM(np.pi / 2., np.pi / 2., np.pi / 2.)\n        cssP22.setBodyToPlatformDCM(np.pi / 2., np.pi / 2., np.pi / 2.)\n        cssP23.setBodyToPlatformDCM(np.pi / 2., np.pi / 2., np.pi / 2.)\n        # cssP24 is not changed so that the default is tested to be identity\n\n        cssP21.phi = np.pi / 4.\n        cssP21.theta = 0.\n        cssP22.phi = np.pi / 4.\n        cssP22.theta = np.pi / 2.\n        cssP23.phi = np.pi / 4.\n        cssP23.theta = np.pi\n        cssP24.phi = np.pi / 6.  # remember, the cssP24 frame is the B frame. This angle is cancelled by a perturbation.\n        cssP24.theta = -np.pi / 8.  # This angle is also provided with a perturbation to test to perturbation functionality.\n\n        cssP21.setUnitDirectionVectorWithPerturbation(0., 0.)\n        cssP22.setUnitDirectionVectorWithPerturbation(0., 0.)\n        cssP23.setUnitDirectionVectorWithPerturbation(0., 0.)\n        cssP24.setUnitDirectionVectorWithPerturbation(-np.pi / 8., -np.pi / 6.)\n\n        constellationP1List = [cssP11, cssP12, cssP13,\n                               cssP14]  # P1 is second platform, numbers following P2 are sensor numbers\n\n        constellationP1 = coarseSunSensor.CSSConstellation()\n        constellationP1.ModelTag = \"constellationP1\"\n        for item in constellationP1List:\n            constellationP1.appendCSS(item)\n        unitTestSim.AddModelToTask(testTaskName, constellationP1)\n\n        constellationP2List = [cssP21, cssP22, cssP23, cssP24]  # P2 is second platform, numbers following P2 are sensor numbers\n        constellationP2 = coarseSunSensor.CSSConstellation()\n        constellationP2.ModelTag = \"constellationP2\"\n        for item in constellationP2List:\n            constellationP2.appendCSS(item)\n        unitTestSim.AddModelToTask(testTaskName, constellationP2)\n\n        dataLogP1 = constellationP1.constellationOutMsg.recorder()\n        dataLogP2 = constellationP2.constellationOutMsg.recorder()\n        unitTestSim.AddModelToTask(testTaskName, dataLogP1)\n        unitTestSim.AddModelToTask(testTaskName, dataLogP2)\n\n    # log single CSS\n    dataLogSingle = singleCss.cssDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(testTaskName, dataLogSingle)\n\n    #\n    #   Modify Truth Vector Appropriately\n    #\n    for i in range(len(truthVector)):\n        if kelly > 0.0000000000001:  # only if kelly isn't actually zero\n            truthVector[i] = truthVector[i] * (\n                    1.0 - np.e ** (-truthVector[i] ** 2.0 / kelly))  # apply kelly factor, note: no albedo\n        truthVector[i] = truthVector[i] * visibilityFactor * sunDistanceFactor  # account for eclipse effects\n        truthVector[i] += albedoValue  # apply albedo\n        truthVector[i] += bias  # apply bias\n    for i in range(len(angles)):\n        if angles[i] > fov and angles[i] < (2 * np.pi - fov):  # first, trim to fov\n            truthVector[i] = 0.0\n            truthVector[i] += albedoValue  # apply albedo\n            truthVector[i] += bias\n    truthVector = truthVector * scaleFactor\n    for i in range(len(truthVector)):\n        truthVector[i] = min([truthVector[i], maxIn])\n        truthVector[i] = max([truthVector[i], minIn])\n\n    #\n    #   Initialize and run simulation one step at a time\n    #\n    unitTestSim.InitializeSimulation()\n\n    # Execute the simulation for one time step\n    for i in range(len(sigmas)):\n        satelliteStateMsg.sigma_BN = [0.0, 0.0, sigmas[i]]\n        scMsg.write(satelliteStateMsg, unitTestSim.TotalSim.CurrentNanos + testTaskRate)\n        unitTestSim.TotalSim.SingleStepProcesses()\n\n    #\n    #   Constellation Outputs and plots\n    #\n    cssOutput = dataLogSingle.OutputData\n    if useConstellation:\n        constellationP1data = dataLogP1.CosValue\n        constellationP2data = dataLogP2.CosValue\n\n        plt.figure(1, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n        plt.clf()\n        plt.subplot(2, 1, 1)\n        for i in range(4):\n            sensorlabel = \"cssP1\" + str(i + 1)\n            plt.plot(dataLogP1.times() * macros.NANO2MIN, constellationP1data[:, i], label=sensorlabel,\n                     linewidth=4 - i)\n        plt.xlabel('Time [min]')\n        plt.ylabel('P1 Output Values [-]')\n        plt.legend(loc='upper center')\n\n        plt.subplot(2, 1, 2)\n        # plt.figure(2,figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n        for i in range(4):\n            sensorlabel = \"cssP2\" + str(i + 1)\n            plt.plot(dataLogP2.times() * macros.NANO2MIN, constellationP2data[:, i], label=sensorlabel,\n                     linewidth=4 - i)\n        plt.xlabel('Time [min]')\n        plt.ylabel('P2 Output Values [-]')\n        plt.legend(loc='upper center')\n        unitTestSupport.writeFigureLaTeX('constellationPlots',\n                                         'Plot of first and second constellation outputs for comparision.\\\n                                          Note that the constellation starts pointing directly at the sun\\\n                                           and linearly rotates in time until it returns to a direct view.',\n                                         plt, 'height=0.7\\\\textwidth, keepaspectratio', path)\n    #\n    #   Single CSS plotting\n    #\n    else:\n        justTheNoise = cssOutput - truthVector  # subtract curve from noisy curve\n        outputStd = np.std(justTheNoise)\n        plt.figure(3, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n        plt.plot(dataLogSingle.times() * macros.NANO2MIN, cssOutput, label=name, zorder=zLevel, linewidth=lineWide)\n        plt.legend()\n        plt.xlabel('Time [min]')\n        plt.ylabel('Output Value [-]')\n        if name == \"combined\":\n            unitTestSupport.writeFigureLaTeX('combinedPlot',\n                                             'Plot of all cases of individual coarse sun sensor in comparison to\\\n                                              each other. Note that the incidence angle starts at direct and linearly\\\n                                               rotates in time until it returns to a direct view.',\n                                             plt, 'height=0.7\\\\textwidth, keepaspectratio', path)\n\n    if name == \"constellation\" and show_plots:  # Don't show plots until last run.\n        plt.show()\n        plt.close('all')\n\n    #\n    #   Compare output and truth vectors\n    #\n    if useConstellation:  # compare constellation P1 to constellation P2\n        for i in range(0, np.shape(constellationP2data)[0]):\n            if not unitTestSupport.isArrayEqualRelative(constellationP2data[i][:], constellationP1data[i][0:], 4,\n                                                        errTol):\n                testFailCount += 1\n    elif noiseStd == 0.0:  # if a test without noise\n        for i in range(0, np.shape(cssOutput)[0]):\n            if cssOutput[i] == 0.0:\n                if not unitTestSupport.isArrayZero([cssOutput[i]], 1, errTol):\n                    testFailCount += 1\n            else:\n                if not unitTestSupport.isDoubleEqualRelative(cssOutput[i], truthVector[i], errTol):\n                    testFailCount += 1\n    else:  # if \"combined\" or \"deviation\"\n        if not unitTestSupport.isDoubleEqualRelative(noiseStd * scaleFactor, outputStd, errTol):\n            print(outputStd)\n            print(noiseStd * scaleFactor)\n            testFailCount += 1\n            print(\"HPS: 2\")\n\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        passFailMsg = \"\"  # \"Passed: \" + name + \".\"\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        passFailMsg = \"Failed: \" + name + \".\"\n        testMessages.append(passFailMsg)\n        testMessages.append(\" | \")\n        passedText = r'\\textcolor{' + colorText + '}{' + \"FAILED\" + '}'\n\n    # Write some snippets for AutoTex\n    snippetName = name + \"PassedText\"\n    snippetContent = passedText\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n\n    snippetName = name + \"PassFailMsg\"\n    snippetContent = passFailMsg\n    unitTestSupport.writeTeXSnippet(snippetName, snippetContent, path)\n    print(\"\\n\", passFailMsg)\n\n    # write pytest parameters to AutoTex folder\n    # \"useConstellation, visibilityFactor, fov, kelly, scaleFactor, bias, noiseStd, albedoValue, errTol, name, zLevel, lineWide\"\n    useConstellationSnippetName = name + \"UseConstellation\"\n    useConstellationSnippetContent = str(useConstellation)\n    unitTestSupport.writeTeXSnippet(useConstellationSnippetName, useConstellationSnippetContent, path)\n\n    visibilityFactorSnippetName = name + \"VisibilityFactor\"\n    visibilityFactorSnippetContent = '{:1.2f}'.format(visibilityFactor)\n    unitTestSupport.writeTeXSnippet(visibilityFactorSnippetName, visibilityFactorSnippetContent, path)\n\n    fovSnippetName = name + \"Fov\"\n    fovSnippetContent = '{:1.4f}'.format(fov)\n    unitTestSupport.writeTeXSnippet(fovSnippetName, fovSnippetContent, path)\n\n    kellySnippetName = name + \"Kelly\"\n    kellySnippetContent = '{:1.2f}'.format(kelly)\n    unitTestSupport.writeTeXSnippet(kellySnippetName, kellySnippetContent, path)\n\n    scaleFactorSnippetName = name + \"ScaleFactor\"\n    scaleFactorSnippetContent = '{:1.2f}'.format(scaleFactor)\n    unitTestSupport.writeTeXSnippet(scaleFactorSnippetName, scaleFactorSnippetContent, path)\n\n    biasSnippetName = name + \"Bias\"\n    biasSnippetContent = '{:1.2f}'.format(bias)\n    unitTestSupport.writeTeXSnippet(biasSnippetName, biasSnippetContent, path)\n\n    noiseStdSnippetName = name + \"NoiseStd\"\n    noiseStdSnippetContent = '{:1.3f}'.format(noiseStd)\n    unitTestSupport.writeTeXSnippet(noiseStdSnippetName, noiseStdSnippetContent, path)\n\n    albedoValueSnippetName = name + \"AlbedoValue\"\n    albedoValueSnippetContent = '{:1.1f}'.format(albedoValue)\n    unitTestSupport.writeTeXSnippet(albedoValueSnippetName, albedoValueSnippetContent, path)\n\n    locationSnippetName = name + \"Location\"\n    locationSnippetContent = '{:1.1f}'.format(sunDistInput)\n    unitTestSupport.writeTeXSnippet(locationSnippetName, locationSnippetContent, path)\n\n    saturationMaxSnippetName = name + \"MaxSaturation\"\n    saturationMaxSnippetContent = '{:2.2f}'.format(maxIn)\n    unitTestSupport.writeTeXSnippet(saturationMaxSnippetName, saturationMaxSnippetContent, path)\n\n    saturationMinSnippetName = name + \"MinSaturation\"\n    saturationMinSnippetContent = '{:2.2f}'.format(minIn)\n    unitTestSupport.writeTeXSnippet(saturationMinSnippetName, saturationMinSnippetContent, path)\n\n    errTolSnippetName = name + \"ErrTol\"\n    errTolSnippetContent = '{:1.1e}'.format(errTol)\n    unitTestSupport.writeTeXSnippet(errTolSnippetName, errTolSnippetContent, path)\n\n    if testFailCount == 0:\n        print(\"PASSED\")\n    return [testFailCount, ''.join(testMessages)]",
  "def setupCSS(CSS):\n        CSS.fov = fov\n        CSS.kellyFactor = kelly\n        CSS.scaleFactor = scaleFactor\n        CSS.senBias = bias\n        CSS.senNoiseStd = noiseStd\n        CSS.albedoValue = albedoValue\n        CSS.minOutput = minIn\n        CSS.maxOutput = maxIn\n        CSS.nHat_B = np.array([1., 0., 0.])\n        CSS.sunInMsg.subscribeTo(sunMsg)\n        CSS.stateInMsg.subscribeTo(scMsg)\n        CSS.sunEclipseInMsg.subscribeTo(ecMsg)",
  "def test_CSSConfig(show_plots, accuracy):\n    '''This function is called by the py.test environment.'''\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(show_plots, accuracy)\n\n    assert testResults < 1, testMessage",
  "def run(show_plots, accuracy):\n    \"\"\"\n        At the end of the python script you can specify the following example parameters.\n\n        Args:\n            show_plots (bool): Determines if the script should display plots\n\n        \"\"\"\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n\n    # Create simulation variable names\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n\n    #  Create a sim module as an empty container\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    #\n    #  create the simulation process\n    #\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n\n    # create the dynamics task and specify the integration update time\n    simulationTimeStep = macros.sec2nano(1.)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    # create the CSS modules\n    CSS1 = coarseSunSensor.CoarseSunSensor()\n    CSS1.ModelTag = \"CSS1\"\n    CSS1.fov = 80. * macros.D2R\n    CSS1.maxOutput = 10.\n    # CSS1.cssConfigLogMsgName is not set to check default behavior\n    CSS1.nHat_B = [1.0, 0.0, 0.0]\n\n    CSS2 = coarseSunSensor.CoarseSunSensor()\n    CSS2.ModelTag = \"CSS2\"\n    CSS2.r_B = [1., 2., 3.]\n    CSS2.fov = 70. * macros.D2R\n    CSS2.minOutput = 1.0\n    CSS2.maxOutput = 20.\n    CSS2.nHat_B = [0.0, -1.0, 0.0]\n    CSS2.CSSGroupID = 1\n\n    scSim.AddModelToTask(simTaskName, CSS1)\n    scSim.AddModelToTask(simTaskName, CSS2)\n\n    dataLog1 = CSS1.cssConfigLogOutMsg.recorder()\n    dataLog2 = CSS2.cssConfigLogOutMsg.recorder()\n    scSim.AddModelToTask(simTaskName, dataLog1)\n    scSim.AddModelToTask(simTaskName, dataLog2)\n\n    # create sun position input message\n    sunPositionMsg = messaging.SpicePlanetStateMsgPayload()\n    sunPositionMsg.PositionVector = [0.0, 0.0, 0.0]\n    sunMsg = messaging.SpicePlanetStateMsg().write(sunPositionMsg)\n    CSS1.sunInMsg.subscribeTo(sunMsg)\n    CSS2.sunInMsg.subscribeTo(sunMsg)\n\n    # create spacecraft state message\n    scStateMsg = messaging.SCStatesMsgPayload()\n    scStateMsg.r_BN_N = [-10.0, 0.0, 0.0]\n    scStateMsg.sigma_BN = [0.0, 0.0, 0.0]\n    scMsg = messaging.SCStatesMsg().write(scStateMsg)\n    CSS1.stateInMsg.subscribeTo(scMsg)\n    CSS2.stateInMsg.subscribeTo(scMsg)\n\n    scSim.InitializeSimulation()\n    scSim.TotalSim.SingleStepProcesses()\n\n    # pull logged data\n    dataCSS1pos = dataLog1.r_B\n    dataCSS1nHat = dataLog1.nHat_B\n    dataCSS1fov = dataLog1.fov\n    dataCSS1signal = dataLog1.signal\n    dataCSS1maxSignal = dataLog1.maxSignal\n    dataCSS1minSignal = dataLog1.minSignal\n    dataCSS1CSSGroupID = dataLog1.CSSGroupID\n\n    dataCSS2pos = dataLog2.r_B\n    dataCSS2nHat = dataLog2.nHat_B\n    dataCSS2fov = dataLog2.fov\n    dataCSS2signal = dataLog2.signal\n    dataCSS2maxSignal = dataLog2.maxSignal\n    dataCSS2minSignal = dataLog2.minSignal\n    dataCSS2CSSGroupID = dataLog2.CSSGroupID\n\n    # check CSS 1 output\n    testFailCount, testMessages = unitTestSupport.compareArray([[0., 0., 0.]], dataCSS1pos,\n                                                               accuracy, \"CSS1 pos\",\n                                                               testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArray([CSS1.nHat_B], dataCSS1nHat,\n                                                               accuracy, \"CSS1 nHat_B\",\n                                                               testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray([CSS1.fov], dataCSS1fov,\n                                                               accuracy, \"CSS1 fov\",\n                                                               testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray([CSS1.maxOutput], dataCSS1signal,\n                                                                     accuracy, \"CSS1 maxSignal\",\n                                                                     testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray([0.0], dataCSS1minSignal,\n                                                                     accuracy, \"CSS1 minSignal\",\n                                                                     testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray([CSS1.maxOutput], dataCSS1maxSignal,\n                                                                     accuracy, \"CSS1 maxSignal\",\n                                                                     testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray([0], dataCSS1CSSGroupID,\n                                                                     accuracy, \"CSS1 CSSGroupID\",\n                                                                     testFailCount, testMessages)\n\n    # check CSS 2 output\n    testFailCount, testMessages = unitTestSupport.compareArray([CSS2.r_B], dataCSS2pos,\n                                                               accuracy, \"CSS2 pos\",\n                                                               testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArray([CSS2.nHat_B], dataCSS2nHat,\n                                                               accuracy, \"CSS2 nHat_B\",\n                                                               testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray([CSS2.fov], dataCSS2fov,\n                                                                     accuracy, \"CSS2 fov\",\n                                                                     testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray([CSS2.minOutput], dataCSS2signal,\n                                                                     accuracy, \"CSS2 signal\",\n                                                                     testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray([CSS2.maxOutput], dataCSS2maxSignal,\n                                                                     accuracy, \"CSS2 maxSignal\",\n                                                                     testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray([CSS2.minOutput], dataCSS2minSignal,\n                                                                     accuracy, \"CSS2 minSignal\",\n                                                                     testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray([CSS2.CSSGroupID], dataCSS2CSSGroupID,\n                                                                     accuracy, \"CSS2 CSSGroupID\",\n                                                                     testFailCount, testMessages)\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: CSS config test\")\n    else:\n        print(\"FAILED: CSS config test\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_coarseSunSensor(cssFault):\n    '''This function is called by the py.test environment.'''\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(cssFault)\n    assert testResults < 1, testMessage\n    __tracebackhide__ = True",
  "def run(cssFault):\n    # np.random.seed(10)\n\n    testFailCount = 0\n    testMessages = []\n    testTaskName = \"unitTestTask\"\n    testProcessName = \"unitTestProcess\"\n    testTaskRate = macros.sec2nano(0.1)\n\n    # Create a simulation container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    # unitTestSim.RNGSeed = 10\n    \n    # Ensure simulation is empty\n    testProc = unitTestSim.CreateNewProcess(testProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(testTaskName, testTaskRate))\n\n    # Input Message Setup\n    # Creates inputs from sun, spacecraft, and eclipse so that those modules don't have to be included\n    # Create dummy sun message\n    sunPositionMsg = messaging.SpicePlanetStateMsgPayload()\n    sunPositionMsg.PositionVector = [om.AU * 1000.0, 0.0, 0.0]\n    sunMsg = messaging.SpicePlanetStateMsg().write(sunPositionMsg)\n\n    # Create dummy spacecraft message\n    satelliteStateMsg = messaging.SCStatesMsgPayload()\n    satelliteStateMsg.r_BN_N = [0.0, 0.0, 0.0]\n    angle = np.pi/16\n    satelliteStateMsg.sigma_BN = [0., 0., angle]\n    scMsg = messaging.SCStatesMsg().write(satelliteStateMsg)\n\n    # Calculate sun distance factor\n    CSS = coarseSunSensor.CoarseSunSensor()\n\n    CSS.fov = 80. * macros.D2R         # half-angle field of view value\n    CSS.scaleFactor = 2.0\n    CSS.nHat_B = np.array([1., 0., 0.])\n    CSS.sunInMsg.subscribeTo(sunMsg)\n    CSS.stateInMsg.subscribeTo(scMsg)\n    CSS.ModelTag = \"CSS\"\n    CSS.RNGSeed = 123\n    unitTestSim.AddModelToTask(testTaskName, CSS)\n\n    # log single CSS\n    cssRecoder = CSS.cssDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(testTaskName, cssRecoder)\n\n    # Truth Values\n    if cssFault == \"CSSFAULT_OFF\":\n        cssFaultValue = coarseSunSensor.CSSFAULT_OFF\n        truthValue = 0.0\n    elif cssFault == \"CSSFAULT_STUCK_CURRENT\":\n        cssFaultValue = coarseSunSensor.CSSFAULT_STUCK_CURRENT\n        truthValue = 1.4280970791070948\n    elif cssFault == \"CSSFAULT_STUCK_MAX\":\n        cssFaultValue = coarseSunSensor.CSSFAULT_STUCK_MAX\n        truthValue = 2.0\n    elif cssFault == \"CSSFAULT_STUCK_RAND\":\n        cssFaultValue = coarseSunSensor.CSSFAULT_STUCK_RAND\n        truthValue = 1.7278304838858731\n    elif cssFault == \"CSSFAULT_RAND\":\n        cssFaultValue = coarseSunSensor.CSSFAULT_RAND\n        truthValue = 0.7974448327854251\n    else:\n        NotImplementedError(\"Fault type specified does not exist.\")\n\n    unitTestSim.InitializeSimulation()\n\n    # Execute the simulation for one time step\n    unitTestSim.TotalSim.SingleStepProcesses()\n    CSS.faultState = cssFaultValue\n    for i in range(3):\n        unitTestSim.TotalSim.SingleStepProcesses()\n\n    cssOutput = cssRecoder.OutputData[-1]\n    print(cssOutput)\n    print(truthValue)\n    \n    if cssFault == \"CSSFAULT_OFF\":\n        if not truthValue == cssOutput:\n            testFailCount += 1\n    elif not unitTestSupport.isDoubleEqualRelative(cssOutput, truthValue, 1E-12):\n        testFailCount += 1\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, gauss, darkCurrent, saltPepper, cosmic, blurSize):\n    \"\"\"\n        **Validation Test Description**\n\n        This module tests the proper functioning of the camera module. This is done by first ensuring that the reading\n        and writing of the camera parameters are properly executed. The test then corrupts a test image accordingly.\n\n        **Description of Variables Being Tested**\n\n        The camera parameters tested are the camera position MRP and the isOn value for the camera. These ensure that\n        the position is properly written and read. The image is also corrupted with the parameterized test information.\n        This is directly tested by differencing the initial and processed image to see a change.\n        and also ensures that the variables are properly read and that all the openCV functions\n        are executing properly.\n\n        - ``camera_MRP``\n        - ``isON``\n        - ``imageNorm Values``\n\n        The comparative value for the test on the image is 1E-2 which depends on the corruptions but is allowed to me small\n        as the relative difference of the images is taken (whereas pixel values can get large).\n\n        The two parameterized test are set with and without corruptions.\n\n        **General Documentation Comments**\n\n        The script could benefit from more profound image processing testing. Currently the bulk of the image processing\n        is only tested by the result image.\n        \"\"\"\n    # each test method requires a single assert method to be called\n    image = \"mars.jpg\"\n    [testResults, testMessage] = cameraTest(show_plots, image, gauss, darkCurrent, saltPepper, cosmic, blurSize)\n\n    # Clean up\n    imagePath = path + '/' + image\n    savedImage1 = '/'.join(imagePath.split('/')[:-1]) + '/' + str(gauss) + str(darkCurrent) \\\n                  + str(saltPepper) + str(cosmic) + str(blurSize) + '0.000000.png'\n    savedImage2 = '/'.join(imagePath.split('/')[:-1]) + '/' + str(gauss) + str(darkCurrent) \\\n                  + str(saltPepper) + str(cosmic) + str(blurSize) + '0.500000.png'\n    try:\n        os.remove(savedImage1)\n        os.remove(savedImage2)\n    except FileNotFoundError:\n        pass\n\n    assert testResults < 1, testMessage",
  "def cameraTest(show_plots, image, gauss, darkCurrent, saltPepper, cosmic, blurSize):\n    if importErr:\n        print(reasonErr)\n        exit()\n\n    # Truth values from python\n    imagePath = path + '/' + image\n    input_image = Image.open(imagePath)\n    input_image.load()\n    #################################################\n    corrupted = (gauss > 0) or (darkCurrent > 0) or (saltPepper > 0) or (cosmic > 0) or (blurSize > 0)\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    bitmapArray = []\n\n    # # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = camera.Camera()\n    module.ModelTag = \"cameras\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    module.filename = imagePath\n    module.saveImages = True\n    # make each image saved have a unique name for this test case\n    module.saveDir = '/'.join(imagePath.split('/')[:-1]) + '/' + str(gauss) + str(darkCurrent) \\\n                           + str(saltPepper) + str(cosmic) + str(blurSize)\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    inputMessageData = messaging.CameraImageMsgPayload()\n    inputMessageData.timeTag = int(1E9)\n    inputMessageData.cameraID = 1\n    inCamMsg = messaging.CameraImageMsg().write(inputMessageData)\n    module.imageInMsg.subscribeTo(inCamMsg)\n\n    module.cameraIsOn = 1\n    module.sigma_CB = [0, 0, 1]\n\n    # Noise parameters\n    module.gaussian = gauss\n    module.darkCurrent = darkCurrent\n    module.saltPepper = saltPepper\n    module.cosmicRays = cosmic\n    module.blurParam = blurSize\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.cameraConfigOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.5))  # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # Truth values from python\n    if corrupted:\n        corruptedPath = module.saveDir + '0.000000.png'\n    else:\n        corruptedPath = module.saveDir + '0.500000.png'\n    output_image = Image.open(corruptedPath)\n\n    isOnValues = dataLog.isOn\n    pos = dataLog.sigma_CB\n\n    #  Error check for corruption\n    err = np.linalg.norm(np.linalg.norm(input_image, axis=2) - np.linalg.norm(output_image, axis=2)) / np.linalg.norm(\n        np.linalg.norm(input_image, axis=2))\n\n    if (err < 1E-2 and corrupted):\n        testFailCount += 1\n        testMessages.append(\"Image not corrupted and show be: \" + image)\n\n    if (err > 1E-2 and not corrupted):\n        testFailCount += 1\n        testMessages.append(\"Image corrupted and show not be: \" + image)\n\n    #   print out success message if no error were found\n    for i in range(3):\n        if np.abs(pos[-1, i] - module.sigma_CB[i]) > 1E-10:\n            testFailCount += 1\n            testMessages.append(\"Test failed position \" + image)\n\n    if np.abs(isOnValues[-1] - module.cameraIsOn) > 1E-10:\n        testFailCount += 1\n        testMessages.append(\"Test failed isOn \" + image)\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Passed\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, HSV, BGR):\n    \"\"\"\n        **Validation Test Description**\n\n        This module tests the color shifting capability of the camera module. Multiple HSV and BGR color\n        adjustments are tests on a TV test image.\n\n        **Description of Variables Being Tested**\n\n        Multiple points on the test images are adjusted in python and compared to the BSK camera module\n        saved image.  The HSV and BGR color corrections are applied on a series of points in the test image.\n        The integer red, green and blue color values are checked to be identical.\n\n    \"\"\"\n    # each test method requires a single assert method to be called\n    image = \"tv_test.png\"\n    [testResults, testMessage] = cameraColorTest(image, HSV, BGR)\n\n    # Clean up\n    imagePath = path + '/' + image\n    savedImage = '/'.join(imagePath.split('/')[:-1]) + '/hsv' + str(HSV) + 'bgr' + str(BGR) + '0.000000.png'\n    try:\n        os.remove(savedImage)\n    except FileNotFoundError:\n        pass\n\n    assert testResults < 1, testMessage",
  "def cameraColorTest(image, HSV, BGR):\n    \"\"\"\n    Test method to apply the HSV and BGR image adjustments.\n\n    :param image: image name to load from local folder\n    :param HSV: 3d vector of HSV adjustments\n    :param BGR: 3d vector of BGR adjustments\n\n    \"\"\"\n    if importErr:\n        print(reasonErr)\n        exit()\n\n    # Truth values from python\n    imagePath = path + '/' + image\n    input_image = Image.open(imagePath)\n    input_image.load()\n    #################################################\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = camera.Camera()\n    module.ModelTag = \"cameras\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    module.filename = imagePath\n    module.saveImages = True\n    # make each image saved have a unique name for this test case\n    module.saveDir = '/'.join(imagePath.split('/')[:-1]) + '/hsv' + str(HSV) + 'bgr' + str(BGR)\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    inputMessageData = messaging.CameraImageMsgPayload()\n    inputMessageData.timeTag = int(1E9)\n    inputMessageData.cameraID = 1\n    inCamMsg = messaging.CameraImageMsg().write(inputMessageData)\n    module.imageInMsg.subscribeTo(inCamMsg)\n    module.cameraIsOn = 1\n    module.sigma_CB = [0, 0, 1]\n\n    # Noise parameters\n    module.bgrPercent = np.array(BGR)\n    module.hsv = np.array(HSV)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.cameraConfigOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.TotalSim.SingleStepProcesses()\n\n    corruptedPath = module.saveDir + '0.000000.png'\n\n    #   print out error message if test failed\n    if not trueColorAdjust(imagePath, corruptedPath, HSV, BGR):\n        testFailCount += 1\n        testMessages.append(\"Test failed color adjustment  \" + image)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def rgb_to_hsv(rgb):\n    hsv = colorsys.rgb_to_hsv(rgb[0], rgb[1], rgb[2])\n    return [hsv[0] * 180., hsv[1] * 255., hsv[2]]",
  "def hsv_to_rgb(hsv):\n    rgb = colorsys.hsv_to_rgb(hsv[0]/180., hsv[1]/255., hsv[2]/255.)\n    return [rgb[0] * 255, rgb[1] * 255, rgb[2] * 255]",
  "def trueColorAdjust(image, corrupted, HSV, BGR):\n    input_rgb = Image.open(image).load()\n    output = Image.open(corrupted).load()\n\n    # these points correspond to the included 'tv_test.png'\n    testPoints = [(100, 300), (250, 300), (450, 300), (600, 300), (700, 300), (950, 300), (1100, 300), (300, 800),\n                  (880, 780)]\n\n    for point in testPoints:\n        px = point[0]\n        py = point[1]\n\n        # do HSV adjustment\n        hsv = rgb_to_hsv(input_rgb[px, py])\n        expected = [0, 0, 0]\n        input_degrees = math.degrees(HSV[0])\n        h_360 = (hsv[0] * 2) + input_degrees\n        h_360 -= 360. * math.floor(h_360 * (1. / 360.))\n        h_360 = int(h_360 / 2)\n        if h_360 == 180:\n            h_360 = 0\n        expected[0] = int(h_360)\n\n        for i in range(2):\n            expected[i+1] = int(hsv[i+1] * (HSV[i+1]/100. + 1.))\n            if expected[i+1] < 0:\n                expected[i+1] = 0\n            if expected[i+1] > 255:\n                expected[i+1] = 255\n\n        expectedAfterHSV = hsv_to_rgb(expected)\n        expectedAfterHSV = [int(i) for i in expectedAfterHSV]\n\n        # do BGR adjustment\n        for i in range(3):\n            expected[i] = int((BGR[2 - i] / 100. + 1.) * expectedAfterHSV[i])\n            if expected[i] > 255:\n                expected[i] = 255\n            if expected[i] < 0:\n                expected[i] = 0\n\n        for i in range(3):\n            if abs(int(output[px, py][i]) - expected[i]) > 3:\n                print(\"Failed HSV at point: px=\" + str(px) + \" py= + \" + str(py))\n                return False\n    print(\"Passed Color Check\")\n    return True",
  "def test_hingedRigidBodyMotorSensor(show_plots, thetaNoiseStd, thetaDotNoiseStd, thetaBias, thetaDotBias, thetaLSB, thetaDotLSB, trueTheta, trueThetaDot, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This test checks the sensor's addition of a bias and discretization to the input value.\n\n    **Test Parameters**\n\n    Args:\n        thetaNoiseStd (double): standard deviation of the added noise to theta\n        thetaDotNoiseStd (double): standard deviation of the added noise to thetaDot\n        thetaBias (double): bias added to theta\n        thetaDotBias (double): bias added to thetaDot\n        thetaLSB (double): least significant bit for discretizing theta. Negative means no discretization.\n        thetaDotLSB (double): least significant bit for discretizing thetaDot. Negative means no discretization.\n        trueTheta (double): true value of theta\n        trueThetaDot (double): true value of thetaDot\n        accuracy (double): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n    \n    The python evaluated sensed value is compared against the module output.\n\n    \"\"\"\n    [testResults, testMessage] = hingedRigidBodyMotorSensorTestFunction(show_plots, thetaNoiseStd, thetaDotNoiseStd, thetaBias, thetaDotBias, thetaLSB, thetaDotLSB, trueTheta, trueThetaDot, accuracy)\n    assert testResults < 1, testMessage",
  "def hingedRigidBodyMotorSensorTestFunction(show_plots, thetaNoiseStd, thetaDotNoiseStd, thetaBias, thetaDotBias, thetaLSB, thetaDotLSB, trueTheta, trueThetaDot, accuracy):\n    \"\"\"Test method\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n    \n    timeStep = 0.5\n    totalTime = 10.0\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(timeStep)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    module = hingedRigidBodyMotorSensor.HingedRigidBodyMotorSensor()\n    module.ModelTag = \"hingedRigidBodyMotorSensorTag\"\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Configure blank module input messages\n    hingedRigidBodyMotorSensorInMsgData = messaging.HingedRigidBodyMsgPayload()\n    \n    # set up fake input message\n    hingedRigidBodyMotorSensorInMsgData.theta = trueTheta;\n    hingedRigidBodyMotorSensorInMsgData.thetaDot = trueThetaDot;\n\n    hingedRigidBodyMotorSensorInMsg = messaging.HingedRigidBodyMsg().write(hingedRigidBodyMotorSensorInMsgData)\n\n    # subscribe input messages to module\n    module.hingedRigidBodyMotorSensorInMsg.subscribeTo(hingedRigidBodyMotorSensorInMsg)\n\n    # set up output message recorder objects\n    dataLog = module.hingedRigidBodyMotorSensorOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n    \n    # set up variables in sensor\n    module.thetaNoiseStd = thetaNoiseStd\n    module.thetaDotNoiseStd = thetaDotNoiseStd\n    module.thetaBias = thetaBias\n    module.thetaDotBias = thetaDotBias\n    module.thetaLSB = thetaLSB\n    module.thetaDotLSB = thetaDotLSB\n    module.setRNGSeed(2) # change RNG seed here\n\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(totalTime))\n    unitTestSim.ExecuteSimulation()\n\n    # pull module data and make sure it is correct\n    sensedTheta = dataLog.theta[-1]\n    sensedThetaDot = dataLog.thetaDot[-1]\n    \n    # add bias to test values\n    biasTheta = trueTheta+thetaBias\n    biasThetaDot = trueThetaDot+thetaDotBias\n    \n    # discretize test values\n    if thetaLSB > 0:\n        discTheta = round(biasTheta/thetaLSB)*thetaLSB\n    else:\n        discTheta = biasTheta\n    if thetaDotLSB > 0:\n        discThetaDot = round(biasThetaDot/thetaDotLSB)*thetaDotLSB\n    else:\n        discThetaDot = biasThetaDot\n        \n    print(sensedTheta)\n    print(sensedThetaDot)\n    print(trueTheta)\n    print(trueThetaDot)\n\n    # check adding bias\n    if abs(thetaBias) > accuracy:\n        if not unitTestSupport.isDoubleEqual(sensedTheta, discTheta, accuracy):\n            testMessages.append(\"Failed theta bias.\")\n            testFailCount += 1\n        if not unitTestSupport.isDoubleEqual(sensedThetaDot, discThetaDot, accuracy):\n            testMessages.append(\"Failed thetaDot bias.\")\n            testFailCount += 1\n    \n    # check discretization\n    if abs(thetaLSB) > accuracy:\n        if not unitTestSupport.isDoubleEqual(sensedTheta, discTheta, accuracy):\n            testMessages.append(\"Failed theta discretization.\")\n            testFailCount += 1\n        if not unitTestSupport.isDoubleEqual(sensedThetaDot, discThetaDot, accuracy):\n            testMessages.append(\"Failed thetaDot discretization.\")\n            testFailCount += 1\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n        \n    if show_plots:\n        thetaVals = trueTheta*np.ones(int(totalTime/timeStep)+1)\n        thetaDotVals = trueThetaDot*np.ones(int(totalTime/timeStep)+1)\n        timeAxis = dataLog.times() * macros.NANO2SEC\n\n        plt.figure(1)\n        plt.plot(timeAxis, thetaVals,\n                 label=r'Theta Truth')\n        plt.plot(timeAxis, dataLog.theta,\n                 label=r'Theta Sensed')\n        plt.legend(loc='lower right')\n        plt.xlabel('Time [s]')\n        plt.ylabel('Theta [rad]')\n        plt.figure(2)\n        plt.plot(timeAxis, thetaDotVals,\n                 label=r'ThetaDot Truth')\n        plt.plot(timeAxis, dataLog.thetaDot,\n                 label=r'ThetaDot Sensed')\n        plt.legend(loc='lower right')\n        plt.xlabel('Time [s]')\n        plt.ylabel('ThetaDot [rad]')\n        plt.show()\n        plt.close(\"all\")\n\n    return [testFailCount, \"\".join(testMessages)]",
  "def listStack(vec,simStopTime,unitProcRate):\n    # returns a list duplicated the number of times needed to be consistent with module output\n    return [vec] * int(simStopTime/(float(unitProcRate)/float(macros.sec2nano(1))))",
  "def setRandomWalk(self, senNoiseStd = 0.0, errorBounds = [[1e6],[1e6],[1e6]]):\n    # sets the module random walk variables\n    PMatrix = [[senNoiseStd, 0., 0.], [0., senNoiseStd, 0.], [0., 0., senNoiseStd]]\n    self.PMatrix = PMatrix\n    self.walkBounds = errorBounds",
  "def test_unitSimStarTracker(show_plots, useFlag, testCase):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitSimStarTracker(show_plots, useFlag, testCase)\n    assert testResults < 1, testMessage",
  "def unitSimStarTracker(show_plots, useFlag, testCase):\n    testFail = False\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # initialize SimulationBaseClass\n    unitSim = SimulationBaseClass.SimBaseClass()\n\n    # create the task and specify the integration update time\n    unitProcRate = macros.sec2nano(0.1)\n    unitProcRate_s = macros.NANO2SEC*unitProcRate\n    unitProc = unitSim.CreateNewProcess(unitProcName)\n    unitProc.addTask(unitSim.CreateNewTask(unitTaskName, unitProcRate))\n\n    # configure module\n    StarTracker = starTracker.StarTracker()\n    StarTracker.ModelTag = \"StarTracker\"\n    setRandomWalk(StarTracker)\n\n    # configure module input message\n    OutputStateData = messaging.SCStatesMsgPayload()\n    OutputStateData.r_BN_N = [0,0,0]\n    OutputStateData.v_BN_N = [0,0,0]\n    OutputStateData.sigma_BN = [0,0,0]\n    OutputStateData.omega_BN_B = [0,0,0]\n    OutputStateData.TotalAccumDVBdy = [0,0,0]\n    OutputStateData.MRPSwitchCount = 0\n\n    trueVector = dict()\n    print(testCase)\n    if testCase == 'basic':\n        # this test verifies basic input and output\n        simStopTime = 0.5\n        sigma = np.array([-0.390614710591786, -0.503642740963740, 0.462959869561285])\n        OutputStateData.sigma_BN = sigma\n        trueVector['qInrtl2Case'] = listStack(rbk.MRP2EP(sigma),simStopTime,unitProcRate)\n        trueVector['timeTag'] =  np.arange(0,0+simStopTime*1E9,unitProcRate_s*1E9)\n\n    elif testCase == 'noise':\n        simStopTime = 1000.\n        noiseStd = 0.1\n        stdCorrectionFactor = 1.5 # this needs to be used because of the Gauss Markov module. need to fix the GM module\n        setRandomWalk(StarTracker, noiseStd*stdCorrectionFactor, [[1.0e-13],[1.0e-13],[1.0e-13]])\n        sigma = np.array([0,0,0])\n        OutputStateData.sigma_BN = sigma\n        trueVector['qInrtl2Case'] = [noiseStd] * 3\n        trueVector['timeTag'] =  np.arange(0,0+simStopTime*1E9,unitProcRate_s*1E9)\n\n    elif testCase == 'walk bounds':\n        # this test checks the walk bounds of random walk\n        simStopTime = 1000.\n        noiseStd = 0.01\n        stdCorrectionFactor = 1.5 # this needs to be used because of the Gauss Markov module. need to fix the GM module\n        walkBound = 0.1\n        setRandomWalk(StarTracker, noiseStd*stdCorrectionFactor, [[walkBound],[walkBound],[walkBound]])\n        sigma = np.array([0,0,0])\n        OutputStateData.sigma_BN = sigma\n        trueVector['qInrtl2Case'] = [walkBound + noiseStd*3] * 3\n        trueVector['timeTag'] =  np.arange(0,0+simStopTime*1E9,unitProcRate_s*1E9)\n\n    else:\n        raise Exception('invalid test case')\n\n    # add module to the task\n    unitSim.AddModelToTask(unitTaskName, StarTracker)\n\n    # log module output message\n    dataLog = StarTracker.sensorOutMsg.recorder()\n    unitSim.AddModelToTask(unitTaskName, dataLog)\n\n    # configure spacecraft state message\n    scMsg = messaging.SCStatesMsg().write(OutputStateData)\n    StarTracker.scStateInMsg.subscribeTo(scMsg)\n\n    unitSim.InitializeSimulation()\n    unitSim.ConfigureStopTime(macros.sec2nano(simStopTime))\n    unitSim.ExecuteSimulation()\n\n    # pull message log data and assemble into dict\n    moduleOutput = dataLog.qInrtl2Case\n\n    # convert quaternion output to prv\n    moduleOutput2 = np.zeros([int(simStopTime/unitProcRate_s)+1, 3])\n    for i in range(0, int(simStopTime/unitProcRate_s)+1):\n        moduleOutput2[i] = rbk.EP2PRV(moduleOutput[i])\n\n    if not 'accuracy' in vars():\n        accuracy = 1e-6\n\n    if testCase == 'noise':\n        for i in range(0,3):\n            if np.abs(np.mean(moduleOutput2[:,i])) > 0.01 \\\n                            or np.abs(np.std(moduleOutput2[:,i]) - trueVector['qInrtl2Case'][i]) > 0.01 :\n                testFail = True\n                break\n\n    elif testCase == 'walk bounds':\n        for i in range(0,3):\n            print(np.max(np.abs(np.asarray(moduleOutput2[i]))))\n            if np.max(np.abs(np.asarray(moduleOutput2[i]))) > trueVector['qInrtl2Case'][i]:\n                testFail = True\n                break\n\n    else:\n        for i in range(0,len(trueVector['qInrtl2Case'])):\n            if not unitTestSupport.isArrayEqual(moduleOutput[i], trueVector['qInrtl2Case'][i], 3, accuracy):\n                testFail = True\n                break\n\n    if testFail:\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + StarTracker.ModelTag + \" Module failed unit test\")\n\n    np.set_printoptions(precision=16)\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED \")\n    else:\n        print(testMessages)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_unitSimpleVoltEstimator(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitSimpleVoltEstimator(show_plots)\n    assert testResults < 1, testMessage",
  "def unitSimpleVoltEstimator(show_plots):\n    path = os.path.dirname(os.path.abspath(__file__))\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    # Create a sim module as an empty container\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    unitTestProc = unitTestSim.CreateNewProcess(unitProcessName)\n    # create the task and specify the integration update time\n    unitTestProc.addTask(unitTestSim.CreateNewTask(unitTaskName, int(1E8)))\n\n    # Now initialize the modules that we are using\n    sVoltObject = simpleVoltEstimator.SimpleVoltEstimator()\n    unitTestSim.AddModelToTask(unitTaskName, sVoltObject)\n\n    scPotential = -2000.\n\n    voltMessageData = messaging.VoltMsgPayload()\n    voltMessageData.voltage = scPotential\n\n    # Volt output Message\n    voltMsg = messaging.VoltMsg().write(voltMessageData)\n    sVoltObject.voltInMsg.subscribeTo(voltMsg)\n\n    sVoltObject.ModelTag = \"SimpleVoltageEstimation\"\n    voltBound = numpy.array([1000.0])\n    voltSigma = 50.0\n\n    pMatrix = [voltSigma]\n    errorBounds = [1000.]\n\n    sVoltObject.walkBounds = errorBounds\n    sVoltObject.PMatrix = pMatrix\n\n    # setup logging\n    dataVoltLog = sVoltObject.voltOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataVoltLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(int(60 * 144.0 * 1E9))\n    unitTestSim.ExecuteSimulation()\n\n    # pull simulation data\n    volt = dataVoltLog.voltage\n\n    countAllow = volt.shape[0] * 0.3 / 100.\n\n    # make sure there are not too many error counts (voltage difference exceeding voltage bound)\n    voltDiffCount = 0\n    i = 0\n    while i < volt.shape[0]:\n        voltDiff = volt[i] - scPotential\n        if abs(voltDiff) > voltBound:\n            voltDiffCount += 1\n        i += 1\n\n    errorCounts = [voltDiffCount]\n\n    for count in errorCounts:\n        if count > countAllow:\n            testFailCount += 1\n            testMessages.append(\"FAILED: Too many error counts - \" + str(count))\n\n    # now make sure there are enough occasions where voltage difference comes close to voltage bound\n    sigmaThreshold = 0.8\n    voltDiffCount = 0\n    i = 0\n    while i < volt.shape[0]:\n        voltDiff = volt[i] - scPotential\n        if abs(voltDiff) > voltBound*sigmaThreshold:\n            voltDiffCount += 1\n        i += 1\n\n    errorCounts = [voltDiffCount]\n\n    for count in errorCounts:\n        if count < 1:\n            testFailCount += 1\n            testMessages.append(\"FAILED: Too few error counts - \" + str(count))\n\n    plt.figure(1)\n    plt.clf()\n    plt.figure(1, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(dataVoltLog.times() * 1.0E-9, volt[:])\n\n    plt.xlabel('Time (s)')\n    plt.ylabel('Voltage (V)')\n    unitTestSupport.writeFigureLaTeX('SimpleVolt', 'Simple Voltage Estimator Voltage Signal', plt,\n                                     r'height=0.4\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    # check if BSK_ERROR is returned if pMatrix is wrong size\n    pMatrixBad = [[0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n                  [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]]\n    stateBoundsBad = [[0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.], [0.]]\n    sVoltObject.walkBounds = stateBoundsBad\n    sVoltObject.PMatrix = pMatrixBad\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(int(1E8))\n    unitTestSim.ExecuteSimulation()\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED\")\n\n    assert testFailCount < 1, testMessages\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test compares the output of the type ``vehicleConfigMsg`` with the input of the type ``scMassPropsMsg``.\n    For the test, a ``scMAssPropsMAsgPayload`` message is created and populated with certain mass, inertia and center of\n    mass values. The simulation is run for one time step, and then the mass properties of the input message are changed\n    again. The simulation is run again for one time step, and then the output message mass properties are compared to\n    the values that were set at each simulation step.\n\n    **Test Parameters**\n\n    Only the ``accuracy`` variable is set as an input to the test function. ITs default value is 1e-8.\n\n    Args:\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    The parameters being checked correspond to the variables inside the ``vehicleConfigMsgPayload`` type message:\n\n    - ``massSc``: total mass of the spacecraft\n    - ``ISCPntB_B[9]``: total inertia of the spacecraft with respect to the origin of the B frame in B frame components\n    - ``CoM_B``: spacecraft's center of mass expressed in the B frame\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = simpleMassPropsTestFunction(show_plots, accuracy)\n    assert testResults < 1, testMessage",
  "def simpleMassPropsTestFunction(show_plots, accuracy):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(1.0)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    scMassPropsModule = simpleMassProps.SimpleMassProps()  # update with current values\n    scMassPropsModule.ModelTag = \"scMassPropsModule\"  # update python name of test module\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, scMassPropsModule)\n\n    # Create input message\n    scMassPropsData = messaging.SCMassPropsMsgPayload()  # Create a structure for the input message\n    scMassPropsData.massSC = 100\n    scMassPropsData.ISC_PntB_B = np.array([[40, 0, 0],\n                                  [0, 50, 0],\n                                  [0, 0, 60]])\n    scMassPropsData.c_B = np.array([0.0, 0.0, 0.0])\n    scMassPropsMsg = messaging.SCMassPropsMsg().write(scMassPropsData)\n    scMassPropsModule.scMassPropsInMsg.subscribeTo(scMassPropsMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    vehicleDataLog = scMassPropsModule.vehicleConfigOutMsg.recorder(testProcessRate)\n    unitTestSim.AddModelToTask(unitTaskName, vehicleDataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Run for one time step\n    unitTestSim.TotalSim.SingleStepProcesses()\n\n    # Change the mass, inertia and center of mass properties\n    scMassPropsData.massSC = 500\n    scMassPropsData.ISC_PntB_B = [[200, 0, 0],\n                                  [0, 300, 0],\n                                  [0, 0, 400]]\n    scMassPropsData.c_B = [1.0, -1.0, 0.0]\n    scMassPropsMsg = messaging.SCMassPropsMsg().write(scMassPropsData)\n    scMassPropsModule.scMassPropsInMsg.subscribeTo(scMassPropsMsg)\n\n    # Run for another time step\n    unitTestSim.TotalSim.SingleStepProcesses()\n\n    # set the filtered output truth states\n    trueMass = [[100], [500]]\n    trueInertia = [[40, 0, 0, 0, 50, 0, 0, 0, 60],\n                   [200, 0, 0, 0, 300, 0, 0, 0, 400]]\n    trueCoM = [[0.0, 0.0, 0.0],\n               [1.0, -1.0, 0.0]]\n\n    for i in range(2):\n        # check a vector values\n        if not unitTestSupport.isDoubleEqual(vehicleDataLog.massSC[i], trueMass[i], accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: simpleMassProps mass test \" + str(i+1) + \"\\n\")\n        if not unitTestSupport.isArrayEqual(vehicleDataLog.ISCPntB_B[i], trueInertia[i], 9, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: simpleMassProps inertia test \" + str(i+1) + \"\\n\")\n        if not unitTestSupport.isArrayEqual(vehicleDataLog.CoM_B[i], trueCoM[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: simpleMassProps center of mass test \" + str(i+1) + \"\\n\")\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + scMassPropsModule.ModelTag)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots):\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = checkStorage_limits(show_plots)\n    assert testResults < 1, testMessage",
  "def checkStorage_limits(show_plots):\n    \"\"\"\n    Tests:\n\n    1. Whether the simpleStorageUnit can add multiple nodes (core base class functionality);\n    2. That the simpleStorageUnit correctly evaluates how much stored data it should have given a pair of\n       1200 baud input messages.\n\n    :param show_plots: Not used; no plots to be shown.\n    \"\"\"\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.1)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    test_storage_unit = simpleStorageUnit.SimpleStorageUnit()\n    test_storage_unit.storageCapacity = 2400. # bit capacity.\n\n    dataMsg1 = messaging.DataNodeUsageMsgPayload()\n    dataMsg1.baudRate = 1200. # baud\n    dataMsg1.dataName = \"node_1_msg\"\n    dat1Msg = messaging.DataNodeUsageMsg().write(dataMsg1)\n\n    dataMsg2 = messaging.DataNodeUsageMsgPayload()\n    dataMsg2.baudRate = 1200. # baud\n    dataMsg2.dataName = \"node_2_msg\"\n    dat2Msg = messaging.DataNodeUsageMsg().write(dataMsg2)\n\n    # Test the addNodeToStorage method:\n    test_storage_unit.addDataNodeToModel(dat1Msg)\n    test_storage_unit.addDataNodeToModel(dat2Msg)\n\n    unitTestSim.AddModelToTask(unitTaskName, test_storage_unit)\n\n    dataLog = test_storage_unit.storageUnitDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(5.0))\n\n    unitTestSim.ExecuteSimulation()\n\n    storedDataLog = dataLog.storageLevel\n    capacityLog = dataLog.storageCapacity\n    netBaudLog = dataLog.currentNetBaud\n\n    #   Check 1 - is net baud rate equal to 2400.?\n    for ind in range(0,len(netBaudLog)):\n        currentBaud = netBaudLog[ind]\n        if currentBaud != 2400.:\n            testFailCount += 1\n            testMessages.append(\"FAILED: SimpleStorageUnit did not correctly log the net baud rate.\")\n\n    #print(netBaudLog)\n\n    if not unitTestSupport.isDoubleEqualRelative((2400.),storedDataLog[-1], 1e-8):\n        testFailCount+=1\n        testMessages.append(\"FAILED: SimpleStorageUnit did not track integrated data. Returned \"+str(storedDataLog[-1,1])+\", expected \"+str((2400.)))\n\n    #print(storedDataLog)\n\n    for ind in range(0,len(storedDataLog)):\n        if storedDataLog[ind] > capacityLog[ind]:\n            testFailCount +=1\n            testMessages.append(\"FAILED: SimpleStorageUnit's stored data exceeded its capacity.\")\n\n        if storedDataLog[ind] < 0.:\n            testFailCount +=1\n            testMessages.append(\"FAILED: SimpleStorageUnit's stored data was negative.\")\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Passed\")\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots):\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = check_storage_limits(show_plots)\n    assert testResults < 1, testMessage",
  "def check_storage_limits(show_plots):\n    \"\"\"\n    Tests:\n\n    1. Whether the partitionedStorageUnit can add multiple nodes (core base class functionality);\n    2. That the partitionedStorageUnit correctly evaluates how much stored data it should have given a pair of\n       1200 baud input messages.\n\n    :param show_plots: Not used; no plots to be shown.\n    :return:\n    \"\"\"\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.1)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    test_storage_unit = partitionedStorageUnit.PartitionedStorageUnit()\n    test_storage_unit.storageCapacity = 2400. # bit capacity.\n\n    dataMsg1 = messaging.DataNodeUsageMsgPayload()\n    dataMsg1.baudRate = 1200. # baud\n    dataMsg1.dataName = \"node_1_msg\"\n    dat1Msg = messaging.DataNodeUsageMsg().write(dataMsg1)\n\n    dataMsg2 = messaging.DataNodeUsageMsgPayload()\n    dataMsg2.baudRate = 1200. # baud\n    dataMsg2.dataName = \"node_2_msg\"\n    dat2Msg = messaging.DataNodeUsageMsg().write(dataMsg2)\n\n    # Test the addNodeToStorage method:\n    test_storage_unit.addDataNodeToModel(dat1Msg)\n    test_storage_unit.addDataNodeToModel(dat2Msg)\n\n    unitTestSim.AddModelToTask(unitTaskName, test_storage_unit)\n\n    dataLog = test_storage_unit.storageUnitDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(5.0))\n\n    unitTestSim.ExecuteSimulation()\n\n    storedDataLog = dataLog.storageLevel\n    capacityLog = dataLog.storageCapacity\n    netBaudLog = dataLog.currentNetBaud\n\n    #   Check 1 - is net baud rate equal to 2400.?\n    for ind in range(0,len(netBaudLog)):\n        currentBaud = netBaudLog[ind]\n        if currentBaud !=2400.:\n            testFailCount +=1\n            testMessages.append(\"FAILED: PartitionedStorageUnit did not correctly log the net baud rate.\")\n\n    #print(netBaudLog)\n\n    if not unitTestSupport.isDoubleEqualRelative((2400.),storedDataLog[-1], 1e-8):\n        testFailCount+=1\n        testMessages.append(\"FAILED: PartitionedStorageUnit did not track integrated data. Returned \"+str(storedDataLog[-1,1])+\", expected \"+str((2400.)))\n\n    #print(storedDataLog)\n\n    for ind in range(0,len(storedDataLog)):\n        if storedDataLog[ind] > capacityLog[ind]:\n            testFailCount +=1\n            testMessages.append(\"FAILED: PartitionedStorageUnit's stored data exceeded its capacity.\")\n\n        if storedDataLog[ind] < 0.:\n            testFailCount +=1\n            testMessages.append(\"FAILED: PartitionedStorageUnit's stored data was negative.\")\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Passed\")\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, deviceStatus, accessStatus):\n    \"\"\"\n    **Validation Test Description**\n\n    1. Whether the simpleTransmitter provides the right output message (baudRate) while on;\n    2. Whether the simpleTransmitter provides the right output message (baudRate) while off.\n    3. Whether the simpleTransmitter provides the right output message (baudRate) while out of access.\n\n    :param show_plots: Not used; no plots to be shown.\n\n    :return:\n    \"\"\"\n\n    default_results, default_message = run(deviceStatus, accessStatus)\n\n    testResults = sum([default_results])\n    testMessage = [default_message]\n\n    assert testResults < 1, testMessage",
  "def run(deviceStatus, accessStatus):\n\n    expectedValue = deviceStatus * accessStatus\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Create fake access messages\n    accMsg1 = messaging.AccessMsgPayload()\n    accMsg1.hasAccess = 0 # We'll never see this one, sadly\n    acc1Msg = messaging.AccessMsg().write(accMsg1)\n\n    accMsg2 = messaging.AccessMsgPayload()\n    accMsg2.hasAccess = accessStatus\n    acc2Msg = messaging.AccessMsg().write(accMsg2)\n\n    # Create the test module\n    testModule = spaceToGroundTransmitter.SpaceToGroundTransmitter()\n    testModule.ModelTag = \"transmitter\"\n    testModule.nodeBaudRate = 9600. # baud\n    testModule.packetSize = -9600 # bits\n    testModule.numBuffers = 1\n    testModule.dataStatus = deviceStatus\n    testModule.addAccessMsgToTransmitter(acc1Msg)\n    testModule.addAccessMsgToTransmitter(acc2Msg)\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    # Create an instrument\n    instrument = simpleInstrument.SimpleInstrument()\n    instrument.ModelTag = \"instrument1\"\n    instrument.nodeBaudRate = 9600. # baud\n    instrument.nodeDataName = \"Instrument 1\"  # baud\n    unitTestSim.AddModelToTask(unitTaskName, instrument)\n\n    # Create a partitionedStorageUnit and attach the instrument to it\n    dataMonitor = partitionedStorageUnit.PartitionedStorageUnit()\n    dataMonitor.ModelTag = \"dataMonitor\"\n    dataMonitor.storageCapacity = 8E9 # bits (1 GB)\n    dataMonitor.addDataNodeToModel(instrument.nodeDataOutMsg)\n    dataMonitor.addDataNodeToModel(testModule.nodeDataOutMsg)\n    unitTestSim.AddModelToTask(unitTaskName, dataMonitor)\n\n    testModule.addStorageUnitToTransmitter(dataMonitor.storageUnitDataOutMsg)\n\n    datLog = testModule.nodeDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, datLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(3.0))\n    unitTestSim.ExecuteSimulation()\n\n    generatedData = datLog.baudRate\n    print(generatedData)\n    accuracy = 1e-16\n\n    trueData = 9600. # Module should be on after enough data is accrued\n    testArray = [0, 0, 0, expectedValue*trueData, expectedValue*trueData, expectedValue*trueData, expectedValue*trueData] # Should go through three iterations of no data downlinked\n\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray(\n        testArray, generatedData, accuracy, \"dataOutput\",\n        testFailCount, testMessages)\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Passed\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_mappingInstrument():\n    r\"\"\"\n    This test checks that both the name of the data and the baudRate are correctly set in the mapping instrument module.\n\n    In this test, two accessMsgs are instantiated to test the module. In the first accessMsg, hasAccess = 1, meaning\n    that the point is accessible. This point is named '1.' In the second accessMsg, hasAccess = 0, meaning that the\n    point is not accessible. The point is named 'data2' to test longer dataNames. The mappingInstrument should output\n    a baudRate of 1 for point one, and a baudRate of 0 for point two. The dataNames in the output message are also\n    checked.\n    \"\"\"\n    [testResults, testMessage] = mappingInstrumentTestFunction()\n    assert testResults < 1, testMessage",
  "def mappingInstrumentTestFunction():\n    \"\"\"Test method\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(0.5)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    module = mappingInstrument.MappingInstrument()\n    module.ModelTag = \"mappingInstrumentTag\"\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    module.nodeBaudRate = 1.\n\n    # Configure blank module input messages\n    accessInMsgData1 = messaging.AccessMsgPayload()\n    accessInMsgData1.hasAccess = 1\n    accessInMsg1 = messaging.AccessMsg().write(accessInMsgData1)\n\n    accessInMsgData2 = messaging.AccessMsgPayload()\n    accessInMsgData2.hasAccess = 0\n    accessInMsg2 = messaging.AccessMsg().write(accessInMsgData2)\n\n    # subscribe input messages to module\n    module.addMappingPoint(accessInMsg1, '1')\n    module.addMappingPoint(accessInMsg2, 'data2')\n\n    # setup output message recorder objects\n    dataLogs = []\n    for idx in range(0, 2):\n        dataLogs.append(module.dataNodeOutMsgs[idx].recorder())\n        unitTestSim.AddModelToTask(unitTaskName, dataLogs[idx])\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))\n    unitTestSim.ExecuteSimulation()\n\n    # pull module data and make sure it is correct\n    dataAmt = []\n    dataNames = []\n    for idx in range(0, 2):\n        dataNames.append(dataLogs[idx].dataName)\n        dataAmt.append(dataLogs[idx].baudRate)\n\n    dataAmt = np.array(dataAmt)\n    dataNames = np.array(dataNames)\n\n    if not np.array_equal(dataAmt[0,:], np.array([1., 1., 1.])):\n        testFailCount += 1\n\n    if not np.array_equal(dataAmt[1,:], np.array([0., 0., 0.])):\n        testFailCount += 1\n\n    if not np.array_equal(dataNames[0,:], np.array(['1', '1', '1'])):\n        testFailCount += 1\n\n    if not np.array_equal(dataNames[1,:], np.array(['data2', 'data2', 'data2'])):\n        testFailCount += 1\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, \"\".join(testMessages)]",
  "def test_simpleInstrumentAll(show_plots, function):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = eval(function + '()')\n    assert testResults < 1, testMessage",
  "def checkDefault():\n    \"\"\"\n    **Validation Test Description**\n\n    1. Whether the simpleInstrument provides the right output message (baudRate) while on;\n    2. Whether the simpleInstrument provides the right output message (baudRate) while off.\n\n    :param show_plots: Not used; no plots to be shown.\n\n    :return:\n    \"\"\"\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    testModule = simpleInstrument.SimpleInstrument()\n    testModule.ModelTag = \"instrument1\"\n    testModule.nodeBaudRate = 9600. # baud\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    dataLog = testModule.nodeDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    generatedData = dataLog.baudRate\n\n    # compare the module results to the truth values\n    accuracy = 1e-16\n\n    trueData = 9600.  # Module should be on\n\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray(\n        [trueData]*3, generatedData, accuracy, \"dataOutput\",\n        testFailCount, testMessages)\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Passed\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def checkStatus():\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    testModule = simpleInstrument.SimpleInstrument()\n    testModule.ModelTag = \"instrument1\"\n    testModule.nodeBaudRate = 9600. # baud\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    # create the input messages\n    dataCmdMsg = messaging.DeviceCmdMsgPayload()  # Create a structure for the input message\n    dataCmdMsg.deviceCmd = 0\n    statMsg = messaging.DeviceCmdMsg().write(dataCmdMsg)\n    testModule.nodeStatusInMsg.subscribeTo(statMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = testModule.nodeDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    drawData = dataLog.baudRate\n\n    # compare the module results to the truth values\n    accuracy = 1e-16\n\n    trueData = 0.0  # Module should be off\n\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray(\n        [trueData]*3, drawData, accuracy, \"instrumentStatusTest\",\n        testFailCount, testMessages)\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Passed\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_simpleTransmitterAll(show_plots, function):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = eval(function + '()')\n    assert testResults < 1, testMessage",
  "def checkDefault():\n    \"\"\"\n    **Validation Test Description**\n\n    1. Whether the simpleTransmitter provides the right output message (baudRate) while on;\n    2. Whether the simpleTransmitter provides the right output message (baudRate) while off.\n\n    :param show_plots: Not used; no plots to be shown.\n\n    :return:\n    \"\"\"\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Create the test module\n    testModule = simpleTransmitter.SimpleTransmitter()\n    testModule.ModelTag = \"transmitter\"\n    testModule.nodeBaudRate = 9600.  # baud\n    testModule.packetSize = -9600  # bits\n    testModule.numBuffers = 1\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    # Create an instrument\n    instrument = simpleInstrument.SimpleInstrument()\n    instrument.ModelTag = \"instrument1\"\n    instrument.nodeBaudRate = 9600.  # baud\n    instrument.nodeDataName = \"Instrument 1\" # baud\n    unitTestSim.AddModelToTask(unitTaskName, instrument)\n\n    # Create a partitionedStorageUnit and attach the instrument to it\n    dataMonitor = partitionedStorageUnit.PartitionedStorageUnit()\n    dataMonitor.ModelTag = \"dataMonitor\"\n    dataMonitor.storageCapacity = 8E9  # bits (1 GB)\n    dataMonitor.addDataNodeToModel(instrument.nodeDataOutMsg)\n    dataMonitor.addDataNodeToModel(testModule.nodeDataOutMsg)\n    unitTestSim.AddModelToTask(unitTaskName, dataMonitor)\n\n    testModule.addStorageUnitToTransmitter(dataMonitor.storageUnitDataOutMsg)\n\n    dataLog = testModule.nodeDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(3.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    generatedData = dataLog.baudRate\n\n    print(generatedData)\n\n    # compare the module results to the truth values\n    accuracy = 1e-16\n\n    trueData = 9600.  # Module should be on after enough data is accrued\n    testArray = [0, 0, 0, trueData, trueData, trueData, trueData]   # Should go through three iterations of no data downlinked\n\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray(\n        testArray, generatedData, accuracy, \"dataOutput\",\n        testFailCount, testMessages)\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Passed\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def checkStatus():\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    testModule = simpleTransmitter.SimpleTransmitter()\n    testModule.ModelTag = \"transmitter\"\n    testModule.nodeBaudRate = 9600. # baud\n    testModule.packetSize = -9600 # bits\n    testModule.numBuffers = 1\n    testModule.dataStatus = 0\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    # Create an instrument\n    instrument = simpleInstrument.SimpleInstrument()\n    instrument.ModelTag = \"instrument1\"\n    instrument.nodeBaudRate = 1200. # baud\n    instrument.nodeDataName = \"Instrument 1\" # baud\n    unitTestSim.AddModelToTask(unitTaskName, instrument)\n\n    # Create a partitionedStorageUnit and attach the instrument to it\n    dataMonitor = partitionedStorageUnit.PartitionedStorageUnit()\n    dataMonitor.ModelTag = \"dataMonitor\"\n    dataMonitor.storageCapacity = 8E9 # bits (1 GB)\n    dataMonitor.addDataNodeToModel(instrument.nodeDataOutMsg)\n    dataMonitor.addDataNodeToModel(testModule.nodeDataOutMsg)\n    unitTestSim.AddModelToTask(unitTaskName, dataMonitor)\n\n    testModule.addStorageUnitToTransmitter(dataMonitor.storageUnitDataOutMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n\n    dataLog = testModule.nodeDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    drawData = dataLog.baudRate\n\n    # compare the module results to the truth values\n    accuracy = 1e-16\n\n    trueData = 0.0  # Module should be off\n\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray(\n        [trueData]*3, drawData, accuracy, \"transmitterStatusTest\",\n        testFailCount, testMessages)\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Passed\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, convertPosUnits, attType, checkThruster, checkRW):\n    \"\"\"\n    **Validation Test Description**\n\n    This section describes the specific unit tests conducted on this module.\n    The test reads in simulation from ``data.txt``, run the module, and compares the Basilisk\n    spacecraft state messages with known values.\n\n    Args:\n\n        convertPosUnits (double): If positive, then this conversion factor is set.  If negative, then the\n            default value of 1000. is checked.\n        attType (int): -1 (use default), 0 (MRP), 1 (quaternion), 2 (3-2-1 Euler Angles)\n        checkThruster (bool): flag to check for simulation data with thrusters\n        checkRW (bool): flag to check for simulation data with RW information\n\n    **Description of Variables Being Tested**\n\n    In this file, we are checking the values of the spacecraft state output message for both spacecraft:\n\n    - ``r_BN_N[3]``\n    - ``sigma_BN[3]``\n    - ``thrustForce``\n\n    which is pulled from the log data to see if they match with the expected truth values.\n\n    \"\"\"\n\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(show_plots, convertPosUnits, attType, checkThruster, checkRW, False)\n    assert testResults < 1, testMessage\n    global dataFileName\n    if os.path.exists(dataFileName):\n        os.remove(dataFileName)",
  "def run(show_plots, convertPosUnits, attType, checkThruster, checkRW, verbose):\n\n    if not verbose:\n        bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    dtSeconds = 0.1\n    simTimeSeconds = 2.0\n    testProcessRate = macros.sec2nano(dtSeconds)\n    simulationTime = macros.sec2nano(simTimeSeconds)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # create the simulation data file\n    rB1N = [6761.48, 1569.01, 905.867]\n    vB1N = [-1.95306, 6.3124, 3.64446]\n    betaB1N = [0.182574, 0.365148, 0.547723, 0.730297]\n    sigmaB1N = [0.1, 0.2, 0.3]\n    omega = [0., 0., 0.]\n    rB2N = [6761.48, 1569.02, 905.874]\n    vB2N = [-1.95308, 6.31239, 3.64446]\n    betaB2N = [-0.182574, 0.365148, 0.547723, 0.730297]\n    sigmaB2N = [-0.1, 0.1, 0.3]\n    global dataFileName\n    dataFileName = \"data\" + str(convertPosUnits) + str(attType) + str(checkThruster) + str(checkRW) + \".txt\"\n    dataFileName = os.path.join(path, dataFileName)\n    delimiter = \",\"\n    fDataFile = open(dataFileName, \"w+\")\n    for i in range(0, int(simTimeSeconds/dtSeconds)+2):\n        t = round(i*dtSeconds, 4)\n\n        # sc1\n        lineString = str(t) + delimiter + str(rB1N)[1:-1] + delimiter + str(vB1N)[1:-1] + delimiter\n        if attType == 1:\n            lineString += str(betaB1N)[1:-1] + delimiter\n        else:\n            lineString += str(sigmaB1N)[1:-1] + delimiter\n        lineString += str(omega)[1:-1] + delimiter\n        if checkThruster:\n            th1ACS = 1.\n            th1DV = 100.\n            numACS1 = 1\n            numDV1 = 1\n            lineString += str(th1ACS) + delimiter + str(th1DV) + delimiter\n        if checkRW:\n            Omega1sc1 = 100.*macros.RPM\n            u1sc1 = 0.1\n            Omega2sc1 = 500. * macros.RPM\n            u2sc1 = -0.1\n            lineString += str(Omega1sc1) + delimiter + str(u1sc1) + delimiter\n            lineString += str(Omega2sc1) + delimiter + str(u2sc1) + delimiter\n\n        # sc2\n        lineString += str(rB2N)[1:-1] + delimiter + str(vB2N)[1:-1] + delimiter\n        if attType == 1:\n            lineString += str(betaB2N)[1:-1] + delimiter\n        else:\n            lineString += str(sigmaB2N)[1:-1] + delimiter\n        lineString += str(omega)[1:-1]\n        if checkThruster:\n            th2ACS = 0.001\n            th2DV = 200.\n            numACS2 = 1\n            numDV2 = 2\n            lineString += delimiter + str(th2ACS) + delimiter + str(th2DV) + delimiter + str(th2DV)\n        if checkRW:\n            Omega1sc2 = 1000.*macros.RPM\n            u1sc2 = 0.3\n            lineString += delimiter + str(Omega1sc2) + delimiter + str(u1sc2)\n\n        lineString += '\\n'\n        fDataFile.write(lineString)\n    fDataFile.close()\n\n    # Construct algorithm and associated C++ container\n    testModule = dataFileToViz.DataFileToViz()\n    testModule.ModelTag = \"testModule\"\n\n    # set number of satellites\n    testModule.setNumOfSatellites(2)\n\n    # load the data path from the same folder where this python script is\n    testModule.dataFileName = dataFileName\n    testModule.delimiter = delimiter\n    if convertPosUnits > 0:\n        testModule.convertPosToMeters = convertPosUnits\n    else:\n        convertPosUnits = 1000.\n    if attType >= 0:\n        testModule.attitudeType = attType\n\n    scNames = [\"test1\", \"test2\"]\n\n    if checkThruster:\n        # sc1\n        thSetAdcs1 = dataFileToViz.ThrClusterMap()\n        thSetAdcs1.thrTag = \"adcs\"\n        thSetAdcs1.color = vizSupport.toRGBA255(\"red\")\n\n        thSetDV1 = dataFileToViz.ThrClusterMap()\n        thSetDV1.thrTag = \"dv\"\n        thSetDV1.color = vizSupport.toRGBA255(\"blue\")\n\n        thList1 = [thSetAdcs1, thSetDV1]\n        numTh1 = [1, 1]\n        testModule.appendThrClusterMap(dataFileToViz.VizThrConfig(thList1), dataFileToViz.IntVector(numTh1))\n\n        # set ACS thruster position and direction states\n        testModule.appendThrPos([0, 0, 3.])  # thr location in B frame, meters\n        testModule.appendThrDir([0, 0, -1])  # thr force direction\n        testModule.appendThrForceMax(th1ACS)\n\n        # set DV thruster position and direction states\n        testModule.appendThrPos([0., 0., -3.])\n        testModule.appendThrDir([0, 0, 1])\n        testModule.appendThrForceMax(th1DV)\n\n        # sc2\n        thSetAdcs2 = dataFileToViz.ThrClusterMap()\n        thSetAdcs2.thrTag = \"adcs\"\n\n        thSetDV2 = dataFileToViz.ThrClusterMap()\n        thSetDV2.thrTag = \"dv\"\n\n        thList2 = [thSetAdcs2, thSetDV2]\n        numTh2 = [1, 2]\n        testModule.appendThrClusterMap(dataFileToViz.VizThrConfig(thList2), dataFileToViz.IntVector(numTh2))\n\n        # set ACS thruster position and direction states\n        testModule.appendThrPos([0, 0, 3.])\n        testModule.appendThrDir([0, 0, -1])\n        testModule.appendThrForceMax(th2ACS)\n\n        # set DV thruster position and direction states\n        testModule.appendThrPos([0., 0., -3.])\n        testModule.appendThrDir([0, 0, 1])\n        testModule.appendThrForceMax(th2DV)\n        testModule.appendThrPos([0., 2., -3.])\n        testModule.appendThrDir([0, 0, 1])\n        testModule.appendThrForceMax(th2DV)\n\n        thrNumList = [numTh1, numTh2]\n\n    if checkRW:\n        # set number of RW for SC1\n        testModule.appendNumOfRWs(2)\n        # RW 1\n        testModule.appendRwPos([0, 0, 0])\n        testModule.appendRwDir([1, 0, 0])\n        testModule.appendOmegaMax(3000.*macros.RPM)\n        testModule.appendUMax(0.5)\n        # RW2\n        testModule.appendRwPos([0, 0, 0])\n        testModule.appendRwDir([0, 1, 0])\n        testModule.appendOmegaMax(3000.*macros.RPM)\n        testModule.appendUMax(0.5)\n\n        # set number of RW for SC2\n        testModule.appendNumOfRWs(1)\n        # RW 1\n        testModule.appendRwPos([0, 0, 0])\n        testModule.appendRwDir([0, 1, 0])\n        testModule.appendOmegaMax(3000.*macros.RPM)\n        testModule.appendUMax(0.5)\n\n    # Add module to the task\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    # clear prior gravitational body and SPICE setup definitions\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n\n    # setup Earth Gravity Body\n    earth = gravFactory.createEarth()\n    earth.isCentralBody = True  # ensure this is the central gravitational body\n\n    # create SC dummy objects to setup basic Vizard settings.  Only one has to have the Grav Bodies attached\n    # to show up in Vizard\n    scObject1 = spacecraft.Spacecraft()\n    scObject1.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n    scObject2 = spacecraft.Spacecraft()\n\n    viz = vizSupport.enableUnityVisualization(unitTestSim, unitTaskName, [scObject1, scObject2]\n                                              # , saveFile=__file__\n                                              )\n    if vizFound:\n        # over-ride the default to not read the SC states from scObjects, but set them directly\n        # to read from the dataFileToFiz output message\n        viz.scData.clear()\n        for c in range(len(scNames)):\n            scData = vizInterface.VizSpacecraftData()\n            scData.spacecraftName = scNames[c]\n            scData.scStateInMsg.subscribeTo(testModule.scStateOutMsgs[c])\n\n            if checkThruster:\n                thrList = []\n                thrInfo = []\n                for thrLogMsg in testModule.thrScOutMsgs[c]:  # loop over the THR cluster log message\n                    thrList.append(thrLogMsg.addSubscriber())\n                k = 0\n                for info in testModule.thrMsgDataSC[c]:\n                    for i in range(thrNumList[c][k]):\n                        thrInfo.append(info)\n                    k += 1\n                scData.thrInMsgs = messaging.THROutputMsgInMsgsVector(thrList)\n                scData.thrInfo = vizInterface.ThrClusterVector(thrInfo)\n\n            if checkRW:\n                rwList = []\n                for rwLogMsg in testModule.rwScOutMsgs[c]:\n                    rwList.append(rwLogMsg.addSubscriber())\n                scData.rwInMsgs = messaging.RWConfigLogMsgInMsgsVector(rwList)\n\n            viz.scData.push_back(scData)\n\n        if checkThruster:\n            viz.settings.defaultThrusterColor = vizSupport.toRGBA255(\"yellow\")\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = []\n    for scCounter in range(2):\n        dataLog.append(testModule.scStateOutMsgs[scCounter].recorder())\n        unitTestSim.AddModelToTask(unitTaskName, dataLog[-1])\n\n    if checkThruster:\n        dataThrLog = []\n        # SC1\n        for i in range(numACS1 + numDV1):\n            dataThrLog.append(testModule.thrScOutMsgs[0][i].recorder())\n            unitTestSim.AddModelToTask(unitTaskName, dataThrLog[-1])\n        # SC2\n        for i in range(numACS2 + numDV2):\n            dataThrLog.append(testModule.thrScOutMsgs[1][i].recorder())\n            unitTestSim.AddModelToTask(unitTaskName, dataThrLog[-1])\n\n    if checkRW:\n        dataSc1RW1Log = testModule.rwScOutMsgs[0][0].recorder()\n        dataSc1RW2Log = testModule.rwScOutMsgs[0][1].recorder()\n        dataSc2RW1Log = testModule.rwScOutMsgs[1][0].recorder()\n        unitTestSim.AddModelToTask(unitTaskName, dataSc1RW1Log)\n        unitTestSim.AddModelToTask(unitTaskName, dataSc1RW2Log)\n        unitTestSim.AddModelToTask(unitTaskName, dataSc2RW1Log)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.ConfigureStopTime(simulationTime) \n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    pos1 = dataLog[0].r_BN_N\n    pos2 = dataLog[1].r_BN_N\n    att1 = dataLog[0].sigma_BN\n    att2 = dataLog[1].sigma_BN\n\n    if checkThruster:\n        thrData = []\n        for item in dataThrLog:\n            thrData.append(item.thrustForce)\n    if checkRW:\n        rw1Sc1OmegaData = dataSc1RW1Log.Omega\n        rw1Sc1uData = dataSc1RW1Log.u_current\n        rw2Sc1OmegaData = dataSc1RW2Log.Omega\n        rw2Sc1uData = dataSc1RW2Log.u_current\n        rw1Sc2OmegaData = dataSc2RW1Log.Omega\n        rw1Sc2uData = dataSc2RW1Log.u_current\n\n    # set input data\n    pos1In = np.array(rB1N)\n    pos2In = np.array(rB2N)\n    if attType == 1:\n        att1In = rbk.EP2MRP(np.array(betaB1N))\n        att2In = rbk.EP2MRP(np.array(betaB2N))\n    else:\n        att1In = np.array(sigmaB1N)\n        att2In = np.array(sigmaB2N)\n\n        if attType == 2:\n            att1In = rbk.euler3212MRP(att1In)\n            att2In = rbk.euler3212MRP(att2In)\n\n    if not unitTestSupport.isVectorEqual(pos1[0], pos1In*convertPosUnits, 0.1):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed pos1 check.\")\n    if not unitTestSupport.isVectorEqual(pos2[0], pos2In*convertPosUnits, 0.1):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed pos2 check.\")\n    if not unitTestSupport.isVectorEqual(att1[0], att1In, 0.1):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed att1 check.\")\n    if not unitTestSupport.isVectorEqual(att2[0], att2In, 0.1):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed att2 check.\")\n    if checkThruster:\n        if not unitTestSupport.isDoubleEqualRelative(thrData[0][0], th1ACS, 0.001):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed th1ACS check.\")\n        if not unitTestSupport.isDoubleEqualRelative(thrData[1][0], th1DV, 0.001):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed th1ACS check.\")\n        if not unitTestSupport.isDoubleEqualRelative(thrData[2][0], th2ACS, 0.001):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed th2ACS check.\")\n        if not unitTestSupport.isDoubleEqualRelative(thrData[3][0], th2DV, 0.001):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed th2DV (1st) check.\")\n        if not unitTestSupport.isDoubleEqualRelative(thrData[4][0], th2DV, 0.001):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed th2DV (2nd) check.\")\n    if checkRW:\n        if not unitTestSupport.isDoubleEqualRelative(rw1Sc1OmegaData[0], Omega1sc1, 0.001):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed Omega1sc1 check.\")\n        if not unitTestSupport.isDoubleEqualRelative(rw1Sc1uData[0], u1sc1, 0.001):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed u1sc1 check.\")\n        if not unitTestSupport.isDoubleEqualRelative(rw2Sc1OmegaData[0], Omega2sc1, 0.001):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed Omega1sc1 check.\")\n        if not unitTestSupport.isDoubleEqualRelative(rw2Sc1uData[0], u2sc1, 0.001):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed u1sc1 check.\")\n        if not unitTestSupport.isDoubleEqualRelative(rw1Sc2OmegaData[0], Omega1sc2, 0.001):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed Omega1sc2 check.\")\n        if not unitTestSupport.isDoubleEqualRelative(rw1Sc2uData[0], u1sc2, 0.001):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed u1sc2 check.\")\n\n\n    # print out success or failure message\n    if testFailCount == 0:\n        print(\"PASSED: \" + testModule.ModelTag)\n    else:\n        print(\"Failed: \" + testModule.ModelTag)\n        print(testMessages)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_unitAlbedo(show_plots, planetCase, modelType, useEclipse):\n    \"\"\"\n    **Validation Test Description**\n\n    This section describes the specific unit tests conducted on this module.\n    The test contains 4 tests and is located at ``test_albedo.py``.\n    The success criteria is to match the outputs with the generated truth.\n\n    Args:\n\n        planetCase (string): Defines which planet to use.  Options include \"earth\" and \"mars\".\n        modelType (string):  Defines which albedo model to use. Options include \"ALBEDO_AVG_EXPLICIT\", \"ALBEDO_AVG_IMPLICIT\" and \"ALBEDO_DATA\".\n        useEclipse (bool):  Defines if the eclipse is considered for this parameterized unit test.\n\n    **Description of Variables Being Tested**\n\n    In this file, we are checking the values of the variable:\n\n    ``albedoAtInstrument``\n\n    which are pulled from the log data to see if they match with the expected truth values.\n\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitAlbedo(show_plots, planetCase, modelType, useEclipse)\n    assert testResults < 1, testMessage",
  "def unitAlbedo(show_plots, planetCase, modelType, useEclipse):\n    __tracebackhide__ = True\n    testFailCount = 0\n    testMessages = []\n    testTaskName = \"unitTestTask\"\n    testProcessName = \"unitTestProcess\"\n    testTaskRate = macros.sec2nano(1.0)\n\n    # Create a simulation container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    testProc = unitTestSim.CreateNewProcess(testProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(testTaskName, testTaskRate))\n\n    # create planet input message\n    planetInMsg = messaging.SpicePlanetStateMsg()\n\n    # Albedo A1\n    albModule = albedo.Albedo()\n    albModule.ModelTag = \"Albedo_0\"\n    if modelType == 'ALBEDO_DATA':\n        dataPath = os.path.abspath(bskPath + \"/supportData/AlbedoData/\")\n        if planetCase == 'earth':\n            fileName = \"Earth_ALB_2018_CERES_All_10x10.csv\"\n        else:\n            fileName = \"Mars_ALB_TES_10x10.csv\"\n        albModule.addPlanetandAlbedoDataModel(planetInMsg, dataPath, fileName)\n    else:\n        ALB_avg = 0.5\n        numLat = 200\n        numLon = 400\n        if modelType == 'ALBEDO_AVG_EXPLICIT':\n            albModule.addPlanetandAlbedoAverageModel(planetInMsg, ALB_avg, numLat, numLon)\n        else:\n            albModule.addPlanetandAlbedoAverageModel(planetInMsg)\n\n    if useEclipse:\n        albModule.eclipseCase = True\n    # Create dummy sun message\n    sunPositionMsg = messaging.SpicePlanetStateMsgPayload()\n\n    # Create dummy planet message\n    planetPositionMsg = messaging.SpicePlanetStateMsgPayload()\n    planetPositionMsg.PositionVector = [0., 0., 0.]\n\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    if planetCase == 'earth':\n        planet = gravFactory.createEarth()\n        sunPositionMsg.PositionVector = [-om.AU * 1000., 0.0, 0.0]\n    elif planetCase == 'mars':\n        planet = gravFactory.createMars()\n        sunPositionMsg.PositionVector = [-1.5 * om.AU * 1000., 0.0, 0.0]\n    planetPositionMsg.PlanetName = planetCase\n    planetPositionMsg.J20002Pfix = np.identity(3)\n\n    req = planet.radEquator\n    sunMessage = \"sun_message\"\n    # Create dummy spacecraft message\n    scStateMsg = messaging.SCStatesMsgPayload()\n    rSC = req + 6000 * 1000  # meters\n    alpha = 71. * macros.D2R\n    scStateMsg.r_BN_N = np.dot(rSC, [np.cos(alpha), np.sin(alpha), 0.0])\n    scStateMsg.sigma_BN = [0., 0., 0.]\n\n    # Albedo instrument configuration\n    config1 = albedo.instConfig_t()\n    config1.fov = 80. * macros.D2R\n    config1.nHat_B = np.array([-np.cos(alpha), -np.sin(alpha), 0.0])\n    config1.r_IB_B = np.array([0., 0., 0.])\n    albModule.addInstrumentConfig(config1)\n\n    sunInMsg = messaging.SpicePlanetStateMsg().write(sunPositionMsg)\n    albModule.sunPositionInMsg.subscribeTo(sunInMsg)\n\n    planetInMsg.write(planetPositionMsg)\n\n    scInMsg = messaging.SCStatesMsg().write(scStateMsg)\n    albModule.spacecraftStateInMsg.subscribeTo(scInMsg)\n\n    unitTestSim.AddModelToTask(testTaskName, albModule)\n\n    # setup logging\n    dataLog = albModule.albOutMsgs[0].recorder()\n    unitTestSim.AddModelToTask(testTaskName, dataLog)\n\n    # Initialize and run simulation one step at a time\n    unitTestSim.InitializeSimulation()\n    # Execute the simulation for one time step\n    unitTestSim.TotalSim.SingleStepProcesses()\n    # This pulls the actual data log from the simulation run.\n    dataAlb0 = dataLog.albedoAtInstrument\n    errTol = 1E-12\n    if planetCase == 'earth':\n        if modelType == 'ALBEDO_DATA':\n            if useEclipse:\n                truthAlb = 0.0022055492477917\n            else:\n                truthAlb = 0.0022055492477917\n        else:\n            if modelType == 'ALBEDO_AVG_EXPLICIT':\n                if useEclipse:\n                    truthAlb = 0.0041742091531996\n                else:\n                    truthAlb = 0.004174209177079\n            else:\n                if useEclipse:\n                    truthAlb = 0.002421222716229847\n                else:\n                    truthAlb = 0.002421222716229847\n    else:\n        if modelType == 'ALBEDO_DATA':\n            if useEclipse:\n                truthAlb = 0.0014001432717662\n            else:\n                truthAlb = 0.0014001432717662\n        else:\n            if modelType == 'ALBEDO_AVG_EXPLICIT':\n                if useEclipse:\n                    truthAlb = 0.0035681407388827\n                else:\n                    truthAlb = 0.0035681407390035\n            else:\n                if useEclipse:\n                    truthAlb = 0.0011418311186365906\n                else:\n                    truthAlb = 0.0011418311186365906\n\n    if not unitTestSupport.isDoubleEqual(dataAlb0[0], truthAlb, errTol):\n        testFailCount += 1\n    #   print out success or failure message\n    if testFailCount == 0:\n            print(\"PASSED: \" + albModule.ModelTag)\n    else:\n            print(\"Failed: \" + albModule.ModelTag)\n    print(\"This test uses a relative accuracy value of \" + str(errTol * 100) + \" percent\")\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, setRAN, setDEC, setLST, setRate):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = planetEphemerisTest(show_plots, setRAN, setDEC, setLST, setRate)\n    assert testResults < 1, testMessage",
  "def planetEphemerisTest(show_plots, setRAN, setDEC, setLST, setRate):\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_SILENT)\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = planetEphemeris.PlanetEphemeris()\n    module.ModelTag = 'planetEphemeris'\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    planetNames = [\"earth\", \"venus\"]\n    module.setPlanetNames(planetEphemeris.StringVector(planetNames))\n\n    # set gravitational constant of the sun\n\n    mu = orbitalMotion.MU_SUN*1000.*1000.*1000  # m^3/s^2\n    # setup planet ephemeris states\n    oeEarth = planetEphemeris.ClassicElementsMsgPayload()\n    oeEarth.a = planetEphemeris.SMA_EARTH*1000  # meters\n    oeEarth.e = 0.001\n    oeEarth.i = 10.0*macros.D2R\n    oeEarth.Omega = 30.0*macros.D2R\n    oeEarth.omega = 20.0*macros.D2R\n    oeEarth.f = 90.0*macros.D2R\n\n    oeVenus = planetEphemeris.ClassicElementsMsgPayload()\n    oeVenus.a = planetEphemeris.SMA_VENUS*1000  # meters\n    oeVenus.e = 0.001\n    oeVenus.i = 5.0*macros.D2R\n    oeVenus.Omega = 110.0*macros.D2R\n    oeVenus.omega = 220.0*macros.D2R\n    oeVenus.f = 180.0*macros.D2R\n\n    module.planetElements = planetEphemeris.classicElementVector([oeEarth, oeVenus])\n\n    evalAttitude = 1\n    if setRAN:\n        # setup planet local right ascension angle at epoch\n        RANlist = [0.*macros.D2R, 272.76*macros.D2R]\n        module.rightAscension = planetEphemeris.DoubleVector(RANlist)\n    else:\n        evalAttitude = 0\n\n    if setDEC:\n        # setup planet local declination angle at epoch\n        DEClist = [90.*macros.D2R, 67.16*macros.D2R]\n        module.declination = planetEphemeris.DoubleVector(DEClist)\n    else:\n        evalAttitude = 0\n\n    if setLST:\n        # setup planet local sidereal time at epoch\n        lstList = [10.*macros.D2R, 30.*macros.D2R]\n        module.lst0 = planetEphemeris.DoubleVector(lstList)\n    else:\n        evalAttitude = 0\n\n    if setRate:\n        # setup planet rotation rate about polar axis\n        omegaList = [planetEphemeris.OMEGA_EARTH, planetEphemeris.OMEGA_VENUS]\n        module.rotRate = planetEphemeris.DoubleVector(omegaList)\n    else:\n        evalAttitude = 0\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = []\n    for c in range(0, len(planetNames)):\n        dataLog.append(module.planetOutMsgs[c].recorder())\n        unitTestSim.AddModelToTask(unitTaskName, dataLog[-1])\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    accuracy = 1e-3\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    c = 0\n    for c in range(0, len(planetNames)):\n        planet = planetNames[c]\n        J2000Current = dataLog[c].J2000Current\n        PositionVector = dataLog[c].PositionVector\n        VelocityVector = dataLog[c].VelocityVector\n        J20002Pfix = dataLog[c].J20002Pfix\n        J20002Pfix_dot = dataLog[c].J20002Pfix_dot\n        computeOrient = dataLog[c].computeOrient\n\n        # check that the proper planet name string is set\n        FinalPlanetMessage = module.planetOutMsgs[c].read()\n\n        if planet != FinalPlanetMessage.PlanetName:\n            testFailCount += 1\n            testMessages.append(\"FAILED: planetEphemeris() didn't set the desired plane name \" + planet)\n\n        # check that the time information is correct\n        timeTrue = [[0.0], [0.5], [1.0]]\n        testFailCount, testMessages = unitTestSupport.compareDoubleArray(\n            timeTrue, J2000Current, accuracy, \"J2000Current\", testFailCount, testMessages)\n\n        # check that the position and velocity vectors are correct\n        if planet == \"earth\":\n            oe = oeEarth\n        else:\n            oe = oeVenus\n        f0 = oe.f\n        E0 = orbitalMotion.f2E(f0, oe.e)\n        M0 = orbitalMotion.E2M(E0, oe.e)\n        rTrue = []\n        vTrue = []\n        for time in timeTrue:\n            Mt = M0 + np.sqrt(mu/oe.a/oe.a/oe.a)*time[0]\n            Et = orbitalMotion.M2E(Mt, oe.e)\n            oe.f = orbitalMotion.E2f(Et, oe.e)\n\n            rv, vv = orbitalMotion.elem2rv(mu, oe)\n            rTrue.append(rv)\n            vTrue.append(vv)\n        testFailCount, testMessages = unitTestSupport.compareArray(rTrue, PositionVector,\n                                                                   accuracy, \"Position Vector\",\n                                                                   testFailCount, testMessages)\n        testFailCount, testMessages = unitTestSupport.compareArray(vTrue, VelocityVector,\n                                                                   accuracy, \"Velocity Vector\",\n                                                                   testFailCount, testMessages)\n\n        # check if the planet DCM and DCM rate is correct\n        dcmTrue = []\n        dcmRateTrue = []\n        if evalAttitude:\n            RAN = RANlist[c]\n            DEC = DEClist[c]\n            lst0 = lstList[c]\n            omega_NP_P = np.array([0.0, 0.0, -omegaList[c]])\n            tilde = rbk.v3Tilde(omega_NP_P)\n            for time in timeTrue:\n                lst = lst0 + omegaList[c]*time[0]\n                DCM = rbk.euler3232C([RAN, np.pi/2.0 - DEC, lst])\n                dcmTrue.append(DCM)\n                dDCMdt = np.matmul(tilde, DCM)\n                dcmRateTrue.append(dDCMdt)\n        else:\n            for time in timeTrue:\n                dcmTrue.append(np.identity(3))\n                dcmRateTrue.append([0.0]*9)\n\n        testFailCount, testMessages = unitTestSupport.compareArrayND(dcmTrue, J20002Pfix,\n                                                                   accuracy, \"DCM\", 9,\n                                                                   testFailCount, testMessages)\n        testFailCount, testMessages = unitTestSupport.compareArrayND(dcmRateTrue, J20002Pfix_dot,\n                                                                   1e-10, \"DCM Rate\", 9,\n                                                                   testFailCount, testMessages)\n\n        # check if the orientation evaluation flag is set correctly\n        flagTrue = [evalAttitude] * 3\n        testFailCount, testMessages = unitTestSupport.compareDoubleArray(\n            flagTrue, computeOrient, accuracy, \"computeOrient\", testFailCount, testMessages)\n\n        c = c+1\n\n    # print out success message if no error were found\n    snippentName = \"passFail\" + str(setRAN) + str(setDEC) + str(setLST) + str(setRate)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_groundMapping():\n    r\"\"\"\n    This test checks two points to determine if they are accessible for mapping or not. One point should be mapped,\n    and one point should not be mapped.\n\n    The inertial, planet-fixed planet-centered, and spacecraft body frames are all aligned.\n    The spacecraft is in the -y direction of the inertial frame. The first point is along the line from the spacecraft\n    to the origin. The second point is along the z-axis. The first point should be accessible because a.) the spacecraft\n    is within the point's visibility cone and the point is within the spacecraft's visibility cone. The second point is\n    not accessible because the spacecraft is not within the point's visibility cone and the point is not within the\n    spacecraft's visibility cone.\n    \"\"\"\n    [testResults, testMessage] = groundMappingTestFunction()\n    assert testResults < 1, testMessage",
  "def groundMappingTestFunction():\n    \"\"\"Test method\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(0.5)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Configure blank module input messages\n    planetInMsgData = messaging.SpicePlanetStateMsgPayload()\n    planetInMsgData.J20002Pfix = [[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]\n    planetInMsgData.PositionVector = [0., 0., 0.]\n    planetInMsg = messaging.SpicePlanetStateMsg().write(planetInMsgData)\n\n    scStateInMsgData = messaging.SCStatesMsgPayload()\n    scStateInMsgData.r_BN_N = [0., -1., 0.]\n    scStateInMsgData.sigma_BN = [0., 0., 0.]\n    scStateInMsg = messaging.SCStatesMsg().write(scStateInMsgData)\n\n    # Create the initial imaging target\n    groundMap = groundMapping.GroundMapping()\n    groundMap.ModelTag = \"groundMapping\"\n    groundMap.addPointToModel([0., -0.1, 0.])\n    groundMap.addPointToModel([0., 0., math.tan(np.radians(22.5))+0.1])\n    groundMap.minimumElevation = np.radians(45.)\n    groundMap.maximumRange = 1e9\n    groundMap.cameraPos_B = [0, 0, 0]\n    groundMap.nHat_B = [0, 1, 0]\n    groundMap.halfFieldOfView = np.radians(22.5)\n    groundMap.scStateInMsg.subscribeTo(scStateInMsg)\n    groundMap.planetInMsg.subscribeTo(planetInMsg)\n    unitTestSim.AddModelToTask(unitTaskName, groundMap)\n\n    # Setup the logging for the mapping locations\n    mapLog = []\n    for idx in range(0, 2):\n        mapLog.append(groundMap.accessOutMsgs[idx].recorder())\n        unitTestSim.AddModelToTask(unitTaskName, mapLog[idx])\n\n    # subscribe input messages to module\n    groundMap.planetInMsg.subscribeTo(planetInMsg)\n    groundMap.scStateInMsg.subscribeTo(scStateInMsg)\n\n    # setup output message recorder objects\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))\n    unitTestSim.ExecuteSimulation()\n\n    # pull module data and make sure it is correct\n    map_access = np.zeros(2, dtype=bool)\n    for idx in range(0, 2):\n        access = mapLog[idx].hasAccess\n        if sum(access):\n            map_access[idx] = 1\n\n    # If the first target is not mapped, failure\n    if not map_access[0]:\n        testFailCount += 1\n\n    # If the second target is mapped, failure\n    if map_access[1]:\n        testFailCount += 1\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + groundMap.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, \"\".join(testMessages)]",
  "def test_dentonFluxModel(show_plots, param1_Kp, param2_LT, param3_z, param4_r_EN, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    The Denton Flux Module is tested for several different Kp indices, local times, and spacecraft/Sun/Earth positions\n\n    **Test Parameters**\n\n    Args:\n        show_plots (bool): specify if plots should be shown\n        param1_Kp (str): Kp Index\n        param2_LT (float): Local Time (use 2 decimals)\n        param3_z (float): z-offset to test spacecraft and Sun position with offset to equatorial plane\n        param4_r_EN (float np.array): r_EN_N position vector of Earth w.r.t. N frame, in N frame components\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    The electron and ion energies are compared to make sure the flux data is computed for the same energy. The main\n    part of the unitTest is to compare the electron and ion flux.\n    \"\"\"\n    dentonFluxModelTestFunction(show_plots, param1_Kp, param2_LT, param3_z, param4_r_EN,\n                                                             accuracy)",
  "def dentonFluxModelTestFunction(show_plots, param1_Kp, param2_LT, param3_z, param4_r_EN, accuracy):\n    \"\"\"Test method\"\"\"\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    # Create sim module and test thread\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(0.5)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    module = dentonFluxModel.DentonFluxModel()\n    module.ModelTag = \"dentonFluxModule\"\n    module.kpIndex = param1_Kp\n    module.numOutputEnergies = 6\n    module.dataPath = bskPath + '/supportData/DentonGEO/'\n\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Set up position vectors (param3_z is used to offset S/C and sun from equatorial plane)\n    LT = param2_LT\n    angle = LT * 360./24. * np.pi/180 - np.pi\n    orbitRadius = 42000 * 1e3  # GEO orbit\n\n    r_BE_N = np.array([orbitRadius * math.cos(angle), orbitRadius * math.sin(angle), param3_z])\n    r_SE_N = np.array([149000000000.0, 0., -2.73*param3_z])\n    r_EN_N = param4_r_EN\n    r_BN_N = r_BE_N + r_EN_N\n    r_SN_N = r_SE_N + r_EN_N\n\n    # Configure input messages\n    scStateInMsgData = messaging.SCStatesMsgPayload()\n    scStateInMsgData.r_BN_N = r_BN_N\n    scStateInMsg = messaging.SCStatesMsg().write(scStateInMsgData)\n\n    sunStateInMsgData = messaging.SpicePlanetStateMsgPayload()\n    sunStateInMsgData.PositionVector = r_SN_N\n    sunStateInMsg = messaging.SpicePlanetStateMsg().write(sunStateInMsgData)\n\n    earthStateInMsgData = messaging.SpicePlanetStateMsgPayload()\n    earthStateInMsgData.PositionVector = r_EN_N\n    earthStateInMsg = messaging.SpicePlanetStateMsg().write(earthStateInMsgData)\n\n    # subscribe input messages to module\n    module.scStateInMsg.subscribeTo(scStateInMsg)\n    module.earthStateInMsg.subscribeTo(earthStateInMsg)\n    module.sunStateInMsg.subscribeTo(sunStateInMsg)\n\n    # setup output message recorder objects\n    fluxOutMsgRec = module.fluxOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, fluxOutMsgRec)\n\n    # run simulation\n    unitTestSim.InitializeSimulation()\n    unitTestSim.TotalSim.SingleStepProcesses()\n\n    # pull module data\n    energyData = fluxOutMsgRec.energies[0]\n    electronFluxData = fluxOutMsgRec.meanElectronFlux[0]\n    ionFluxData = fluxOutMsgRec.meanIonFlux[0]\n\n    # convert Kp index to Kp index counter (between 0 and 27)\n    kpMain = param1_Kp[0]  # main Kp index, between 0 and 9\n    kpSub = param1_Kp[1]  # sub Kp index, either '-', 'o', or '+'\n    if kpSub == '-':\n        kpIndexCounter = 3*int(kpMain) - 1\n    elif kpSub == 'o':\n        kpIndexCounter = 3*int(kpMain)\n    elif kpSub == '+':\n        kpIndexCounter = 3*int(kpMain) + 1\n\n    # load true data from corresponding support file (note that Python indexing starts at 0 and Fortran indexing\n    # starts at 1, relevant for Kp index counter)\n    filename = 'FluxData_' + str(kpIndexCounter+1) + '_' + str(\"%.2f\" % param2_LT) + '.txt'\n    filepath = path + '/Support/' + filename\n    trueEnergyData = np.array([0.0] * messaging.MAX_PLASMA_FLUX_SIZE)\n    trueElectronFluxData = np.array([0.0] * messaging.MAX_PLASMA_FLUX_SIZE)\n    trueIonFluxData = np.array([0.0] * messaging.MAX_PLASMA_FLUX_SIZE)\n    with open(filepath, 'r') as file:\n        rows = np.loadtxt(file, delimiter=\",\", unpack=False)\n        # true flux data provided by Denton is in Units of [cm^-2 s^-1 sr^-2 eV^-1], but DentonFluxModel converts it to\n        # [m^-2 s^-1 sr^-2 eV^-1]. Need to multiply by 1e4\n        trueEnergyData[0:module.numOutputEnergies] = rows[0]\n        trueElectronFluxData[0:module.numOutputEnergies] = 10.**(rows[1]) * 1e4\n        trueIonFluxData[0:module.numOutputEnergies] = 10.**(rows[2]) * 1e4\n\n    # make sure module output data is correct\n    paramsString = ' for Kp-Index={}, LT={}, accuracy={}'.format(\n        str(param1_Kp),\n        str(param2_LT),\n        str(accuracy))\n\n    np.testing.assert_allclose(energyData,\n                               trueEnergyData,\n                               rtol=0,\n                               atol=accuracy,\n                               err_msg=('Variable: energyData,' + paramsString),\n                               verbose=True)\n\n    np.testing.assert_allclose(electronFluxData,\n                               trueElectronFluxData,\n                               rtol=0,\n                               atol=accuracy,\n                               err_msg=('Variable: electronFluxData,' + paramsString),\n                               verbose=True)\n\n    np.testing.assert_allclose(ionFluxData,\n                               trueIonFluxData,\n                               rtol=0,\n                               atol=accuracy,\n                               err_msg=('Variable: ionFluxData,' + paramsString),\n                               verbose=True)\n\n    plt.figure(1)\n    fig = plt.gcf()\n    ax = fig.gca()\n    plt.semilogy(energyData[0:module.numOutputEnergies], electronFluxData[0:module.numOutputEnergies])\n    plt.xlabel('Energy [eV]')\n    plt.ylabel('Electron Flux [e$^{-}$ cm$^{-2}$ s$^{-1}$ str$^{-1}$ eV$^{-1}$]')\n\n    if show_plots:\n        plt.show()",
  "def test_ephemConvert(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitephemeris_converter(show_plots)\n    assert testResults < 1, testMessage",
  "def unitephemeris_converter(show_plots):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    # Create a sim module as an empty container\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    sim = SimulationBaseClass.SimBaseClass()\n\n    simulationTime = macros.sec2nano(30.)\n    numDataPoints = 600\n    samplingTime = simulationTime // (numDataPoints-1)\n    DynUnitTestProc = sim.CreateNewProcess(unitProcessName)\n    # create the dynamics task and specify the integration update time\n    DynUnitTestProc.addTask(sim.CreateNewTask(unitTaskName, samplingTime))\n\n    # List of planets tested\n    planets = [\"earth\", \"mars barycenter\", \"sun\"]\n\n    # Initialize the spice module\n    spiceObject = spiceInterface.SpiceInterface()\n    spiceObject.ModelTag = \"SpiceInterfaceData\"\n    spiceObject.SPICEDataPath = bskPath + '/supportData/EphemerisData/'\n    spiceObject.addPlanetNames(spiceInterface.StringVector(planets))\n    spiceObject.UTCCalInit = \"2015 February 10, 00:00:00.0 TDB\"\n    sim.AddModelToTask(unitTaskName, spiceObject)\n\n    # Initialize the ephemeris module\n    ephemObject = ephemerisConverter.EphemerisConverter()\n    ephemObject.ModelTag = 'EphemData'\n    ephemObject.addSpiceInputMsg(spiceObject.planetStateOutMsgs[0])  # earth\n    ephemObject.addSpiceInputMsg(spiceObject.planetStateOutMsgs[1])  # mars\n    ephemObject.addSpiceInputMsg(spiceObject.planetStateOutMsgs[2])  # sun\n    sim.AddModelToTask(unitTaskName, ephemObject)\n\n    # Configure simulation\n    sim.ConfigureStopTime(int(simulationTime))\n\n    dataSpiceLog = []\n    dataEphemLog = []\n    for i in range(0, len(planets)):\n        dataSpiceLog.append(spiceObject.planetStateOutMsgs[i].recorder())\n        dataEphemLog.append(ephemObject.ephemOutMsgs[i].recorder())\n        sim.AddModelToTask(unitTaskName, dataSpiceLog[-1])\n        sim.AddModelToTask(unitTaskName, dataEphemLog[-1])\n\n    # Execute simulation\n    sim.InitializeSimulation()\n    sim.ExecuteSimulation()\n\n    # Initialize sigma_BN and omega_BN_B spice message truth data\n    sigma_BN = np.zeros((len(planets), numDataPoints, 3))\n    omega_BN_B = np.zeros((len(planets), numDataPoints, 3))\n\n    # Loop through planets and data points to compute sigma_BN and omega_BN_B\n    for i in range(0, len(planets)):\n        spicePlanetDCM_PN = dataSpiceLog[i].J20002Pfix\n        spicePlanetDCM_PN_dot = dataSpiceLog[i].J20002Pfix_dot\n        for j in range(0, numDataPoints):\n            dcm_PN = spicePlanetDCM_PN[j,:]\n            dcm_PN_dot = spicePlanetDCM_PN_dot[j,:]\n            sigma_BN[i,j,0:3] = RigidBodyKinematics.C2MRP(dcm_PN)\n            omega_BN_B_tilde = -np.matmul(dcm_PN_dot, dcm_PN.T)\n            omega_BN_B[i,j,0] = omega_BN_B_tilde[2,1]\n            omega_BN_B[i,j,1] = omega_BN_B_tilde[0,2]\n            omega_BN_B[i,j,2] = omega_BN_B_tilde[1,0]\n\n    # Get the position, velocities, attitude, attitude rate, and time for the message before and after the copy\n    accuracy = 1e-12\n    for i in range(0, len(planets)):\n        ephemPlanetPosData = dataEphemLog[i].r_BdyZero_N\n        spicePlanetPosData = dataSpiceLog[i].PositionVector\n        ephemPlanetVelData = dataEphemLog[i].v_BdyZero_N\n        spicePlanetVelData = dataSpiceLog[i].VelocityVector\n        ephemPlanetAttData = dataEphemLog[i].sigma_BN\n        ephemePlanetAngVelData = dataEphemLog[i].omega_BN_B\n        testFailCount, testMessages = unitTestSupport.compareArrayRelative(spicePlanetPosData[:,0:3], ephemPlanetPosData, accuracy, \"Position\", testFailCount, testMessages)\n        testFailCount, testMessages = unitTestSupport.compareArrayRelative(spicePlanetVelData[:,0:3], ephemPlanetVelData, accuracy, \"Velocity\", testFailCount, testMessages)\n        testFailCount, testMessages = unitTestSupport.compareArrayRelative(sigma_BN[i,:,:], ephemPlanetAttData, accuracy, \"Attitude\", testFailCount, testMessages)\n        testFailCount, testMessages = unitTestSupport.compareArray(omega_BN_B[i,:], ephemePlanetAngVelData, accuracy, \"Angular Velocity\", testFailCount, testMessages)\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\" \\n PASSED \")\n    else:\n        print(testMessages)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, decimalYear, Height, Lat, Lon, BxTrue, ByTrue, BzTrue,\n                useDefault, useMsg, useMinReach, useMaxReach, usePlanetEphemeris, accuracy):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(show_plots, decimalYear, Height, Lat, Lon, BxTrue, ByTrue, BzTrue,\n                                     useDefault, useMsg, useMinReach, useMaxReach, usePlanetEphemeris, accuracy)\n    assert testResults < 1, testMessage",
  "def run(show_plots, decimalYear, Height, Lat, Lon, BxTrue, ByTrue, BzTrue, useDefault, useMsg, useMinReach,\n        useMaxReach, usePlanetEphemeris, accuracy):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    testModule = magneticFieldWMM.MagneticFieldWMM()\n    testModule.ModelTag = \"WMM\"\n    testModule.dataPath = bskPath + '/supportData/MagneticField/'\n\n    if not useDefault:\n        testModule.epochDateFractionalYear = decimalYear\n\n    if useMsg:\n        epochMsgData = messaging.EpochMsgPayload()\n        dt = unitTestSupport.decimalYearToDateTime(decimalYear)\n        epochMsgData.year = dt.year\n        epochMsgData.month = dt.month\n        epochMsgData.day = dt.day\n        epochMsgData.hours = dt.hour\n        epochMsgData.minutes = dt.minute\n        epochMsgData.seconds = dt.second\n        epMsg = messaging.EpochMsg().write(epochMsgData)\n        testModule.epochInMsg.subscribeTo(epMsg)\n\n        if not useDefault:\n            testModule.epochDateFractionalYear = decimalYear + 1.0\n\n    minReach = -1.0\n    if useMinReach:\n        minReach = (orbitalMotion.REQ_EARTH+200.)*1000.0     # meters\n        testModule.envMinReach = minReach\n    maxReach = -1.0\n    if useMaxReach:\n        maxReach = (orbitalMotion.REQ_EARTH-200.)*1000.0     # meters\n        testModule.envMaxReach = maxReach\n    planetPosition = np.array([0.0, 0.0, 0.0])\n    refPlanetDCM = np.array(((1, 0, 0), (0, 1, 0), (0, 0, 1)))\n    if usePlanetEphemeris:\n        planetStateMsg = messaging.SpicePlanetStateMsgPayload()\n        planetPosition = [1000.0, 2000.0, -1000.0]\n        planetStateMsg.PositionVector = planetPosition\n        refPlanetDCM = np.array(((-1, 0, 0), (0, -1, 0), (0, 0, 1)))\n        planetStateMsg.J20002Pfix = refPlanetDCM.tolist()\n        plMsg = messaging.SpicePlanetStateMsg().write(planetStateMsg)\n        testModule.planetPosInMsg.subscribeTo(plMsg)\n\n    # add spacecraft to environment model\n    sc0StateMsg = messaging.SCStatesMsg()\n    sc1StateMsg = messaging.SCStatesMsg()\n    testModule.addSpacecraftToModel(sc0StateMsg)\n    testModule.addSpacecraftToModel(sc1StateMsg)\n\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    # define the spacecraft locations\n    r0 = (orbitalMotion.REQ_EARTH + Height) * 1000.0  # meters\n    phi = Lat * macros.D2R\n    long = Lon * macros.D2R\n    r0P = np.array([np.cos(phi)*np.cos(long),np.cos(phi)*np.sin(long),np.sin(phi)])*r0\n    r0N = np.dot(refPlanetDCM.transpose(),r0P)\n\n    # create the input messages\n    sc0StateMsgData = messaging.SCStatesMsgPayload()  # Create a structure for the input message\n    sc0StateMsgData.r_BN_N = np.array(r0N) + np.array(planetPosition)\n    sc0StateMsg.write(sc0StateMsgData)\n\n    sc1StateMsgData = messaging.SCStatesMsgPayload()  # Create a structure for the input message\n    sc1StateMsgData.r_BN_N = np.array(r0N) + np.array(planetPosition)\n    sc1StateMsg.write(sc1StateMsgData)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog0 = testModule.envOutMsgs[0].recorder()\n    dataLog1 = testModule.envOutMsgs[1].recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog0)\n    unitTestSim.AddModelToTask(unitTaskName, dataLog1)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.TotalSim.SingleStepProcesses()\n\n    # This pulls the actual data log from the simulation run and converts to nano-Tesla\n    mag0Data = dataLog0.magField_N*1e9\n    mag1Data = dataLog1.magField_N*1e9\n\n    def wmmInertial(pos_N, Bx, By, Bz, phi, long, refPlanetDCM, minReach, maxReach):\n        radius = np.linalg.norm(pos_N)\n        B_M = np.array([Bx, By, Bz])\n        M2 = rbk.euler2(phi + np.pi/2.0)\n        M3 = rbk.euler3(-long)\n        PM = np.dot(M3,M2)\n        NM = np.dot(refPlanetDCM.transpose(), PM)\n        magField_N = [np.dot(NM, B_M).tolist()]\n\n        if radius < minReach:\n            magField_N = [[0.0, 0.0, 0.0]]\n        if radius > maxReach > 0:\n            magField_N = [[0.0, 0.0, 0.0]]\n        return magField_N\n\n    # compare the module results to the truth values\n    unitTestSupport.writeTeXSnippet(\"unitTestToleranceValue\", str(accuracy), path)\n\n    # check the exponential atmosphere results\n    #\n    # check spacecraft 0 neutral density results\n    if len(mag0Data) > 0:\n        trueMagField = wmmInertial(r0N, BxTrue, ByTrue, BzTrue, phi, long, refPlanetDCM, minReach, maxReach)\n        testFailCount, testMessages = unitTestSupport.compareArray(\n            trueMagField, mag0Data, accuracy, \"SC0 mag vector\",\n            testFailCount, testMessages)\n\n    if len(mag1Data) > 0:\n        testFailCount, testMessages = unitTestSupport.compareArrayRelative(\n            trueMagField, mag1Data, accuracy, \"SC1 mag vector\",\n            testFailCount, testMessages)\n\n    #   print out success or failure message\n    snippentName = \"unitTestPassFail\" + str(useDefault) + str(useMinReach) + str(useMaxReach) + str(usePlanetEphemeris)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + testModule.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + testModule.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def wmmInertial(pos_N, Bx, By, Bz, phi, long, refPlanetDCM, minReach, maxReach):\n        radius = np.linalg.norm(pos_N)\n        B_M = np.array([Bx, By, Bz])\n        M2 = rbk.euler2(phi + np.pi/2.0)\n        M3 = rbk.euler3(-long)\n        PM = np.dot(M3,M2)\n        NM = np.dot(refPlanetDCM.transpose(), PM)\n        magField_N = [np.dot(NM, B_M).tolist()]\n\n        if radius < minReach:\n            magField_N = [[0.0, 0.0, 0.0]]\n        if radius > maxReach > 0:\n            magField_N = [[0.0, 0.0, 0.0]]\n        return magField_N",
  "def test_scenarioMsisAtmosphereOrbit(show_plots, orbitType, setEpoch):\n    \"\"\"This function is called by the py.test environment.\"\"\"\n    # each test method requires a single assert method to be called\n    showVal = False\n\n    [testResults, testMessage] = run(showVal, orbitType, setEpoch)\n\n    assert testResults < 1, testMessage",
  "def run(show_plots, orbitCase, setEpoch):\n    \"\"\"Call this routine directly to run the script.\"\"\"\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n\n    #\n    #  From here on there scenario python code is found.  Above this line the code is to setup a\n    #  unitTest environment.  The above code is not critical if learning how to code BSK.\n    #\n\n    # Create simulation variable names\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n\n    #  Create a sim module as an empty container\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    #  create the simulation process\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n\n    # create the dynamics task and specify the integration update time\n    simulationTimeStep = macros.sec2nano(10.)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    #   Initialize new atmosphere and drag model, add them to task\n    newAtmo = msisAtmosphere.MsisAtmosphere()\n    atmoTaskName = \"atmosphere\"\n    newAtmo.ModelTag = \"MsisAtmo\"\n\n    if setEpoch == \"Msg\":\n        epochMsg = unitTestSupport.timeStringToGregorianUTCMsg('2019 Jan 01 00:00:00.00 (UTC)')\n        newAtmo.epochInMsg.subscribeTo(epochMsg)\n\n        # setting epoch day of year info deliberately to a false value.  The epoch msg info should be used\n        newAtmo.epochDoy = 10\n\n    elif setEpoch == \"Direct\":\n        newAtmo.epochDoy = 1  # setting epoch day of year info directly\n\n    dynProcess.addTask(scSim.CreateNewTask(atmoTaskName, simulationTimeStep))\n    scSim.AddModelToTask(atmoTaskName, newAtmo)\n\n    # initialize spacecraft object and set properties\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n    # add spacecraft object to the simulation process\n    scSim.AddModelToTask(simTaskName, scObject)\n\n    # clear prior gravitational body and SPICE setup definitions\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    newAtmo.addSpacecraftToModel(scObject.scStateOutMsg)\n\n    planet = gravFactory.createEarth()\n    planet.isCentralBody = True          # ensure this is the central gravitational body\n    mu = planet.mu\n\n    # attach gravity model to spacecraft\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    #   setup orbit and simulation time\n    oe = orbitalMotion.ClassicElements()\n    r_eq = planet.radEquator\n    if orbitCase == \"LPO\":\n        orbAltMin = 100.0*1000.0\n        orbAltMax = orbAltMin\n    elif orbitCase == \"LTO\":\n        orbAltMin = 100.*1000.0\n        orbAltMax = 100.0 * 1000.0\n\n    rMin = r_eq + orbAltMin\n    rMax = r_eq + orbAltMax\n    oe.a = (rMin+rMax)/2.0\n    oe.e = 1.0 - rMin/oe.a\n    oe.i = 0.0*macros.D2R\n\n    oe.Omega = 0.0*macros.D2R\n    oe.omega = 0.0*macros.D2R\n    oe.f     = 0.0*macros.D2R\n    rN, vN = orbitalMotion.elem2rv(mu, oe)\n    oe = orbitalMotion.rv2elem(mu, rN, vN)      # this stores consistent initial orbit elements\n                                                # with circular or equatorial orbit, some angles are\n                                                # arbitrary\n\n    # set the simulation time\n    n = np.sqrt(mu/oe.a/oe.a/oe.a)\n    P = 2.*np.pi/n\n\n    simulationTime = macros.sec2nano(0.002*P)\n\n    #\n    #   Setup data logging before the simulation is initialized\n    #\n    sw_msg_names = [\n        \"ap_24_0\", \"ap_3_0\", \"ap_3_-3\", \"ap_3_-6\", \"ap_3_-9\",\n        \"ap_3_-12\", \"ap_3_-15\", \"ap_3_-18\", \"ap_3_-21\", \"ap_3_-24\",\n        \"ap_3_-27\", \"ap_3_-30\", \"ap_3_-33\", \"ap_3_-36\", \"ap_3_-39\",\n        \"ap_3_-42\", \"ap_3_-45\", \"ap_3_-48\", \"ap_3_-51\", \"ap_3_-54\",\n        \"ap_3_-57\", \"f107_1944_0\", \"f107_24_-24\"\n    ]\n\n    swMsgList = []\n    for c in range(len(sw_msg_names)):\n        swMsgData = messaging.SwDataMsgPayload()\n        swMsgData.dataValue = 0\n        swMsgList.append(messaging.SwDataMsg().write(swMsgData))\n        newAtmo.swDataInMsgs[c].subscribeTo(swMsgList[-1])\n\n    dataLog = scObject.scStateOutMsg.recorder()\n    denLog = newAtmo.envOutMsgs[0].recorder()\n    scSim.AddModelToTask(simTaskName, dataLog)\n    scSim.AddModelToTask(simTaskName, denLog)\n\n    #\n    #   initialize Spacecraft States with the initialization variables\n    #\n    scObject.hub.r_CN_NInit = rN  # m - r_CN_N\n    scObject.hub.v_CN_NInit = vN  # m - v_CN_N\n\n    #\n    #   initialize Simulation\n    #\n    scSim.InitializeSimulation()\n\n    #\n    #   configure a simulation stop time and execute the simulation run\n    #\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    #\n    #   retrieve the logged data\n    #\n    posData = dataLog.r_BN_N\n    velData = dataLog.v_BN_N\n    densData = denLog.neutralDensity\n    tempData = denLog.localTemp\n\n    np.set_printoptions(precision=16)\n\n    #   Compare to expected values\n\n    refAtmoData = np.loadtxt(path + '/truthOutputs.txt')\n\n    accuracy = 1e-8\n\n    unitTestSupport.writeTeXSnippet(\"unitTestToleranceValue\", str(accuracy), path)\n\n    #   Test atmospheric density calculation; note that refAtmoData is in g/cm^3,\n    #   and must be adjusted by a factor of 1e-3 to match kg/m^3\n    print(densData[-1])\n    print(refAtmoData[5]*1000)\n    if np.testing.assert_allclose(densData[-1], refAtmoData[5]*1000., atol=accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED:  NRLMSISE-00 failed density unit test with a value difference of \"+str(densData[0]-refAtmoData[5]*1000))\n\n    print(tempData[-1])\n    print(refAtmoData[-1])\n    if np.testing.assert_allclose(tempData[-1], refAtmoData[-1], atol=accuracy):\n        testFailCount += 1\n        testMessages.append(\n        \"FAILED:  NRLMSISE-00 failed temperature unit test with a value difference of \"+str(tempData[-1]-refAtmoData[-1]))\n\n    snippentName = \"unitTestPassFail\" + str(orbitCase) + str(setEpoch)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + newAtmo.ModelTag)\n        passedText = '\\\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + newAtmo.ModelTag)\n        passedText = '\\\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n        print(testMessages)\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_unitExponentialAtmosphere():\n    \"\"\"This function is called by the py.test environment.\"\"\"\n    # each test method requires a single assert method to be called\n\n    newAtmo = exponentialAtmosphere.ExponentialAtmosphere()\n    newAtmo.ModelTag = \"ExpAtmo\"\n\n    testResults = []\n    testMessage = []\n\n    addScRes, addScMsg = AddSpacecraftToModel(newAtmo)\n    testMessage.append(addScMsg)\n    testResults.append(addScRes)\n\n    exponentialRes, exponentialMsg = TestExponentialAtmosphere()\n    testMessage.append(exponentialMsg)\n    testResults.append(exponentialRes)\n\n    #   print out success message if no error were found\n    snippetName = \"passFail\"\n    testSum = sum(testResults)\n    if testSum == 0:\n        colorText = 'ForestGreen'\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippetName, passedText, path)\n\n    if testSum == 0:\n        print(\"Passed\")\n\n    assert testSum < 1, testMessage",
  "def AddSpacecraftToModel(atmoModel):\n    testFailCount = 0\n    testMessages = []\n\n    # create the dynamics task and specify the integration update time\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    scObject2 = spacecraft.Spacecraft()\n    scObject2.ModelTag = \"spacecraftBody\"\n    # add spacecraft object to the simulation process\n    atmoModel.addSpacecraftToModel(scObject.scStateOutMsg)\n    atmoModel.addSpacecraftToModel(scObject2.scStateOutMsg)\n\n    if len(atmoModel.scStateInMsgs) != 2:\n        testFailCount += 1\n        testMessages.append(\n            \"FAILED: ExponentialAtmosphere does not have enough input message names.\")\n\n    if len(atmoModel.envOutMsgs) != 2:\n        testFailCount += 1\n        testMessages.append(\n            \"FAILED: ExponentialAtmosphere does not have enough output message names.\")\n    return testFailCount, testMessages",
  "def TestExponentialAtmosphere():\n    testFailCount = 0\n    testMessages = []\n\n    def expAtmoComp(alt, baseDens, scaleHeight):\n        density = baseDens * math.exp(-alt/scaleHeight)\n        return density\n\n\n    # Create simulation variable names\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n\n    #  Create a sim module as an empty container\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    #  create the simulation process\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n\n    # create the dynamics task and specify the integration update time\n    simulationTimeStep = macros.sec2nano(10.)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    #   Initialize new atmosphere and drag model, add them to task\n    newAtmo = exponentialAtmosphere.ExponentialAtmosphere()\n    newAtmo.ModelTag = \"ExpAtmo\"\n\n    #\n    #   setup the simulation tasks/objects\n    #\n\n    # initialize spacecraft object and set properties\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"spacecraftBody\"\n\n    # clear prior gravitational body and SPICE setup definitions\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    newAtmo.addSpacecraftToModel(scObject.scStateOutMsg)\n\n    planet = gravFactory.createEarth()\n\n    planet.isCentralBody = True          # ensure this is the central gravitational body\n    mu = planet.mu\n    # attach gravity model to spacecraft\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    #\n    #   setup orbit and simulation time\n    oe = orbitalMotion.ClassicElements()\n\n    r_eq = 6371*1000.0\n    refBaseDens = 1.217\n    refScaleHeight = 8500.0\n\n    #   Set base density, equitorial radius, scale height in Atmosphere\n    newAtmo.baseDensity = refBaseDens\n    newAtmo.scaleHeight = refScaleHeight\n    newAtmo.planetRadius = r_eq\n\n\n    oe.a = r_eq + 300.*1000\n    oe.e = 0.0\n    oe.i = 0.0*macros.D2R\n\n    oe.Omega = 0.0*macros.D2R\n    oe.omega = 0.0*macros.D2R\n    oe.f     = 0.0*macros.D2R\n    rN, vN = orbitalMotion.elem2rv(mu, oe)\n    oe = orbitalMotion.rv2elem(mu, rN, vN)      # this stores consistent initial orbit elements\n    # with circular or equatorial orbit, some angles are\n    # arbitrary\n\n    #\n    #   initialize Spacecraft States with the initialization variables\n    #\n    scObject.hub.r_CN_NInit = rN  # m - r_CN_N\n    scObject.hub.v_CN_NInit = vN  # m - v_CN_N\n\n\n    # set the simulation time\n    n = np.sqrt(mu/oe.a/oe.a/oe.a)\n    P = 2.*np.pi/n\n\n    simulationTime = macros.sec2nano(0.5*P)\n\n    #\n    #   Setup data logging before the simulation is initialized\n    #\n    numDataPoints = 10\n    samplingTime = unitTestSupport.samplingTime(simulationTime, simulationTimeStep, numDataPoints)\n    dataLog = scObject.scStateOutMsg.recorder(samplingTime)\n    denLog = newAtmo.envOutMsgs[0].recorder(samplingTime)\n\n    # add BSK objects to the simulation process\n    scSim.AddModelToTask(simTaskName, scObject)\n    scSim.AddModelToTask(simTaskName, newAtmo)\n    scSim.AddModelToTask(simTaskName, dataLog)\n    scSim.AddModelToTask(simTaskName, denLog)\n\n    #\n    #   initialize Simulation\n    #\n    scSim.InitializeSimulation()\n\n    #\n    #   configure a simulation stop time and execute the simulation run\n    #\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    #\n    #   retrieve the logged data\n    #\n    posData = dataLog.r_BN_N\n    densData = denLog.neutralDensity\n    np.set_printoptions(precision=16)\n\n    #   Compare to expected values\n    accuracy = 1e-5\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    if len(densData) > 0:\n        for ind in range(0,len(densData)):\n            dist = np.linalg.norm(posData[ind])\n            alt = dist - newAtmo.planetRadius\n\n            trueDensity = expAtmoComp(alt, refBaseDens, refScaleHeight)\n            # check a vector values\n            if not unitTestSupport.isDoubleEqualRelative(densData[ind], trueDensity, accuracy):\n                testFailCount += 1\n                testMessages.append(\n                    \"FAILED:  ExpAtmo failed density unit test at t=\" + str(densData[ind, 0] * macros.NANO2SEC) + \"sec with a value difference of \"+str(densData[ind,1]-trueDensity))\n    else:\n        testFailCount += 1\n        testMessages.append(\"FAILED:  ExpAtmo failed to pull any logged data\")\n\n    return testFailCount, testMessages",
  "def expAtmoComp(alt, baseDens, scaleHeight):\n        density = baseDens * math.exp(-alt/scaleHeight)\n        return density",
  "def test_module(show_plots, useDefault, useMinReach, useMaxReach, usePlanetEphemeris):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(show_plots, useDefault, useMinReach, useMaxReach, usePlanetEphemeris)\n    assert testResults < 1, testMessage",
  "def run(show_plots, useDefault, useMinReach, useMaxReach, usePlanetEphemeris):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    testModule = exponentialAtmosphere.ExponentialAtmosphere()\n    testModule.ModelTag = \"exponential\"\n\n    if useDefault:\n        refBaseDens = 0\n        refScaleHeight = 1.0\n        refPlanetRadius = 0.0\n    else:\n        simSetPlanetEnvironment.exponentialAtmosphere(testModule, \"earth\")\n        refPlanetRadius = testModule.planetRadius\n        refBaseDens = testModule.baseDensity\n        refScaleHeight = testModule.scaleHeight\n\n    minReach = -1.0\n    if useMinReach:\n        minReach = 200*1000.0     # meters\n        testModule.envMinReach = minReach\n        testModule.planetRadius =  6378136.6 #meters\n    maxReach = -1.0\n    if useMaxReach:\n        maxReach = 200*1000.0     # meters\n        testModule.envMaxReach = maxReach\n        testModule.planetRadius =  6378136.6\n    planetPosition = [0.0, 0.0, 0.0]\n    if usePlanetEphemeris:\n        planetStateMsg = messaging.SpicePlanetStateMsgPayload()\n        planetPosition = [1000.0, 2000.0, -1000.0]\n        planetStateMsg.PositionVector = planetPosition\n        plMsg = messaging.SpicePlanetStateMsg().write(planetStateMsg)\n        testModule.planetPosInMsg.subscribeTo(plMsg)\n\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    # define the spacecraft locations\n    r0 = 6571 * 1000.0  # meters\n    r1 = 6600 * 1000.0  # meters\n    #\n    #   setup orbit and simulation time\n    oe = orbitalMotion.ClassicElements()\n    mu = 0.3986004415E+15  # meters^3/s^2\n    oe.a = r0\n    oe.e = 0.0\n    oe.i = 45.0 * macros.D2R\n    oe.Omega = 30.0 * macros.D2R\n    oe.omega = 120.0 * macros.D2R\n    oe.f = 0.0 * macros.D2R\n    r0N, v0N = orbitalMotion.elem2rv(mu, oe)\n    oe.a = r1\n    r1N, v1N = orbitalMotion.elem2rv(mu, oe)\n\n    # create the input messages\n    sc0StateMsg = messaging.SCStatesMsgPayload()  # Create a structure for the input message\n    sc0StateMsg.r_BN_N = np.array(r0N) + np.array(planetPosition)\n    sc0InMsg = messaging.SCStatesMsg().write(sc0StateMsg)\n\n    sc1StateMsg = messaging.SCStatesMsgPayload()  # Create a structure for the input message\n    sc1StateMsg.r_BN_N = np.array(r1N) + np.array(planetPosition)\n    sc1InMsg = messaging.SCStatesMsg().write(sc1StateMsg)\n\n    # add spacecraft to environment model\n    testModule.addSpacecraftToModel(sc0InMsg)\n    testModule.addSpacecraftToModel(sc1InMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog0 = testModule.envOutMsgs[0].recorder()\n    dataLog1 = testModule.envOutMsgs[1].recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog0)\n    unitTestSim.AddModelToTask(unitTaskName, dataLog1)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    dens0Data = dataLog0.neutralDensity\n    dens1Data = dataLog1.neutralDensity\n\n    def expAtmoComp(alt, baseDens, scaleHeight, minReach, maxReach):\n        density = baseDens * math.exp(-alt/scaleHeight)\n        if alt < minReach:\n            density = 0.0\n        if alt > maxReach and maxReach > 0:\n            density = 0.0\n        return density\n\n    # compare the module results to the truth values\n    accuracy = 1e-5\n    unitTestSupport.writeTeXSnippet(\"unitTestToleranceValue\", str(accuracy), path)\n\n    # check the exponential atmosphere results\n    #\n    # check spacecraft 0 neutral density results\n    alt = r0 - refPlanetRadius\n    trueDensity = expAtmoComp(alt, refBaseDens, refScaleHeight, minReach, maxReach)\n    if trueDensity != 0:\n        testFailCount, testMessages = unitTestSupport.compareDoubleArrayRelative(\n            [trueDensity]*3, dens0Data, accuracy, \"density sc0\",\n            testFailCount, testMessages)\n    else:\n        testFailCount, testMessages = unitTestSupport.compareDoubleArray(\n            [trueDensity] * 3, dens0Data, accuracy, \"density sc0\",\n            testFailCount, testMessages)\n\n    # check spacecraft 1 neutral density results\n    alt = r1 - refPlanetRadius\n    trueDensity = expAtmoComp(alt, refBaseDens, refScaleHeight, minReach, maxReach)\n    if trueDensity != 0:\n        testFailCount, testMessages = unitTestSupport.compareDoubleArrayRelative(\n            [trueDensity]*3, dens1Data, accuracy, \"density sc1\",\n            testFailCount, testMessages)\n    else:\n        testFailCount, testMessages = unitTestSupport.compareDoubleArray(\n            [trueDensity] * 3, dens1Data, accuracy, \"density sc1\",\n            testFailCount, testMessages)\n\n    #   print out success or failure message\n    snippentName = \"unitTestPassFail\" + str(useDefault) + str(useMinReach) + str(useMaxReach) + str(usePlanetEphemeris)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + testModule.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + testModule.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def expAtmoComp(alt, baseDens, scaleHeight, minReach, maxReach):\n        density = baseDens * math.exp(-alt/scaleHeight)\n        if alt < minReach:\n            density = 0.0\n        if alt > maxReach and maxReach > 0:\n            density = 0.0\n        return density",
  "def test_range(show_plots):\n    \"\"\"\n    Tests whether groundLocation:\n\n    1. Computes range correctly by evaluating slantRange;\n    2. Tests whether elevation is correctly evaluated;\n    3. Tests whether range limits impact access.\n    4. Tests whether multiple spacecraft are supported in parallel\n\n    :return:\n    \"\"\"\n\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n    scSim = SimulationBaseClass.SimBaseClass()\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n    simulationTime = macros.sec2nano(10.)\n    simulationTimeStep = macros.sec2nano(1.)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    #   Initialize new atmosphere and drag model, add them to task\n    groundTarget = groundLocation.GroundLocation()\n    groundTarget.ModelTag = \"groundTarget\"\n    groundTarget.planetRadius = orbitalMotion.REQ_EARTH * 1000.\n    groundTarget.maximumRange = 100e3 # meters\n    groundTarget.minimumElevation = np.radians(80.)\n    groundTarget.specifyLocation(np.radians(0.), np.radians(0.), 0.)\n    scSim.AddModelToTask(simTaskName, groundTarget)\n\n    #   Write out mock planet rotation, spacecraft position messages\n    sc1_message = messaging.SCStatesMsgPayload()\n    sc1_message.r_BN_N = [orbitalMotion.REQ_EARTH*1e3 + 100e3, 0, 0]  # SC1 is in range\n    sc1Msg = messaging.SCStatesMsg().write(sc1_message)\n\n    sc2_message = messaging.SCStatesMsgPayload()\n    #   SC2 is placed inside/outside the visibility cone for the ground station\n    sc2_message.r_BN_N = [orbitalMotion.REQ_EARTH*1e3 + 101e3,0, 0]\n    sc2Msg = messaging.SCStatesMsg().write(sc2_message)\n\n    sc3_message = messaging.SCStatesMsgPayload()\n    #   SC3 is inside the altitude limit,  but outside the visibility cone\n    sc3_message.r_BN_N = rbk.euler3(np.radians(11.)).dot(np.array([100e3, 0, 0])) + np.array(\n        [orbitalMotion.REQ_EARTH * 1e3, 0, 0])\n    sc3Msg = messaging.SCStatesMsg().write(sc3_message)\n\n    groundTarget.addSpacecraftToModel(sc1Msg)\n    groundTarget.addSpacecraftToModel(sc2Msg)\n    groundTarget.addSpacecraftToModel(sc3Msg)\n\n    # Log the access indicator\n    numDataPoints = 2\n    samplingTime = unitTestSupport.samplingTime(simulationTime, simulationTimeStep, numDataPoints)\n    dataLog0 = groundTarget.accessOutMsgs[0].recorder(samplingTime)\n    dataLog1 = groundTarget.accessOutMsgs[1].recorder(samplingTime)\n    dataLog2 = groundTarget.accessOutMsgs[2].recorder(samplingTime)\n    scSim.AddModelToTask(simTaskName, dataLog0)\n    scSim.AddModelToTask(simTaskName, dataLog1)\n    scSim.AddModelToTask(simTaskName, dataLog2)\n\n    # Run the sim\n    scSim.InitializeSimulation()\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    # Get the logged data\n    sc1_access = dataLog0.hasAccess\n    sc1_slant = dataLog0.slantRange\n    sc1_elevation = dataLog0.elevation\n\n    sc2_access = dataLog1.hasAccess\n    sc2_slant = dataLog1.slantRange\n    sc2_elevation = dataLog1.elevation\n\n    sc3_access = dataLog2.hasAccess\n    sc3_slant = dataLog2.slantRange\n    sc3_elevation = dataLog2.elevation\n\n    #   Compare to expected values\n    accuracy = 1e-8\n    ref_ranges = [100e3, 101e3, 100e3]\n    ref_elevation = [np.radians(90.), np.radians(90.), np.radians(79.)]\n    ref_access = [1, 0, 0]\n\n    test_ranges = [sc1_slant[1], sc2_slant[1], sc3_slant[1]]\n    test_elevation = [sc1_elevation[1],sc2_elevation[1],sc3_elevation[1]]\n    test_access = [sc1_access[1],sc2_access[1],sc3_access[1]]\n\n    range_worked = test_ranges == pytest.approx(ref_ranges, accuracy)\n    elevation_worked = test_elevation == pytest.approx(ref_elevation, accuracy)\n    access_worked = test_access == pytest.approx(ref_access, abs=1e-16)\n\n    assert (range_worked and elevation_worked and access_worked)",
  "def test_rotation(show_plots):\n    \"\"\"\n    Tests whether groundLocation:\n\n    1. Computes the current location based on the initial position and the rotation rate of the planet\n       it is attached to.\n\n    :return:\n    \"\"\"\n    simTime = 1.\n\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n    scSim = SimulationBaseClass.SimBaseClass()\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n    simulationTime = macros.sec2nano(simTime)\n    simulationTimeStep = macros.sec2nano(1.)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    #   Initialize new atmosphere and drag model, add them to task\n    groundTarget = groundLocation.GroundLocation()\n    groundTarget.ModelTag = \"groundTarget\"\n    groundTarget.planetRadius = orbitalMotion.REQ_EARTH * 1000.\n    groundTarget.maximumRange = 200e3 # meters\n    groundTarget.minimumElevation = np.radians(10.)\n    groundTarget.specifyLocation(np.radians(0.), np.radians(10.), 0.)\n    scSim.AddModelToTask(simTaskName, groundTarget)\n\n    #   Write out mock planet rotation, spacecraft position messages\n    sc1_message = messaging.SCStatesMsgPayload()\n    sc1_message.r_BN_N = np.array([orbitalMotion.REQ_EARTH*1e3 + 90e3, 0, 0])  # SC1 is in range\n    scMsg = messaging.SCStatesMsg().write(sc1_message)\n    groundTarget.addSpacecraftToModel(scMsg)\n\n    planet_message = messaging.SpicePlanetStateMsgPayload()\n    planet_message.J20002Pfix = rbk.euler3(np.radians(-10.)).tolist()\n    planetMsg = messaging.SpicePlanetStateMsg().write(planet_message)\n    groundTarget.planetInMsg.subscribeTo(planetMsg)\n\n    # Log the access indicator\n    numDataPoints = 2\n    samplingTime = unitTestSupport.samplingTime(simulationTime, simulationTimeStep, numDataPoints)\n    dataLog = groundTarget.accessOutMsgs[0].recorder(samplingTime)\n    scSim.AddModelToTask(simTaskName, dataLog)\n\n    # Run the sim\n    scSim.InitializeSimulation()\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    # Get the logged data\n    sc1_access = dataLog.hasAccess\n    sc1_slant = dataLog.slantRange\n    sc1_elevation = dataLog.elevation\n    sc1_azimuth = dataLog.azimuth\n\n    #   Compare to expected values\n    accuracy = 1e-8\n    ref_ranges = [90e3]\n    ref_elevation = [np.radians(90.)]\n    ref_access = [1]\n\n    test_ranges = [sc1_slant[1]]\n    test_elevation = [sc1_elevation[1]]\n    test_access = [sc1_access[1]]\n\n    range_worked = test_ranges == pytest.approx(ref_ranges, accuracy)\n    elevation_worked = test_elevation == pytest.approx(ref_elevation, accuracy)\n    access_worked = test_access == pytest.approx(ref_access, abs=1e-16)\n\n    assert (range_worked and elevation_worked and access_worked)",
  "def test_AzElR_rates():\n    \"\"\"\n    Tests that the Az,El,range rates are correct by using 1-step Euler integration\n\n    :return:\n    \"\"\"\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n    scSim = SimulationBaseClass.SimBaseClass()\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n    dt = 1.0\n    simulationTimeStep = macros.sec2nano(dt)\n    simulationTime = simulationTimeStep\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    planet = gravFactory.createEarth()\n    mu = planet.mu\n    planet.isCentralBody = True\n    timeInitString = '2021 MAY 04 06:47:48.965 (UTC)'\n    gravFactory.createSpiceInterface(bskPath + '/supportData/EphemerisData/'\n                                     , timeInitString\n                                     )\n    gravFactory.spiceObject.zeroBase = 'Earth'\n    scSim.AddModelToTask(simTaskName, gravFactory.spiceObject, -1)\n\n    scObject = spacecraft.Spacecraft()\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n    scSim.AddModelToTask(simTaskName, scObject)\n    oe = orbitalMotion.ClassicElements()\n    r_sc = planet.radEquator + 100*1E3\n    oe.a = r_sc\n    oe.e = 0.00001\n    oe.i = 53.0*macros.D2R\n    oe.Omega = 115.0*macros.D2R\n    oe.omega = 5.0*macros.D2R\n    oe.f = 75.*macros.D2R\n    rN, vN = orbitalMotion.elem2rv(mu, oe)\n    scObject.hub.r_CN_NInit = rN\n    scObject.hub.v_CN_NInit = vN\n\n    groundStation = groundLocation.GroundLocation()\n    groundStation.planetRadius = planet.radEquator\n    groundStation.specifyLocation(np.radians(40.009971), np.radians(-105.243895), 1624)\n    groundStation.planetInMsg.subscribeTo(gravFactory.spiceObject.planetStateOutMsgs[0])\n    groundStation.minimumElevation = np.radians(60.)\n    groundStation.addSpacecraftToModel(scObject.scStateOutMsg)\n    scSim.AddModelToTask(simTaskName, groundStation)\n\n    # Log the Az,El,R and rates info\n    numDataPoints = 2\n    samplingTime = unitTestSupport.samplingTime(simulationTime, simulationTimeStep, numDataPoints)\n    dataLog = groundStation.accessOutMsgs[0].recorder(samplingTime)\n    scSim.AddModelToTask(simTaskName, dataLog)\n\n    # Run the sim\n    scSim.InitializeSimulation()\n    scSim.ConfigureStopTime(simulationTime)\n    scSim.ExecuteSimulation()\n\n    # Get logged data\n    sc_range = dataLog.slantRange\n    sc_elevation = dataLog.elevation\n    sc_azimuth = dataLog.azimuth\n    sc_range_rate = dataLog.range_dot\n    sc_el_rate = dataLog.el_dot\n    sc_az_rate = dataLog.az_dot\n\n    # Euler integration\n    sc_Euler_range = sc_range[0] + sc_range_rate[0]*dt\n    sc_Euler_elev = sc_elevation[0] + sc_el_rate[0]*dt\n    sc_Euler_azimuth = sc_azimuth[0] + sc_az_rate[0]*dt\n\n    range_rate_worked = sc_range[1] == pytest.approx(sc_Euler_range, rel=1e-5)\n    el_rate_worked = sc_elevation[1] == pytest.approx(sc_Euler_elev, rel=1e-5)\n    az_rate_worked = sc_azimuth[1] == pytest.approx(sc_Euler_azimuth, rel=1e-5)\n\n    assert (range_rate_worked and el_rate_worked and az_rate_worked)",
  "def plot_geometry(groundLocation, scLocations, minimumElevation):\n    \"\"\"\n    Plots the location of a ground station, its field of view,  and the positions of two spacecraft to verify whether\n    the spacecraft have access to the ground station.\n\n    :param groundLocation: [3,] : an ECI ground position.\n    :param scLocations: [3,2] : two spacecraft position vectors\n    :param minimumElevation: double : minimum view elevation angle in degrees.\n    :return:\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(projection='3d')\n\n    # draw sphere\n    u, v = np.mgrid[0:2 * np.pi:20j, 0:np.pi:20j]\n    x = orbitalMotion.REQ_EARTH*1000 * np.cos(u) * np.sin(v)\n    y = orbitalMotion.REQ_EARTH*1000 *np.sin(u) * np.sin(v)\n    z = orbitalMotion.REQ_EARTH*1000 *np.cos(v)\n    ax.plot_wireframe(x, y, z, color=\"g\")\n\n    # draw a point0\n    ax.scatter(groundLocation[0],groundLocation[1],groundLocation[2], color=\"r\", s=100)\n\n    # draw a vector\n\n    for location in scLocations:\n        ax.scatter(location[0],location[1],location[2],color='k',s=100)\n\n        ax.quiver(groundLocation[0],groundLocation[1],groundLocation[2],\n              location[0],location[1],location[2], length=1.0, normalize=True)\n    #ax.add_artist(a)\n\n    plt.show()",
  "def test_tabularAtmosphere(altitude, accuracy, useMinReach, useMaxReach):\n    r\"\"\"\n    **Validation Test Description**\n    \n    TabularAtmosphere interpolates from user-provided data to compute density and temperature at the current s/c\n    altitude. The unit test checks altitudes at, between, above, and below the values included in the table. This\n    test uses a python helper function to provide data from EarthGRAM (see supportData\\AtmosphereData\\support).\n    Data lists can also be manually-input, but check sorting and units per documentation and support info (above).\n    The module returns 0 for both density and temperature if ANY ONE of the following conditions is met:\n\n    - altitude below minimum value in provided table\n    - altitude above maximum value in provided table\n    - altitude below envMinReach\n    - altitude above envMaxReach\n\n    Note that this results in nonphysical behavior for temperature (absolute zero) when outside defined range.\n\n    **Test Parameters**\n\n    Args:\n\n    - altitude (float): Spacecraft altitude for which density, temperature are returned\n    - accuracy (float): accuracy value used in validation tests\n    - useMinReach (bool): set value of envMinReach\n    - useMaxReach (bool): set value of envMaxReach\n\n    **Description of Variables Being Tested**\n\n    The unit test checks density (kg/m^3) and temperature (K) against their expected values:\n\n    - ``densData[0]``\n    - ``tempData[0]``\n    \"\"\"\n    \n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = tabularAtmosphereTestFunction(altitude, accuracy, useMinReach, useMaxReach)\n    assert testResults < 1, testMessage",
  "def tabularAtmosphereTestFunction(altitude, accuracy, useMinReach, useMaxReach):\n    testFailCount = 0                       # zero unit test result counter\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = tabularAtmosphere.TabularAtmosphere()   # update with current values\n    module.ModelTag = \"tabularAtmosphere\"            # update python name of test module\n    \n    # define constants & load data\n    r_eq = 6378136.6\n    filename = bskPath + '/../../supportData/AtmosphereData/EarthGRAMNominal.txt'\n    altList, rhoList, tempList = readAtmTable(filename,'EarthGRAM')\n        \n    # assign constants & ref. data to module\n    module.planetRadius = r_eq\n    module.altList = tabularAtmosphere.DoubleVector(altList)    \n    module.rhoList = tabularAtmosphere.DoubleVector(rhoList)\n    module.tempList = tabularAtmosphere.DoubleVector(tempList)\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    \n    # CHECK - env min and max\n    if useMinReach:\n        minReach = 50.0 * 1000\n        module.envMinReach = minReach\n    else:\n        minReach = -1.0 * 1000\n    if useMaxReach:\n        maxReach = 20.0 * 1000\n        module.envMaxReach = maxReach\n    else:\n        maxReach = 5000.0 * 1000\n    \n    #   setup orbit and simulation time\n    r0 = r_eq + (altitude * 1000.0)  # meters\n    oe = orbitalMotion.ClassicElements()\n    mu = 0.3986004415E+15  # meters^3/s^2\n    oe.a = r0\n    oe.e = 0.0\n    oe.i = 45.0 * macros.D2R\n    oe.Omega = 30.0 * macros.D2R\n    oe.omega = 120.0 * macros.D2R\n    oe.f = 0.0 * macros.D2R\n    r0N, v0N = orbitalMotion.elem2rv(mu, oe)\n\n    # create the input messages\n    scStateMsg = messaging.SCStatesMsgPayload()  # Create a structure for the input message\n    scStateMsg.r_BN_N = np.array(r0N)\n    scInMsg = messaging.SCStatesMsg().write(scStateMsg)\n    \n    # add spacecraft to environment model\n    module.addSpacecraftToModel(scInMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.envOutMsgs[0].recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n    \n    # This pulls the actual data log from the simulation run.\n    densData = dataLog.neutralDensity\n    tempData = dataLog.localTemp\n    \n    # define python function to compute truth values\n    def tabAtmoComp(val, xList, yList):\n        if (val < xList[0]) or (val <= minReach):\n            out = 0.0\n            return out\n        elif (val > xList[-1]) or (val >= maxReach):\n            out = 0.0\n            return out\n        else:\n            for i, x in enumerate(xList):\n                if x >= val:\n                    x0 = xList[i-1]\n                    y0 = yList[i-1]\n                    y1 = yList[i]\n                    m = (y1 - y0)/(x - x0)\n                    out = y0 + (val - x0) * m\n                    return out\n    \n    # compute truth values\n    trueDensity = tabAtmoComp(altitude * 1000, altList, rhoList)\n    print('\\nmodule density: {0:.6e}'.format(densData[0]))\n    print('true density: {0:.6e}'.format(trueDensity))\n    \n    trueTemp = tabAtmoComp(altitude * 1000, altList, tempList)\n    print('\\nmodule temperature: {0:.6e}'.format(tempData[0]))\n    print('true temperature: {0:.6e}\\n'.format(trueTemp))\n    \n    # compare truth values to module results\n    if trueDensity != 0:\n        testFailCount = not unitTestSupport.isDoubleEqualRelative(densData[0], trueDensity, accuracy)\n    else:\n        testFailCount = not unitTestSupport.isDoubleEqual(densData[0], trueDensity, accuracy)\n    if testFailCount == 0:\n        testMessage = \"density computed correctly\"\n    else:\n        testMessage = \"density computed incorrectly\"\n        \n    # compare truth values to module results for temperature\n    if trueTemp != 0 :    # needs checking\n        testFailCount = not unitTestSupport.isDoubleEqualRelative(tempData[0], trueTemp, accuracy)\n    else:\n        testFailCount = not unitTestSupport.isDoubleEqual(tempData[0], trueTemp, accuracy)\n    if testFailCount == 0:\n        testMessage += \" and temperature computed correctly\"\n    else:\n        testMessage += \" and temperature computed incorrectly\"\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)       \n\n    return [testFailCount, testMessage]",
  "def tabAtmoComp(val, xList, yList):\n        if (val < xList[0]) or (val <= minReach):\n            out = 0.0\n            return out\n        elif (val > xList[-1]) or (val >= maxReach):\n            out = 0.0\n            return out\n        else:\n            for i, x in enumerate(xList):\n                if x >= val:\n                    x0 = xList[i-1]\n                    y0 = yList[i-1]\n                    y1 = yList[i]\n                    m = (y1 - y0)/(x - x0)\n                    out = y0 + (val - x0) * m\n                    return out",
  "def test_solarFlux(show_plots, positionFactor, shadowFactor, eclipseMsgName, relTol):\n    \"\"\"\n    **Test Description**\n\n    Test that solar flux is appropriately modified depending on spacecraft distance from the sun.\n    To test this, the module is asked to write the solar flux at 1 AU. Then it is asked to write\n    the flux at ``positionFactor*AU`` and the flux is checked to be ``positionFactor**2`` of that at 1 AU to within\n    a relative tolerance of relTol.\n    The application of the shadowFactor is also checked as a multiple of the un-shadowed flux.\n\n    Args:\n        positionFactor (float): positive,\n            a factor by which to multiply the original s/c position to check flux at a new position\n        shadowFactor (float): between 0 and 1,\n            the eclipse factor by which to multiple the solar flux at a position\n        relTol (float): positive, the relative tolerance to which the result is checked.\n    \"\"\"\n\n    sim = SimulationBaseClass.SimBaseClass()\n    proc = sim.CreateNewProcess(\"proc\")\n    task = sim.CreateNewTask(\"task\", int(1e9))\n    proc.addTask(task)\n\n    sunPositionMessage = messaging.SpicePlanetStateMsgPayload()\n    sunPositionMessage.PositionVector = [0., 0., 0.]\n    sunMsg = messaging.SpicePlanetStateMsg().write(sunPositionMessage)\n\n    scPositionMessage = messaging.SCStatesMsgPayload()\n    scPositionMessage.r_BN_N = [0., 0., om.AU*1000]\n    scMsg = messaging.SCStatesMsg().write(scPositionMessage)\n\n    eclipseMessage = messaging.EclipseMsgPayload()\n    eclipseMessage.shadowFactor = shadowFactor\n    eclMsg = messaging.EclipseMsg().write(eclipseMessage)\n\n    sf = solarFlux.SolarFlux()\n    sim.AddModelToTask(task.Name, sf)\n    sf.sunPositionInMsg.subscribeTo(sunMsg)\n    sf.spacecraftStateInMsg.subscribeTo(scMsg)\n    sf.eclipseInMsg.subscribeTo(eclMsg)\n\n    dataLog = sf.solarFluxOutMsg.recorder()\n    sim.AddModelToTask(task.Name, dataLog)\n\n    sim.InitializeSimulation()\n    sim.TotalSim.SingleStepProcesses()\n\n    fluxOutEarth = dataLog.flux\n    scPositionMessage.r_BN_N = [0., 0., positionFactor * om.AU*1000]\n    scMsg.write(scPositionMessage)\n\n    sim.TotalSim.SingleStepProcesses()\n    fluxOutFurther = dataLog.flux\n\n    assert fluxOutFurther[1] == pytest.approx(fluxOutEarth[0] / shadowFactor / (positionFactor**2) * shadowFactor, rel=relTol)",
  "def test_unitEclipse(show_plots, eclipseCondition, planet):\n    \"\"\"\n**Test Description and Success Criteria**\n\nThe unit test validates the internal aspects of the Basilisk eclipse module by comparing simulated output with \\\nexpected output. It validates the computation of a shadow factor for total eclipse, partial eclipse,annular eclipse, \\\nand no eclipse scenarios. The test is designed to analyze one type at a time for both Earth and Mars and is then \\\nrepeated for all three.\n\nEarth is set as the zero base for all eclipse types to test it as the occulting body. For full, partial, and \\\nno eclipse cases, orbital elements describing the spacecraft states are then converted to Cartesian vectors. \\\nThese orbital elements vary for each eclipse type since the Sun and planet states are fixed. The conversion is \\\nmade using the orbitalMotion elem2rv function, where the inputs are six orbital elements (a, e, i, Omega, omega, f) \\\nand the outputs are Cartesian position and velocity vectors. For the annular eclipse case, the conversion is \\\navoided and a Cartesian position vector is initially provided instead. The vectors are then passed into \\\nspacecraft and, subsequently, the eclipse module through the Basilisk messaging system.\n\nTesting the no eclipse case with Mars as the occulting body is the same as the Earth no eclipse test, except \\\nMars is set as the zero base. The Mars full, partial, and annular eclipse cases, however, are like the Earth \\\nannular case where Cartesian vectors are, instead, the initial inputs. Since the test is performed as a single \\\nstep process, the velocity is not necessarily needed as an input, so only a position vector is provided \\\nfor these cases.\n\nThe shadow factor obtained through the module is compared to the expected result, which is either trivial or \\\ncalculated, depending on the eclipse type. Full eclipse and no eclipse shadow factors are compared without the \\\nneed for computation, since they are just 0.0 and 1.0, respectively. The partial and annular eclipse shadow \\\nfactors, however, vary between 0.0 and 1.0, based on the cone dimensions, and are calculated using \\\nMATLAB and Spice data.\n\n\n**Test Parameters:**\n\n- ``eclipseCondition``: [string]\n  defines if the eclipse is partial, full, none or annular\n- ``planet``: [string]\n  defines which planet to use.  Options include \"earth\" and \"mars\"\n\n\n**Description of Variables Being Tested**\n\nIn each test scenario the shadow eclipse variable\n\n    ``shadowFactor``\n\nis pulled from the log data and compared to expected truth values.\n\n    \"\"\"\n    [testResults, testMessage] = unitEclipse(show_plots, eclipseCondition, planet)\n    assert testResults < 1, testMessage",
  "def test_unitEclipseCustom(show_plots):\n    \"\"\"\n**Test Description and Success Criteria**\n\nThe unit test validates the internal aspects of the Basilisk eclipse module by comparing simulated output with \\\nexpected output. It validates the computation of a shadow factor for total eclipse using a custom gravity body.\n\nThis unit test sets up a custom gravity body, the asteroid Bennu, using the planetEphemeris module (i.e. Spice \\\nis not used for this test.) An empty spice planet message is created for the sun. The spacecraft is set 500 m \\\non the side of the asteroid opposite of the sun.\n\nThe shadow factor obtained through the module is compared to the expected result, which is trivial to compute.\n\n**Description of Variables Being Tested**\n\nIn this test scenario the shadow eclipse variable\n\n    ``shadowFactor``\n\nis pulled from the log data and compared to the expected truth value.\n\n    \"\"\"\n    [testResults, testMessage] = unitEclipseCustom(show_plots)\n    assert testResults < 1, testMessage",
  "def unitEclipse(show_plots, eclipseCondition, planet):\n    __tracebackhide__ = True\n\n    testFailCount = 0\n    testMessages = []\n    testTaskName = \"unitTestTask\"\n    testProcessName = \"unitTestProcess\"\n    testTaskRate = macros.sec2nano(1)\n\n    # Create a simulation container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    testProc = unitTestSim.CreateNewProcess(testProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(testTaskName, testTaskRate))\n\n    # Set up first spacecraft\n    scObject_0 = spacecraft.Spacecraft()\n    scObject_0.ModelTag = \"spacecraft\"\n    unitTestSim.AddModelToTask(testTaskName, scObject_0)\n\n    # setup Gravity Bodies\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    earth = gravFactory.createEarth()\n    mars = gravFactory.createMarsBarycenter()\n    if planet == \"earth\":\n        earth.isCentralBody = True\n    elif planet == \"mars\":\n        mars.isCentralBody = True\n    scObject_0.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    # setup Spice interface for some solar system bodies\n    timeInitString = '2021 MAY 04 07:47:48.965 (UTC)'\n    gravFactory.createSpiceInterface(bskPath + '/supportData/EphemerisData/'\n                                     , timeInitString\n                                     # earth and mars must come first as with gravBodies\n                                     , spicePlanetNames=[\"earth\", \"mars barycenter\", \"sun\", \"venus\"]\n                                     )\n\n    if planet == \"earth\":\n        if eclipseCondition == \"full\":\n            gravFactory.spiceObject.zeroBase = \"earth\"\n            # set up spacecraft 0 position and velocity for full eclipse\n            oe = orbitalMotion.ClassicElements()\n            r_0 = (500 + orbitalMotion.REQ_EARTH)  # km\n            oe.a = r_0\n            oe.e = 0.00001\n            oe.i = 5.0 * macros.D2R\n            oe.Omega = 48.2 * macros.D2R\n            oe.omega = 0 * macros.D2R\n            oe.f = 173 * macros.D2R\n            r_N_0, v_N_0 = orbitalMotion.elem2rv(orbitalMotion.MU_EARTH, oe)\n            scObject_0.hub.r_CN_NInit = r_N_0 * 1000  # convert to meters\n            scObject_0.hub.v_CN_NInit = v_N_0 * 1000  # convert to meters\n        elif eclipseCondition == \"partial\":\n            gravFactory.spiceObject.zeroBase = \"earth\"\n            # set up spacecraft 0 position and velocity for full eclipse\n            oe = orbitalMotion.ClassicElements()\n            r_0 = (500 + orbitalMotion.REQ_EARTH)  # km\n            oe.a = r_0\n            oe.e = 0.00001\n            oe.i = 5.0 * macros.D2R\n            oe.Omega = 48.2 * macros.D2R\n            oe.omega = 0 * macros.D2R\n            oe.f = 107.5 * macros.D2R\n            r_N_0, v_N_0 = orbitalMotion.elem2rv(orbitalMotion.MU_EARTH, oe)\n            scObject_0.hub.r_CN_NInit = r_N_0 * 1000  # convert to meters\n            scObject_0.hub.v_CN_NInit = v_N_0 * 1000  # convert to meters\n        elif eclipseCondition == \"none\":\n            oe = orbitalMotion.ClassicElements()\n            r_0 = 9959991.68982  # km\n            oe.a = r_0\n            oe.e = 0.00001\n            oe.i = 5.0 * macros.D2R\n            oe.Omega = 48.2 * macros.D2R\n            oe.omega = 0 * macros.D2R\n            oe.f = 107.5 * macros.D2R\n            r_N_0, v_N_0 = orbitalMotion.elem2rv(orbitalMotion.MU_EARTH, oe)\n            scObject_0.hub.r_CN_NInit = r_N_0 * 1000  # convert to meters\n            scObject_0.hub.v_CN_NInit = v_N_0 * 1000  # convert to meters\n        elif eclipseCondition == \"annular\":\n            gravFactory.spiceObject.zeroBase = \"earth\"\n            scObject_0.hub.r_CN_NInit = [-326716535628.942, -287302983139.247, -124542549301.050]\n\n    elif planet == \"mars\":\n        if eclipseCondition == \"full\":\n            gravFactory.spiceObject.zeroBase = \"mars barycenter\"\n            scObject_0.hub.r_CN_NInit = [-2930233.55919119, 2567609.100747609, 41384.23366372246] # meters\n        elif eclipseCondition == \"partial\":\n            gravFactory.spiceObject.zeroBase = \"mars barycenter\"\n            scObject_0.hub.r_CN_NInit = [-6050166.454829555, 2813822.447404055, 571725.5651779658] # meters\n        elif eclipseCondition == \"none\":\n            oe = orbitalMotion.ClassicElements()\n            r_0 = 9959991.68982  # km\n            oe.a = r_0\n            oe.e = 0.00001\n            oe.i = 5.0 * macros.D2R\n            oe.Omega = 48.2 * macros.D2R\n            oe.omega = 0 * macros.D2R\n            oe.f = 107.5 * macros.D2R\n            r_N_0, v_N_0 = orbitalMotion.elem2rv(orbitalMotion.MU_MARS, oe)\n            scObject_0.hub.r_CN_NInit = r_N_0 * 1000  # convert to meters\n            scObject_0.hub.v_CN_NInit = v_N_0 * 1000  # convert to meters\n        elif eclipseCondition == \"annular\":\n            gravFactory.spiceObject.zeroBase = \"mars barycenter\"\n            scObject_0.hub.r_CN_NInit = [-427424601171.464, 541312532797.400, 259820030623.064]  # meters\n\n    unitTestSim.AddModelToTask(testTaskName, gravFactory.spiceObject, -1)\n\n    eclipseObject = eclipse.Eclipse()\n    eclipseObject.addSpacecraftToModel(scObject_0.scStateOutMsg)\n    eclipseObject.addPlanetToModel(gravFactory.spiceObject.planetStateOutMsgs[3])   # venus\n    eclipseObject.addPlanetToModel(gravFactory.spiceObject.planetStateOutMsgs[1])   # mars\n    eclipseObject.addPlanetToModel(gravFactory.spiceObject.planetStateOutMsgs[0])   # earth\n    eclipseObject.sunInMsg.subscribeTo(gravFactory.spiceObject.planetStateOutMsgs[2])   # sun\n\n    unitTestSim.AddModelToTask(testTaskName, eclipseObject)\n\n    dataLog = eclipseObject.eclipseOutMsgs[0].recorder()\n    unitTestSim.AddModelToTask(testTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n\n    # Execute the simulation for one time step\n    unitTestSim.TotalSim.SingleStepProcesses()\n\n    eclipseData_0 = dataLog.shadowFactor\n    # Obtain body position vectors to check with MATLAB\n\n    errTol = 1E-12\n    if planet == \"earth\":\n        if eclipseCondition == \"partial\":\n            truthShadowFactor = 0.62310760206735027\n            if not unitTestSupport.isDoubleEqual(eclipseData_0[-1], truthShadowFactor, errTol):\n                testFailCount += 1\n                testMessages.append(\"Shadow Factor failed for Earth partial eclipse condition\")\n\n        elif eclipseCondition == \"full\":\n            truthShadowFactor = 0.0\n            if not unitTestSupport.isDoubleEqual(eclipseData_0[-1], truthShadowFactor, errTol):\n                testFailCount += 1\n                testMessages.append(\"Shadow Factor failed for Earth full eclipse condition\")\n\n        elif eclipseCondition == \"none\":\n            truthShadowFactor = 1.0\n            if not unitTestSupport.isDoubleEqual(eclipseData_0[-1], truthShadowFactor, errTol):\n                testFailCount += 1\n                testMessages.append(\"Shadow Factor failed for Earth none eclipse condition\")\n        elif eclipseCondition == \"annular\":\n            truthShadowFactor = 1.497253388113018e-04\n            if not unitTestSupport.isDoubleEqual(eclipseData_0[-1], truthShadowFactor, errTol):\n                testFailCount += 1\n                testMessages.append(\"Shadow Factor failed for Earth annular eclipse condition\")\n\n    elif planet == \"mars\":\n        if eclipseCondition == \"partial\":\n            truthShadowFactor = 0.18745025055615416\n            if not unitTestSupport.isDoubleEqual(eclipseData_0[-1], truthShadowFactor, errTol):\n                testFailCount += 1\n                testMessages.append(\"Shadow Factor failed for Mars partial eclipse condition\")\n        elif eclipseCondition == \"full\":\n            truthShadowFactor = 0.0\n            if not unitTestSupport.isDoubleEqual(eclipseData_0[-1], truthShadowFactor, errTol):\n                testFailCount += 1\n                testMessages.append(\"Shadow Factor failed for Mars full eclipse condition\")\n        elif eclipseCondition == \"none\":\n            truthShadowFactor = 1.0\n            if not unitTestSupport.isDoubleEqual(eclipseData_0[-1], truthShadowFactor, errTol):\n                testFailCount += 1\n                testMessages.append(\"Shadow Factor failed for Mars none eclipse condition\")\n        elif eclipseCondition == \"annular\":\n            truthShadowFactor = 4.245137380531894e-05\n            if not unitTestSupport.isDoubleEqual(eclipseData_0[-1], truthShadowFactor, errTol):\n                testFailCount += 1\n                testMessages.append(\"Shadow Factor failed for Mars annular eclipse condition\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + planet + \"-\" + eclipseCondition)\n        # return fail count and join into a single string all messages in the list\n        # testMessage\n    else:\n        print(testMessages)\n\n    print('The error tolerance for all tests is ' + str(errTol))\n\n    #\n    #  unload the SPICE libraries that were loaded by the spiceObject earlier\n    #\n    gravFactory.unloadSpiceKernels()\n\n    return [testFailCount, ''.join(testMessages)]",
  "def unitEclipseCustom(show_plots):\n    __tracebackhide__ = True\n\n    testFailCount = 0\n    testMessages = []\n    testTaskName = \"unitTestTask\"\n    testProcessName = \"unitTestProcess\"\n    testTaskRate = macros.sec2nano(1)\n\n    # Create a simulation container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    testProc = unitTestSim.CreateNewProcess(testProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(testTaskName, testTaskRate))\n\n    # Set up first spacecraft\n    scObject_0 = spacecraft.Spacecraft()\n    scObject_0.ModelTag = \"spacecraft\"\n    unitTestSim.AddModelToTask(testTaskName, scObject_0)\n\n    # setup Gravity Bodies\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    mu_bennu = 4.892\n    custom = gravFactory.createCustomGravObject(\"custom\", mu_bennu) # creates a custom grav object (bennu)\n    scObject_0.gravField.gravBodies = spacecraft.GravBodyVector(list(gravFactory.gravBodies.values()))\n\n    # Create the ephemeris data for the bodies\n    # setup celestial object ephemeris module\n    gravBodyEphem = planetEphemeris.PlanetEphemeris()\n    gravBodyEphem.ModelTag = 'planetEphemeris'\n    gravBodyEphem.setPlanetNames(planetEphemeris.StringVector([\"custom\"]))\n\n    # Specify bennu orbit\n    oeAsteroid = planetEphemeris.ClassicElementsMsgPayload()\n    oeAsteroid.a = 1.1259 * orbitalMotion.AU * 1000. # m\n    oeAsteroid.e = 0.20373\n    oeAsteroid.i = 6.0343 * macros.D2R\n    oeAsteroid.Omega = 2.01820 * macros.D2R\n    oeAsteroid.omega = 66.304 * macros.D2R\n    oeAsteroid.f = 120.0 * macros.D2R\n\n    gravBodyEphem.planetElements = planetEphemeris.classicElementVector([oeAsteroid])\n    custom.planetBodyInMsg.subscribeTo(gravBodyEphem.planetOutMsgs[0])\n\n    # Create an empty sun spice object\n    sunPlanetStateMsgData = messaging.SpicePlanetStateMsgPayload()\n    sunPlanetStateMsg = messaging.SpicePlanetStateMsg()\n    sunPlanetStateMsg.write(sunPlanetStateMsgData)\n\n    r_ast_N = np.array([-177862743954.6422, -25907896415.157013, -2074871174.236055])\n    r_sc_N = r_ast_N + 500 * r_ast_N / np.linalg.norm(r_ast_N)\n    scObject_0.hub.r_CN_NInit = r_sc_N\n\n    unitTestSim.AddModelToTask(testTaskName, gravBodyEphem, -1)\n\n    eclipseObject = eclipse.Eclipse()\n    eclipseObject.addSpacecraftToModel(scObject_0.scStateOutMsg)\n    eclipseObject.addPlanetToModel(gravBodyEphem.planetOutMsgs[0])  # custom\n    eclipseObject.sunInMsg.subscribeTo(sunPlanetStateMsg)   # sun\n    eclipseObject.rEqCustom = 282. # m\n\n    unitTestSim.AddModelToTask(testTaskName, eclipseObject)\n\n    dataLog = eclipseObject.eclipseOutMsgs[0].recorder()\n    unitTestSim.AddModelToTask(testTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n\n    # Execute the simulation for one time step\n    unitTestSim.TotalSim.SingleStepProcesses()\n\n    eclipseData_0 = dataLog.shadowFactor\n    # Obtain body position vectors to check with MATLAB\n\n    errTol = 1E-12\n    truthShadowFactor = 0.0\n    if not unitTestSupport.isDoubleEqual(eclipseData_0[-1], truthShadowFactor, errTol):\n        testFailCount += 1\n        testMessages.append(\"Shadow Factor failed for custom full eclipse condition\")\n\n    if testFailCount == 0:\n        print(\"PASSED: custom-full\")\n        # return fail count and join into a single string all messages in the list\n        # testMessage\n    else:\n        print(testMessages)\n\n    print('The error tolerance for all tests is ' + str(errTol))\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, useDefault, useMinReach, useMaxReach, usePlanetEphemeris):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(show_plots, useDefault, useMinReach, useMaxReach, usePlanetEphemeris)\n    assert testResults < 1, testMessage",
  "def run(show_plots, useDefault, useMinReach, useMaxReach, usePlanetEphemeris):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    testModule = magneticFieldCenteredDipole.MagneticFieldCenteredDipole()\n    testModule.ModelTag = \"CenteredDipole\"\n\n    if useDefault:\n        refg10 = 0.0     # Tesla\n        refg11 = 0.0     # Tesla\n        refh11 = 0.0     # Tesla\n        refPlanetRadius = 0.0   # meters\n    else:\n        simSetPlanetEnvironment.centeredDipoleMagField(testModule, \"earth\")\n        refg10 = testModule.g10\n        refg11 = testModule.g11\n        refh11 = testModule.h11\n        refPlanetRadius = testModule.planetRadius\n\n    minReach = -1.0\n    if useMinReach:\n        minReach = (orbitalMotion.REQ_EARTH+300.)*1000.0     # meters\n        testModule.envMinReach = minReach\n    maxReach = -1.0\n    if useMaxReach:\n        maxReach = (orbitalMotion.REQ_EARTH+100.)     # meters\n        testModule.envMaxReach = maxReach\n    planetPosition = np.array([0.0, 0.0, 0.0])\n    refPlanetDCM = np.array(((1, 0, 0), (0, 1, 0), (0, 0, 1)))\n    if usePlanetEphemeris:\n        planetStateMsg = messaging.SpicePlanetStateMsgPayload()\n        planetPosition = [1000.0, 2000.0, -1000.0]\n        planetStateMsg.PositionVector = planetPosition\n        refPlanetDCM = np.array(((-1, 0, 0), (0, -1, 0), (0, 0, 1)))\n        planetStateMsg.J20002Pfix = refPlanetDCM.tolist()\n        planetMsg = messaging.SpicePlanetStateMsg().write(planetStateMsg)\n        testModule.planetPosInMsg.subscribeTo(planetMsg)\n\n\n    # add spacecraft to environment model\n    sc0StateMsg = messaging.SCStatesMsg()\n    sc1StateMsg = messaging.SCStatesMsg()\n    testModule.addSpacecraftToModel(sc0StateMsg)\n    testModule.addSpacecraftToModel(sc1StateMsg)\n\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    # define the spacecraft locations\n    r0 = 6571 * 1000.0  # meters\n    r1 = 6600 * 1000.0  # meters\n    #\n    #   setup orbit and simulation time\n    oe = orbitalMotion.ClassicElements()\n    mu = 0.3986004415E+15  # meters^3/s^2\n    oe.a = r0\n    oe.e = 0.0\n    oe.i = 45.0 * macros.D2R\n    oe.Omega = 30.0 * macros.D2R\n    oe.omega = 120.0 * macros.D2R\n    oe.f = 0.0 * macros.D2R\n    r0N, v0N = orbitalMotion.elem2rv(mu, oe)\n    oe.a = r1\n    r1N, v1N = orbitalMotion.elem2rv(mu, oe)\n\n\n    # create the input messages\n    sc0StateMsgData = messaging.SCStatesMsgPayload()  # Create a structure for the input message\n    sc0StateMsgData.r_BN_N = np.array(r0N) + np.array(planetPosition)\n    sc0StateMsg.write(sc0StateMsgData)\n\n    sc1StateMsgData = messaging.SCStatesMsgPayload()  # Create a structure for the input message\n    sc1StateMsgData.r_BN_N = np.array(r1N) + np.array(planetPosition)\n    sc1StateMsg.write(sc1StateMsgData)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog0 = testModule.envOutMsgs[0].recorder()\n    dataLog1 = testModule.envOutMsgs[1].recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog0)\n    unitTestSim.AddModelToTask(unitTaskName, dataLog1)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    mag0Data = dataLog0.magField_N\n    mag1Data = dataLog1.magField_N\n\n    def centeredDipole(pos_N, X, refPlanetRadius, refPlanetDCM, minReach, maxReach):\n        radius = np.linalg.norm(pos_N)\n        planetPos_E = refPlanetDCM.dot(pos_N)\n        rHat_E = planetPos_E/radius\n\n        magField_E = (refPlanetRadius/radius)**3 * (3*rHat_E*np.dot(rHat_E, X)-X)\n\n        magField_N = [((refPlanetDCM.transpose()).dot(magField_E)).tolist()]*3\n\n        if radius < minReach:\n            magField_N = [[0.0, 0.0, 0.0]]*3\n        if radius > maxReach and maxReach > 0:\n            magField_N = [[0.0, 0.0, 0.0]]*3\n        return magField_N\n\n\n    # compare the module results to the truth values\n    accuracy = 1e-5\n    unitTestSupport.writeTeXSnippet(\"unitTestToleranceValue\", str(accuracy), path)\n\n\n    # check the exponential atmosphere results\n    #\n    # check spacecraft 0 neutral density results\n    if len(mag0Data) > 0:\n        trueMagField = centeredDipole(r0N, np.array([refg11, refh11, refg10]), refPlanetRadius, refPlanetDCM, minReach, maxReach)\n        testFailCount, testMessages = unitTestSupport.compareArrayRelative(\n            trueMagField, mag0Data, accuracy, \"SC0 mag vector\",\n            testFailCount, testMessages)\n\n    if len(mag1Data) > 0:\n        trueMagField = centeredDipole(r1N, np.array([refg11, refh11, refg10]), refPlanetRadius, refPlanetDCM, minReach, maxReach)\n        testFailCount, testMessages = unitTestSupport.compareArrayRelative(\n            trueMagField, mag1Data, accuracy, \"SC1 mag vector\",\n            testFailCount, testMessages)\n\n\n    #   print out success or failure message\n    snippentName = \"unitTestPassFail\" + str(useDefault) + str(useMinReach) + str(useMaxReach) + str(usePlanetEphemeris)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + testModule.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + testModule.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def centeredDipole(pos_N, X, refPlanetRadius, refPlanetDCM, minReach, maxReach):\n        radius = np.linalg.norm(pos_N)\n        planetPos_E = refPlanetDCM.dot(pos_N)\n        rHat_E = planetPos_E/radius\n\n        magField_E = (refPlanetRadius/radius)**3 * (3*rHat_E*np.dot(rHat_E, X)-X)\n\n        magField_N = [((refPlanetDCM.transpose()).dot(magField_E)).tolist()]*3\n\n        if radius < minReach:\n            magField_N = [[0.0, 0.0, 0.0]]*3\n        if radius > maxReach and maxReach > 0:\n            magField_N = [[0.0, 0.0, 0.0]]*3\n        return magField_N",
  "def test_spacecraftLocation(show_plots, defaultPolarRadius, defaultPlanet, latitude, maxRange, cone):\n    \"\"\"\n    Tests whether spacecraftLocation:\n\n    1. defaults planet polar radius to equatorial radius if the polar radius is not set\n    2. checks that the zero default planet states are used if the planet is not provided\n    3. checks that the planet oblateness is accounted for\n    4. checks if the optional sensor boresight axis is properly accounted for\n\n    :return:\n    \"\"\"\n\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(show_plots, defaultPolarRadius, defaultPlanet, latitude, maxRange, cone)\n    assert testResults < 1, testMessage",
  "def run(showplots, defaultPolarRadius, defaultPlanet, latitude, maxRange, cone):\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n    scSim = SimulationBaseClass.SimBaseClass()\n    dynProcess = scSim.CreateNewProcess(simProcessName)\n    simulationTimeStep = macros.sec2nano(1.)\n    dynProcess.addTask(scSim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    #   Initialize new atmosphere and drag model, add them to task\n    module = spacecraftLocation.SpacecraftLocation()\n    module.ModelTag = \"scLocation\"\n    module.rEquator = orbitalMotion.REQ_EARTH * 1000.\n    if not defaultPolarRadius:\n        module.rPolar = orbitalMotion.REQ_EARTH * 1000. * 0.5\n    if maxRange:\n        module.maximumRange = maxRange\n    if cone != 0:\n        module.aHat_B = [0, 0, cone]\n        module.theta = 80. * macros.D2R\n\n    scSim.AddModelToTask(simTaskName, module)\n\n    # create planet message\n    planetPos = np.array([0.0, 0.0, 0.0])\n    if not defaultPlanet:\n        planet_message = messaging.SpicePlanetStateMsgPayload()\n        planet_message.J20002Pfix = rbk.euler3(np.radians(-90.)).tolist()\n        planetPos = np.array([orbitalMotion.AU * 1000, 0.0, 0.0])\n        planet_message.PositionVector = planetPos\n        planetMsg = messaging.SpicePlanetStateMsg().write(planet_message)\n        module.planetInMsg.subscribeTo(planetMsg)\n\n    # create primary spacecraft state message\n    alt = 1000. * 1000      # meters\n    scMsgData = messaging.SCStatesMsgPayload()\n    r = orbitalMotion.REQ_EARTH * 1000. + alt\n    scMsgData.r_BN_N = planetPos + np.array([r, 0.0, 0.0])\n    scMsgData.sigma_BN = [1.0, 0.0, 0.0]\n    scMsg = messaging.SCStatesMsg().write(scMsgData)\n    module.primaryScStateInMsg.subscribeTo(scMsg)\n\n    sc1MsgData = messaging.SCStatesMsgPayload()\n    angle = np.radians(latitude)\n    sc1MsgData.r_BN_N = planetPos + np.array([r * np.cos(angle), 0.0, r * np.sin(angle)])\n    sc1Msg = messaging.SCStatesMsg().write(sc1MsgData)\n    module.addSpacecraftToModel(sc1Msg)\n\n    # Run the sim\n    scSim.InitializeSimulation()\n\n    # check polar planet radius default behavior\n    if defaultPolarRadius and module.rPolar < 0:\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed default polar radius check.\")\n\n    scSim.TotalSim.SingleStepProcesses()\n\n    accessMsg = module.accessOutMsgs[0].read()\n\n    if latitude == 55 or (latitude == 65 and not defaultPolarRadius):\n        trueAccess = 1\n        if maxRange > 0:\n            if accessMsg.slantRange > maxRange:\n                trueAccess = 0\n        if cone == 1:\n            trueAccess = 0\n\n        if accessMsg.hasAccess != trueAccess:\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed access test.\")\n\n        if accessMsg.slantRange <= 1e-6:\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed positive slant range test.\")\n    if (latitude == 65 and defaultPolarRadius) or latitude == 115:\n        # should not have access\n        if accessMsg.hasAccess != 0:\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed negative have access test.\")\n\n        if np.abs(accessMsg.slantRange) > 1e-6:\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed negative slant range test.\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_unitSpiceSc(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitSpiceSc(show_plots)\n    assert testResults < 1, testMessage",
  "def unitSpiceSc(show_plots):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    # Create a sim module as an empty container\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    TotalSim = SimulationBaseClass.SimBaseClass()\n\n    DynUnitTestProc = TotalSim.CreateNewProcess(unitProcessName)\n    # create the dynamics task and specify the integration update time\n    DynUnitTestProc.addTask(TotalSim.CreateNewTask(unitTaskName, macros.sec2nano(0.1)))\n    dateSpice = \"2015 February 10, 00:00:00.0 TDB\"\n\n    # Initialize the spice modules that we are using.\n    spiceObject = spiceInterface.SpiceInterface()\n    spiceObject.ModelTag = \"SpiceInterfaceData\"\n    spiceObject.SPICEDataPath = bskPath + '/supportData/EphemerisData/'\n    scNames = [\"HUBBLE SPACE TELESCOPE\"]\n    spiceObject.addSpacecraftNames(spiceInterface.StringVector(scNames))\n    spiceObject.UTCCalInit = dateSpice\n    spiceObject.zeroBase = \"earth\"\n    spiceObject.loadSpiceKernel(\"hst_edited.bsp\", bskPath + '/supportData/EphemerisData/')\n\n    TotalSim.AddModelToTask(unitTaskName, spiceObject)\n\n    # Configure simulation\n    TotalSim.ConfigureStopTime(macros.sec2nano(0.1))\n\n    # Execute simulation\n    TotalSim.InitializeSimulation()\n    TotalSim.ExecuteSimulation()\n\n    # unload spice kernel\n    spiceObject.unloadSpiceKernel(\"hst_edited.bsp\", bskPath + '/supportData/EphemerisData/')\n\n    # set truth\n    truthPosition = np.array([-5855529.540348052, 1986110.860522791, -3116764.7117067943])\n    truthVelocity = np.array([-1848.9038338503085, -7268.515626753905, -1155.3578832725618])\n    truthAtt = np.array([0., 0., 0.])\n    truthZero = np.array([0., 0., 0.])\n\n    scStateMsg = spiceObject.scStateOutMsgs[0].read()\n    # print(scStateMsg.r_BN_N)\n    # print(scStateMsg.v_BN_N)\n    # print(scStateMsg.sigma_BN)\n    accuracy = 0.01\n    testFailCount, testMessages = unitTestSupport.compareVector(truthPosition,\n                                                                scStateMsg.r_BN_N,\n                                                                accuracy, \"scState-r_BN_N\",\n                                                                testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareVector(truthPosition,\n                                                                scStateMsg.r_CN_N,\n                                                                accuracy, \"scState-r_CN_N\",\n                                                                testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareVector(truthVelocity,\n                                                                scStateMsg.v_BN_N,\n                                                                accuracy, \"scState-v_BN_N\",\n                                                                testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareVector(truthVelocity,\n                                                                scStateMsg.v_CN_N,\n                                                                accuracy, \"scState-v_CN_N\",\n                                                                testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareVector(truthAtt,\n                                                                scStateMsg.sigma_BN,\n                                                                accuracy, \"scState-sigma_BN\",\n                                                                testFailCount, testMessages)\n    attStateMsg = spiceObject.attRefStateOutMsgs[0].read()\n    testFailCount, testMessages = unitTestSupport.compareVector(truthAtt,\n                                                                attStateMsg.sigma_RN,\n                                                                accuracy, \"scState-sigma_RN\",\n                                                                testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareVector(truthZero,\n                                                                attStateMsg.omega_RN_N,\n                                                                accuracy, \"scState-omega_RN_N\",\n                                                                testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareVector(truthZero,\n                                                                attStateMsg.domega_RN_N,\n                                                                accuracy, \"scState-domega_RN_N\",\n                                                                testFailCount, testMessages)\n\n    transStateMsg = spiceObject.transRefStateOutMsgs[0].read()\n    testFailCount, testMessages = unitTestSupport.compareVector(truthPosition,\n                                                                transStateMsg.r_RN_N,\n                                                                accuracy, \"scState-r_RN_N\",\n                                                                testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareVector(truthVelocity,\n                                                                transStateMsg.v_RN_N,\n                                                                accuracy, \"scState-v_RN_N\",\n                                                                testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareVector(truthZero,\n                                                                transStateMsg.a_RN_N,\n                                                                accuracy, \"scState-a_RN_N\",\n                                                                testFailCount, testMessages)\n\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\" \\n PASSED \")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "class DataStore:\n    def __init__(self):\n        self.Date = []  # replace these with appropriate containers for the data to be stored for plotting\n        self.MarsPosErr = []\n        self.EarthPosErr = []\n        self.SunPosErr = []\n\n    def plotData(self):\n        fig1 = plt.figure(1)\n        rect = fig1.patch\n        rect.set_facecolor('white')\n\n        plt.xticks(numpy.arange(len(self.Date)), self.Date)\n        plt.plot(self.MarsPosErr, 'r', label='Mars')\n        plt.plot(self.EarthPosErr, 'bs', label='Earth')\n        plt.plot(self.SunPosErr, 'yo', label='Sun')\n\n        plt.rc('font', size=50)\n        plt.legend(loc='upper left')\n        fig1.autofmt_xdate()\n        plt.xlabel('Date of test')\n        plt.ylabel('Position Error [m]')\n        plt.show()\n\n    def giveData(self):\n        plt.figure(1)\n        plt.close(1)\n        fig1 = plt.figure(1, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n\n        plt.xticks(numpy.arange(len(self.Date)), self.Date)\n        plt.plot(self.MarsPosErr, 'r', label='Mars')\n        plt.plot(self.EarthPosErr, 'b', label='Earth')\n        plt.plot(self.SunPosErr, 'y', label='Sun')\n\n        plt.legend(loc='upper left')\n        fig1.autofmt_xdate()\n        plt.xlabel('Date of test')\n        plt.ylabel('Position Error [m]')\n\n        return plt",
  "def testPlottingFixture(show_plots):\n    dataStore = DataStore()\n    yield dataStore\n\n    plt = dataStore.giveData()\n    unitTestSupport.writeFigureLaTeX('EphemMars', 'Ephemeris Error on Mars', plt, 'height=0.7\\\\textwidth, keepaspectratio', path)\n    plt.ylim(0, 2E-2)\n    unitTestSupport.writeFigureLaTeX('EphemEarth', 'Ephemeris Error on Earth', plt, 'height=0.7\\\\textwidth, keepaspectratio', path)\n    plt.ylim(0, 5E-6)\n    unitTestSupport.writeFigureLaTeX('EphemSun', 'Ephemeris Error on Sun', plt, 'height=0.7\\\\textwidth, keepaspectratio', path)\n    if show_plots:\n        dataStore.plotData()",
  "def test_unitSpice(testPlottingFixture, show_plots, DateSpice, DatePlot, MarsTruthPos, EarthTruthPos,\n                   SunTruthPos, useMsg):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitSpice(testPlottingFixture, show_plots, DateSpice, DatePlot, MarsTruthPos,\n                                           EarthTruthPos, SunTruthPos, useMsg)\n    assert testResults < 1, testMessage",
  "def unitSpice(testPlottingFixture, show_plots, DateSpice, DatePlot, MarsTruthPos, EarthTruthPos, SunTruthPos, useMsg):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    # Create a sim module as an empty container\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    TotalSim = SimulationBaseClass.SimBaseClass()\n\n    DynUnitTestProc = TotalSim.CreateNewProcess(unitProcessName)\n    # create the dynamics task and specify the integration update time\n    DynUnitTestProc.addTask(TotalSim.CreateNewTask(unitTaskName, macros.sec2nano(0.1)))\n\n    # Initialize the spice modules that we are using.\n    SpiceObject = spiceInterface.SpiceInterface()\n    SpiceObject.ModelTag = \"SpiceInterfaceData\"\n    SpiceObject.SPICEDataPath = bskPath + '/supportData/EphemerisData/'\n    planetNames = [\"earth\", \"mars barycenter\", \"sun\"]\n    SpiceObject.addPlanetNames(spiceInterface.StringVector(planetNames))\n    SpiceObject.UTCCalInit = DateSpice\n\n    if useMsg:      # in this case check that the planet frame names can be set as well\n        planetFrames = []\n        for planet in planetNames:\n            planetFrames.append(\"IAU_\" + planet)\n        planetFrames[1] = \"\"    # testing that default IAU values are used here\n        SpiceObject.planetFrames = spiceInterface.StringVector(planetFrames)\n\n    TotalSim.AddModelToTask(unitTaskName, SpiceObject)\n\n    if useMsg:\n        epochMsg = unitTestSupport.timeStringToGregorianUTCMsg(DateSpice)\n        SpiceObject.epochInMsg.subscribeTo(epochMsg)\n\n        # The following value is set, but should not be used by the module.  This checks that the above\n        # epoch message over-rules any info set in this variable.\n        SpiceObject.UTCCalInit = \"1990 February 10, 00:00:00.0 TDB\"\n\n    # Configure simulation\n    TotalSim.ConfigureStopTime(int(60.0 * 1E9))\n    TotalSim.AddVariableForLogging('SpiceInterfaceData.GPSSeconds')\n    TotalSim.AddVariableForLogging('SpiceInterfaceData.J2000Current')\n    TotalSim.AddVariableForLogging('SpiceInterfaceData.julianDateCurrent')\n    TotalSim.AddVariableForLogging('SpiceInterfaceData.GPSWeek')\n\n    # Execute simulation\n    TotalSim.InitializeSimulation()\n    TotalSim.ExecuteSimulation()\n\n    # Get the logged variables (GPS seconds, Julian Date)\n    DataGPSSec = TotalSim.GetLogVariableData('SpiceInterfaceData.GPSSeconds')\n    DataJD = TotalSim.GetLogVariableData('SpiceInterfaceData.julianDateCurrent')\n\n    # Get parametrized date from DatePlot\n    year = \"\".join((\"20\", DatePlot[6:8]))\n    date = datetime.datetime( int(year), int(DatePlot[0:2]), int(DatePlot[3:5]))\n\n    testPlottingFixture.Date = DatePlot[0:8]\n\n    # Get the GPS time\n    date2 = datetime.datetime(1980, 0o1, 6)  # Start of GPS time\n    timeDiff = date-date2  # Time in days since GPS time\n    GPSTimeSeconds = timeDiff.days*86400\n\n    # Get the Julian day\n    JulianStartDate = date.toordinal()+1721424.5\n\n    #\n    # Begin testing module results to truth values\n    #\n\n    # Truth values\n    # For Time delta check\n    GPSRow = DataGPSSec[0, :]\n    InitDiff = GPSRow[1] - GPSRow[0] * 1.0E-9\n    i = 1\n\n    # Compare the GPS seconds values\n    AllowTolerance = 1E-6\n    while i < DataGPSSec.shape[0]:\n        if date.isoweekday() == 7:  # Skip test on Sundays, because it's the end of a GPS week (seconds go to zero)\n            i += 1\n        else:\n            GPSRow = DataGPSSec[i, :]\n            CurrDiff = GPSRow[1] - GPSRow[0] * 1.0E-9\n            if abs(CurrDiff - InitDiff) > AllowTolerance:\n                testFailCount += 1\n                testMessages.append(\"FAILED: Time delta check failed with difference of: %(DiffVal)f \\n\"% \\\n                                {\"DiffVal\": CurrDiff - InitDiff})\n            i += 1\n\n    # Truth values\n    # For absolute GPS time check\n    if date > datetime.datetime(2015, 0o6, 30):  # Taking into account the extra leap second added on 6/30/2015\n        GPSEndTime = GPSTimeSeconds + 17 + 60.0 - 68.184  # 17 GPS skip seconds passed that date\n    else:\n        GPSEndTime = GPSTimeSeconds + 16 + 60.0 - 67.184  # 16 GPS skip seconds before\n\n    GPSWeek = int(GPSEndTime / (86400 * 7))\n    GPSSecondAssumed = GPSEndTime - GPSWeek * 86400 * 7\n    GPSSecDiff = abs(GPSRow[1] - GPSSecondAssumed)\n\n    # TestResults['GPSAbsTimeCheck'] = True\n    AllowTolerance = 1E-4\n    if useMsg:\n        AllowTolerance = 2E-2\n    # Skip test days that are Sunday because of the end of a GPS week\n    if date.isoweekday() != 7 and GPSSecDiff > AllowTolerance:\n        testFailCount += 1\n        testMessages.append(\"FAILED: Absolute GPS time check failed with difference of: %(DiffVal)f \\n\" % \\\n                            {\"DiffVal\": GPSSecDiff})\n\n    # Truth values\n    # For absolute Julian date time check\n    if date>datetime.datetime(2015, 0o6, 30):  # Taking into account the extra leap second added on 6/30/2015\n        JDEndTime = JulianStartDate + 0.0006944440 - 68.184 / 86400\n    else:\n        JDEndTime = JulianStartDate + 0.0006944440 - 67.184 / 86400\n\n    # Simulated values\n    JDEndSim = DataJD[i - 1, 1]\n    JDTimeErrorAllow = 0.1 / (24.0 * 3600.0)\n    if abs(JDEndSim - JDEndTime) > JDTimeErrorAllow:\n        testFailCount += 1\n        testMessages.append(\"FAILED: Absolute Julian Date time check failed with difference of: %(DiffVal)f \\n\" % \\\n                            {\"DiffVal\": abs(JDEndSim - JDEndTime)})\n\n    # Truth values\n    # For Mars position check\n    MarsPosEnd = numpy.array(MarsTruthPos)\n    MarsPosEnd = MarsPosEnd * 1000.0\n\n    # Get Simulated values\n    MarsPosVec = SpiceObject.planetStateOutMsgs[1].read().PositionVector\n\n    # Compare Mars position values\n    MarsPosArray = numpy.array([MarsPosVec[0], MarsPosVec[1], MarsPosVec[2]])\n    MarsPosDiff = MarsPosArray - MarsPosEnd\n    PosDiffNorm = numpy.linalg.norm(MarsPosDiff)\n\n    # Plot Mars position values\n    testPlottingFixture.MarsPosErr = PosDiffNorm\n\n    # Test Mars position values\n    PosErrTolerance = 250\n    if useMsg:\n        PosErrTolerance = 1000\n    if (PosDiffNorm > PosErrTolerance):\n        testFailCount += 1\n        testMessages.append(\"FAILED: Mars position check failed with difference of: %(DiffVal)f \\n\" % \\\n                            {\"DiffVal\": PosDiffNorm})\n\n    # Truth values\n    # For Earth position check\n    EarthPosEnd = numpy.array(EarthTruthPos)\n    EarthPosEnd = EarthPosEnd * 1000.0\n\n    # Simulated Earth position values\n    EarthPosVec = SpiceObject.planetStateOutMsgs[0].read().PositionVector\n\n    # Compare Earth position values\n    EarthPosArray = numpy.array([EarthPosVec[0], EarthPosVec[1], EarthPosVec[2]])\n    EarthPosDiff = EarthPosArray - EarthPosEnd\n    PosDiffNorm = numpy.linalg.norm(EarthPosDiff)\n\n    # Plot Earth position values\n    testPlottingFixture.EarthPosErr = PosDiffNorm\n\n    # TestResults['EarthPosCheck'] = True\n    if (PosDiffNorm > PosErrTolerance):\n        testFailCount += 1\n        testMessages.append(\"FAILED: Earth position check failed with difference of: %(DiffVal)f \\n\" % \\\n                            {\"DiffVal\": PosDiffNorm})\n\n    # Truth Sun position values\n    SunPosEnd = numpy.array(SunTruthPos)\n    SunPosEnd = SunPosEnd * 1000.0\n\n    #Simulated Sun position values\n    SunPosVec = SpiceObject.planetStateOutMsgs[2].read().PositionVector\n\n    # Compare Sun position values\n    SunPosArray = numpy.array([SunPosVec[0], SunPosVec[1], SunPosVec[2]])\n    SunPosDiff = SunPosArray - SunPosEnd\n    PosDiffNorm = numpy.linalg.norm(SunPosDiff)\n\n    # plot Sun position values\n    testPlottingFixture.SunPosErr = PosDiffNorm\n\n    # Test Sun position values\n    if (PosDiffNorm > PosErrTolerance):\n        testFailCount += 1\n        testMessages.append(\"FAILED: Sun position check failed with difference of: %(DiffVal)f \\n\" % \\\n                            {\"DiffVal\": PosDiffNorm})\n\n    if date == datetime.datetime(2016,12,20): # Only test the false files on the last test\n\n        # Test non existing directory\n        SpiceObject.SPICEDataPath = \"ADirectoryThatDoesntreallyexist\"\n        SpiceObject.SPICELoaded = False\n\n        # TotalSim.ConfigureStopTime(int(1E9)) #Uncomment these 3 lines to test false directory\n        # TotalSim.InitializeSimulation()\n        # TotalSim.ExecuteSimulation()\n\n        # Test overly long planet name\n        SpiceObject.SPICEDataPath = \"\"\n        SpiceObject.SPICELoaded = False\n        # Uncomment these 4 lines to test false planet names\n        # SpiceObject.addPlanetNames(spiceInterface.StringVector([\"earth\", \"mars\", \"sun\",\n        #                                                     \"thisisaplanetthatisntreallyanythingbutIneedthenametobesolongthatIhitaninvalidconditioninmycode\"]))\n        # TotalSim.ConfigureStopTime(int(1E9))\n        # TotalSim.InitializeSimulation()\n        # TotalSim.ExecuteSimulation()\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\" \\n PASSED \")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def __init__(self):\n        self.Date = []  # replace these with appropriate containers for the data to be stored for plotting\n        self.MarsPosErr = []\n        self.EarthPosErr = []\n        self.SunPosErr = []",
  "def plotData(self):\n        fig1 = plt.figure(1)\n        rect = fig1.patch\n        rect.set_facecolor('white')\n\n        plt.xticks(numpy.arange(len(self.Date)), self.Date)\n        plt.plot(self.MarsPosErr, 'r', label='Mars')\n        plt.plot(self.EarthPosErr, 'bs', label='Earth')\n        plt.plot(self.SunPosErr, 'yo', label='Sun')\n\n        plt.rc('font', size=50)\n        plt.legend(loc='upper left')\n        fig1.autofmt_xdate()\n        plt.xlabel('Date of test')\n        plt.ylabel('Position Error [m]')\n        plt.show()",
  "def giveData(self):\n        plt.figure(1)\n        plt.close(1)\n        fig1 = plt.figure(1, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n\n        plt.xticks(numpy.arange(len(self.Date)), self.Date)\n        plt.plot(self.MarsPosErr, 'r', label='Mars')\n        plt.plot(self.EarthPosErr, 'b', label='Earth')\n        plt.plot(self.SunPosErr, 'y', label='Sun')\n\n        plt.legend(loc='upper left')\n        fig1.autofmt_xdate()\n        plt.xlabel('Date of test')\n        plt.ylabel('Position Error [m]')\n\n        return plt",
  "def test_module(show_plots, param1, param2, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    Compose a general description of what is being tested in this unit test script.  Add enough information so the\n    reader understands the purpose and limitations of the test.  As this test script is not parameterized, only one\n    version of this script will run.  Note that the ``pytest`` HTML report will list each parameterized test case\n    individually.  This way it is clear what set of parameters passed.  But, this also means that this doc-string\n    content will be copied into each report so each test description is individually complete.  If there is a\n    discussion you want to include that is specific to the a parameterized test case, then include this at the\n    end of the file with a conditional print() statement that only executes for that particular parameterized test.\n\n    **Test Parameters**\n\n    As this is a parameterized unit test, note that the test case parameters values are shown automatically in the\n    pytest HTML report.  This sample script has the parameters param1 and param 2.  Provide a description of what\n    each parameter controls.  This is a convenient location to include the accuracy variable used in the\n    validation test.\n\n    Args:\n        param1 (int): Dummy test parameter for this parameterized unit test\n        param2 (int): Dummy test parameter for this parameterized unit test\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    Here discuss what parameters are being checked.  For example, in this file we are checking the values of the\n    variables\n\n    - ``dummy``\n    - ``dataVector[3]``\n\n    **Figure Discussion**\n\n    If the test script produces figures you might include a brief discussion on what the simulation results show.\n    Discuss why these results validate the operation of the BSK module.\n\n    **General Documentation Comments**\n\n    If the script generates figures, these figures will be automatically pulled from ``matplotlib`` and included below.\n    Make sure that the figures have appropriate axes labels and a figure title if needed.  The figures content\n    should be understood by just looking at the figure.\n\n    At the end of the script where a print statement says that the script passes.\n\n    Don't use any of the AutoTeX methods we used to use as the goal is to have all the validation reporting\n    contained within this HTML ``pytest`` report.\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = fswModuleTestFunction(show_plots, param1, param2, accuracy)\n    assert testResults < 1, testMessage",
  "def fswModuleTestFunction(show_plots, param1, param2, accuracy):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = cModuleTemplate.cModuleTemplate()\n    module.ModelTag = \"cModuleTemplate\"                                        # update python name of test module\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.dummy = 1                              # update module parameter with required values\n    module.dumVector = [1., 2., 3.]\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    inputMessageData = messaging.CModuleTemplateMsgPayload() # Create a structure for the input message\n    inputMessageData.dataVector = [param1, param2, 0.7]       # Set up a list as a 3-vector\n    inputMsg = messaging.CModuleTemplateMsg().write(inputMessageData)\n    module.dataInMsg.subscribeTo(inputMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.dataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    variableName = \"dummy\"                              # name the module variable to be logged\n    unitTestSim.AddVariableForLogging(module.ModelTag + \".\" + variableName, testProcessRate)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # reset the module to test this functionality\n    module.Reset(1)     # this module reset function needs a time input (in NanoSeconds)\n\n    # run the module again for an additional 1.0 seconds\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n\n    # This pulls the BSK module internal varialbe log from the simulation run.\n    # Note, this should only be done for debugging as it is a slow process\n    variableState = unitTestSim.GetLogVariableData(module.ModelTag + \".\" + variableName)\n\n    # set the filtered output truth states\n    trueVector = []\n    if param1 == 1:\n        if param2 == 1:\n            trueVector = [\n                       [2.0, 1.0, 0.7],\n                       [3.0, 1.0, 0.7],\n                       [4.0, 1.0, 0.7],\n                       [2.0, 1.0, 0.7],\n                       [3.0, 1.0, 0.7]\n                       ]\n        else:\n            if param2 == 3:\n                trueVector = [\n                       [2.0, 3.0, 0.7],\n                       [3.0, 3.0, 0.7],\n                       [4.0, 3.0, 0.7],\n                       [2.0, 3.0, 0.7],\n                       [3.0, 3.0, 0.7]\n                       ]\n            else:\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + module.ModelTag\n                                    + \" Module failed with unsupported input parameters\")\n    else:\n        if param1 == 2:\n            trueVector = [\n                       [3.0, 2.0, 0.7],\n                       [4.0, 2.0, 0.7],\n                       [5.0, 2.0, 0.7],\n                       [3.0, 2.0, 0.7],\n                       [4.0, 2.0, 0.7]\n                       ]\n        else:\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed with unsupported input parameters\")\n\n    # compare the module results to the truth values\n    dummyTrue = [1.0, 2.0, 3.0, 1.0, 2.0]\n\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, dataLog.dataVector,\n                                                               accuracy, \"Output Vector\",\n                                                               testFailCount, testMessages)\n    variableState = np.transpose(variableState)[1]\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray(dummyTrue, variableState,\n                                                                     accuracy, \"dummy parameter\",\n                                                                     testFailCount, testMessages)\n\n    # Note that we can continue to step the simulation however we feel like.\n    # Just because we stop and query data does not mean everything has to stop for good\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.6))    # run an additional 0.6 seconds\n    unitTestSim.ExecuteSimulation()\n\n    # If the argument provided at commandline \"--show_plots\" evaluates as true,\n    # plot all figures\n    # plot a sample variable.\n    plt.close(\"all\")    # close all prior figures so we start with a clean slate\n    plt.figure(1)\n    plt.plot(dataLog.times()*macros.NANO2SEC, variableState,\n             label='Case param1 = ' + str(param1) + ' and param2 = ' + str(param2))\n    plt.legend(loc='upper left')\n    plt.xlabel('Time [s]')\n    plt.ylabel('Variable Description [unit]')\n    plt.suptitle('Title of Sample Plot')\n\n    plt.figure(2)\n    for idx in range(3):\n        plt.plot(dataLog.times() * macros.NANO2MIN, dataLog.dataVector[:, idx],\n                 color=unitTestSupport.getLineColor(idx, 3),\n                 label=r'$s_' + str(idx) + '$')\n    plt.legend(loc='lower right')\n    plt.xlabel('Time [min]')\n    plt.ylabel(r'Msg Output Vector States')\n\n    if show_plots:\n        plt.show()\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots):     # update \"module\" in this function name to reflect the module name\n    r\"\"\"\n    **Validation Test Description**\n\n    Compose a general description of what is being tested in this unit test script.  Add enough information so\n    the reader understands the purpose and limitations of the test.  As this test script is not parameterized, only\n    one version of this script will run.\n\n    **Description of Variables Being Tested**\n\n    Here discuss what parameters are being checked.  For example, in this file we are checking the values of the\n    variables\n\n    - ``dummy``\n    - ``dataVector[3]``\n\n    **General Documentation Comments**\n    \n    If the script generates figures, these figures will be automatically pulled from ``matplotlib`` and included below.\n    Make sure that the figures have appropriate axes labels and a figure title if needed.  The figures content\n    should be understood by just looking at the figure.\n\n    At the end of the script where a print statement says that the script passes, also add a print statement\n    saying what accuracy tolerance(s) were used.\n\n    Don't use any of the AutoTeX methods we used to use as the goal is to have all the validation reporting\n    contained within this HTML ``pytest`` report.\n    \"\"\"\n    # each test method requires a single assert method to be called\n    # pass on the testPlotFixture so that the main test function may set the DataStore attributes\n    [testResults, testMessage] = fswModuleTestFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def fswModuleTestFunction(show_plots):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = cModuleTemplate.cModuleTemplate()\n    module.ModelTag = \"cModuleTemplate\"           # update python name of test module\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.dummy = 1                              # update module parameter with required values\n    module.dumVector = [1., 2., 3.]\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    inputMessageData = messaging.CModuleTemplateMsgPayload()  # Create a structure for the input message\n    inputMessageData.dataVector = [1.0, -0.5, 0.7]             # Set up a list as a 3-vector\n    inputMsg = messaging.CModuleTemplateMsg().write(inputMessageData)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.dataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n    variableName = \"dummy\"                              # name the module variable to be logged\n    unitTestSim.AddVariableForLogging(module.ModelTag + \".\" + variableName, testProcessRate)\n\n    # connect the message interfaces\n    module.dataInMsg.subscribeTo(inputMsg)\n\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # reset the module to test this functionality\n    module.Reset(1)     # this module reset function needs a time input (in NanoSeconds)\n\n    # run the module again for an additional 1.0 seconds\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    variableState = unitTestSim.GetLogVariableData(module.ModelTag + \".\" + variableName)\n\n    # set the filtered output truth states\n    trueVector = [\n               [2.0, -0.5, 0.7],\n               [3.0, -0.5, 0.7],\n               [4.0, -0.5, 0.7],\n               [2.0, -0.5, 0.7],\n               [3.0, -0.5, 0.7]\n               ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    dummyTrue = [1.0, 2.0, 3.0, 1.0, 2.0]\n    variableStateNoTime = np.transpose(variableState)[1]\n    for i in range(0, len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.dataVector[i], trueVector[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed dataVector\" +\n                                \" unit test at t=\" +\n                                str(dataLog.times()[i]*macros.NANO2SEC) +\n                                \"sec\\n\")\n\n        # check a scalar double value\n        if not unitTestSupport.isDoubleEqual(variableStateNoTime[i], dummyTrue[i], accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed \" +\n                                variableName + \" unit test at t=\" +\n                                str(variableState[i, 0]*macros.NANO2SEC) +\n                                \"sec\\n\")\n\n    # Note that we can continue to step the simulation however we feel like.\n    # Just because we stop and query data does not mean everything has to stop for good\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.6))    # run an additional 0.6 seconds\n    unitTestSim.ExecuteSimulation()\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n        print(\"This test uses an accuracy value of \" + str(accuracy))\n    else:\n        print(\"FAILED \" + module.ModelTag)\n        print(testMessages)\n\n    plt.close(\"all\")  # close all prior figures so we start with a clean slate\n    plt.figure(1)\n    plt.plot(variableState[:, 0] * macros.NANO2SEC, variableState[:, 1])\n    plt.xlabel('Time [s]')\n    plt.ylabel('Variable Description [unit]')\n    plt.suptitle('Title of Sample Plot')\n\n    plt.figure(2)\n    for idx in range(3):\n        plt.plot(dataLog.times() * macros.NANO2MIN, dataLog.dataVector[:, idx],\n                 color=unitTestSupport.getLineColor(idx, 3),\n                 label=r'$s_' + str(idx) + '$')\n    plt.legend(loc='lower right')\n    plt.xlabel('Time [min]')\n    plt.ylabel(r'Msg Output Vector States')\n\n    if show_plots:\n        plt.show()\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, param1, param2, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    Compose a general description of what is being tested in this unit test script.  Add enough information so the\n    reader understands the purpose and limitations of the test.  As this test script is not parameterized, only one\n    version of this script will run.  Note that the ``pytest`` HTML report will list each parameterized test case\n    individually.  This way it is clear what set of parameters passed.  But, this also means that this doc-string\n    content will be copied into each report so each test description is individually complete.  If there is a\n    discussion you want to include that is specific to the a parameterized test case, then include this at the\n    end of the file with a conditional print() statement that only executes for that particular parameterized test.\n\n    **Test Parameters**\n\n    As this is a parameterized unit test, note that the test case parameters values are shown automatically in the\n    pytest HTML report.  This sample script has the parameters param1 and param 2.  Provide a description of what\n    each parameter controls.  This is a convenient location to include the accuracy variable used in the\n    validation test.\n\n    Args:\n        param1 (int): Dummy test parameter for this parameterized unit test\n        param2 (int): Dummy test parameter for this parameterized unit test\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    Here discuss what parameters are being checked.  For example, in this file we are checking the values of the\n    variables\n\n    - ``dummy``\n    - ``dataVector[3]``\n\n    **Figure Discussion**\n\n    If the test script produces figures you might include a brief discussion on what the simulation results show.\n    Discuss why these results validate the operation of the BSK module.\n\n    **General Documentation Comments**\n\n    If the script generates figures, these figures will be automatically pulled from ``matplotlib`` and included below.\n    Make sure that the figures have appropriate axes labels and a figure title if needed.  The figures content\n    should be understood by just looking at the figure.\n\n    At the end of the script where a print statement says that the script passes.\n\n    Don't use any of the AutoTeX methods we used to use as the goal is to have all the validation reporting\n    contained within this HTML ``pytest`` report.\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = cppModuleTestFunction(show_plots, param1, param2, accuracy)\n    assert testResults < 1, testMessage",
  "def cppModuleTestFunction(show_plots, param1, param2, accuracy):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = cppModuleTemplate.CppModuleTemplate()   # update with current values\n    module.ModelTag = \"cppModuleTemplate\"            # update python name of test module\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.dummy = 1                              # update module parameter with required values\n    module.dumVector = [1., 2., 3.]\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    inputMessageData = messaging.CModuleTemplateMsgPayload() # Create a structure for the input message\n    inputMessageData.dataVector = [param1, param2, 0.7]       # Set up a list as a 3-vector\n    inputMsg = messaging.CModuleTemplateMsg().write(inputMessageData)\n    module.dataInMsg.subscribeTo(inputMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.dataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    variableName = \"dummy\"                              # name the module variable to be logged\n    unitTestSim.AddVariableForLogging(module.ModelTag + \".\" + variableName, testProcessRate)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # reset the module to test this functionality\n    module.Reset(1)     # this module reset function needs a time input (in NanoSeconds)\n\n    # run the module again for an additional 1.0 seconds\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n\n    # This pulls the BSK module internal varialbe log from the simulation run.\n    # Note, this should only be done for debugging as it is a slow process\n    variableState = unitTestSim.GetLogVariableData(module.ModelTag + \".\" + variableName)\n\n    # set the filtered output truth states\n    trueVector = []\n    if param1 == 1:\n        if param2 == 1:\n            trueVector = [\n                       [2.0, 1.0, 0.7],\n                       [3.0, 1.0, 0.7],\n                       [4.0, 1.0, 0.7],\n                       [2.0, 1.0, 0.7],\n                       [3.0, 1.0, 0.7]\n                       ]\n        else:\n            if param2 == 3:\n                trueVector = [\n                       [2.0, 3.0, 0.7],\n                       [3.0, 3.0, 0.7],\n                       [4.0, 3.0, 0.7],\n                       [2.0, 3.0, 0.7],\n                       [3.0, 3.0, 0.7]\n                       ]\n            else:\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + module.ModelTag\n                                    + \" Module failed with unsupported input parameters\")\n    else:\n        if param1 == 2:\n            trueVector = [\n                       [3.0, 2.0, 0.7],\n                       [4.0, 2.0, 0.7],\n                       [5.0, 2.0, 0.7],\n                       [3.0, 2.0, 0.7],\n                       [4.0, 2.0, 0.7]\n                       ]\n        else:\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed with unsupported input parameters\")\n\n    # compare the module results to the truth values\n    dummyTrue = [1.0, 2.0, 3.0, 1.0, 2.0]\n\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, dataLog.dataVector,\n                                                               accuracy, \"Output Vector\",\n                                                               testFailCount, testMessages)\n    variableState = np.transpose(variableState)[1]\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray(dummyTrue, variableState,\n                                                                     accuracy, \"dummy parameter\",\n                                                                     testFailCount, testMessages)\n\n    # Note that we can continue to step the simulation however we feel like.\n    # Just because we stop and query data does not mean everything has to stop for good\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.6))    # run an additional 0.6 seconds\n    unitTestSim.ExecuteSimulation()\n\n    # If the argument provided at commandline \"--show_plots\" evaluates as true,\n    # plot all figures\n    # plot a sample variable.\n    plt.close(\"all\")    # close all prior figures so we start with a clean slate\n    plt.figure(1)\n    plt.plot(dataLog.times()*macros.NANO2SEC, variableState,\n             label='Case param1 = ' + str(param1) + ' and param2 = ' + str(param2))\n    plt.legend(loc='upper left')\n    plt.xlabel('Time [s]')\n    plt.ylabel('Variable Description [unit]')\n    plt.suptitle('Title of Sample Plot')\n\n    plt.figure(2)\n    for idx in range(3):\n        plt.plot(dataLog.times() * macros.NANO2MIN, dataLog.dataVector[:, idx],\n                 color=unitTestSupport.getLineColor(idx, 3),\n                 label=r'$s_' + str(idx) + '$')\n    plt.legend(loc='lower right')\n    plt.xlabel('Time [min]')\n    plt.ylabel(r'Msg Output Vector States')\n\n    if show_plots:\n        plt.show()\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, image, saveImage):\n    \"\"\"\n    Unit test for CNN module for radius and center finding. Each parameter reads a different image.\n    They are both images of Mars, and were not in the training data.\n\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = cnnTest(show_plots, image, saveImage)\n    assert testResults < 1, testMessage",
  "def cnnTest(show_plots, image, saveImage):\n\n    # Truth values from python\n    imagePath = path + '/' + image\n    input_image = Image.open(imagePath)\n    input_image.load()\n    #################################################\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = centerRadiusCNN.CenterRadiusCNN()\n    module.ModelTag = \"cnn\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    module.pathToNetwork = path + \"/../CAD.onnx\"\n    module.filename = imagePath\n    module.pixelNoise = [5,5,5]\n\n    circles = []\n    if image == \"mars.jpg\":\n        circles = [(254.81655883789062, 263.2418518066406, 120.9570541381836)]\n    if image == \"mars2.jpg\":\n        circles = [(269.21127319, 231.63162231, 144.85394287)]\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.opnavCirclesOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    centers = dataLog.circlesCenters[:, :10*2]\n    radii = dataLog.circlesRadii[:, :10]\n\n    # Output image:\n    output_image = Image.new(\"RGB\", input_image.size)\n    output_image.paste(input_image)\n    draw_result = ImageDraw.Draw(output_image)\n\n    imageProcCircles = []\n    for j in range(len(radii[-1, 0:])):\n        if radii[-1,j] > 0:\n            imageProcCircles.append((centers[-1, 2*j], centers[-1, 2*j+1], radii[-1, j]))\n    for x, y, r in imageProcCircles:\n        draw_result.ellipse((x - r, y - r, x + r, y + r), outline=(255, 0, 0, 0))\n\n    # Save output image\n    if saveImage:\n        output_image.save(\"result_\"+ image)\n\n    if show_plots:\n        print(imageProcCircles[0])\n        output_image.show()\n\n\n    #   print out success message if no error were found\n    for testCircle, refCircle in zip(imageProcCircles, circles):\n        for i in range(3):\n            if np.abs((testCircle[i] - refCircle[i])/refCircle[i])>1:\n                testFailCount+=1\n                testMessages.append(\"Test failed processing \" + image)\n\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def back_substitution(A, b):\n    n = b.size\n    x = np.zeros_like(b)\n\n    if A[-1, -1] == 0:\n        raise ValueError\n\n    x[-1] = b[-1]/ A[-1, -1]\n    for i in range(n-2, -1, -1):\n        sum=0\n        for j in range(i, n):\n            sum += A[i, j]*x[j]\n        x[i] = (b[i] - sum)/A[i,i]\n    return x",
  "def test_horizonOpNav():\n    \"\"\"\n    Unit test for Horizon Navigation. The unit test specifically covers:\n\n        1. Individual methods: This module contains a back substitution method as well as a QR decomposition.\n            This test ensures that they are working properly with a direct test of the method input/outputs with\n            expected results\n\n        2. State and Covariances: This unit test also computes the state estimate and covariance in python. This is\n            compared directly to the output from the module for exact matching.\n\n    The Horizon Nav module gives the spacecraft position given a limb input. This test ensures that the results are as\n    expected both for the state estimate and the covariance associated with the measurement.\n    \"\"\"\n    [testResults, testMessage] = horizonOpNav_methods()\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = horizonOpNav_update()\n    assert testResults < 1, testMessage",
  "def horizonOpNav_methods():\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    ###################################################################################\n    ## Testing QR decomp\n    ###################################################################################\n    Hinput = np.array([[1,2,3],[1,20,3],[3,0,1],[2,1,0],[20,-1, -5],[0,10,-5]])\n    numStates = np.shape(Hinput)[0]\n    # Fill in the variables for the test\n    Qin = horizonOpNav.new_doubleArray(3 * numStates)\n    Rin = horizonOpNav.new_doubleArray(3 * 3)\n    Hin = horizonOpNav.new_doubleArray(numStates * 3)\n    for j in range(numStates*3):\n        horizonOpNav.doubleArray_setitem(Qin, j, 0)\n    for j in range(3 * 3):\n        horizonOpNav.doubleArray_setitem(Rin, j, 0)\n    for j in range(numStates * 3):\n        horizonOpNav.doubleArray_setitem(Hin, j, Hinput.flatten().tolist()[j])\n    horizonOpNav.QRDecomp(Hin, numStates, Qin, Rin)\n\n    Qout = []\n    for j in range(3 * numStates):\n        Qout.append(horizonOpNav.doubleArray_getitem(Qin, j))\n    Rout = []\n    for j in range(3 * 3):\n        Rout.append(horizonOpNav.doubleArray_getitem(Rin, j))\n\n    q,r = np.linalg.qr(Hinput)\n\n    Rpy = np.zeros([3,3])\n    Qpy = np.zeros([numStates, 3])\n    for i in range(0,3):\n        Qpy[:,i] = Hinput[:,i]\n        for j in range(i):\n            Rpy[j,i] = np.dot(Qpy[:,j], Hinput[:,i])\n            Qpy[:,i]= Qpy[:,i] - Rpy[j,i]*Qpy[:,j]\n        Rpy[i,i] = np.linalg.norm(Qpy[:,i])\n        Qpy[:,i] = 1 / Rpy[i,i] *  Qpy[:,i]\n\n\n    Qtest = np.array(Qout).reshape([numStates,3])\n    Rtest = np.array(Rout).reshape(3, 3)\n    errorNorm1 = np.linalg.norm(Qpy - Qtest)\n    errorNorm2 = np.linalg.norm(Rpy - Rtest)\n    if (errorNorm1 > 1.0E-10):\n        print(errorNorm1, \"QR decomp\")\n        testFailCount += 1\n        testMessages.append(\"QR decomp Failure in Q\" + \"\\n\")\n    if (errorNorm2 > 1.0E-10):\n        print(errorNorm2, \"QR decomp\")\n        testFailCount += 1\n        testMessages.append(\"QR decomp Failure in R\" + \"\\n\")\n    errorNorm1 = np.linalg.norm(q + Qtest)\n    errorNorm2 = np.linalg.norm(r[:3,:3] + Rtest)\n    if (errorNorm1 > 1.0E-10):\n        print(errorNorm1, \"QR decomp\")\n        testFailCount += 1\n        testMessages.append(\"QR decomp Failure in Q\" + \"\\n\")\n    if (errorNorm2 > 1.0E-10):\n        print(errorNorm2, \"QR decomp\")\n        testFailCount += 1\n        testMessages.append(\"QR decomp Failure in R\" + \"\\n\")\n\n    ###################################################################################\n    ## Testing Back Sub\n    ###################################################################################\n    V = np.ones(3)\n    nIn = horizonOpNav.new_doubleArray(3)\n    VIn = horizonOpNav.new_doubleArray(3)\n    RIn = horizonOpNav.new_doubleArray(numStates*3)\n    for i in range(3):\n        horizonOpNav.doubleArray_setitem(nIn, i, 0.0)\n    for i in range(3*3):\n        horizonOpNav.doubleArray_setitem(RIn, i, r.flatten().tolist()[i])\n    for i in range(3):\n        horizonOpNav.doubleArray_setitem(VIn, i, V.flatten().tolist()[i])\n\n    horizonOpNav.BackSub(RIn, VIn, 3, nIn)\n    BackSubOut = []\n    for i in range(3):\n        BackSubOut.append(horizonOpNav.doubleArray_getitem(nIn, i))\n\n    exp = back_substitution(r[:3,:3], V)\n\n    BackSubOut = np.array(BackSubOut)\n    errorNorm = np.linalg.norm(exp - BackSubOut)\n    if(errorNorm > 1.0E-10):\n        print(errorNorm, \"BackSub\")\n        testFailCount += 1\n        testMessages.append(\"BackSub Failure \" + \"\\n\")\n\n    return [testFailCount, ''.join(testMessages)]",
  "def horizonOpNav_update():\n    # Create a sim module as an empty container\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))  # Add a new task to the process\n\n    # Construct the ephemNavConverter module\n    # Set the names for the input messages\n    opNav = horizonOpNav.horizonOpNav()\n    opNav.noiseSF = 2\n    # ephemNavConfig.outputState = simFswInterfaceMessages.NavTransIntMsg()\n\n    # This calls the algContain to setup the selfInit, update, and reset\n    opNav.ModelTag = \"limbNav\"\n\n    # Add the module to the task\n    unitTestSim.AddModelToTask(unitTaskName, opNav)\n\n    # These are example points for fitting used from an image processing algorithm\n    inputPoints = [226., 113., 227., 113., 223., 114., 224., 114., 225., 114., 219.,\n       115., 220., 115., 221., 115., 222., 115., 215., 116., 216., 116.,\n       217., 116., 218., 116., 212., 117., 213., 117., 214., 117., 209.,\n       118., 210., 118., 211., 118., 205., 119., 206., 119., 207., 119.,\n       208., 119., 204., 120., 205., 120., 201., 121., 202., 121., 203.,\n       121., 199., 122., 200., 122., 197., 123., 198., 123., 195., 124.,\n       196., 124., 193., 125., 194., 125., 191., 126., 192., 126., 189.,\n       127., 190., 127., 187., 128., 188., 128., 185., 129., 186., 129.,\n       183., 130., 184., 130., 181., 131., 182., 131., 180., 132., 181.,\n       132., 178., 133., 179., 133., 177., 134., 178., 134., 175., 135.,\n       176., 135., 174., 136., 175., 136., 172., 137., 173., 137., 171.,\n       138., 172., 138., 170., 139., 171., 139., 168., 140., 169., 140.,\n       167., 141., 168., 141., 166., 142., 167., 142., 164., 143., 165.,\n       143., 163., 144., 164., 144., 162., 145., 163., 145., 161., 146.,\n       162., 146., 160., 147., 161., 147., 159., 148., 160., 148., 158.,\n       149., 159., 149., 156., 150., 157., 150., 155., 151., 156., 151.,\n       154., 152., 155., 152., 153., 153., 154., 153., 153., 154., 152.,\n       155., 151., 156., 152., 156., 150., 157., 151., 157., 149., 158.,\n       150., 158., 148., 159., 149., 159., 147., 160., 148., 160., 146.,\n       161., 147., 161., 145., 162., 146., 162., 145., 163., 144., 164.,\n       143., 165., 144., 165., 142., 166., 143., 166., 142., 167., 141.,\n       168., 140., 169., 141., 169., 139., 170., 140., 170., 139., 171.,\n       138., 172., 137., 173., 138., 173., 137., 174., 136., 175., 135.,\n       176., 136., 176., 135., 177., 134., 178., 133., 179., 134., 179.,\n       133., 180., 132., 181., 132., 182., 131., 183., 131., 184., 130.,\n       185., 129., 186., 130., 186., 129., 187., 128., 188., 128., 189.,\n       127., 190., 127., 191., 126., 192., 126., 193., 125., 194., 125.,\n       195., 125., 196., 124., 197., 124., 198., 123., 199., 123., 200.,\n       122., 201., 122., 202., 122., 203., 121., 204., 120., 205., 121.,\n       205., 120., 206., 120., 207., 120., 208., 119., 209., 119., 210.,\n       119., 211., 118., 212., 118., 213., 118., 214., 117., 215., 117.,\n       216., 117., 217., 117., 218., 116., 219., 116., 220., 116., 221.,\n       116., 222., 115., 223., 115., 224., 115., 225., 115., 226., 114.,\n       227., 114., 228., 114., 229., 114., 230., 114., 231., 114., 232.,\n       113., 233., 113., 234., 113., 235., 113., 236., 113., 237., 113.,\n       238., 113., 239., 112., 240., 112., 241., 112., 242., 112., 243.,\n       112., 244., 112., 245., 112., 246., 112., 247., 112., 248., 112.,\n       249., 112., 250., 112., 251., 112., 252., 112., 253., 112., 254.,\n       111., 255., 111., 256., 112., 257., 112., 258., 112., 259., 112.,\n       260., 112., 261., 112., 262., 112., 263., 112., 264., 112., 265.,\n       112., 266., 112., 267., 112., 268., 112., 269., 112., 270., 112.,\n       271., 113., 272., 113., 273., 113., 274., 113., 275., 113., 276.,\n       113., 277., 113., 278., 114., 279., 114., 280., 114., 281., 114.,\n       282., 114., 283., 114., 284., 115., 285., 115., 286., 115., 287.,\n       115., 288., 116., 289., 116., 290., 116., 291., 116., 292., 117.,\n       293., 117., 294., 117., 295., 117., 296., 118., 297., 118., 298.,\n       118., 299., 119., 300., 119., 301., 119., 302., 120., 303., 120.,\n       304., 120., 305., 121., 306., 121., 307., 122., 308., 122., 309.,\n       122., 310., 123., 311., 123., 312., 124., 313., 124., 314., 125.,\n       315., 125., 316., 125., 317., 126., 318., 126., 319., 127., 320.,\n       127., 321., 128., 322., 128., 323., 129., 324., 129., 325., 130.,\n       325., 130., 326., 131., 327., 131., 328., 132., 329., 132., 330.,\n       133., 331., 133., 332., 134., 332., 134., 333., 135., 334., 135.,\n       335., 136., 335., 136., 336., 137., 337., 137., 338., 138., 338.,\n       138., 339., 139., 340., 139., 341., 140., 341., 140., 342., 141.,\n       342., 141., 343., 142., 344., 142., 345., 143., 345., 143., 346.,\n       144., 346., 144., 347., 145., 348., 145., 349., 146., 349., 146.,\n       350., 147., 350., 147., 351., 148., 351., 148., 352., 149., 352.,\n       149., 353., 150., 353., 150., 354., 151., 354., 151., 355., 152.,\n       356., 152., 357., 153., 357., 153., 358., 154., 358., 154., 359.,\n       155., 359., 155., 360., 156., 360., 156., 361., 157., 361., 158.,\n       362., 159., 362., 159., 363., 160., 363., 160., 364., 161., 364.,\n       161., 365., 162., 365., 162., 366., 163., 366., 163., 367., 164.,\n       367., 164., 368., 165., 368., 166., 369., 167., 369., 167., 370.,\n       168., 370., 168., 371., 169., 371., 169., 372., 170., 372., 171.,\n       373., 172., 373., 172., 374., 173., 374., 174., 375., 175., 375.,\n       175., 376., 176., 376., 177., 377., 178., 377., 178., 378., 179.,\n       378., 180., 379., 181., 379., 181., 380., 182., 380., 183., 381.,\n       184., 381., 185., 382., 186., 382., 187., 383., 188., 383., 188.,\n       384., 189., 384., 190., 385., 191., 385., 192., 386.]\n\n    # Create the input messages.\n    inputCamera = messaging.CameraConfigMsgPayload()\n    inputLimbMsg = messaging.OpNavLimbMsgPayload()\n    inputAtt = messaging.NavAttMsgPayload()\n\n    # Set camera\n    inputCamera.fieldOfView = 2.0 * np.arctan(10*1e-3 / 2.0 / 1. )  # 2*arctan(s/2 / f)\n    inputCamera.resolution = [512, 512]\n    inputCamera.sigma_CB = [1.,0.2,0.3]\n    camInMsg = messaging.CameraConfigMsg().write(inputCamera)\n    opNav.cameraConfigInMsg.subscribeTo(camInMsg)\n\n    # Set circles\n    inputLimbMsg.valid = 1\n    inputLimbMsg.limbPoints = inputPoints\n    inputLimbMsg.numLimbPoints = int(len(inputPoints)/2)\n    inputLimbMsg.timeTag = 12345\n    limbInMsg = messaging.OpNavLimbMsg().write(inputLimbMsg)\n    opNav.limbInMsg.subscribeTo(limbInMsg)\n\n\n    # Set attitude\n    inputAtt.sigma_BN = [0.6, 1., 0.1]\n    attInMsg = messaging.NavAttMsg().write(inputAtt)\n    opNav.attInMsg.subscribeTo(attInMsg)\n\n\n    # Set module for Mars\n    opNav.planetTarget = 2\n    dataLog = opNav.opNavOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n    # The result isn't going to change with more time. The module will continue to produce the same result\n    unitTestSim.ConfigureStopTime(testProcessRate)  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # Truth Vlaues\n    ############################\n    Q = np.eye(3)\n    B = np.zeros([3,3])\n    Q *= 1/(3396.19*1E3)  # km\n    # Q[2,2] = 1/(3376.2*1E3)\n\n    numPoints = int(len(inputPoints)/2)\n\n    CB = rbk.MRP2C(inputCamera.sigma_CB)\n    BN = rbk.MRP2C(inputAtt.sigma_BN)\n    CN = np.dot(CB,BN)\n    B = np.dot(Q, CN.T)\n\n    # Transf camera to meters\n    alpha =0\n    up = inputCamera.resolution[0] / 2\n    vp = inputCamera.resolution[1] / 2\n    pX = 2. * np.tan(inputCamera.fieldOfView * inputCamera.resolution[0] / inputCamera.resolution[1] / 2.0)\n    pY = 2. * np.tan(inputCamera.fieldOfView / 2.0)\n    d_x = inputCamera.resolution[0] / pX\n    d_y = inputCamera.resolution[1] / pY\n\n    transf = np.zeros([3,3])\n    transf[0, 0] = 1 / d_x\n    transf[1, 1] = 1 / d_y\n    transf[2, 2] = 1\n    transf[0, 1] = -alpha/(d_x*d_y)\n    transf[0, 2] = (alpha*vp - d_y*up)/ (d_x * d_y)\n    transf[1, 2] = -vp / (d_y)\n\n    s = np.zeros([numPoints,3])\n    sBar = np.zeros([numPoints,3])\n    sBarPrime = np.zeros([numPoints,3])\n    H = np.zeros([numPoints,3])\n    for i in range(numPoints):\n        s[i,:] = np.dot(transf, np.array([inputPoints[2*i], inputPoints[2*i+1], 1]))\n        sBar[i,:] = np.dot(B, s[i,:])\n        sBarPrime[i,:] = sBar[i,:]/np.linalg.norm(sBar[i,:])\n        H[i,:] = sBarPrime[i,:]\n\n    # QR H\n    Rpy = np.zeros([3,3])\n    Qpy = np.zeros([numPoints, 3])\n    for i in range(0,3):\n        Qpy[:,i] = H[:,i]\n        for j in range(i):\n            Rpy[j,i] = np.dot(Qpy[:,j], H[:,i])\n            Qpy[:,i]= Qpy[:,i] - Rpy[j,i]*Qpy[:,j]\n        Rpy[i,i] = np.linalg.norm(Qpy[:,i])\n        Qpy[:,i] = 1 / Rpy[i,i] *  Qpy[:,i]\n\n    errorNorm1 = np.linalg.norm(np.dot(Qpy, Rpy) - H)\n    if (errorNorm1 > 1.0E-8):\n        print(errorNorm1, \"QR decomp\")\n        testFailCount += 1\n        testMessages.append(\"QR decomp Failure in update test \" + \"\\n\")\n\n    # Back Sub\n    RHS = np.dot(Qpy.T, np.ones(numPoints))\n    n = back_substitution(Rpy, RHS)\n    n_test = np.dot(np.linalg.inv(Rpy), RHS)\n\n    R_s = (opNav.noiseSF*inputCamera.resolution[0]/(numPoints))**2/d_x**2*np.array([[1,0,0],[0,1,0],[0,0,0]])\n    R_s = np.dot(np.dot(B, R_s), B.T)\n    R_yInv = np.zeros([numPoints, numPoints])\n    for i in range(numPoints):\n        J = 1./np.linalg.norm(sBar[i,:])*np.dot(n, np.eye(3) - np.outer(sBarPrime[i,:], sBarPrime[i,:]))\n        temp = np.dot(R_s, J)\n        R_yInv[i,i] = 1./np.dot(temp, J)\n\n    Pn = np.linalg.inv(np.dot(np.dot(H.T, R_yInv),H))\n    F = -(np.dot(n,n) - 1)**(-0.5)*np.dot(np.linalg.inv(B), np.eye(3) - np.outer(n,n)/(np.dot(n,n)-1))\n    Covar_C_test = np.dot(np.dot(F, Pn), F.T)\n    errorNorm1 = np.linalg.norm(n_test - n)\n    if (errorNorm1 > 1.0E-8):\n        print(errorNorm1, \"Back Sub\")\n        testFailCount += 1\n        testMessages.append(\"Back Sub Failure in update test \" + \"\\n\")\n\n    r_BN_C = - (np.dot(n,n) - 1.)**(-0.5)*np.dot(np.linalg.inv(B), n)\n\n    posErr = 1e-3 #(m)\n    covarErr = 1e-5\n    unitTestSupport.writeTeXSnippet(\"toleranceValuePos\", str(posErr), path)\n    unitTestSupport.writeTeXSnippet(\"toleranceValueVel\", str(covarErr), path)\n\n    outputR = dataLog.r_BN_C\n    outputCovar = dataLog.covar_C\n    outputTime = dataLog.timeTag\n\n    for i in range(len(outputR[-1, 1:])):\n        if np.abs((r_BN_C[i] - outputR[0, i])/r_BN_C[i]) > posErr or np.isnan(outputR.any()):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Position Check in Horizon Nav for index \"+ str(i) + \" with error \" + str(np.abs((r_BN_C[i] - outputR[-1, i+1])/r_BN_C[i])))\n\n    for i in range(len(outputCovar[-1, 1:])):\n        if np.abs((Covar_C_test.flatten()[i] - outputCovar[0, i])/Covar_C_test.flatten()[i]) > covarErr or np.isnan(outputTime.any()):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Covar Check in Horizon Nav for index \"+ str(i) + \" with error \" + str(np.abs((Covar_C_test.flatten()[i] - outputCovar[-1, i+1]))))\n\n    snippentName = \"passFail\"\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + opNav.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + opNav.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n        print(testMessages)\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, image, blur, maxCircles , minDist , minRad, cannyLow, cannyHigh, dp, saveImage):\n    \"\"\"\n    Unit test for Hough Circles. The unit test specifically runs on 2 images:\n\n        1. A crescent Mars: This image only contains a slim Mars crescent\n\n        2. Moons: This image contains several Moon crescents\n\n    This modules compares directly to the expected circles from the images.\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = houghCirclesTest(show_plots, image, blur, maxCircles , minDist , minRad, cannyLow, cannyHigh, dp, saveImage)\n    assert testResults < 1, testMessage",
  "def houghCirclesTest(show_plots, image, blur, maxCircles , minDist , minRad, cannyLow, cannyHigh, dp, saveImage):\n\n    # Truth values from python\n    imagePath = path + '/' + image\n    input_image = Image.open(imagePath)\n    input_image.load()\n    #################################################\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm\n    module = houghCircles.HoughCircles()\n    module.ModelTag = \"houghCircles\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    module.filename = imagePath\n    module.expectedCircles = maxCircles\n    module.cannyThresh = cannyHigh\n    module.voteThresh = cannyLow\n    module.houghMinDist = minDist\n    module.houghMinRadius = minRad\n    module.blurrSize = blur\n    module.dpValue = dp\n    module.houghMaxRadius = int(input_image.size[0]/1.25)\n\n    circles = []\n    if image == \"mars.png\":\n        circles = [(250, 260, 110)]\n    if image == \"moons.png\":\n        circles = [(205, 155, 48.900001525878906), (590, 313, 46.29999923706055), (590, 165, 46.29999923706055), (400, 313, 43.79999923706055), (400, 151.5, 45), (210, 313, 45)]\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    inputMessageData = messaging.CameraImageMsgPayload()\n    inputMessageData.timeTag = int(1E9)\n    inputMessageData.cameraID = 1\n    imgInMsg = messaging.CameraImageMsg().write(inputMessageData)\n    module.imageInMsg.subscribeTo(imgInMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.opnavCirclesOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    centers = dataLog.circlesCenters\n    radii = dataLog.circlesRadii\n\n    # Output image:\n    output_image = Image.new(\"RGB\", input_image.size)\n    output_image.paste(input_image)\n    draw_result = ImageDraw.Draw(output_image)\n\n    imageProcCircles = []\n    for j in range(len(radii[-1,1:])):\n        if radii[-1,j] > 0:\n            imageProcCircles.append((centers[-1, 2*j], centers[-1, 2*j+1], radii[-1, j]))\n    for x, y, r in imageProcCircles:\n        draw_result.ellipse((x - r, y - r, x + r, y + r), outline=(255, 0, 0, 0))\n\n    # Save output image\n    if saveImage:\n        output_image.save(\"result_\"+ image)\n\n    if show_plots:\n        print(imageProcCircles[0])\n        output_image.show()\n\n\n    #   print out success message if no error were found\n    for testCircle, refCircle in zip(imageProcCircles, circles):\n        for i in range(3):\n            if np.abs((testCircle[i] - refCircle[i])/refCircle[i])>1:\n                testFailCount+=1\n                testMessages.append(\"Test failed processing \" + image)\n\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def mapState(state, planet, camera):\n    D = planet[\"diameter\"]\n\n    pX = 2. * np.tan(camera.fieldOfView * camera.resolution[0] / camera.resolution[1] / 2.0)\n    pY = 2. * np.tan(camera.fieldOfView/2.0)\n    d_x = pX/camera.resolution[0]\n    d_y = pY/camera.resolution[1]\n\n    A = 2 * np.arctan(state[2]*d_x)\n\n    norm = 0.5 * D/np.sin(0.5*A)\n    vec = np.array([state[0]*d_x, state[1]*d_y, 1.])\n    return norm*vec/np.linalg.norm(vec)",
  "def mapCovar(CovarXYR, rho, planet, camera):\n    D = planet[\"diameter\"]\n\n    pX = 2. * np.tan(camera.fieldOfView * camera.resolution[0] / camera.resolution[1] / 2.0)\n    pY = 2. * np.tan(camera.fieldOfView/2.0)\n    d_x = pX / camera.resolution[0]\n    d_y = pY / camera.resolution[1]\n\n    A = 2 * np.arctan(rho*d_x)\n\n    # rho_map = (0.33 * D * np.cos(A)/np.sin(A/2.)**2. * 2./f * 1./(1. + (rho/f)**2.) * (d_x/f) )\n    rho_map = 0.5*D*(-np.sqrt(1 + rho**2*d_x**2)/(rho**2*d_x) + d_x/(np.sqrt(1 + rho**2*d_x**2)))\n    x_map =   0.5 * D/np.sin(0.5*A)*(d_x)\n    y_map =  0.5 * D/np.sin(0.5*A)*(d_y)\n    CovarMap = np.array([[x_map,0.,0.],[0., y_map, 0.],[0.,0., rho_map]])\n    CoarIn = np.array(CovarXYR).reshape([3,3])\n    return np.dot(CovarMap, np.dot(CoarIn, CovarMap.T))",
  "def test_pixelLine_converter():\n    \"\"\" Test ephemNavConverter. \"\"\"\n    [testResults, testMessage] = pixelLineConverterTestFunction()\n    assert testResults < 1, testMessage",
  "def pixelLineConverterTestFunction():\n    \"\"\" Test the ephemNavConverter module. Setup a simulation \"\"\"\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))  # Add a new task to the process\n\n    # Construct the ephemNavConverter module\n    # Set the names for the input messages\n    pixelLine = pixelLineConverter.pixelLineConverter()\n\n    # This calls the algContain to setup the selfInit, update, and reset\n    pixelLine.ModelTag = \"pixelLineConverter\"\n\n    # Add the module to the task\n    unitTestSim.AddModelToTask(unitTaskName, pixelLine)\n\n    # Create the input messages.\n    inputCamera = messaging.CameraConfigMsgPayload()\n    inputCircles = messaging.OpNavCirclesMsgPayload()\n    inputAtt = messaging.NavAttMsgPayload()\n\n    # Set camera\n    inputCamera.fieldOfView = 2.0 * np.arctan(10*1e-3 / 2.0 / (1.*1e-3) )  # 2*arctan(s/2 / f)\n    inputCamera.resolution = [512, 512]\n    inputCamera.sigma_CB = [1., 0.3, 0.1]\n    camInMsg = messaging.CameraConfigMsg().write(inputCamera)\n    pixelLine.cameraConfigInMsg.subscribeTo(camInMsg)\n\n    # Set circles\n    inputCircles.circlesCenters = [152, 251]\n    inputCircles.circlesRadii = [75]\n    inputCircles.uncertainty = [0.5, 0., 0., 0., 0.5, 0., 0., 0., 1.]\n    inputCircles.timeTag = 12345\n    circlesInMsg = messaging.OpNavCirclesMsg().write(inputCircles)\n    pixelLine.circlesInMsg.subscribeTo(circlesInMsg)\n\n    # Set attitude\n    inputAtt.sigma_BN = [0.6, 1., 0.1]\n    attInMsg = messaging.NavAttMsg().write(inputAtt)\n    pixelLine.attInMsg.subscribeTo(attInMsg)\n\n    # Set module for Mars\n    pixelLine.planetTarget = 2\n\n    dataLog = pixelLine.opNavOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n    # The result isn't going to change with more time. The module will continue to produce the same result\n    unitTestSim.ConfigureStopTime(testProcessRate)  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # Truth Values\n    planet = {}\n    # camera = {}\n    planet[\"name\"] = \"Mars\"\n    planet[\"diameter\"] = 3396.19 * 2  # km\n\n    state = [inputCircles.circlesCenters[0], inputCircles.circlesCenters[1], inputCircles.circlesRadii[0]]\n\n    r_Cexp = mapState(state, planet, inputCamera)\n    covar_Cexp = mapCovar(inputCircles.uncertainty, state[2], planet, inputCamera)\n\n    dcm_CB = rbk.MRP2C(inputCamera.sigma_CB)\n    dcm_BN = rbk.MRP2C(inputAtt.sigma_BN)\n\n    dcm_NC = np.dot(dcm_CB, dcm_BN).T\n\n    r_Nexp = np.dot(dcm_NC, r_Cexp)\n    covar_Nexp = np.dot(dcm_NC, np.dot(covar_Cexp, dcm_NC.T)).flatten()\n    timTagExp = inputCircles.timeTag\n\n    posErr = 1e-10\n    covarErr = 1e-10\n    unitTestSupport.writeTeXSnippet(\"toleranceValuePos\", str(posErr), path)\n    unitTestSupport.writeTeXSnippet(\"toleranceValueVel\", str(covarErr), path)\n\n    outputR = dataLog.r_BN_N\n    outputCovar = dataLog.covar_N\n    outputTime = dataLog.timeTag\n    #\n    #\n    for i in range(len(outputR[-1, 1:])):\n        if np.abs(r_Nexp[i] - outputR[-1, i]) > 1E-10 and np.isnan(outputR.any()):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Position Check in pixelLine\")\n\n    for i in range(len(outputCovar[-1, 0:])):\n        if np.abs((covar_Nexp[i] - outputCovar[-1, i])) > 1E-10 and np.isnan(outputTime.any()):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Covar Check in pixelLine\")\n\n    if np.abs((timTagExp - outputTime[-1])/timTagExp) > 1E-10 and np.isnan(outputTime.any()):\n        testFailCount += 1\n        testMessages.append(\"FAILED: Time Check in pixelLine\")\n    #\n    #   print out success message if no error were found\n    snippentName = \"passFail\"\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + pixelLine.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + pixelLine.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, image, blur, cannyLow, cannyHigh, saveImage):\n    \"\"\"\n    Unit test for Limb Finding. The unit test specifically runs on 3 images:\n\n        1. A full Mars: This image has an easy to detect, full mars disk\n\n        2. A crescent Mars: This image only contains a slim Mars crescent\n\n        3. Moons: This image contains several Moon crescents\n\n    The Limb Finding module uses the Canny transform in order to find the planet limb. It then outputs all the points\n    on the limb.\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = limbFindingTest(show_plots, image, blur, cannyLow, cannyHigh, saveImage)\n    assert testResults < 1, testMessage",
  "def limbFindingTest(show_plots, image, blur, cannyLow, cannyHigh, saveImage):\n\n    # Truth values from python\n    imagePath = path + '/' + image\n    input_image = Image.open(imagePath)\n    input_image.load()\n    #################################################\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = limbFinding.LimbFinding()\n    module.ModelTag = \"limbFind\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    module.filename = imagePath\n    module.cannyThreshHigh = cannyHigh\n    module.cannyThreshLow = cannyLow\n    module.blurrSize = blur\n\n    reference = []\n    refPoints = 0\n    if image == \"MarsBright.jpg\":\n        reference = [253.0, 110.0]\n        refPoints = 2*475.0\n    if image == \"MarsDark.jpg\":\n        reference = [187.0, 128.0]\n        refPoints = 2*192.0\n    if image == \"moons.jpg\":\n        reference = [213.0, 66.0]\n        refPoints = 2*270.0\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    inputMessageData = messaging.CameraImageMsgPayload()\n    inputMessageData.timeTag = int(1E9)\n    inputMessageData.cameraID = 1\n    imageInMsg = messaging.CameraImageMsg().write(inputMessageData)\n    module.imageInMsg.subscribeTo(imageInMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.opnavLimbOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    valid = dataLog.valid\n    points = dataLog.limbPoints[:, :2*1000]\n    numPoints = dataLog.numLimbPoints\n\n    # Output image:\n    output_image = Image.new(\"RGB\", input_image.size)\n    output_image.paste(input_image)\n    draw_result = ImageDraw.Draw(output_image)\n\n    imageProcLimb = []\n    for j in range(int(len(points[-1,1:])/2)):\n        if points[-1,2*j]>1E-2:\n            imageProcLimb.append((points[-1,2*j], points[-1,2*j+1]))\n\n    draw_result.point(imageProcLimb, fill=128)\n\n    # Save output image\n    if saveImage:\n        output_image.save(\"result_\"+ image)\n\n    if show_plots:\n        output_image.show()\n\n\n    #   print out success message if no error were found\n    for i in range(2):\n        if np.abs((reference[i] - imageProcLimb[0][i])/reference[i])>1:\n            print(np.abs((reference[i] - imageProcLimb[0][i])/reference[i]))\n            testFailCount += 1\n            testMessages.append(\"Limb Test failed processing \" + image)\n    if valid[-1] != 1:\n        testFailCount += 1\n        testMessages.append(\"Validity test failed processing \" + image)\n    if np.abs(numPoints[-1]-refPoints)>10:\n        testFailCount += 1\n        testMessages.append(\"NumPoints test failed processing \" + image)\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Passed\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_thrustRWDesat():\n    \"\"\" Test thrustRWDesat. \"\"\"\n    [testResults, testMessage] = thrustRWDesatTestFunction()\n    assert testResults < 1, testMessage",
  "def thrustRWDesatTestFunction():\n    \"\"\" Test the thrustRWDesat module. Setup a simulation, \"\"\"\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # This is needed if multiple unit test scripts are run\n    # This create a fresh and consistent simulation environment for each test run\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))  # Add a new task to the process\n\n    # Construct the thrustRWDesat module\n    # Set the names for the input messages\n    module = thrustRWDesat.thrustRWDesat()\n\n    # Set the necessary data in the module. NOTE: This information is more or less random\n    module.thrFiringPeriod = .5 # The amount of time to rest between thruster firings [s]\n    module.DMThresh = 20 # The point at which to stop decrementing momentum [r/s]\n    module.currDMDir = [1, 0, 0] # The current direction of momentum reduction\n    module.maxFiring = 5 # Maximum time to fire a jet for [s]\n\n    # This calls the algContain to setup the selfInit, update, and reset\n    module.ModelTag = \"thrustRWDesat\"\n\n    # Add the module to the task\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    numRW = 3\n\n    inputRWConstellationMsg = messaging.RWConstellationMsgPayload()\n    inputRWConstellationMsg.numRW = numRW\n\n    # Initialize the msg that gives the speed of the reaction wheels\n    inputSpeedMsg = messaging.RWSpeedMsgPayload()\n\n    gsHat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n    # Iterate over all of the reaction wheels, create a rwConfigElementFswMsg, and add them to the rwConstellationFswMsg\n    rwConfigElementList = list()\n    for rw in range(numRW):\n        rwConfigElementMsg = messaging.RWConfigElementMsgPayload()\n        rwConfigElementMsg.gsHat_B = gsHat[rw]  # Spin axis unit vector of the wheel in structure # [1, 0, 0]\n        rwConfigElementMsg.Js = 0.08  # Spin axis inertia of wheel [kgm2]\n        rwConfigElementMsg.uMax = 0.2  # maximum RW motor torque [Nm]\n\n        # Add this to the list\n        rwConfigElementList.append(rwConfigElementMsg)\n\n    inputSpeedMsg.wheelSpeeds = [20, 10, 30] # The current angular velocities of the RW wheel\n\n    # Set the array of the reaction wheels in RWConstellationFswMsg to the list created above\n    inputRWConstellationMsg.reactionWheels = rwConfigElementList\n\n    # Initialize the msg that gives the mass properties. This just needs the center of mass value\n    inputVehicleMsg = messaging.VehicleConfigMsgPayload()\n    inputVehicleMsg.CoM_B = [0, 0, 0] # This is random.\n\n    # setup thruster cluster message\n    fswSetupThrusters.clearSetup()\n    rcsLocationData = [\n        [-0.86360, -0.82550, 1.79070],\n        [-0.82550, -0.86360, 1.79070],\n        [0.82550, 0.86360, 1.79070],\n        [0.86360, 0.82550, 1.79070],\n        [-0.86360, -0.82550, -1.79070],\n        [-0.82550, -0.86360, -1.79070],\n        [0.82550, 0.86360, -1.79070],\n        [0.86360, 0.82550, -1.79070]\n        ]\n    rcsDirectionData = [\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, -1.0, 0.0],\n        [-1.0, 0.0, 0.0],\n        [-1.0, 0.0, 0.0],\n        [0.0, -1.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [1.0, 0.0, 0.0]\n        ]\n\n    for i in range(len(rcsLocationData)):\n        fswSetupThrusters.create(rcsLocationData[i], rcsDirectionData[i], 2.0)\n\n    thrConfigInMsg = fswSetupThrusters.writeConfigMessage()\n    numThrusters = fswSetupThrusters.getNumOfDevices()\n\n    # Set these messages\n    rwSpeedInMsg = messaging.RWSpeedMsg().write(inputSpeedMsg)\n    rwConstInMsg = messaging.RWConstellationMsg().write(inputRWConstellationMsg)\n    vcConfigInMsg = messaging.VehicleConfigMsg().write(inputVehicleMsg)\n\n    dataLog = module.thrCmdOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    module.rwSpeedInMsg.subscribeTo(rwSpeedInMsg)\n    module.rwConfigInMsg.subscribeTo(rwConstInMsg)\n    module.vecConfigInMsg.subscribeTo(vcConfigInMsg)\n    module.thrConfigInMsg.subscribeTo(thrConfigInMsg)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n\n    #   Step the simulation to 9*process rate so 10 total steps including zero\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # This doesn't work if only 1 number is passed in as the second argument, but we don't need the second\n    outputThrData = dataLog.OnTimeRequest[:, :numThrusters]\n\n    # print(outputThrData)\n\n    # This is just what is outputted...\n    trueVector = [[0., 0., 0., 0., 0., 0., 0., 0.],\n                 [0.00000000e+00,   1.97181559e+00,   0.00000000e+00, 0.00000000e+00,   0.00000000e+00,   0.0, 0.0, 0.0],\n                 [ 0.00000000e+00,   0.00000000e+00,   0.00000000e+00, 0.00000000e+00,  0.0, 1.28062495e+00, 0.0, 0.0],\n                 [ 0.00000000e+00,   0.00000000e+00,   0.00000000e+00, 0.00000000e+00,  0.0, 1.28062495e+00, 0.0, 0.0],\n                 [ 0.00000000e+00,   1.97181559e+00,   0.00000000e+00, 0.00000000e+00,   0.00000000e+00,   0.0, 0.0, 0.0]]\n\n    accuracy = 1e-6\n\n    # At each timestep, make sure the vehicleConfig values haven't changed from the initial values\n    testFailCount, testMessages = unitTestSupport.compareArrayND(trueVector, outputThrData,\n                                                                 accuracy,\n                                                                 \"ThrustRWDesat output\",\n                                                                 numThrusters, testFailCount, testMessages)\n\n    if testFailCount == 0:\n        print(\"Passed\")\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_rwNullSpace(numWheels, defaultDesired):\n    \"\"\" Test rwNullSpace. \"\"\"\n    [testResults, testMessage] = rwNullSpaceTestFunction(numWheels, defaultDesired)\n    assert testResults < 1, testMessage",
  "def rwNullSpaceTestFunction(numWheels, defaultDesired):\n    \"\"\" Test the rwNullSpace module. Setup a simulation, \"\"\"\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # This is needed if multiple unit test scripts are run\n    # This create a fresh and consistent simulation environment for each test run\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))  # Add a new task to the process\n\n    # Construct the rwNullSpace module\n    # Set the names for the input messages\n    module = rwNullSpace.rwNullSpace()\n\n    # Set the necessary data in the module. NOTE: This information is more or less random\n    module.OmegaGain = .5 # The feedback gain value applied for the RW despin control law\n\n    # This calls the algContain to setup the selfInit, update, and reset\n    module.ModelTag = \"rwNullSpace\"\n\n    # Add the module to the task\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    numRW = numWheels\n\n    inputRWConstellationMsg = messaging.RWConstellationMsgPayload()\n    inputRWConstellationMsg.numRW = numRW\n\n    # Initialize the msg that gives the speed of the reaction wheels\n    inputSpeedMsg = messaging.RWSpeedMsgPayload()\n\n    if defaultDesired:\n        desiredOmega = [0]*numRW\n    else:\n        desiredOmega = [5]*numRW\n        inputDesiredSpeedMsg = messaging.RWSpeedMsgPayload()\n        inputDesiredSpeedMsg.wheelSpeeds = desiredOmega\n\n    gsHat = [[1, 0, 0], [0,1,0], [0, 0, 1]]\n    if numWheels == 4:\n        gs4Hat = np.array([1,1,1])\n        gs4Hat = gs4Hat/np.sqrt(gs4Hat.dot(gs4Hat))\n        gsHat.append(gs4Hat.tolist())\n\n    # Iterate over all of the reaction wheels, create a rwConfigElementFswMsg, and add them to the rwConstellationFswMsg\n    rwConfigElementList = list()\n    for rw in range(numRW):\n        rwConfigElementMsg = messaging.RWConfigElementMsgPayload()\n        rwConfigElementMsg.gsHat_B = gsHat[rw] # Spin axis unit vector of the wheel in structure\n        rwConfigElementMsg.Js = 0.08 # Spin axis inertia of wheel [kgm2]\n        rwConfigElementMsg.uMax = 0.2 # maximum RW motor torque [Nm]\n\n        # Add this to the list\n        rwConfigElementList.append(rwConfigElementMsg)\n\n    rwSpeeds = [10, 20, 30] # [rad/sec] The current angular velocities of the RW wheel\n    if numWheels == 4:\n        rwSpeeds.append(40)  # [rad/sec]\n    inputSpeedMsg.wheelSpeeds = rwSpeeds\n\n    # Set the array of the reaction wheels in RWConstellationFswMsg to the list created above\n    inputRWConstellationMsg.reactionWheels = rwConfigElementList\n\n    inputRWCmdMsg = messaging.ArrayMotorTorqueMsgPayload()\n    usControl = [0.1, 0.2, 0.15] # [Nm] RW motor torque array\n    if numWheels == 4:\n        usControl.append(-0.2) # [Nm]\n    inputRWCmdMsg.motorTorque = usControl\n\n\n    # Set these messages\n    rwSpeedMsg = messaging.RWSpeedMsg().write(inputSpeedMsg)\n    rwConfigMsg = messaging.RWConstellationMsg().write(inputRWConstellationMsg)\n    rwCmdMsg = messaging.ArrayMotorTorqueMsg().write(inputRWCmdMsg)\n\n    dataLog = module.rwMotorTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.rwMotorTorqueInMsg.subscribeTo(rwCmdMsg)\n    module.rwSpeedsInMsg.subscribeTo(rwSpeedMsg)\n    module.rwConfigInMsg.subscribeTo(rwConfigMsg)\n    if not defaultDesired:\n        rwDesiredMsg = messaging.RWSpeedMsg().write(inputDesiredSpeedMsg)\n        module.rwDesiredSpeedsInMsg.subscribeTo(rwDesiredMsg)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n\n    #   Step the simulation to 3*process rate so 4 total steps including zero\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    outputCrtlData = dataLog.motorTorque[:, :numRW]\n    print(outputCrtlData)\n\n    if numWheels == 3:\n        # in this case there is no nullspace of the RW configuration.  The output torque should be the input torque\n        trueVector = [inputRWCmdMsg.motorTorque,\n                     inputRWCmdMsg.motorTorque,\n                     inputRWCmdMsg.motorTorque,\n                     inputRWCmdMsg.motorTorque,\n                     inputRWCmdMsg.motorTorque]\n    elif numWheels == 4:\n        # in this case there is a 1D nullspace of [Gs]\n        GsT = np.array(gsHat)\n        Gs = GsT.transpose()\n        tmp = Gs.dot(GsT)\n        tmp = GsT.dot(inv(tmp))\n        tmp = tmp.dot(Gs)\n        tau = np.identity(numWheels) - tmp\n        d = - module.OmegaGain * (np.array(rwSpeeds) - np.array(desiredOmega))\n        uNull = tau.dot(d)\n        trueTorque = np.array(usControl) + uNull\n        trueVector = [\n            trueTorque.tolist(),\n            trueTorque.tolist(),\n            trueTorque.tolist(),\n            trueTorque.tolist(),\n            trueTorque.tolist()\n        ]\n\n\n    accuracy = 1e-6\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    # At each timestep, make sure the vehicleConfig values haven't changed from the initial values\n    testFailCount, testMessages = unitTestSupport.compareArrayND(trueVector, outputCrtlData,\n                                                                 accuracy,\n                                                                 \"numWheels = \" + str(numWheels),\n                                                                 2, testFailCount, testMessages)\n\n\n    snippentName = \"passFail\" + str(numWheels)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_torque2Dipole_module():     # update \"module\" in this function name to reflect the module name\n    r\"\"\"\n    **Validation Test Description**\n\n    This script tests that the 3x1 Body frame dipole vector, \n    dipole_B, is computed correctly and that the algorithm doesn't fail when\n    the inputs are given zero values.\n\n    **Description of Variables Being Tested**\n\n    In this file we are checking the values of the variable:\n\n    - ``dipole_B[3]``\n    \"\"\"\n    # each test method requires a single assert method to be called\n    # pass on the testPlotFixture so that the main test function may set the DataStore attributes\n    [testResults, testMessage] = torque2DipoleModuleTestFunction()\n    assert testResults < 1, testMessage",
  "def torque2DipoleModuleTestFunction():\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.01)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Initialize module under test's config message and add module to runtime call list\n    module = torque2Dipole.torque2Dipole()\n    module.ModelTag = \"mtbMomentumManagement\"           # update python name of test module\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    \n    # Initialize TAMSensorBodyMsg\n    tamSensorBodyInMsgContainer = messaging.TAMSensorBodyMsgPayload()\n    tamSensorBodyInMsgContainer.tam_B = [1E-5, 0.0, 0.0]\n    tamSensorBodyInMsg = messaging.TAMSensorBodyMsg().write(tamSensorBodyInMsgContainer)\n    \n    # Initialize CmdTorqueBodyMsg\n    tauRequestInMsgContainer = messaging.CmdTorqueBodyMsgPayload()\n    tauRequestInMsgContainer.torqueRequestBody = [10.* 1E-3, 20. * 1E-3, 30 * 1E-3]\n    tauRequestInMsg = messaging.CmdTorqueBodyMsg().write(tauRequestInMsgContainer)\n    \n    # Setup logging on the test module output message so that we get all the writes to it\n    resultDipoleRequestOutMsg = module.dipoleRequestOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, resultDipoleRequestOutMsg)\n    \n    # connect the message interfaces\n    module.tamSensorBodyInMsg.subscribeTo(tamSensorBodyInMsg)\n    module.tauRequestInMsg.subscribeTo(tauRequestInMsg)\n    \n    # Set the simulation time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.0))        # seconds to stop simulation\n    unitTestSim.InitializeSimulation()\n    \n    '''\n        TEST 1: \n            Check that dipole_B is non-zero expected value.\n    '''\n    unitTestSim.ExecuteSimulation()\n    b = np.array(tamSensorBodyInMsgContainer.tam_B)\n    tau = np.array(tauRequestInMsgContainer.torqueRequestBody)\n    expectedDipole = 1 / np.dot(b, b) * np.cross(b, tau)\n    testFailCount, testMessages = unitTestSupport.compareVector(expectedDipole,\n                                                                resultDipoleRequestOutMsg.dipole_B[0],\n                                                                accuracy,\n                                                                \"dipole_B\",\n                                                                testFailCount, testMessages)\n    \n    '''\n        TEST 2: \n            Check that dipole_B is zero when tam_B is zero.\n    '''\n    tamSensorBodyInMsgContainer.tam_B = [0., 0., 0.]\n    tamSensorBodyInMsg = messaging.TAMSensorBodyMsg().write(tamSensorBodyInMsgContainer)\n    module.tamSensorBodyInMsg.subscribeTo(tamSensorBodyInMsg)\n    \n    unitTestSim.InitializeSimulation()\n    unitTestSim.ExecuteSimulation()\n    \n    expectedDipole = [0., 0., 0.]\n    testFailCount, testMessages = unitTestSupport.compareVector(expectedDipole,\n                                                                resultDipoleRequestOutMsg.dipole_B[0],\n                                                                accuracy,\n                                                                \"dipole_B\",\n                                                                testFailCount, testMessages)\n    \n    '''\n        TEST 3: \n            Check that dipole_B is zero when torqueRequestBody is zero.\n    '''\n    tamSensorBodyInMsgContainer.tam_B = [1E-5, 0.0, 0.0]\n    tamSensorBodyInMsg = messaging.TAMSensorBodyMsg().write(tamSensorBodyInMsgContainer)\n    module.tamSensorBodyInMsg.subscribeTo(tamSensorBodyInMsg)\n    \n    tauRequestInMsgContainer.torqueRequestBody = [0., 0., 0.]\n    tauRequestInMsg = messaging.CmdTorqueBodyMsg().write(tauRequestInMsgContainer)\n    module.tauRequestInMsg.subscribeTo(tauRequestInMsg)\n    \n    unitTestSim.InitializeSimulation()\n    unitTestSim.ExecuteSimulation()\n    \n    expectedDipole = [0., 0., 0.]\n    testFailCount, testMessages = unitTestSupport.compareVector(expectedDipole,\n                                                                resultDipoleRequestOutMsg.dipole_B[0],\n                                                                accuracy,\n                                                                \"dipole_B\",\n                                                                testFailCount, testMessages)\n    \n    \n    print(\"Accuracy used: \" + str(accuracy))\n    if testFailCount == 0:\n        print(\"PASSED: torque2Dipole unit test\")\n    else:\n        print(\"Failed: torque2Dipole unit test\")\n    return [testFailCount, ''.join(testMessages)]",
  "def test_rwMotorTorque(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = rwMotorTorqueTest(show_plots)\n    assert testResults < 1, testMessage",
  "def rwMotorTorqueTest(show_plots):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = rwMotorTorque.rwMotorTorque()\n    module.ModelTag = \"rwMotorTorque\"\n\n    # Initialize module variables\n    controlAxes_B = [\n             1,0,0\n            ,0,1,0\n            ,0,0,1\n    ]\n    module.controlAxes_B = controlAxes_B\n\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n\n    # attControl message\n    inputMessageData = messaging.CmdTorqueBodyMsgPayload()  # Create a structure for the input message\n    requestedTorque = [1.0, -0.5, 0.7] # Set up a list as a 3-vector\n    inputMessageData.torqueRequestBody = requestedTorque # write torque request to input message\n    cmdTorqueInMsg = messaging.CmdTorqueBodyMsg().write(inputMessageData)\n\n    # wheelConfigData message\n    rwConfigParams = messaging.RWArrayConfigMsgPayload()\n    rwConfigParams.GsMatrix_B = [\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0.0,\n        0.0, 0.0, 1.0,\n        0.5773502691896258, 0.5773502691896258, 0.5773502691896258\n    ]\n    rwConfigParams.JsList = [0.1, 0.1, 0.1, 0.1]\n    rwConfigParams.numRW = 4\n    rwConfigInMsg = messaging.RWArrayConfigMsg().write(rwConfigParams)\n\n    # wheelAvailability message\n    rwAvailabilityMessage = messaging.RWAvailabilityMsgPayload()\n    avail = [messaging.AVAILABLE, messaging.AVAILABLE, messaging.AVAILABLE, messaging.AVAILABLE]\n    rwAvailabilityMessage.wheelAvailability = avail\n    rwAvailInMsg = messaging.RWAvailabilityMsg().write(rwAvailabilityMessage)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.rwMotorTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.vehControlInMsg.subscribeTo(cmdTorqueInMsg)\n    module.rwParamsInMsg.subscribeTo(rwConfigInMsg)\n    module.rwAvailInMsg.subscribeTo(rwAvailInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    module.Reset(0)\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.5))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    moduleOutput = dataLog.motorTorque\n    # print('\\n', moduleOutput)\n\n    # set the output truth states\n    ans = [0]*messaging.MAX_EFF_CNT\n    ans[0:4] = [-0.8, 0.7000000000000001, -0.5, -0.3464101615137755]\n    trueVector = [\n                   ans,\n                   ans\n    ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleOutput[i], trueVector[i], rwConfigParams.numRW, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed motorTorque unit test at t=\" +\n                                str(dataLog.times()[i]*macros.NANO2SEC) +\n                                \"sec\\n\")\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_rwMotorTorque(show_plots, numControlAxes, numWheels, RWAvailMsg):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = rwMotorTorqueTest(show_plots, numControlAxes, numWheels, RWAvailMsg)\n    assert testResults < 1, testMessage",
  "def rwMotorTorqueTest(show_plots, numControlAxes, numWheels, RWAvailMsg):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = rwMotorTorque.rwMotorTorque()\n    module.ModelTag = \"rwMotorTorque\"\n\n\n    # Initialize module variables\n    if numControlAxes == 3:\n        controlAxes_B = [\n            1, 0, 0\n            , 0, 1, 0\n            , 0, 0, 1\n        ]\n    elif numControlAxes == 2:\n        controlAxes_B = [\n             1,0,0\n            ,0,1,0\n        ]\n    elif numControlAxes == 1:\n        controlAxes_B = [\n            1, 0, 0\n        ]\n    else:\n        controlAxes_B = []\n\n    module.controlAxes_B = controlAxes_B\n\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n\n    # attControl message\n    inputMessageData = messaging.CmdTorqueBodyMsgPayload()  # Create a structure for the input message\n    requestedTorque = [1.0, -0.5, 0.7] # Set up a list as a 3-vector\n    inputMessageData.torqueRequestBody = requestedTorque # write torque request to input message\n    cmdTorqueInMsg = messaging.CmdTorqueBodyMsg().write(inputMessageData)\n\n    # wheelConfigData message\n    rwConfigParams = messaging.RWArrayConfigMsgPayload()\n    MAX_EFF_CNT = messaging.MAX_EFF_CNT\n\n    if numWheels == MAX_EFF_CNT:\n        rwConfigParams.GsMatrix_B = [\n            0.4835867893995201, 0.7025829597277155, 0.5220354411517549,\n            0.6274167231454653, 0.4634123147571517, 0.6257773422303058,\n            0.4927675437195689, 0.3909468277672152, 0.7773935462269635,\n            0.2791305379092009, 0.20278639222840245, 0.9385967301954065,\n            0.1742148051521812, 0.9353106472878886, 0.3079662233682429,\n            0.7408864742367625, 0.30733781515416325, 0.5971856492492805,\n            0.49166240509756476, 0.11024265612126483, 0.863779275153674,\n            0.08522980139648922, 0.5635691254043687, 0.8216603445736381,\n            0.5169183283391889, 0.6482094982986043, 0.5591242153068406,\n            0.5539478507672101, 0.4352935184619988, 0.7096910112262675,\n            0.08177103922211226, 0.7185493168899821, 0.6906521384470449,\n            0.5424303480563135, 0.8034905566669417, 0.24530031156636306,\n            0.6791649825098244, 0.25103926707369056, 0.6897203874901293,\n            0.6662787689368599, 0.6695372377111813, 0.32831766535181106,\n            0.28428078464167594, 0.5440295499812461, 0.7894404880867942,\n            0.8881073966834958, 0.007176386091829566, 0.4595799728433832,\n            0.7043700914244455, 0.20398698108861654, 0.6798912308987893,\n            0.5913513581668906, 0.7154722881784563, 0.3720255045596441,\n            0.5353927164036736, 0.8292977052562882, 0.1600623480977027,\n            0.5626385603464779, 0.5530980227747188, 0.6144269099038059,\n            0.8047402627946283, 0.5179828986694456, 0.2899772855298006,\n            0.6435726414836709, 0.49863310510036174, 0.5806714059015666,\n            0.2533767502100278, 0.8066673674024603, 0.533936307831739,\n            0.051675625147813466, 0.741898369799065, 0.6685180914942186,\n            0.6705007071467579, 0.243658731626882, 0.700756180292173,\n            0.6124322825812726, 0.6044312394389204, 0.5094993386086216,\n            0.5025822950964116, 0.49662160344788164, 0.7076567103083798,\n            0.4875326918964735, 0.8575174427431412, 0.16424283766253403,\n            0.3659744927810267, 0.8415919620749859, 0.39722240622155974,\n            0.6205921515961875, 0.5508152351685801, 0.5580931446303532,\n            0.20125257120061574, 0.7022636474963218, 0.6828785924235018,\n            0.4318909377763495, 0.6786025351852008, 0.5941117883924572,\n            0.6839787443692367, 0.6598940110591041, 0.31098709204629277,\n            0.35743175000357147, 0.8343049491885353, 0.4197353878920623,\n            0.8124751056450826, 0.35669421673672336, 0.46114362020262967,\n            0.04721328350343224, 0.8901899787392832, 0.45313652204714083]\n    else:\n        rwConfigParams.GsMatrix_B = [\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0,\n            0.5773502691896258, 0.5773502691896258, 0.5773502691896258\n        ]\n        rwConfigParams.JsList = [0.1]*numWheels\n\n    rwConfigParams.numRW = numWheels\n    rwConfigInMsg = messaging.RWArrayConfigMsg().write(rwConfigParams)\n\n    if RWAvailMsg != \"NO\":\n        rwAvailabilityMessage = messaging.RWAvailabilityMsgPayload()\n\n        avail = [messaging.UNAVAILABLE] * numWheels\n        for i in range(numWheels):\n            if RWAvailMsg == \"ON\":\n                avail[i] = messaging.AVAILABLE\n            elif RWAvailMsg == \"OFF\":\n                avail[i] = messaging.UNAVAILABLE\n            else:\n                if i < int(numWheels / 2):\n                    avail[i] = messaging.AVAILABLE\n\n        rwAvailabilityMessage.wheelAvailability = avail\n\n        rwAvailInMsg = messaging.RWAvailabilityMsg().write(rwAvailabilityMessage)\n        module.rwAvailInMsg.subscribeTo(rwAvailInMsg)\n\n    else:\n        avail = [rwMotorTorque.AVAILABLE] * numWheels  # this is used purely for the python level solution\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.rwMotorTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.vehControlInMsg.subscribeTo(cmdTorqueInMsg)\n    module.rwParamsInMsg.subscribeTo(rwConfigInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    module.Reset(0)\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.5))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    moduleOutput = dataLog.motorTorque\n\n    trueVector = np.array([\n        [0.0] * MAX_EFF_CNT,\n        [0.0] * MAX_EFF_CNT\n    ])\n\n    # set the output truth states\n    trueVector[0] = results_rwMotorTorque.computeTorqueU(np.array(controlAxes_B),\n                                                                   np.array(rwConfigParams.GsMatrix_B).reshape((\n                                                                       3, MAX_EFF_CNT), order='F'),\n                                                                   requestedTorque,\n                                                                   avail)\n    trueVector[1] = trueVector[0]\n\n    # compare the module results to the truth values\n    accuracy = 1e-8\n    testFailCount, testMessages = unitTestSupport.compareArrayND(trueVector, moduleOutput, accuracy, \"rwMotorTorques\",\n                                                                 MAX_EFF_CNT, testFailCount, testMessages)\n\n\n    GsMatrix = np.transpose(np.reshape(rwConfigParams.GsMatrix_B,(MAX_EFF_CNT,3),\"C\"))\n    F = np.transpose(moduleOutput[0])\n    receivedTorque = -1.0*np.array([np.matmul(GsMatrix,F)])\n    receivedTorque = np.append(np.array([]), receivedTorque)\n\n    if numWheels >= numControlAxes and numControlAxes > 0:\n        if (len(avail) - np.sum(avail)) > numControlAxes:\n            testFailCount, testMessages = unitTestSupport.compareArrayND(np.array([requestedTorque]),\n                                                                         np.array([receivedTorque]), accuracy,\n                                                                         \"CompareTorques\",\n                                                                         numControlAxes, testFailCount, testMessages)\n\n    snippetName = \"LrBReq_LrBRec_\"+str(numControlAxes) + \"_\" + str(numWheels) + \"_\" + RWAvailMsg\n    requestedTex = str(requestedTorque)\n    receivedTex = str(receivedTorque[1:4])\n    snippetTex = \"Requested:\\t\" + requestedTex + \"\\n\"\n    snippetTex += \"Received:\\t\" + receivedTex + \"\\n\"\n\n    unitTestSupport.writeTeXSnippet(snippetName, snippetTex, path)\n\n    #   print out success message if no error were found\n    unitTestSupport.writeTeXSnippet('toleranceValue', str(accuracy), path)\n\n    snippentName = \"passFail_\"+str(numControlAxes) + str(numWheels) + RWAvailMsg\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def controlAxes3D():\n    C = np.array([\n        [1.0, 0.0, 0.0]\n        , [0.0, 1.0, 0.0]\n        , [0.0, 0.0, 1.0]\n    ])\n    return C",
  "def controlAxes2D():\n    C = np.array([\n        [1.0, 0.0, 0.0]\n        , [0.0, 0.0, 1.0]\n    ])\n    return C",
  "def controlAxes1D():\n    C = np.array([\n        [1.0, 0.0, 0.0]\n    ])\n    return C",
  "def computeTorqueU(CArray, Gs_B, Lr, availMsg):\n\n    numControlAxes = len(CArray)//3\n    numWheels = len(availMsg)\n    nonAvailWheels = 0\n\n    # Build Control Frame (doesn't need to be a complete frame)\n    C = np.zeros((3,3))\n    for i in range(3):\n        if numControlAxes > i:\n            C[i,:] = CArray[3*i:3*(i+1)]\n        else:\n            C[i,:] = [0.0, 0.0, 0.0]\n\n    # Remove wheels that are deemed unavailable\n    for i in range(len(Gs_B[0])): #\n        if numWheels > i:\n            if availMsg[i] is not rwMotorTorque.AVAILABLE:\n                Gs_B[:,i] = [0.0, 0.0, 0.0]\n                nonAvailWheels += 1\n        else:\n            Gs_B[:,i] = [0.0, 0.0, 0.0]\n\n    # If fewer wheels than number of control axes, output no torque\n    if (numWheels-nonAvailWheels) < numControlAxes:\n        return [0.0]*len(Gs_B[0])\n\n\n    Lr_C = np.dot(C,Lr) # Project torque onto control axes\n    CGs = np.dot(C, Gs_B) # Map the control axes onto the wheels\n\n    # Build minimum norm framework\n    M = np.dot(CGs, CGs.T)\n    M_rep = np.identity(3) # Need to keep the matrix non-singular for inversion\n    for i in range(0,numControlAxes):\n        for j in range(0,numControlAxes):\n            M_rep[i][j] = M[i][j]\n    M_inv = la.inv(M_rep)\n\n    # Remove projection to any non-defined control axes\n    for i in range(numControlAxes,3):\n        M_inv[i][i] = 0.0\n\n    # Determine the solution\n    v3_temp = np.dot(M_inv, Lr_C)\n\n    # Map the solution to the wheels\n    u_s = np.dot(CGs.T, v3_temp)\n\n    return -u_s",
  "def exampleComputation():\n    Gs_B = np.array([\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, 0.0, 1.0],\n        [0.5773502691896258, 0.5773502691896258, 0.5773502691896258]\n    ]).T\n\n    JsList = np.array([0.1, 0.1, 0.1, 0.1])\n    numRW = 4\n    rwConfigParams = (Gs_B, JsList, numRW)\n\n    Lr = np.array([1.0, -0.5, 0.7])\n    rwAvailability = np.array([1, 1, 1, 1])\n\n    print('3D Control')\n    u_s = computeTorqueU(controlAxes3D(), Gs_B, Lr)\n    print('U_s = ', u_s, '\\n')\n\n    print('2D Control')\n    u_s = computeTorqueU(controlAxes2D(), Gs_B, Lr)\n    print('U_s = ', u_s)\n\n    print('1D Control')\n    u_s = computeTorqueU(controlAxes1D(), Gs_B, Lr)\n    print('U_s = ', u_s)",
  "def test_thrFiringRemainder(show_plots, resetCheck, dvOn):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = thrFiringRemainderTestFunction(show_plots, resetCheck, dvOn)\n    assert testResults < 1, testMessage",
  "def thrFiringRemainderTestFunction(show_plots, resetCheck, dvOn):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = thrFiringRemainder.thrFiringRemainder()\n    module.ModelTag = \"thrFiringRemainder\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.thrMinFireTime = 0.2\n    if dvOn == 1:\n        module.baseThrustState = 1\n    else:\n        module.baseThrustState = 0\n\n    # setup thruster cluster message\n    fswSetupThrusters.clearSetup()\n    rcsLocationData = [\n        [-0.86360, -0.82550, 1.79070],\n        [-0.82550, -0.86360, 1.79070],\n        [0.82550, 0.86360, 1.79070],\n        [0.86360, 0.82550, 1.79070],\n        [-0.86360, -0.82550, -1.79070],\n        [-0.82550, -0.86360, -1.79070],\n        [0.82550, 0.86360, -1.79070],\n        [0.86360, 0.82550, -1.79070]\n        ]\n    rcsDirectionData = [\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, -1.0, 0.0],\n        [-1.0, 0.0, 0.0],\n        [-1.0, 0.0, 0.0],\n        [0.0, -1.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [1.0, 0.0, 0.0]\n        ]\n\n    for i in range(len(rcsLocationData)):\n        fswSetupThrusters.create(rcsLocationData[i], rcsDirectionData[i], 0.5)\n    thrConfigMsg = fswSetupThrusters.writeConfigMessage()\n    numThrusters = fswSetupThrusters.getNumOfDevices()\n\n\n    # setup thruster impulse request message\n    thrMessageData = messaging.THRArrayCmdForceMsgPayload()\n    if dvOn:\n        thrMessageData.thrForce = [-0.5, 0.0, -0.1, -0.2, -0.3, -0.34, -0.39, -0.44]\n    else:\n        thrMessageData.thrForce = [0.5, 0.05, 0.1, 0.15, 0.19, 0.0, 0.2, 0.49]\n    thrForceMsg = messaging.THRArrayCmdForceMsg().write(thrMessageData)\n\n\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.onTimeOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n\n    # connect messages\n    module.thrConfInMsg.subscribeTo(thrConfigMsg)\n    module.thrForceInMsg.subscribeTo(thrForceMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(3.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    if resetCheck:\n        # reset the module to test this functionality\n        module.Reset(macros.sec2nano(3.0))     # this module reset function needs a time input (in NanoSeconds)\n\n        # run the module again for an additional 1.0 seconds\n        unitTestSim.ConfigureStopTime(macros.sec2nano(5.5))        # seconds to stop simulation\n        unitTestSim.ExecuteSimulation()\n\n    moduleOutput = dataLog.OnTimeRequest[:, :numThrusters]\n\n    # set the filtered output truth states\n    if resetCheck==1:\n        if dvOn:\n            trueVector = [\n                   [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0],\n                   [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.32, 0.22, 0.0],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.32, 0.22, 0.24],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0],\n                   [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.32, 0.22, 0.0],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.32, 0.22, 0.24],\n                   ]\n        else:\n            trueVector = [\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.55, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.49],\n                   [0.55, 0.0, 0.2, 0.3, 0.38, 0.0, 0.2, 0.49],\n                   [0.55, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.49],\n                   [0.55, 0.2, 0.2, 0.3, 0.38, 0.0, 0.2, 0.49],\n                   [0.55, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.49],\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.55, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.49],\n                   [0.55, 0.0, 0.2, 0.3, 0.38, 0.0, 0.2, 0.49],\n                   [0.55, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.49],\n                   [0.55, 0.2, 0.2, 0.3, 0.38, 0.0, 0.2, 0.49],\n                   ]\n\n    else:\n        if dvOn:\n            trueVector = [\n                   [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0],\n                   [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.32, 0.22, 0.0],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.32, 0.22, 0.24],\n                   [0.0, 0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0],\n                   ]\n        else:\n            trueVector = [\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.55, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.49],\n                   [0.55, 0.0, 0.2, 0.3, 0.38, 0.0, 0.2, 0.49],\n                   [0.55, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.49],\n                   [0.55, 0.2, 0.2, 0.3, 0.38, 0.0, 0.2, 0.49],\n                   [0.55, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.49],\n                   ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput, accuracy,\n                                                               \"OnTimeRequest\", testFailCount, testMessages)\n\n    snippentName = \"passFail\" + str(resetCheck) + str(dvOn)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_PrescribedRot2DOFTestFunction(show_plots, thetaInit, thetaRef1a, thetaRef2a, thetaRef1b, thetaRef2b, phiDDotMax, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    The unit test for this module simulates TWO consecutive 2 DOF rotational attitude maneuvers for a secondary rigid\n    body connected to a rigid spacecraft hub. Two maneuvers are simulated to ensure that the module correctly updates\n    the required relative PRV attitude when a new attitude reference message is written. This unit test checks that the\n    prescribed body's MRP attitude converges to both reference attitudes for a series of initial and reference attitudes\n    and maximum angular accelerations. (``sigma_FM_Final1`` is checked to converge to ``sigma_FM_Ref1``, and\n    ``sigma_FM_Final2`` is checked to converge to ``sigma_FM_Ref2``). Additionally, the prescribed body's final angular\n    velocity magnitude ``thetaDot_Final`` is checked for convergence to the reference angular velocity magnitude,\n    ``thetaDot_Ref``.\n\n    **Test Parameters**\n\n    Args:\n        thetaInit (float): [rad] Initial PRV angle of the F frame with respect to the M frame\n        thetaRef1a (float): [rad] First reference PRV angle for the first attitude maneuver\n        thetaRef2a (float): [rad] Second reference PRV angle for the first attitude maneuver\n        thetaRef1b (float): [rad] First reference PRV angle for the second attitude maneuver\n        thetaRef2b (float): [rad] Second reference PRV angle for the second attitude maneuver\n        phiDDotMax (float): [rad/s^2] Maximum angular acceleration for the attitude maneuver\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    The prescribed body's MRP attitude at the end of the first maneuver ``sigma_FM_Final1`` is checked to converge to\n    the first reference attitude ``sigma_FM_Ref1``. The prescribed body's MRP attitude at the end of the second\n    maneuver ``sigma_FM_Final2`` is checked to converge to the second reference attitude ``sigma_FM_Ref2``.\n    Additionally, the prescribed body's final angular velocity magnitude ``thetaDot_Final`` is checked for convergence\n    to the reference angular velocity magnitude, ``thetaDot_Ref``.\n    \"\"\"\n\n    [testResults, testMessage] = PrescribedRot2DOFTestFunction(show_plots, thetaInit, thetaRef1a, thetaRef2a, thetaRef1b, thetaRef2b, phiDDotMax, accuracy)\n\n    assert testResults < 1, testMessage",
  "def PrescribedRot2DOFTestFunction(show_plots, thetaInit, thetaRef1a, thetaRef2a, thetaRef1b, thetaRef2b, phiDDotMax, accuracy):\n    \"\"\"Call this routine directly to run the unit test.\"\"\"\n    testFailCount = 0                                        # zero unit test result counter\n    testMessages = []                                        # create empty array to store test log messages\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create the test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Create an instance of the =module that is being tested\n    prescribedRot2DOFObj = prescribedRot2DOF.prescribedRot2DOF()\n    prescribedRot2DOFObj.ModelTag = \"PrescribedRot2DOF\"\n\n    # Initialize the test module configuration data\n    rotAxis1_M = np.array([0.0, 1.0, 0.0])                                      # Rotation axis for the first reference rotation angle, thetaRef1a\n    rotAxis2_F1 = np.array([0.0, 0.0, 1.0])                                     # Rotation axis for the second reference rotation angle, thetaRef2a\n    prescribedRot2DOFObj.rotAxis1_M = rotAxis1_M\n    prescribedRot2DOFObj.rotAxis2_F1 = rotAxis2_F1\n    prescribedRot2DOFObj.phiDDotMax = phiDDotMax\n    prescribedRot2DOFObj.r_FM_M = np.array([1.0, 0.0, 0.0])                  # [m] Position of the F frame origin relative to the M frame origin in M frame components\n    prescribedRot2DOFObj.rPrime_FM_M = np.array([0.0, 0.0, 0.0])             # [m/s] B frame time derivative of r_FM_M in M frame components\n    prescribedRot2DOFObj.rPrimePrime_FM_M = np.array([0.0, 0.0, 0.0])        # [m/s^2] B frame time derivative of rPrime_FM_M in M frame components\n    prescribedRot2DOFObj.omega_FM_F = np.array([0.0, 0.0, 0.0])              # [rad/s] Angular velocity of frame F relative to frame M in F frame components\n    prescribedRot2DOFObj.omegaPrime_FM_F = np.array([0.0, 0.0, 0.0])         # [rad/s^2] B frame time derivative of omega_FB_F in F frame components\n    prescribedRot2DOFObj.sigma_FM = np.array([0.0, 0.0, 0.0])                # MRP attitude of frame F relative to frame M\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, prescribedRot2DOFObj)\n\n    # Create the prescribedRot2DOF input message\n    thetaDot_Ref = 0.0  # [rad/s]\n    hingedRigidBodyMessageData1 = messaging.HingedRigidBodyMsgPayload()\n    hingedRigidBodyMessageData2 = messaging.HingedRigidBodyMsgPayload()\n    hingedRigidBodyMessageData1.theta = thetaRef1a\n    hingedRigidBodyMessageData2.theta = thetaRef2a\n    hingedRigidBodyMessageData1.thetaDot = thetaDot_Ref\n    hingedRigidBodyMessageData2.thetaDot = thetaDot_Ref\n    HingedRigidBodyMessage1 = messaging.HingedRigidBodyMsg().write(hingedRigidBodyMessageData1)\n    HingedRigidBodyMessage2 = messaging.HingedRigidBodyMsg().write(hingedRigidBodyMessageData2)\n    prescribedRot2DOFObj.spinningBodyRef1InMsg.subscribeTo(HingedRigidBodyMessage1)\n    prescribedRot2DOFObj.spinningBodyRef2InMsg.subscribeTo(HingedRigidBodyMessage2)\n\n    # Set up message data recording logging on the test module output message to get access to it\n    dataLog = prescribedRot2DOFObj.prescribedMotionOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Set up module variable data recording\n    unitTestSim.AddVariableForLogging(prescribedRot2DOFObj.ModelTag + \".phi\", testProcessRate, 0, 0, 'double')\n    unitTestSim.AddVariableForLogging(prescribedRot2DOFObj.ModelTag + \".phiAccum\", testProcessRate, 0, 0, 'double')\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n\n    # Calculate the two reference PRVs for the first attitude maneuver\n    prv_F0M_a = thetaRef1a * rotAxis1_M[0], thetaRef1a * rotAxis1_M[1], thetaRef1a * rotAxis1_M[2]\n    prv_F1F0_a = thetaRef2a * rotAxis2_F1[0], thetaRef2a * rotAxis2_F1[1], thetaRef2a * rotAxis2_F1[2]\n\n    # Calculate a single reference PRV for the first attitude maneuver and the associated MRP attitude\n    if (thetaRef1a == 0 and thetaRef2a == 0):  # Prevent a (0,0,0) error using rbk.addPRV()\n        prv_F1M_a = np.array([0.0, 0.0, 0.0])\n        phi_F1M_a = 0.0\n        sigma_FM_Ref1 = np.array([0.0, 0.0, 0.0])\n    else:\n        prv_F1M_a = rbk.addPRV(prv_F0M_a, prv_F1F0_a)\n        phi_F1M_a = np.linalg.norm(prv_F1M_a)\n        sigma_FM_Ref1 = rbk.PRV2MRP(prv_F1M_a)\n\n    # Set the simulation time for the first attitude maneuver\n    simTime1 = np.sqrt(((0.5 * np.abs(phi_F1M_a)) * 8) / phiDDotMax) + 10\n    unitTestSim.ConfigureStopTime(macros.sec2nano(simTime1))\n\n    # Execute the first attitude maneuver\n    unitTestSim.ExecuteSimulation()\n\n    # Extract the logged sigma_FM MRPs for data comparison\n    sigma_FM_FirstMan = dataLog.sigma_FM\n    sigma_FM_Final1 = sigma_FM_FirstMan[-1, :]\n\n    # Calculate the two reference PRVs for the second attitude maneuver\n    prv_F2M_b = thetaRef1b * rotAxis1_M[0], thetaRef1b * rotAxis1_M[1], thetaRef1b * rotAxis1_M[2]\n    prv_F3F2_b = thetaRef2b * rotAxis2_F1[0], thetaRef2b * rotAxis2_F1[1], thetaRef2b * rotAxis2_F1[2]\n\n    # Calculate a single reference PRV (prv_F3M_b) for the second attitude maneuver beginning from the M frame\n    if (thetaRef1b == 0 and thetaRef2b == 0):  # Prevent a (0,0,0) error using rbk.addPRV()\n        prv_F3M_b = np.array([0.0, 0.0, 0.0])\n    else:\n        prv_F3M_b = rbk.addPRV(prv_F2M_b, prv_F3F2_b)\n\n    # Calculate a single reference PRV (prv_F3F1_b) for the second attitude maneuver beginning from the spinning body location after the first maneuver (F1)\n    # Also calculate the MRP representing the desired final attitude of the spinning body with respesct to the M frame\n    if not unitTestSupport.isArrayEqual(prv_F1M_a, prv_F3M_b, 3, 1e-12):\n        prv_F3F1_b = rbk.subPRV(prv_F1M_a, prv_F3M_b)\n        sigma_FM_Ref2 = rbk.PRV2MRP(prv_F3M_b)\n    else:\n        prv_F3F1_b = np.array([0.0, 0.0, 0.0])\n        sigma_FM_Ref2 = sigma_FM_Ref1\n    phi_F3F1_b = np.linalg.norm(prv_F3F1_b)\n\n    # Write the HingedRigidBody reference messages for the second maneuver\n    hingedRigidBodyMessageData1 = messaging.HingedRigidBodyMsgPayload()\n    hingedRigidBodyMessageData2 = messaging.HingedRigidBodyMsgPayload()\n    hingedRigidBodyMessageData1.theta = thetaRef1b\n    hingedRigidBodyMessageData2.theta = thetaRef2b\n    hingedRigidBodyMessageData1.thetaDot = thetaDot_Ref\n    hingedRigidBodyMessageData2.thetaDot = thetaDot_Ref\n    HingedRigidBodyMessage1 = messaging.HingedRigidBodyMsg().write(hingedRigidBodyMessageData1, macros.sec2nano(simTime1))\n    HingedRigidBodyMessage2 = messaging.HingedRigidBodyMsg().write(hingedRigidBodyMessageData2, macros.sec2nano(simTime1))\n    prescribedRot2DOFObj.spinningBodyRef1InMsg.subscribeTo(HingedRigidBodyMessage1)\n    prescribedRot2DOFObj.spinningBodyRef2InMsg.subscribeTo(HingedRigidBodyMessage2)\n\n    # Set the simulation time for the second maneuver\n    simTime2 = np.sqrt(((0.5 * np.abs(phi_F3F1_b)) * 8) / phiDDotMax) + 10\n    unitTestSim.ConfigureStopTime(macros.sec2nano(simTime1 + simTime2))\n\n    # Execute the second attitude maneuver\n    unitTestSim.ExecuteSimulation()\n\n    # Extract the recorded data for data comparison and plotting\n    timespan = dataLog.times()\n    omega_FM_F = dataLog.omega_FM_F\n    sigma_FM = dataLog.sigma_FM\n\n    # Extract the logged module variables\n    phi = unitTestSim.GetLogVariableData(prescribedRot2DOFObj.ModelTag + \".phi\")\n    phi = np.delete(phi, 0, axis=1)\n    phiAccum = unitTestSim.GetLogVariableData(prescribedRot2DOFObj.ModelTag + \".phiAccum\")\n    phiAccum = np.delete(phiAccum, 0, axis=1)\n\n    # Store the final angular velocity of the spinning body\n    thetaDot_Final = np.linalg.norm(omega_FM_F[-1, :])\n\n    # Store the final MRP of the spinning body with respect to the M frame\n    sigma_FM_Final2 = sigma_FM[-1, :]\n\n    # Convert the logged omega_FM_F data to scalar thetaDot data\n    n = len(timespan)\n    thetaDot_FM = []\n    for i in range(n):\n        thetaDot_FM.append((np.linalg.norm(omega_FM_F[i, :])))\n\n    # Plot omega_FB_F\n    plt.figure()\n    plt.clf()\n    plt.plot(timespan * macros.NANO2SEC, omega_FM_F[:, 0], label=r'$\\omega_{1}$')\n    plt.plot(timespan * macros.NANO2SEC, omega_FM_F[:, 1], label=r'$\\omega_{2}$')\n    plt.plot(timespan * macros.NANO2SEC, omega_FM_F[:, 2], label=r'$\\omega_{3}$')\n    plt.title(r'Prescribed Angular Velocity ${}^\\mathcal{F} \\omega_{\\mathcal{F}/\\mathcal{M}}$')\n    plt.xlabel('Time (s)')\n    plt.ylabel('(rad/s)')\n    plt.legend(loc='upper right', prop={'size': 12})\n\n    # Plot phi\n    thetaRef1_plotting = np.ones(len(timespan)) * phi_F1M_a\n    thetaRef2_plotting = np.ones(len(timespan)) * phi_F3F1_b\n    thetaInit_plotting = np.ones(len(timespan)) * thetaInit\n    plt.figure()\n    plt.clf()\n    plt.plot(timespan * macros.NANO2SEC, phi, label=r'$\\Phi$')\n    plt.plot(timespan * macros.NANO2SEC, thetaInit_plotting, '--', label=r'$\\Phi_{0}$')\n    plt.plot(timespan * macros.NANO2SEC, thetaRef1_plotting, '--', label=r'$\\Phi_{1_{Ref}}$')\n    plt.plot(timespan * macros.NANO2SEC, thetaRef2_plotting, '--', label=r'$\\Phi_{2_{Ref}}$')\n    plt.title(r'Prescribed Principal Rotation Vector (PRV) Angles $\\Phi$')\n    plt.xlabel('Time (s)')\n    plt.ylabel('(rad)')\n    plt.legend(loc='upper right', prop={'size': 12})\n\n    # Plot the accumulated PRV angle\n    plt.figure()\n    plt.clf()\n    plt.plot(timespan * macros.NANO2SEC, phiAccum)\n    plt.title(r'Accumulated Principal Rotation Vector (PRV) Angle $\\Phi$')\n    plt.xlabel('Time (s)')\n    plt.ylabel('(rad)')\n\n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n    # Compare the reference and simulated data and output failure messages as necessary\n    if not unitTestSupport.isDoubleEqual(thetaDot_Final, thetaDot_Ref, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + prescribedRot2DOFObj.ModelTag + \" thetaDot_Final and thetaDot_Ref do not match\")\n        print(\"thetaDot_Final: \")\n        print(thetaDot_Final)\n        print(\"thetaDot_Ref: \")\n        print(thetaDot_Ref)\n\n    if not unitTestSupport.isArrayEqual(sigma_FM_Final1, sigma_FM_Ref1, 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + prescribedRot2DOFObj.ModelTag + \" MRPs sigma_FM_Final1 and sigma_FM_Ref1 do not match\")\n        print(\"sigma_FM_Final1: \")\n        print(sigma_FM_Final1)\n        print(\"sigma_FM_Ref1: \")\n        print(sigma_FM_Ref1)\n\n    if not unitTestSupport.isArrayEqual(sigma_FM_Final2, sigma_FM_Ref2, 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + prescribedRot2DOFObj.ModelTag + \" MRPs sigma_FM_Final2 and sigma_FM_Ref2 do not match\")\n        print(\"sigma_FM_Final2: \")\n        print(sigma_FM_Final2)\n        print(\"sigma_FM_Ref2: \")\n        print(sigma_FM_Ref2)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_platformRotation(show_plots, delta_CM, K, seed, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test script tests the correctness of the tip and tilt reference angles computed by \n    :ref:`thrusterPlatformReference`. The correctness of the output is determined based on whether the thruster \n    is aligned with the system's center of mass, when the momentum dumping control gain :math:`\\kappa = 0`.\n    Moreover, the other module output messages, ``bodyHeadingOutMsg`` and ``thrusterTorqueOutMsg`` are checked\n    versus equivalent python code.\n\n    **Test Parameters**\n\n    This test randomizes the position of the center of mass and runs the test 10 times for any other combination\n    of test parameters. \n\n    Args:\n        delta_CM (m): magnitude of the center of mass shift, whose direction is generated randomly\n        K (Hz): proportional gain of the momentum dumping control law\n        seed (-): seed is varied to randomly change the shift in the center of mass\n        accuracy (float): accuracy within which results are considered to match the truth values.\n\n    **Description of Variables Being Tested**\n\n    For :math:`\\kappa = 0`, the correctness of the result is assessed based on the norm of the\n    cross product between the thrust direction vector :math:`{}^\\mathcal{F}\\boldsymbol{t}` and the relative position\n    of the center of mass with respect to the thruster application point :math:`T`. For :math:`\\kappa \\neq 0` this \n    test is not performed, as the thruster is not aligned with the center of mass.\n\n    The python code also computes equivalently the thrust direction in body frame coordinates :math:`{}^\\mathcal{B}\\boldsymbol{t}`\n    and the net torque on the system :math:`{}^\\mathcal{B}\\boldsymbol{L}`, and compares them to the respective output\n    messages for all values of :math:`\\kappa = 0` tested.\n\n    **General Documentation Comments**\n\n    The offset vectors provided as input parameters ensure that a solution exists, such that the Unit Test can correctly\n    assess the alignment of the thruster. This is, in general, not guaranteed.\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = platformRotationTestFunction(show_plots, delta_CM, K, seed, accuracy)\n    assert testResults < 1, testMessage",
  "def platformRotationTestFunction(show_plots, delta_CM, K, seed, accuracy):\n\n    random.seed(seed)\n\n    sigma_MB = np.array([0., 0., 0.])\n    r_BM_M = np.array([0.0, 0.1, 1.4])\n    r_FM_F = np.array([0.0, 0.0, -0.1])\n    r_TF_F = np.array([-0.01, 0.03, 0.02])\n    T_F    = np.array([1.0, 1.0, 10.0])\n\n    r_CB_B = np.array([0,0,0]) + np.random.rand(3)\n    r_CB_B = r_CB_B / np.linalg.norm(r_CB_B) * delta_CM\n\n    testFailCount = 0                        # zero unit test result counter\n    testMessages = []                        # create empty array to store test log messages\n    unitTaskName = \"unitTask\"                # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"          # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(1)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    platform = thrusterPlatformReference.thrusterPlatformReference()\n    platform.ModelTag = \"platformReference\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, platform)\n\n    # Initialize the test module configuration data\n    platform.sigma_MB = sigma_MB\n    platform.r_BM_M = r_BM_M\n    platform.r_FM_F = r_FM_F\n    platform.r_TF_F = r_TF_F\n    platform.T_F    = T_F\n    platform.K      = K\n\n    # Create input vehicle configuration msg\n    inputVehConfigMsgData = messaging.VehicleConfigMsgPayload()\n    inputVehConfigMsgData.CoM_B = r_CB_B\n    inputVehConfigMsg = messaging.VehicleConfigMsg().write(inputVehConfigMsgData)\n    platform.vehConfigInMsg.subscribeTo(inputVehConfigMsg)\n\n    # Create input RW configuration msg\n    inputRWConfigMsgData = messaging.RWArrayConfigMsgPayload()\n    inputRWConfigMsgData.GsMatrix_B = [1,0,0,0,1,0,0,0,1]\n    inputRWConfigMsgData.JsList = [0.01, 0.01, 0.01]\n    inputRWConfigMsgData.numRW = 3\n    inputRWConfigMsgData.uMax = [0.001, 0.001, 0.001]\n    inputRWConfigMsg = messaging.RWArrayConfigMsg().write(inputRWConfigMsgData)\n    platform.rwConfigDataInMsg.subscribeTo(inputRWConfigMsg)\n\n    # Create input RW speeds msg\n    inputRWSpeedsMsgData = messaging.RWSpeedMsgPayload()\n    inputRWSpeedsMsgData.wheelSpeeds = [100, 100, 100]\n    inputRWSpeedsMsg = messaging.RWSpeedMsg().write(inputRWSpeedsMsgData)\n    platform.rwSpeedsInMsg.subscribeTo(inputRWSpeedsMsg)\n\n    # Setup logging on the test module output messages so that we get all the writes to it\n    ref1Log = platform.hingedRigidBodyRef1OutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, ref1Log)\n    ref2Log = platform.hingedRigidBodyRef2OutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, ref2Log)\n    bodyHeadingLog = platform.bodyHeadingOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, bodyHeadingLog)\n    thrusterTorqueLog = platform.thrusterTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, thrusterTorqueLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.5))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    theta1 = ref1Log.theta[0]\n    theta2 = ref2Log.theta[0]\n\n    FM = [[np.cos(theta2),  np.sin(theta1)*np.sin(theta2), -np.cos(theta1)*np.sin(theta2)],\n          [       0      ,          np.cos(theta1)       ,         np.sin(theta1)        ],\n          [np.sin(theta2), -np.sin(theta1)*np.cos(theta2),  np.cos(theta1)*np.cos(theta2)]]\n\n    MB = rbk.MRP2C(sigma_MB)\n\n    r_CB_M = np.matmul(MB, r_CB_B)\n    r_CM_M = r_CB_M + r_BM_M\n    r_CM_F = np.matmul(FM, r_CM_M)\n    r_CT_F = r_CM_F - r_FM_F - r_TF_F\n\n    offset = np.linalg.norm(np.cross(r_CT_F,T_F) / np.linalg.norm(np.array(r_CT_F)) / np.linalg.norm(np.array(T_F)))\n\n    # check if the CM offset is zero if control gain K is also 0\n    if K == 0:\n        if not unitTestSupport.isDoubleEqual(offset, 0.0, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + platform.ModelTag + \"thrusterPlatformReference module failed unit test on zero offset \\n\")\n\n    T_B_hat_sim = bodyHeadingLog.rHat_XB_B[0]               # simulation result\n    FB = np.matmul(FM, MB)\n    T_B = np.matmul(FB.transpose(), T_F)\n    T_B_hat = T_B / np.linalg.norm(T_B)                     # truth value\n\n    # compare the module results to the python computation for body-frame thruster direction\n    if not unitTestSupport.isVectorEqual(T_B_hat_sim, T_B_hat, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + platform.ModelTag + \"thrusterPlatformReference module failed unit test on body frame thruster direction \\n\")\n\n    L_B_sim = thrusterTorqueLog.torqueRequestBody[0]        # simulation result\n    L_F = np.cross(r_CT_F, T_F)\n    L_B = np.matmul(FB.transpose(),L_F)\n\n    # compare the module results to the python computation for body-frame cmd torque\n    if not unitTestSupport.isVectorEqual(L_B_sim, L_B, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + platform.ModelTag + \"thrusterPlatformReference module failed unit test on thruster torque \\n\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_thrFiringSchmitt(show_plots, resetCheck, dvOn):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = thrFiringSchmittTestFunction(show_plots, resetCheck, dvOn)\n    assert testResults < 1, testMessage",
  "def thrFiringSchmittTestFunction(show_plots, resetCheck, dvOn):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = thrFiringSchmitt.thrFiringSchmitt()\n    module.ModelTag = \"thrFiringSchmitt\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.thrMinFireTime = 0.2\n    if dvOn == 1:\n        module.baseThrustState = 1\n    else:\n        module.baseThrustState = 0\n\n    module.level_on = .75\n    module.level_off = .25\n\n    # setup thruster cluster message\n    fswSetupThrusters.clearSetup()\n    rcsLocationData = [\n        [-0.86360, -0.82550, 1.79070],\n        [-0.82550, -0.86360, 1.79070],\n        [0.82550, 0.86360, 1.79070],\n        [0.86360, 0.82550, 1.79070],\n        [-0.86360, -0.82550, -1.79070],\n        [-0.82550, -0.86360, -1.79070],\n        [0.82550, 0.86360, -1.79070],\n        [0.86360, 0.82550, -1.79070]\n        ]\n    rcsDirectionData = [\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, -1.0, 0.0],\n        [-1.0, 0.0, 0.0],\n        [-1.0, 0.0, 0.0],\n        [0.0, -1.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [1.0, 0.0, 0.0]\n        ]\n\n    for i in range(len(rcsLocationData)):\n        fswSetupThrusters.create(rcsLocationData[i], rcsDirectionData[i], 0.5)\n    thrConfMsg = fswSetupThrusters.writeConfigMessage()\n    numThrusters = fswSetupThrusters.getNumOfDevices()\n    module.thrConfInMsg.subscribeTo(thrConfMsg)\n\n    # setup thruster impulse request message\n    inputMessageData = messaging.THRArrayCmdForceMsgPayload()\n    thrCmdMsg = messaging.THRArrayCmdForceMsg()\n    module.thrForceInMsg.subscribeTo(thrCmdMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.onTimeOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n\n    if dvOn:\n        effReq1 = [0.0, -0.1, -0.2, -0.3, -0.349, -0.351, -0.451, -0.5]\n        effReq2 = [0.0, -0.1, -0.2, -0.3, -0.351, -0.351, -0.451, -0.5]\n        effReq3 = [0.0, -0.1, -0.2, -0.3, -0.5, -0.351, -0.451, -0.5]\n        effReq4 = [0.0, -0.1, -0.2, -0.3, -0.351, -0.351, -0.451, -0.5]\n\n    else:\n        effReq1 = [0.5, 0.05, 0.09, 0.11, 0.16, 0.18, 0.2, 0.49]\n        effReq2 = [0.5, 0.05, 0.09, 0.11, 0.16, 0.18, 0.2, 0.11]\n        effReq3 = [0.5, 0.05, 0.09, 0.11, 0.16, 0.18, 0.2, 0.01]\n        effReq4 = [0.5, 0.05, 0.09, 0.11, 0.16, 0.18, 0.2, 0.11]\n\n    inputMessageData.thrForce = effReq1\n    thrCmdMsg.write(inputMessageData)\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n\n    inputMessageData.thrForce = effReq2\n    thrCmdMsg.write(inputMessageData)\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n\n    inputMessageData.thrForce = effReq3\n    thrCmdMsg.write(inputMessageData)\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.5))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n\n    inputMessageData.thrForce = effReq4\n    thrCmdMsg.write(inputMessageData)\n    unitTestSim.ConfigureStopTime(macros.sec2nano(3.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    if resetCheck:\n        # reset the module to test this functionality\n        module.Reset(macros.sec2nano(3.0))     # this module reset function needs a time input (in NanoSeconds)\n\n        # run the module again for an additional 1.0 seconds\n        unitTestSim.ConfigureStopTime(macros.sec2nano(5.5))        # seconds to stop simulation\n        unitTestSim.ExecuteSimulation()\n\n\n    # This pulls the actual data log from the simulation run.\n    moduleOutput = dataLog.OnTimeRequest[:, :numThrusters]\n    # print moduleOutput\n\n    # set the filtered output truth states\n    if resetCheck==1:\n        if dvOn == 1:\n            trueVector = [\n                   [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0],\n                   [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.2, 0.0, 0.0, 0.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.2, 0.0, 0.0, 0.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.2, 0.0, 0.0, 0.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0, 0.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0, 0.0],\n                   [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0, 0.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0, 0.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0, 0.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0, 0.0],\n                   ]\n        else:\n            trueVector = [\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.49],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.2],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.2],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.0],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.0],\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.0],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.0],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.0],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.0],\n                   ]\n\n    else:\n        if dvOn == 1:\n            trueVector = [\n                   [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0],\n                   [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.2, 0.0, 0.0, 0.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.2, 0.0, 0.0, 0.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.2, 0.0, 0.0, 0.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0, 0.0],\n                   [0.55, 0.4, 0.3, 0.2, 0.0, 0.0, 0.0, 0.0],\n                   ]\n        else:\n            trueVector = [\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.49],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.2],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.2],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.0],\n                   [0.55, 0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.0],\n                   ]\n\n        # else:\n        #     testFailCount+=1\n        #     testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed with unsupported input parameters\")\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput, accuracy,\n                                                               \"OnTimeRequest\", testFailCount, testMessages)\n\n    snippentName = \"passFail\" + str(resetCheck) + str(dvOn)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_hingedRigidBodyPIDMotor(show_plots, thetaR, thetaDotR, theta, thetaDot, K, P, I, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test verifies the correctness of the output motor torque :ref:`hingedRigidBodyPIDMotor`.\n    The inputs provided are reference angle and angle rate, current angle and angle rate, proportional,\n    derivative, and integral gain.\n\n    **Test Parameters**\n\n    Args:\n        thetaR (double): reference angle;\n        thetaDotR (double): reference angle rate;\n        theta (double): current angle;\n        thetaDot (double): current angle rate;\n        K (double): proportional gain;\n        P (double): derivative gain;\n        I (double): integral gain;\n        accuracy (float): absolute accuracy value used in the validation tests.\n\n    **Description of Variables Being Tested**\n\n    This unit test checks the correctness of the output motor torque\n\n    - ``motorTorqueOutMsg``\n\n    where in this case the output is one dimensional, since the spinning body is one dimensional. The unit test\n    only checks the output at the first time step, for which the integral term does not contribute.\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = hingedRigidBodyPIDMotorTestFunction(show_plots, thetaR, thetaDotR, theta, thetaDot, K, P, I, accuracy)\n    assert testResults < 1, testMessage",
  "def hingedRigidBodyPIDMotorTestFunction(show_plots, thetaR, thetaDotR, theta, thetaDot, K, P, I, accuracy):\n\n    testFailCount = 0                        # zero unit test result counter\n    testMessages = []                        # create empty array to store test log messages\n    unitTaskName = \"unitTask\"                # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"          # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(1)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    motor = hingedRigidBodyPIDMotor.hingedRigidBodyPIDMotor()\n    motor.ModelTag = \"hingedRigidBodyPIDMotor\"  \n    motor.K = K\n    motor.P = P\n    motor.I = I\n    unitTestSim.AddModelToTask(unitTaskName, motor)\n\n    # Create input spinning body reference message\n    refInMsgData = messaging.HingedRigidBodyMsgPayload()\n    refInMsgData.theta = thetaR\n    refInMsgData.thetaDot = thetaDotR\n    refInMsg = messaging.HingedRigidBodyMsg().write(refInMsgData)\n    motor.hingedRigidBodyRefInMsg.subscribeTo(refInMsg)\n\n    # Create input spinning body message\n    stateInMsgData = messaging.HingedRigidBodyMsgPayload()\n    stateInMsgData.theta = theta\n    stateInMsgData.thetaDot = thetaDot\n    stateInMsg = messaging.HingedRigidBodyMsg().write(stateInMsgData)\n    motor.hingedRigidBodyInMsg.subscribeTo(stateInMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = motor.motorTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.5))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    T = K * (thetaR - theta) + P * (thetaDotR - thetaDot)\n\n    # compare the module results to the truth values\n    if not unitTestSupport.isDoubleEqual(dataLog.motorTorque[0][0], T, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + motor.ModelTag + \" module failed unit test for thetaR = {}, thetaDotR  = {}, theta = {}, thetaDot = {}, K = {}, P = {} \\n\".format(thetaR, thetaDotR, theta, thetaDot, K, P))\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def computeRotationAngle(sigma_RN, rHat_SB_N, a1Hat_B, a2Hat_B, theta0):\n\n    RN = rbk.MRP2C(sigma_RN)\n    rS_R = np.matmul(RN, rHat_SB_N)\n\n    a2_R = []\n    dotP = np.dot(rS_R, a1Hat_B)\n    for n in range(3):\n        a2_R.append(rS_R[n] - dotP * a1Hat_B[n])\n    a2_R = np.array(a2_R)\n    a2_R_norm = np.linalg.norm(a2_R)\n    if a2_R_norm > 1e-6:\n        a2_R = a2_R / a2_R_norm\n        theta = np.arccos(min(max(np.dot(a2Hat_B, a2_R),-1),1))\n        if np.dot(a1Hat_B, np.cross(a2Hat_B, a2_R)) < 0:\n            theta = -theta\n    else:\n        theta = theta0\n\n    return theta",
  "def test_solarArrayRotation(show_plots, rHat_SB_N, sigma_BN, sigma_RN, bodyFrame, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test verifies the correctness of the output reference angle computed by the :ref:`solarArrayReference`.\n    The inputs provided are the inertial Sun direction, current attitude of the hub, and reference frame. Based on\n    current attitude, the sun direction vector is mapped into body frame coordinates and passed into the Attitude\n    Navigation Message.\n\n    **Test Parameters**\n\n    Args:\n        rHat_SB_N[3] (double): Sun direction vector, in inertial frame components;\n        sigma_BN[3] (double): spacecraft hub attitude with respect to the inertial frame, in MRP;\n        sigma_RN[3] (double): reference frame attitude with respect to the inertial frame, in MRP;\n        bodyFrame (int): 0 to calculate reference rotation angle w.r.t. reference frame, 1 to calculate it w.r.t the current spacecraft attitude;\n        accuracy (float): absolute accuracy value used in the validation tests.\n\n    **Description of Variables Being Tested**\n\n    This unit test checks the correctness of the output attitude reference message \n\n    - ``hingedRigidBodyRefOutMsg``\n\n    in all its parts. The reference angle ``theta`` is checked versus the value computed by a python function that computes the same angle. \n    The reference angle derivative ``thetaDot`` is checked versus zero, as the module is run for only one Update call.\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = solarArrayRotationTestFunction(show_plots, rHat_SB_N, sigma_BN, sigma_RN, bodyFrame, accuracy)\n    assert testResults < 1, testMessage",
  "def solarArrayRotationTestFunction(show_plots, rHat_SB_N, sigma_BN, sigma_RN, attitudeFrame, accuracy):\n\n    a1Hat_B = np.array([1, 0, 0])\n    a2Hat_B = np.array([0, 1, 0])\n    BN = rbk.MRP2C(sigma_BN)\n    rHat_SB_B = np.matmul(BN, rHat_SB_N)\n    thetaC = 0\n    thetaDotC = 0\n\n    testFailCount = 0                        # zero unit test result counter\n    testMessages = []                        # create empty array to store test log messages\n    unitTaskName = \"unitTask\"                # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"          # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(1)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct tested module and associated C container\n    solarArray = solarArrayReference.solarArrayReference()\n    solarArray.ModelTag = \"solarArrayReference\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, solarArray)\n\n    # Initialize the test module configuration data\n    solarArray.a1Hat_B = a1Hat_B\n    solarArray.a2Hat_B = a2Hat_B\n    solarArray.attitudeFrame = attitudeFrame\n\n    # Create input attitude navigation message\n    natAttInMsgData = messaging.NavAttMsgPayload()\n    natAttInMsgData.sigma_BN = sigma_BN\n    natAttInMsgData.vehSunPntBdy = rHat_SB_B\n    natAttInMsg = messaging.NavAttMsg().write(natAttInMsgData)\n    solarArray.attNavInMsg.subscribeTo(natAttInMsg)\n\n    # Create input attitude reference message\n    attRefInMsgData = messaging.AttRefMsgPayload()\n    attRefInMsgData.sigma_RN = sigma_RN\n    attRefInMsg = messaging.AttRefMsg().write(attRefInMsgData)\n    solarArray.attRefInMsg.subscribeTo(attRefInMsg)\n\n    # Create input hinged rigid body body message\n    hingedRigidBodyInMsgData = messaging.HingedRigidBodyMsgPayload()\n    hingedRigidBodyInMsgData.theta = thetaC\n    hingedRigidBodyInMsgData.thetaDot = thetaDotC\n    hingedRigidBodyInMsg = messaging.HingedRigidBodyMsg().write(hingedRigidBodyInMsgData)\n    solarArray.hingedRigidBodyInMsg.subscribeTo(hingedRigidBodyInMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = solarArray.hingedRigidBodyRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.5))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    if attitudeFrame == 0:\n        thetaR = computeRotationAngle(sigma_RN, rHat_SB_N, a1Hat_B, a2Hat_B, thetaC)\n    else:\n        thetaR = computeRotationAngle(sigma_BN, rHat_SB_N, a1Hat_B, a2Hat_B, thetaC)\n    if thetaR-thetaC > np.pi:\n        thetaR -= np.pi\n    elif thetaR-thetaC < -np.pi:\n        thetaR += np.pi\n    # compare the module results to the truth values\n    if not unitTestSupport.isDoubleEqual(dataLog.theta[0], thetaR, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \"\n                    + solarArray.ModelTag\n                    + \"solarArrayRotation module failed unit test on thetaR for sigma_BN = [{},{},{}], \"\n                      \"sigma_RN = [{},{},{}] and attitudeFrame = {} \\n\".format(\n                        sigma_BN[0], sigma_BN[1], sigma_BN[2], sigma_RN[0], sigma_RN[1], sigma_RN[2], attitudeFrame))\n    if not unitTestSupport.isDoubleEqual(dataLog.thetaDot[0], 0, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \"\n                    + solarArray.ModelTag\n                    + \"solarArrayRotation module failed unit test on thetaDotR for sigma_BN = [{},{},{}], \"\n                      \"sigma_RN = [{},{},{}] and attitudeFrame = {} \\n\".format(\n                        sigma_BN[0], sigma_BN[1], sigma_BN[2], sigma_RN[0], sigma_RN[1], sigma_RN[2], attitudeFrame))\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_torqueScheduler(lockFlag, tSwitch, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test verifies the correctness of the output motor torque :ref:`torqueScheduler`.\n    The inputs provided are the lock flag and the time at which thr control is switched from \n    one degree of freedom to the other.\n\n    **Test Parameters**\n\n    Args:\n        lockFlag (int): flag to determine which torque to use first;\n        tSwitch (double): time at which torque is to be switched from one d.o.f. to the other;\n\n    **Description of Variables Being Tested**\n\n    This unit test checks the correctness of the output motor torque msg and the output effector lock msg:\n\n    - ``motorTorqueOutMsg``\n    - ``effectorLockOutMsg``.\n\n    The test checks that the output of ``motorTorqueOutMsg`` always matches the torques contained in the input msgs\n    and that the flags contained in ``effectorLockOutMsg`` are consistent with the schedule logic that the user is requesting.\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = torqueSchedulerTestFunction(lockFlag, tSwitch, accuracy)\n    assert testResults < 1, testMessage",
  "def torqueSchedulerTestFunction(lockFlag, tSwitch, accuracy):\n\n    testFailCount = 0                        # zero unit test result counter\n    testMessages = []                        # create empty array to store test log messages\n    unitTaskName = \"unitTask\"                # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"          # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(1)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C container\n    scheduler = torqueScheduler.torqueScheduler()\n    scheduler.ModelTag = \"torqueScheduler\"\n    scheduler.lockFlag = lockFlag\n    scheduler.tSwitch = tSwitch\n    unitTestSim.AddModelToTask(unitTaskName, scheduler)\n\n    # Create input array motor torque msg #1\n    motorTorque1InMsgData = messaging.ArrayMotorTorqueMsgPayload()\n    motorTorque1InMsgData.motorTorque = [1]\n    motorTorque1InMsg = messaging.ArrayMotorTorqueMsg().write(motorTorque1InMsgData)\n    scheduler.motorTorque1InMsg.subscribeTo(motorTorque1InMsg)\n\n    # Create input array motor torque msg #2\n    motorTorque2InMsgData = messaging.ArrayMotorTorqueMsgPayload()\n    motorTorque2InMsgData.motorTorque = [3]\n    motorTorque2InMsg = messaging.ArrayMotorTorqueMsg().write(motorTorque2InMsgData)\n    scheduler.motorTorque2InMsg.subscribeTo(motorTorque2InMsg)\n\n    # Setup logging on the test module output messages so that we get all the writes to it\n    torqueLog = scheduler.motorTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, torqueLog)\n    lockLog = scheduler.effectorLockOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, lockLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(10))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # compare the module results to the truth values\n    time = torqueLog.times() * macros.NANO2SEC\n\n    for i in range(len(time)):\n        if not unitTestSupport.isDoubleEqual(torqueLog.motorTorque[i][0], motorTorque1InMsgData.motorTorque[0], accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at passing motor torque #1 value\")\n        if not unitTestSupport.isDoubleEqual(torqueLog.motorTorque[i][1], motorTorque2InMsgData.motorTorque[0], accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at passing motor torque #2 value\")\n\n        if lockFlag == 0:\n            if not unitTestSupport.isDoubleEqual(lockLog.effectorLockFlag[i][0], 0, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at outputting effector flag #1\")\n            if not unitTestSupport.isDoubleEqual(lockLog.effectorLockFlag[i][1], 0, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at outputting effector flag #2\")\n        elif lockFlag == 1:\n            if time[i] > tSwitch:\n                if not unitTestSupport.isDoubleEqual(lockLog.effectorLockFlag[i][0], 1, accuracy):\n                    testFailCount += 1\n                    testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at outputting effector flag #1\")\n                if not unitTestSupport.isDoubleEqual(lockLog.effectorLockFlag[i][1], 0, accuracy):\n                    testFailCount += 1\n                    testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at outputting effector flag #2\")\n            else:\n                if not unitTestSupport.isDoubleEqual(lockLog.effectorLockFlag[i][0], 0, accuracy):\n                    testFailCount += 1\n                    testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at outputting effector flag #1\")\n                if not unitTestSupport.isDoubleEqual(lockLog.effectorLockFlag[i][1], 1, accuracy):\n                    testFailCount += 1\n                    testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at outputting effector flag #2\")\n        elif lockFlag == 2:\n            if time[i] > tSwitch:\n                if not unitTestSupport.isDoubleEqual(lockLog.effectorLockFlag[i][0], 0, accuracy):\n                    testFailCount += 1\n                    testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at outputting effector flag #1\")\n                if not unitTestSupport.isDoubleEqual(lockLog.effectorLockFlag[i][1], 1, accuracy):\n                    testFailCount += 1\n                    testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at outputting effector flag #2\")\n            else:\n                if not unitTestSupport.isDoubleEqual(lockLog.effectorLockFlag[i][0], 1, accuracy):\n                    testFailCount += 1\n                    testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at outputting effector flag #1\")\n                if not unitTestSupport.isDoubleEqual(lockLog.effectorLockFlag[i][1], 0, accuracy):\n                    testFailCount += 1\n                    testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at outputting effector flag #2\")\n        else:\n            if not unitTestSupport.isDoubleEqual(lockLog.effectorLockFlag[i][0], 1, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at outputting effector flag #1\")\n            if not unitTestSupport.isDoubleEqual(lockLog.effectorLockFlag[i][1], 1, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + scheduler.ModelTag + \" module failed at outputting effector flag #2\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_prescribedTransTestFunction(show_plots, scalarPosInit, scalarPosRef, scalarAccelMax, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test ensures that the profiled translational maneuver for a secondary rigid body connected\n    to the spacecraft hub is properly computed for a series of initial and reference positions and maximum\n    accelerations. The final prescribed position and velocity magnitudes are compared with the reference values.\n\n    **Test Parameters**\n\n    Args:\n        scalarPosInit (float): [m] Initial scalar position of the F frame with respect to the M frame\n        scalarPosRef (float): [m] Reference scalar position of the F frame with respect to the M frame\n        scalarAccelMax (float): [m/s^2] Maximum acceleration for the translational maneuver\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    This unit test ensures that the profiled translational maneuver is properly computed for a series of initial and\n    reference positions and maximum accelerations. The final prescribed position magnitude ``r_FM_M_Final`` and\n    velocity magnitude ``rPrime_FM_M_Final`` are compared with the reference values ``r_FM_M_Ref`` and\n    ``rPrime_FM_M_Ref``, respectively.\n    \"\"\"\n\n    [testResults, testMessage] = prescribedTransTestFunction(show_plots, scalarPosInit, scalarPosRef, scalarAccelMax, accuracy)\n\n    assert testResults < 1, testMessage",
  "def prescribedTransTestFunction(show_plots, scalarPosInit, scalarPosRef, scalarAccelMax, accuracy):\n    \"\"\"Call this routine directly to run the unit test.\"\"\"\n    testFailCount = 0                                        # zero unit test result counter\n    testMessages = []                                        # create empty array to store test log messages\n    unitTaskName = \"unitTask\"                                # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"                          # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.1)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    PrescribedTrans = prescribedTrans.prescribedTrans()\n    PrescribedTrans.ModelTag = \"prescribedTrans\"                                 # update python name of test module\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, PrescribedTrans)\n\n    # Initialize the test module configuration data\n    transAxis_M = np.array([0.5, 0.0, 0.5 * np.sqrt(3)])\n    PrescribedTrans.transAxis_M = transAxis_M\n    PrescribedTrans.scalarAccelMax = scalarAccelMax  # [rad/s^2]\n    PrescribedTrans.r_FM_M = scalarPosInit * transAxis_M\n    PrescribedTrans.rPrime_FM_M = np.array([0.0, 0.0, 0.0])\n    PrescribedTrans.rPrimePrime_FM_M = np.array([0.0, 0.0, 0.0])\n    PrescribedTrans.omega_FM_F = np.array([0.0, 0.0, 0.0])\n    PrescribedTrans.omegaPrime_FM_F = np.array([0.0, 0.0, 0.0])\n    PrescribedTrans.sigma_FM = np.array([0.0, 0.0, 0.0])\n\n    # Create input message\n    scalarVelRef = 0.0  # [m/s]\n    PrescribedTransMessageData = messaging.PrescribedTransMsgPayload()\n    PrescribedTransMessageData.scalarPos = scalarPosRef\n    PrescribedTransMessageData.scalarVel = scalarVelRef\n    PrescribedTransMessage = messaging.PrescribedTransMsg().write(PrescribedTransMessageData)\n    PrescribedTrans.prescribedTransInMsg.subscribeTo(PrescribedTransMessage)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = PrescribedTrans.prescribedMotionOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time\n    simTime = np.sqrt(((0.5 * np.abs(scalarPosRef - scalarPosInit)) * 8) / scalarAccelMax) + 5\n    unitTestSim.ConfigureStopTime(macros.sec2nano(simTime))\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # Extract logged data\n    r_FM_M = dataLog.r_FM_M\n    rPrime_FM_M = dataLog.rPrime_FM_M\n    timespan = dataLog.times()\n\n    scalarVel_Final = np.linalg.norm(rPrime_FM_M[-1, :])\n    scalarPos_Final = np.linalg.norm(r_FM_M[-1, :])\n\n    # Plot r_FM_F\n    r_FM_M_Ref = scalarPosRef * transAxis_M\n    r_FM_M_1_Ref = np.ones(len(timespan)) * r_FM_M_Ref[0]\n    r_FM_M_2_Ref = np.ones(len(timespan)) * r_FM_M_Ref[1]\n    r_FM_M_3_Ref = np.ones(len(timespan)) * r_FM_M_Ref[2]\n\n    plt.figure()\n    plt.clf()\n    plt.plot(timespan * macros.NANO2SEC, r_FM_M[:, 0], label=r'$r_{1}$')\n    plt.plot(timespan * macros.NANO2SEC, r_FM_M[:, 1], label=r'$r_{2}$')\n    plt.plot(timespan * macros.NANO2SEC, r_FM_M[:, 2], label=r'$r_{3}$')\n    plt.plot(timespan * macros.NANO2SEC, r_FM_M_1_Ref, '--', label=r'$r_{1 Ref}$')\n    plt.plot(timespan * macros.NANO2SEC, r_FM_M_2_Ref, '--', label=r'$r_{2 Ref}$')\n    plt.plot(timespan * macros.NANO2SEC, r_FM_M_3_Ref, '--', label=r'$r_{3 Ref}$')\n    plt.title(r'${}^\\mathcal{M} r_{\\mathcal{F}/\\mathcal{M}}$ Profiled Trajectory', fontsize=14)\n    plt.ylabel('(m)', fontsize=16)\n    plt.xlabel('Time (s)', fontsize=16)\n    plt.legend(loc='center left', prop={'size': 16})\n\n    # Plot rPrime_FM_F\n    plt.figure()\n    plt.clf()\n    plt.plot(timespan * macros.NANO2SEC, rPrime_FM_M[:, 0], label='$r\\'_{1}$')\n    plt.plot(timespan * macros.NANO2SEC, rPrime_FM_M[:, 1], label='$r\\'_{2}$')\n    plt.plot(timespan * macros.NANO2SEC, rPrime_FM_M[:, 2], label='$r\\'_{3}$')\n    plt.title(r'${}^\\mathcal{M} r\\'_{\\mathcal{F}/\\mathcal{M}}$ Profiled Trajectory', fontsize=14)\n    plt.ylabel('(m/s)', fontsize=16)\n    plt.xlabel('Time (s)', fontsize=16)\n    plt.legend(loc='upper left', prop={'size': 16})\n\n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n    # set the filtered output truth states\n    if not unitTestSupport.isDoubleEqual(scalarVel_Final, scalarVelRef, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + PrescribedTrans.ModelTag + \"scalarVel_Final and scalarVelRef do not match\")\n\n    if not unitTestSupport.isDoubleEqual(scalarPos_Final, scalarPosRef, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + PrescribedTrans.ModelTag + \"scalarPos_Final and scalarPosRef do not match\")\n\n    return [testFailCount, ''.join(testMessages)]",
  "def addTimeColumn(time, data):\n    return np.transpose(np.vstack([[time], np.transpose(data)]))",
  "def test_module(show_plots, useLargeVoltage, useAvailability, useTorqueLoop, testName):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(show_plots, useLargeVoltage, useAvailability, useTorqueLoop, testName)\n    assert testResults < 1, testMessage",
  "def run(show_plots, useLargeVoltage, useAvailability, useTorqueLoop, testName):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = rwMotorVoltage.rwMotorVoltage()\n    module.ModelTag = \"rwMotorVoltage\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    # module.torqueInMsgName = \"rw_torque_Lr\"\n    # module.rwParamsInMsgName = \"rw_parameters\"\n    # module.voltageOutMsgName = \"rw_volt_cmd\"\n\n    # set module parameters\n    module.VMin = 1.0     # Volts\n    module.VMax = 11.0    # Volts\n\n    if useTorqueLoop:\n        module.K = 1.5\n        rwSpeedMessage = messaging.RWSpeedMsgPayload()\n        rwSpeedMessage.wheelSpeeds = [1.0, 2.0, 1.5, -3.0]      # rad/sec Omega's\n        rwSpeedInMsg = messaging.RWSpeedMsg().write(rwSpeedMessage)\n        module.rwSpeedInMsg.subscribeTo(rwSpeedInMsg)\n        unitTestSupport.writeTeXSnippet(\"Omega1\", r\"$\\bm\\Omega = \" \\\n                                        + str(rwSpeedMessage.wheelSpeeds[0:4]) + \"$\"\n                                        , path)\n\n    #\n    #   create BSK messages\n    #\n    # Create RW configuration parameter input message\n    GsMatrix_B = [\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, 0.0, 1.0],\n        [1.0, 1.0, 1.0]         # the create routine below normalizes these vectors\n    ]\n    fswSetupRW.clearSetup()\n    for i in range(4):\n        fswSetupRW.create(GsMatrix_B[i],    #           spin axis\n                          0.1,              # kg*m^2    J2\n                          0.2)              # Nm        uMax\n    rwConfigInMsg = fswSetupRW.writeConfigMessage()\n    module.rwParamsInMsg.subscribeTo(rwConfigInMsg)\n    numRW = fswSetupRW.getNumOfDevices()\n\n    # Create RW motor torque input message\n    usMessageData = messaging.ArrayMotorTorqueMsgPayload()\n    if useLargeVoltage:\n        usMessageData.motorTorque = [0.5, 0.0, -0.15, -0.5]           # [Nm] RW motor torque cmds\n    else:\n        usMessageData.motorTorque = [0.05, 0.0, -0.15, -0.2]  # [Nm] RW motor torque cmds\n    rwMotorTorqueInMsg = messaging.ArrayMotorTorqueMsg().write(usMessageData)\n    module.torqueInMsg.subscribeTo(rwMotorTorqueInMsg)\n\n    # create RW availability message\n    if useAvailability:\n        rwAvailabilityMessage = messaging.RWAvailabilityMsgPayload()\n        rwAvailArray = np.zeros(messaging.MAX_EFF_CNT, dtype=int)\n        rwAvailArray.fill(messaging.AVAILABLE)\n        rwAvailArray[2] = messaging.UNAVAILABLE        # make 3rd RW unavailable\n        rwAvailabilityMessage.wheelAvailability = rwAvailArray\n        rwAvailInMsg = messaging.RWAvailabilityMsg().write(rwAvailabilityMessage)\n        module.rwAvailInMsg.subscribeTo(rwAvailInMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.voltageOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    if useTorqueLoop:\n        rwSpeedMessage.wheelSpeeds = [1.1, 2.1, 1.1, -4.1]  # rad/sec Omega's\n        rwSpeedInMsg.write(rwSpeedMessage)\n        unitTestSupport.writeTeXSnippet(\"Omega2\", r\"$\\bm\\Omega = \" \\\n                                        + str(rwSpeedMessage.wheelSpeeds[0:4]) + \"$\"\n                                        , path)\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.5))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # reset the module to test this functionality\n    module.Reset(1)     # this module reset function needs a time input (in NanoSeconds)\n\n    # run the module again for an additional 1.0 seconds\n    unitTestSim.ConfigureStopTime(macros.sec2nano(3.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n\n    # This pulls the actual data log from the simulation run.\n    moduleOutput = dataLog.voltage[:, :numRW]\n    print(moduleOutput)\n\n\n    # set the filtered output truth states\n    trueVector=[];\n    if not useLargeVoltage and not useAvailability and not useTorqueLoop:\n        trueVector = [\n                   [3.5, 0., -8.5, -11.]\n                 , [3.5, 0., -8.5, -11.]\n                 , [3.5, 0., -8.5, -11.]\n                 , [3.5, 0., -8.5, -11.]\n                 , [3.5, 0., -8.5, -11.]\n                 , [3.5, 0., -8.5, -11.]\n                 , [3.5, 0., -8.5, -11.]\n                   ]\n    if useLargeVoltage and not useAvailability and not useTorqueLoop:\n        trueVector = [\n                   [11., 0., -8.5, -11.]\n                 , [11., 0., -8.5, -11.]\n                 , [11., 0., -8.5, -11.]\n                 , [11., 0., -8.5, -11.]\n                 , [11., 0., -8.5, -11.]\n                 , [11., 0., -8.5, -11.]\n                 , [11., 0., -8.5, -11.]\n                   ]\n    if not useLargeVoltage and useAvailability and not useTorqueLoop:\n        trueVector = [\n                   [3.5, 0., 0., -11.]\n                 , [3.5, 0., 0., -11.]\n                 , [3.5, 0., 0., -11.]\n                 , [3.5, 0., 0., -11.]\n                 , [3.5, 0., 0., -11.]\n                 , [3.5, 0., 0., -11.]\n                 , [3.5, 0., 0., -11.]\n                   ]\n    if not useLargeVoltage and not useAvailability and useTorqueLoop:\n        trueVector = [\n                   [3.5, 0., -8.5, -11.]\n                 , [3.5, 0., -8.5, -11.]\n                 , [3.5, 0., -8.5, -11.]\n                 , [5.75, -2.5, -11., -9.5]\n                 , [3.5, 0., -8.5, -11.]\n                 , [3.5, 0., -8.5, -11.]\n                 , [7.25, 0., -11., -11.]\n                   ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-10\n\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput,\n                                                               accuracy, \"Output Vector\",\n                                                               testFailCount, testMessages)\n\n\n\n    # If the argument provided at commandline \"--show_plots\" evaluates as true,\n    # plot all figures\n    # plot a sample variable.\n    # plt.close(\"all\")    # close all prior figures so we start with a clean slate\n    # plt.figure(1)\n    # plt.plot(variableState[:, 0]*macros.NANO2SEC, variableState[:, 1],\n    #          label='Case useLargeVoltage = ' + str(useLargeVoltage))\n    # plt.legend(loc='upper left')\n    # plt.xlabel('Time [s]')\n    # plt.ylabel('Variable Description [unit]')\n    # if show_plots:\n    #     plt.show()\n    #     plt.close('all')\n\n    #   print out success message if no error were found\n    snippentName = \"passFail\" + testName\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    # write TeX Tables for documentation\n    moduleOutput = addTimeColumn(dataLog.times(), dataLog.voltage)[:, :numRW+1]\n    resultTable = moduleOutput\n    resultTable[:, 0] = macros.NANO2SEC * resultTable[:, 0]\n    diff = np.delete(moduleOutput, 0, 1) - trueVector\n    resultTable = np.insert(resultTable, list(range(2, 2 + len(diff.transpose()))), diff, axis=1)\n\n    tableName = \"test\" + str(useLargeVoltage) + str(useAvailability) + str(useTorqueLoop)\n    tableHeaders = [\"time [s]\", \"$V_{s,1}$\", \"Error\", \"$V_{s,2}$\", \"Error\", \"$V_{s,3}$\", \"Error\", \"$V_{s,4}$\", \"Error\"]\n    caption = 'RW voltage output for case {\\\\tt useLargeVoltage = ' + str(useLargeVoltage) \\\n              + ', useAvailability = ' + str(useAvailability) \\\n              + ', useTorqueLoop = ' + str(useTorqueLoop) + '}.'\n    unitTestSupport.writeTableLaTeX(\n        tableName,\n        tableHeaders,\n        caption,\n        resultTable,\n        path)\n    unitTestSupport.writeTeXSnippet(\"us\"+ str(useLargeVoltage) + str(useAvailability) + str(useTorqueLoop)\n                                    , \"$\\\\bm u_s = \" + str(usMessageData.motorTorque[0:numRW]) + \"$\"\n                                    , path)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_thrMomentumDumping(show_plots, resetCheck, largeMinFireTime):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = thrMomentumDumpingTestFunction(show_plots, resetCheck, largeMinFireTime)\n    assert testResults < 1, testMessage",
  "def thrMomentumDumpingTestFunction(show_plots, resetCheck, largeMinFireTime):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = thrMomentumDumping.thrMomentumDumping()\n    module.ModelTag = \"thrMomentumDumping\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.maxCounterValue = 2\n    if largeMinFireTime:\n        module.thrMinFireTime = 0.200         # seconds\n    else:\n        module.thrMinFireTime = 0.020         # seconds\n\n    # setup thruster cluster message\n    fswSetupThrusters.clearSetup()\n    rcsLocationData = [\n        [-0.86360, -0.82550, 1.79070],\n        [-0.82550, -0.86360, 1.79070],\n        [0.82550, 0.86360, 1.79070],\n        [0.86360, 0.82550, 1.79070],\n        [-0.86360, -0.82550, -1.79070],\n        [-0.82550, -0.86360, -1.79070],\n        [0.82550, 0.86360, -1.79070],\n        [0.86360, 0.82550, -1.79070]\n        ]\n    rcsDirectionData = [\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, -1.0, 0.0],\n        [-1.0, 0.0, 0.0],\n        [-1.0, 0.0, 0.0],\n        [0.0, -1.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [1.0, 0.0, 0.0]\n        ]\n\n    for i in range(len(rcsLocationData)):\n        fswSetupThrusters.create(rcsLocationData[i], rcsDirectionData[i], 2.0)\n    thrConfInMsg = fswSetupThrusters.writeConfigMessage()\n    numThrusters = fswSetupThrusters.getNumOfDevices()\n\n    # setup thruster impulse request message\n    DeltaPInMsgData = messaging.THRArrayCmdForceMsgPayload()\n    DeltaPInMsgData.thrForce = [1.2, 0.2, 0.0, 1.6, 1.2, 0.2, 1.6, 0.0]\n    deltaPInMsg = messaging.THRArrayCmdForceMsg().write(DeltaPInMsgData)\n\n    # setup the commanded angular momentum change message\n    DeltaHInMsgData = messaging.CmdTorqueBodyMsgPayload()\n    DeltaHInMsgData.torqueRequestBody = [0., 0., 0.]\n    deltaHInMsg = messaging.CmdTorqueBodyMsg()\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.thrusterOnTimeOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.thrusterImpulseInMsg.subscribeTo(deltaPInMsg)\n    module.thrusterConfInMsg.subscribeTo(thrConfInMsg)\n    module.deltaHInMsg.subscribeTo(deltaHInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.5))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # write the input Delta_H message\n    deltaHInMsg.write(DeltaHInMsgData, macros.sec2nano(0.5))\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(3.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    if resetCheck:\n        # reset the module to test this functionality\n        module.Reset(macros.sec2nano(3.0))     # this module reset function needs a time input (in NanoSeconds)\n\n        # run the module again for an additional 1.0 seconds\n        unitTestSim.ConfigureStopTime(macros.sec2nano(3.5))        # seconds to stop simulation\n        unitTestSim.ExecuteSimulation()\n\n        # re-write the input Delta_H message so that it checks for a new message\n        deltaHInMsg.write(DeltaHInMsgData, macros.sec2nano(3.5))\n\n        unitTestSim.ConfigureStopTime(macros.sec2nano(5.5))        # seconds to stop simulation\n        unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    moduleOutput = dataLog.OnTimeRequest[:, :numThrusters]\n    # set the filtered output truth states\n    if resetCheck==1:\n        trueVector = [\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.5, 0.1, 0.0, 0.5, 0.5, 0.1, 0.5, 0.0],\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.1, 0.0, 0.0, 0.3, 0.1, 0.0, 0.3, 0.0],\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.5, 0.1, 0.0, 0.5, 0.5, 0.1, 0.5, 0.0],\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                   [0.1, 0.0, 0.0, 0.3, 0.1, 0.0, 0.3, 0.0]\n                   ]\n    else:\n        if largeMinFireTime:\n            trueVector = [\n                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                [0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, 0.0],\n                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 0.3, 0.0, 0.0, 0.3, 0.0],\n                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n            ]\n        else:\n            trueVector = [\n                       [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                       [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                       [0.5, 0.1, 0.0, 0.5, 0.5, 0.1, 0.5, 0.0],\n                       [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                       [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                       [0.1, 0.0, 0.0, 0.3, 0.1, 0.0, 0.3, 0.0],\n                       [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n                       ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput, accuracy,\n                                                               \"OnTimeRequest\", testFailCount, testMessages)\n\n    snippentName = \"passFail\" + str(resetCheck) + str(largeMinFireTime)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, useDVThruster, useCOMOffset, dropThruster, asymmetricDrop, numControlAxis, saturateThrusters, misconfigThruster):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = thrusterForceTest(show_plots, useDVThruster, useCOMOffset, dropThruster, asymmetricDrop,\n                                                   numControlAxis, saturateThrusters, misconfigThruster)\n    assert testResults < 1, testMessage",
  "def thrusterForceTest(show_plots, useDVThruster, useCOMOffset, dropThruster, asymmetricDrop, numControlAxis, saturateThrusters, misconfigThruster):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = thrForceMapping.thrForceMapping()\n    module.ModelTag = \"thrForceMapping\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # write vehicle configuration message\n    vehicleConfigOut = messaging.VehicleConfigMsgPayload()\n    if useCOMOffset == 1:\n        CoM_B = [0.03,0.001,0.02]\n    else:\n        CoM_B = [0,0,0]\n    vehicleConfigOut.CoM_B = CoM_B\n    vcInMsg = messaging.VehicleConfigMsg().write(vehicleConfigOut)\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    inputMessageData = messaging.CmdTorqueBodyMsgPayload()  # Create a structure for the input message\n    requestedTorque = [1.0, -0.5, 0.7]             # Set up a list as a 3-vector\n    if saturateThrusters>0:        # default angErrThresh is 0, thus this should trigger scaling\n        requestedTorque = [10.0, -5.0, 7.0]\n    if saturateThrusters==2:        # angle is set and small enough to trigger scaling\n        module.angErrThresh = 10.0*macros.D2R\n    if saturateThrusters==3:        # angle is too large enough to trigger scaling\n        module.angErrThresh = 40.0*macros.D2R\n\n    inputMessageData.torqueRequestBody = requestedTorque   # write torque request to input message\n    cmdTorqueInMsg = messaging.CmdTorqueBodyMsg().write(inputMessageData)\n\n    module.epsilon = 0.0005\n    fswSetupThrusters.clearSetup()\n    MAX_EFF_CNT = messaging.MAX_EFF_CNT\n    rcsLocationData = np.zeros((MAX_EFF_CNT, 3))\n    rcsDirectionData = np.zeros((MAX_EFF_CNT, 3))\n\n    controlAxes_B = np.array([\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]\n    ])\n\n    controlAxes_B = controlAxes_B[0:numControlAxis]\n    if len(controlAxes_B) == 0:\n        controlAxes_B = np.array([[]])\n\n    controlAxes_B = np.reshape(controlAxes_B, (1, 3 * numControlAxis))\n    module.controlAxes_B = controlAxes_B[0].tolist()\n\n    if useDVThruster:\n        # DV thruster setup\n        module.thrForceSign = -1\n        numThrusters = 6\n        rcsLocationData[0:6] = [ \\\n            [0, 0.413, -0.1671],\n            [0, -0.413, -0.1671],\n            [0.35766849176297305, 0.20650000000000013, -0.1671],\n            [0.3576684917629732, -0.20649999999999988, -0.1671],\n            [-0.35766849176297333, 0.20649999999999968, -0.1671],\n            [-0.35766849176297305, -0.20650000000000018, -0.1671] \\\n            ]\n        rcsDirectionData[0:6] = [ \\\n            [0.0, 0.0, 1.0],\n            [0.0, 0.0, 1.0],\n            [0.0, 0.0, 1.0],\n            [0.0, 0.0, 1.0],\n            [0.0, 0.0, 1.0],\n            [0.0, 0.0, 1.0] \\\n            ]\n    else:\n        # RCS thruster setup\n        module.thrForceSign = +1\n        numThrusters = 8\n        rcsLocationData[0:8] = [ \\\n                [-0.86360, -0.82550, 1.79070],\n                [-0.82550, -0.86360, 1.79070],\n                [0.82550, 0.86360, 1.79070],\n                [0.86360, 0.82550, 1.79070],\n                [-0.86360, -0.82550, -1.79070],\n                [-0.82550, -0.86360, -1.79070],\n                [0.82550, 0.86360, -1.79070],\n                [0.86360, 0.82550, -1.79070] \\\n                ]\n\n        rcsDirectionData[0:8] = [ \\\n            [1.0, 0.0, 0.0],\n            [0.0, 1.0, 0.0],\n            [0.0, -1.0, 0.0],\n            [-1.0, 0.0, 0.0],\n            [1.0, 0.0, 0.0],\n            [0.0, 1.0, 0.0],\n            [0.0, -1.0, 0.0],\n            [-1.0, 0.0, 0.0] \\\n            ]\n\n\n    if dropThruster > 0:\n        if (dropThruster % 2==0) and asymmetricDrop: # Drop thrusters that dont share the same torque direction\n            removedThrusters = 0\n            for i in range(0, numThrusters, 2):\n                rcsLocationData[i] = [0.0, 0.0, 0.0]\n                rcsDirectionData[i] = [0.0, 0.0, 0.0]\n                removedThrusters += 1\n            if removedThrusters < dropThruster:\n                rcsLocationData[1] = [0.0, 0.0, 0.0]\n                removedThrusters += 1\n        else:\n            for i in range(dropThruster):\n                rcsLocationData[numThrusters - 1 - i, :] = [0.0, 0.0, 0.0]\n                rcsDirectionData[numThrusters - 1 - i, :] = [0.0, 0.0, 0.0]\n\n        indices = []\n        for i in range(numThrusters):\n            if np.linalg.norm(rcsLocationData[i]) == 0:\n                indices = np.append(indices, i)\n\n        offset = 0\n        for i in indices:\n            idx = (int) (i - offset)\n            rcsLocationData = np.delete(rcsLocationData, idx, axis=0)\n            rcsDirectionData = np.delete(rcsDirectionData, idx, axis=0)\n            rcsLocationData = np.append(rcsLocationData,[[0.0, 0.0, 0.0]], axis=0)\n            rcsDirectionData = np.append(rcsDirectionData, [[0.0, 0.0, 0.0]], axis=0)\n            offset = offset + 1\n\n        numThrusters = numThrusters - dropThruster\n    maxThrust = 0.95\n    if useDVThruster:\n        maxThrust = 10.0\n\n\n    for i in range(numThrusters):\n        if misconfigThruster and i == 0:\n            maxThrustConfig = 0.0\n        else:\n            maxThrustConfig = maxThrust\n        fswSetupThrusters.create(rcsLocationData[i], rcsDirectionData[i], maxThrustConfig)\n    thrConfigInMsg = fswSetupThrusters.writeConfigMessage()\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.thrForceCmdOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.cmdTorqueInMsg.subscribeTo(cmdTorqueInMsg)\n    module.thrConfigInMsg.subscribeTo(thrConfigInMsg)\n    module.vehConfigInMsg.subscribeTo(vcInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.5))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    moduleOutput = dataLog.thrForce\n    if misconfigThruster:\n        return [testFailCount, ''.join(testMessages)] # We don't handle cases where a thruster is configured incorrectly.\n\n    if useDVThruster and numControlAxis == 3:\n        return [testFailCount, ''.join(testMessages)] # 3 control axes doesn't work for dv thrusters (only two axes controllable)\n\n\n    results = thrForceMapping.Results_thrForceMapping(requestedTorque, module.controlAxes_B,\n                                         vehicleConfigOut.CoM_B, rcsLocationData,\n                                         rcsDirectionData, module.thrForceSign,\n                                         module.thrForcMag, module.angErrThresh,\n                                         numThrusters, module.epsilon, False)\n    F, DNew = results.results_thrForceMapping()\n\n    accuracy = 1E-6\n\n    # Check that Python Math and C Math are Identical\n    testFailCount, testMessages = unitTestSupport.compareArrayND(np.array([F]), np.array([moduleOutput[0]]), accuracy,\n                                                                 \"CompareForces\",\n                                                                 numThrusters, testFailCount, testMessages)\n\n\n    unitTestSupport.writeTeXSnippet('toleranceValue', str(accuracy), path)\n\n    snippentName = \"passFail_\" + str(useDVThruster) + \"_\" + str(useCOMOffset) + \"_\" + str(dropThruster) + \"_\" + str(\n        numControlAxis) + \"_\" + str(saturateThrusters) + \"_\" + str(misconfigThruster)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, useDVThruster, useCOMOffset, dropThruster, asymmetricDrop, numControlAxis, saturateThrusters, misconfigThruster, use2ndLoop):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = thrusterForceTest(show_plots, useDVThruster, useCOMOffset, dropThruster, asymmetricDrop,\n                                                   numControlAxis, saturateThrusters, misconfigThruster, use2ndLoop)\n    assert testResults < 1, testMessage",
  "def thrusterForceTest(show_plots, useDVThruster, useCOMOffset, dropThruster, asymmetricDrop, numControlAxis,\n                      saturateThrusters, misconfigThruster,use2ndLoop):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = thrForceMapping.thrForceMapping()\n    module.ModelTag = \"thrForceMapping\"\n\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.use2ndLoop = use2ndLoop\n\n    # write vehicle configuration message\n    vehicleConfigOut = messaging.VehicleConfigMsgPayload()\n    if useCOMOffset == 1:\n        CoM_B = [0.03,0.001,0.02]\n    else:\n        CoM_B = [0,0,0]\n    vehicleConfigOut.CoM_B = CoM_B\n    vcInMsg = messaging.VehicleConfigMsg().write(vehicleConfigOut)\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    inputMessageData = messaging.CmdTorqueBodyMsgPayload()  # Create a structure for the input message\n    requestedTorque = [1.0, -0.5, 0.7]             # Set up a list as a 3-vector\n    if saturateThrusters>0:        # default angErrThresh is 0, thus this should trigger scaling\n        requestedTorque = [10.0, -5.0, 7.0]\n    if saturateThrusters==2:        # angle is set and small enough to trigger scaling\n        module.angErrThresh = 10.0*macros.D2R\n    if saturateThrusters==3:        # angle is too large enough to trigger scaling\n        module.angErrThresh = 40.0*macros.D2R\n\n    inputMessageData.torqueRequestBody = requestedTorque   # write torque request to input message\n    cmdTorqueInMsg = messaging.CmdTorqueBodyMsg().write(inputMessageData)\n\n    module.epsilon = 0.0005\n    fswSetupThrusters.clearSetup()\n    MAX_EFF_CNT = messaging.MAX_EFF_CNT\n    rcsLocationData = np.zeros((MAX_EFF_CNT, 3))\n    rcsDirectionData = np.zeros((MAX_EFF_CNT, 3))\n\n    controlAxes_B = np.array([\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]\n    ])\n\n    controlAxes_B = controlAxes_B[0:numControlAxis]\n    if len(controlAxes_B) == 0:\n        controlAxes_B = np.array([[]])\n\n    controlAxes_B = np.reshape(controlAxes_B, (1, 3 * numControlAxis))\n    module.controlAxes_B = controlAxes_B[0].tolist()\n\n    if useDVThruster:\n        # DV thruster setup\n        module.thrForceSign = -1\n        numThrusters = 6\n        rcsLocationData[0:6] = [ \\\n            [0, 0.413, -0.1671],\n            [0, -0.413, -0.1671],\n            [0.35766849176297305, 0.20650000000000013, -0.1671],\n            [0.3576684917629732, -0.20649999999999988, -0.1671],\n            [-0.35766849176297333, 0.20649999999999968, -0.1671],\n            [-0.35766849176297305, -0.20650000000000018, -0.1671] \\\n            ]\n        rcsDirectionData[0:6] = [ \\\n            [0.0, 0.0, 1.0],\n            [0.0, 0.0, 1.0],\n            [0.0, 0.0, 1.0],\n            [0.0, 0.0, 1.0],\n            [0.0, 0.0, 1.0],\n            [0.0, 0.0, 1.0] \\\n            ]\n    else:\n        # RCS thruster setup\n        module.thrForceSign = +1\n        numThrusters = 8\n        rcsLocationData[0:8] = [ \\\n                [-0.86360, -0.82550, 1.79070],\n                [-0.82550, -0.86360, 1.79070],\n                [0.82550, 0.86360, 1.79070],\n                [0.86360, 0.82550, 1.79070],\n                [-0.86360, -0.82550, -1.79070],\n                [-0.82550, -0.86360, -1.79070],\n                [0.82550, 0.86360, -1.79070],\n                [0.86360, 0.82550, -1.79070] \\\n                ]\n\n        rcsDirectionData[0:8] = [ \\\n            [1.0, 0.0, 0.0],\n            [0.0, 1.0, 0.0],\n            [0.0, -1.0, 0.0],\n            [-1.0, 0.0, 0.0],\n            [1.0, 0.0, 0.0],\n            [0.0, 1.0, 0.0],\n            [0.0, -1.0, 0.0],\n            [-1.0, 0.0, 0.0] \\\n            ]\n\n\n    if dropThruster > 0:\n        if (dropThruster % 2==0) and asymmetricDrop: # Drop thrusters that don't share the same torque direction\n            removedThrusters = 0\n            for i in range(0, numThrusters, 2):\n                rcsLocationData[i] = [0.0, 0.0, 0.0]\n                rcsDirectionData[i] = [0.0, 0.0, 0.0]\n                removedThrusters += 1\n            if removedThrusters < dropThruster:\n                rcsLocationData[1] = [0.0, 0.0, 0.0]\n                removedThrusters += 1\n        else:\n            for i in range(dropThruster):\n                rcsLocationData[numThrusters - 1 - i, :] = [0.0, 0.0, 0.0]\n                rcsDirectionData[numThrusters - 1 - i, :] = [0.0, 0.0, 0.0]\n\n        indices = []\n        for i in range(numThrusters):\n            if np.linalg.norm(rcsLocationData[i]) == 0:\n                indices = np.append(indices, i)\n\n        offset = 0\n        for i in indices:\n            idx = (int) (i - offset)\n            rcsLocationData = np.delete(rcsLocationData, idx, axis=0)\n            rcsDirectionData = np.delete(rcsDirectionData, idx, axis=0)\n            rcsLocationData = np.append(rcsLocationData,[[0.0, 0.0, 0.0]], axis=0)\n            rcsDirectionData = np.append(rcsDirectionData, [[0.0, 0.0, 0.0]], axis=0)\n            offset = offset + 1\n\n        numThrusters = numThrusters - dropThruster\n    maxThrust = 0.95\n    if useDVThruster:\n        maxThrust = 10.0\n\n\n    for i in range(numThrusters):\n        if misconfigThruster and i == 0:\n            maxThrustConfig = 0.0\n        else:\n            maxThrustConfig = maxThrust\n        fswSetupThrusters.create(rcsLocationData[i], rcsDirectionData[i], maxThrustConfig)\n    thrConfigInMsg = fswSetupThrusters.writeConfigMessage()\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.thrForceCmdOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.cmdTorqueInMsg.subscribeTo(cmdTorqueInMsg)\n    module.thrConfigInMsg.subscribeTo(thrConfigInMsg)\n    module.vehConfigInMsg.subscribeTo(vcInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.5))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    moduleOutput = dataLog.thrForce\n\n    if misconfigThruster:\n        return [testFailCount, ''.join(testMessages)] # We don't handle cases where a thruster is configured incorrectly.\n\n    if useDVThruster and numControlAxis == 3:\n        return [testFailCount, ''.join(testMessages)] # 3 control axes doesn't work for dv thrusters (only two axes controllable)\n\n    results = thrForceMapping.Results_thrForceMapping(requestedTorque, module.controlAxes_B,\n                                         vehicleConfigOut.CoM_B, rcsLocationData,\n                                         rcsDirectionData, module.thrForceSign,\n                                         module.thrForcMag, module.angErrThresh,\n                                         numThrusters, module.epsilon, use2ndLoop)\n\n    F, DNew = results.results_thrForceMapping()\n\n    trueVector = np.zeros((2, MAX_EFF_CNT))\n    trueVector[0,:] = F\n    trueVector[1,:] = F\n\n    C = np.reshape(controlAxes_B, (numControlAxis, 3))\n    CT = np.transpose(C)\n    D = np.cross(rcsDirectionData,rcsLocationData-CoM_B)\n    receivedTorque = -1.0*np.array([np.matmul(np.transpose(D), np.transpose(moduleOutput[0]))])\n    receivedTorque = np.append(np.array([]), receivedTorque)\n\n    Lr_offset = np.array([0.0, 0.0, 0.0])\n    Lr_B = np.array([0.0, 0.0, 0.0])\n    for i in range(0,numThrusters):\n        if module.thrForceSign < 0 and module.thrForcMag[i] >= 0:\n            Lr_offset -= module.thrForcMag[i]*np.cross(rcsLocationData[i,:]-CoM_B,rcsDirectionData[i,:]) # off pulsing\n\n    Lr_B = requestedTorque + Lr_offset\n\n    # This computes the requested torque direction and the received torque directions\n    Lr_Req_B_Unit = Lr_B / np.linalg.norm(Lr_B)\n    Lr_Rec_B_Unit = receivedTorque / np.linalg.norm(receivedTorque)\n\n    # This is the requested and recieved torque projected onto the control axes\n    Lr_Req_Bar_B = np.matmul(CT, np.matmul(C, Lr_B))\n    Lr_Rec_Bar_B = np.matmul(CT, np.matmul(C, receivedTorque))\n\n    # This computes the projected requested and received control torque directions\n    Lr_Req_Bar_B_Unit = Lr_Req_Bar_B/np.linalg.norm(Lr_Req_Bar_B)\n    Lr_Rec_Bar_B_Unit = Lr_Rec_Bar_B/np.linalg.norm(Lr_Rec_Bar_B)\n    if np.linalg.norm(Lr_Rec_Bar_B) == 0.0:\n        Lr_Rec_Bar_B_Unit = [0.0, 0.0, 0.0]\n\n    accuracy = 1E-6\n\n    # Check that Python Math and C Math are Identical\n    testFailCount, testMessages = unitTestSupport.compareArrayND(np.array([F]), np.array([moduleOutput[0]]), accuracy,\n                                                                 \"CompareForces\",\n                                                                 MAX_EFF_CNT, testFailCount, testMessages)\n\n    # Checks to make sure that no forces are negative\n    if not useDVThruster and np.any(moduleOutput[0] < 0):\n        testFailCount += 1\n        print(\"A negative force exists in the C RCS solution. This is not allowed!\\n\")\n\n    if not useDVThruster and np.any(F < 0):\n        testFailCount += 1\n        print(\"A negative force exists in the Python RCS solution. This is not allowed!\\n\")\n\n    if testFailCount > 0:\n        return [testFailCount, ''.join(testMessages)]\n\n\n    # Check that Torques are Sensible\n    print(\"\\nReq Lr_Bar [B]: \" + str(Lr_Req_Bar_B))\n    print(\"Rec Lr_Bar [B]: \" + str(Lr_Rec_Bar_B))\n\n    testFailCount, testMessages = unitTestSupport.compareArrayND(np.array([Lr_Req_Bar_B_Unit]),\n                                                                 np.array([Lr_Rec_Bar_B_Unit]), accuracy,\n                                                                 \"CompareTorques\",\n                                                                 3, testFailCount, testMessages)\n\n    snippetName = \"LrData_\" + str(useDVThruster) + \"_\" + str(dropThruster) + \"_\" + str(numControlAxis) + \"_\" + str(useCOMOffset) + \"____\" + str(asymmetricDrop) + \"_\" + str(saturateThrusters) + \"_\" + str(misconfigThruster)\n\n    snippetTex = \"DV Thrusters:\\t\" + str(useDVThruster) + \"\\n\"\n    snippetTex += \"Number of Dropped Thrusters:\\t\" + str(dropThruster)+ \"\\n\"\n    snippetTex += \"Number of Control Axes:\\t\" + str(numControlAxis) + \"\\n\"\n    snippetTex += \"COM Offset:\\t\" + str(useCOMOffset) + \"\\n\\n\"\n    snippetTex += \"Was the drop asymmetric about the COM?\\t\" + str(asymmetricDrop) + \"\\n\"\n    snippetTex += \"Number of Saturated Thrusters:\\t\" + str(saturateThrusters) + \"\\n\"\n    snippetTex += \"Misconfigured Thruster?:\\t\" + str(misconfigThruster) + \"\\n\\n\"\n\n\n    snippetTex += \"Original [B]:\\t\" + str(requestedTorque) + \"\\n\"\n\n    snippetTex += \"Requested (Original + Offset) [B]:\\t\" + str(Lr_B) + \"\\n\"\n    snippetTex += \"Received [B]:\\t\\t\" + str(receivedTorque) + \"\\n\\n\"\n    snippetTex += \"Requested Unit:\\t\\t\" + str(Lr_Req_B_Unit) + \"\\n\"\n    snippetTex += \"Received Unit:\\t\\t\" + str(Lr_Rec_B_Unit) + \"\\n\\n\"\n\n    snippetTex += \"Requested On Control Axes (Original + Offset) [B]:\\t\" + str(Lr_Req_Bar_B) + \"\\n\"\n    snippetTex += \"Received On Control Axes [B]:\\t\\t\" + str(Lr_Rec_Bar_B) + \"\\n\\n\"\n    snippetTex += \"Requested On Control Axes Unit:\\t\\t\" + str(Lr_Req_Bar_B_Unit) + \"\\n\"\n    snippetTex += \"Received On Control Axes Unit:\\t\\t\" + str(Lr_Rec_Bar_B_Unit) + \"\\n\\n\"\n\n    snippetTex += \"D-Matrix:\\n\" + str(D) + \"\\n\\n\"\n    snippetTex += \"Forces:\\n\" + str(np.transpose(F)) + \"\\n\\n\"\n\n    directory = \"Nom/UnitVec/\"\n\n    # Any solutions that dont have the correct torque, but do have the correct unit direction are called successful.\n\n    if testFailCount > 0:\n        unitTestSupport.writeTeXSnippet(directory+\"Failed/\"+snippetName, snippetTex, path)\n        print(\"FAILED: \" + module.ModelTag)\n        testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed  unit test at t=\" +\n                            str(dataLog.times()[0] * macros.NANO2SEC) +\n                            \"sec\\n\")\n    else:\n        unitTestSupport.writeTeXSnippet(directory+\"/Passed/\" + snippetName, snippetTex, path)\n        print(\"PASSED: \" + module.ModelTag)\n\n\n    unitTestSupport.writeTeXSnippet('toleranceValue', str(accuracy), path)\n\n    snippentName = \"passFail_\" + str(useDVThruster) + \"_\" + str(useCOMOffset) + \"_\" + str(dropThruster) + \"_\" + str(\n        numControlAxis) + \"_\" + str(saturateThrusters) + \"_\" + str(misconfigThruster)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    if testFailCount > 0:\n        print(\"Python:\\t \" + str(F))\n        print(\"C: \\t:\" + str(moduleOutput[0]))\n\n    return [testFailCount, ''.join(testMessages)]",
  "class Results_thrForceMapping():\n    def __init__(self, Lr, COrig, COM, rData, gData, thrForceSign, thrForceMag, angErrThresh, numThrusters, epsilon, use2ndLoop):\n        self.rData = np.array(rData)\n        self.gData = np.array(gData)\n        self.Lr_B = np.array(Lr) #Original Requested Torque in B Frame\n        self.COM = COM\n\n        self.thrForceSign = thrForceSign # -1 is DV thrusters; +1 is RCS thrusters\n        self.thrForceMag = thrForceMag # specifies the max thrust for each thruster\n        self.angErrThresh = angErrThresh # Determines when the thrusters are considered saturated\n\n        self.numThrusters = numThrusters # number of explicitly configured thrusters\n\n        self.C = np.array(COrig) # Control \"Frame\" (could be 1, 2, or 3 axii controllable)\n        self.C = np.reshape(self.C, ((len(self.C)//3),3),'C')\n\n        self.epsilon = epsilon\n        self.use2ndLoop = use2ndLoop\n        return\n\n    def results_thrForceMapping(self):\n        # Produce the forces with all thrusters included\n        Lr_offset = [0.0, 0.0, 0.0]\n        CT = np.transpose(self.C)\n\n        # Compute D Matrix and Determine Force\n        D = np.zeros((3,len(self.rData)))\n        for i in range(len(self.rData)):\n            D[:,i] = np.cross((self.rData[i,:] - self.COM), self.gData[i,:])\n            if(self.thrForceSign < 0):\n                Lr_offset -= self.thrForceMag[i]*D[:,i]\n\n        self.Lr_B = self.Lr_B + Lr_offset\n        Lr_Bar = np.dot(self.C, self.Lr_B)\n        F = self.mapToForce(D, Lr_Bar)\n\n        # Subtract off minimum force (remove null space contribution)\n        if self.thrForceSign > 0:\n            #F = self.subtractPairwiseNullSpace(F, D)\n            F = self.subtractMin(F, self.numThrusters)\n\n        # Identify any negative forces\n        t = (F[:]*self.thrForceSign > self.epsilon)\n\n        # Recompute the D Matrix with negative forces removed and compute Force\n        if self.thrForceSign < 0 or self.use2ndLoop:\n            DNew = np.array([])\n            for i in range(0,len(F)):\n                if t[i]:\n                    DNew = np.append(DNew, np.cross((self.rData[i,:] - self.COM), self.gData[i]))\n            DNew = np.reshape(DNew, (3, (len(DNew) // 3)), 'F')\n            FNew = self.mapToForce(DNew, Lr_Bar)\n            if (self.thrForceSign > 0):\n                FNew = self.subtractMin(FNew,len(DNew[0])) # Produced negative forces when doing 2nd loop, dropped thruster, and COM offset\n            # Remove minumum force\n            count = 0\n            for i in range(0,len(F)):\n                if t[i]:\n                    F[i] = FNew[count]\n                    count += 1\n                else:\n                    F[i] = 0.0\n        else:\n            DNew = D\n        angle = self.results_computeAngErr(D, Lr_Bar, F)\n\n        if angle > self.angErrThresh:\n\n            maxFractUse = 0.0\n            for i in range(0, self.numThrusters):\n                if self.thrForceMag[i] > 0 and abs(F[i])/self.thrForceMag[i] > maxFractUse:\n                    maxFractUse = abs(F[i])/self.thrForceMag[i]\n            if maxFractUse > 1.0:\n                F = F/maxFractUse\n                angleErr = self.results_computeAngErr(D, Lr_Bar, F)\n\n        return F, DNew\n\n    def results_computeAngErr(self, D, BLr_B, F):\n        returnAngle = 0.0\n        DT = np.transpose(D)\n\n        if np.linalg.norm(BLr_B) > 10 ** -9:\n            tauActual_B = [0.0, 0.0, 0.0]\n            BLr_B_hat = BLr_B / np.linalg.norm(BLr_B)\n            for i in range(0, self.numThrusters):\n                if abs(F[i]) < self.thrForceMag[i]:\n                    thrForce = F[i]\n                else:\n                    thrForce = self.thrForceMag[i] * abs(F[i]) / F[i]\n\n                LrEffector_B = thrForce * DT[i, :]\n                tauActual_B += LrEffector_B\n\n            tauActual_B = tauActual_B / np.linalg.norm(tauActual_B)\n\n            if np.dot(BLr_B_hat, tauActual_B) < 1.0:\n                returnAngle = np.arccos(np.dot(BLr_B_hat, tauActual_B))\n\n        return returnAngle\n\n    def numRelEqualElements(self, array1, array2, accuracy):\n        count = 0\n        for i in range(3):\n            if abs(array1[i] - array2[i]) < accuracy:\n                count += 1\n        return count\n\n    def mapToForce(self, D, Lr_Bar):\n        numControlAxes = 0\n        for i in range(0, len(self.C[0])):\n            if not np.array_equal(self.C[:, i], [0.0, 0.0, 0.0]):\n                numControlAxes = numControlAxes + 1\n        numThr = 0\n        for i in range(0, len(D[0])):\n            if not np.array_equal(D[:, i], [0.0, 0.0, 0.0]):\n                numThr = numThr + 1\n        D = np.matmul(self.C, D)\n        DT = np.transpose(D)\n        DDT = np.eye(3)\n        for i in range(0, numControlAxes):\n            for j in range(0, numControlAxes):\n                DDT[i][j] = 0.0\n                for k in range(0, numThr):\n                    DDT[i][j] += D[i][k] * D[j][k]\n        try:\n            DDTInv = np.linalg.inv(DDT)\n            if np.linalg.det(DDT) < self.epsilon:\n                raise np.linalg.LinAlgError()\n        except:\n            DDTInv = np.zeros((3, 3))\n            print(\"Singular Matrix! Outputting Zeros.\")\n\n        DDTInvLr_Bar = np.dot(DDTInv, Lr_Bar)\n        F = np.dot(DT, DDTInvLr_Bar)\n        return F\n\n    def subtractPairwiseNullSpace(self, F, D):\n\n        for i in range(self.numThrusters):\n            if F[i] < 0.0:\n                for j in range(self.numThrusters):\n                    if (np.allclose(D[:, i], D[:, j], atol=self.epsilon) and i != j):\n                        F[j] -= F[i]\n                        break\n                F[i] = 0.0\n\n        return F\n\n    def subtractMin(self, F, size):\n        minValue = 0.0\n        for i in range(size):\n            if F[i] < minValue:\n                minValue = F[i]\n\n        for i in range(size):\n            F[i] -= minValue\n\n        return F",
  "def __init__(self, Lr, COrig, COM, rData, gData, thrForceSign, thrForceMag, angErrThresh, numThrusters, epsilon, use2ndLoop):\n        self.rData = np.array(rData)\n        self.gData = np.array(gData)\n        self.Lr_B = np.array(Lr) #Original Requested Torque in B Frame\n        self.COM = COM\n\n        self.thrForceSign = thrForceSign # -1 is DV thrusters; +1 is RCS thrusters\n        self.thrForceMag = thrForceMag # specifies the max thrust for each thruster\n        self.angErrThresh = angErrThresh # Determines when the thrusters are considered saturated\n\n        self.numThrusters = numThrusters # number of explicitly configured thrusters\n\n        self.C = np.array(COrig) # Control \"Frame\" (could be 1, 2, or 3 axii controllable)\n        self.C = np.reshape(self.C, ((len(self.C)//3),3),'C')\n\n        self.epsilon = epsilon\n        self.use2ndLoop = use2ndLoop\n        return",
  "def results_thrForceMapping(self):\n        # Produce the forces with all thrusters included\n        Lr_offset = [0.0, 0.0, 0.0]\n        CT = np.transpose(self.C)\n\n        # Compute D Matrix and Determine Force\n        D = np.zeros((3,len(self.rData)))\n        for i in range(len(self.rData)):\n            D[:,i] = np.cross((self.rData[i,:] - self.COM), self.gData[i,:])\n            if(self.thrForceSign < 0):\n                Lr_offset -= self.thrForceMag[i]*D[:,i]\n\n        self.Lr_B = self.Lr_B + Lr_offset\n        Lr_Bar = np.dot(self.C, self.Lr_B)\n        F = self.mapToForce(D, Lr_Bar)\n\n        # Subtract off minimum force (remove null space contribution)\n        if self.thrForceSign > 0:\n            #F = self.subtractPairwiseNullSpace(F, D)\n            F = self.subtractMin(F, self.numThrusters)\n\n        # Identify any negative forces\n        t = (F[:]*self.thrForceSign > self.epsilon)\n\n        # Recompute the D Matrix with negative forces removed and compute Force\n        if self.thrForceSign < 0 or self.use2ndLoop:\n            DNew = np.array([])\n            for i in range(0,len(F)):\n                if t[i]:\n                    DNew = np.append(DNew, np.cross((self.rData[i,:] - self.COM), self.gData[i]))\n            DNew = np.reshape(DNew, (3, (len(DNew) // 3)), 'F')\n            FNew = self.mapToForce(DNew, Lr_Bar)\n            if (self.thrForceSign > 0):\n                FNew = self.subtractMin(FNew,len(DNew[0])) # Produced negative forces when doing 2nd loop, dropped thruster, and COM offset\n            # Remove minumum force\n            count = 0\n            for i in range(0,len(F)):\n                if t[i]:\n                    F[i] = FNew[count]\n                    count += 1\n                else:\n                    F[i] = 0.0\n        else:\n            DNew = D\n        angle = self.results_computeAngErr(D, Lr_Bar, F)\n\n        if angle > self.angErrThresh:\n\n            maxFractUse = 0.0\n            for i in range(0, self.numThrusters):\n                if self.thrForceMag[i] > 0 and abs(F[i])/self.thrForceMag[i] > maxFractUse:\n                    maxFractUse = abs(F[i])/self.thrForceMag[i]\n            if maxFractUse > 1.0:\n                F = F/maxFractUse\n                angleErr = self.results_computeAngErr(D, Lr_Bar, F)\n\n        return F, DNew",
  "def results_computeAngErr(self, D, BLr_B, F):\n        returnAngle = 0.0\n        DT = np.transpose(D)\n\n        if np.linalg.norm(BLr_B) > 10 ** -9:\n            tauActual_B = [0.0, 0.0, 0.0]\n            BLr_B_hat = BLr_B / np.linalg.norm(BLr_B)\n            for i in range(0, self.numThrusters):\n                if abs(F[i]) < self.thrForceMag[i]:\n                    thrForce = F[i]\n                else:\n                    thrForce = self.thrForceMag[i] * abs(F[i]) / F[i]\n\n                LrEffector_B = thrForce * DT[i, :]\n                tauActual_B += LrEffector_B\n\n            tauActual_B = tauActual_B / np.linalg.norm(tauActual_B)\n\n            if np.dot(BLr_B_hat, tauActual_B) < 1.0:\n                returnAngle = np.arccos(np.dot(BLr_B_hat, tauActual_B))\n\n        return returnAngle",
  "def numRelEqualElements(self, array1, array2, accuracy):\n        count = 0\n        for i in range(3):\n            if abs(array1[i] - array2[i]) < accuracy:\n                count += 1\n        return count",
  "def mapToForce(self, D, Lr_Bar):\n        numControlAxes = 0\n        for i in range(0, len(self.C[0])):\n            if not np.array_equal(self.C[:, i], [0.0, 0.0, 0.0]):\n                numControlAxes = numControlAxes + 1\n        numThr = 0\n        for i in range(0, len(D[0])):\n            if not np.array_equal(D[:, i], [0.0, 0.0, 0.0]):\n                numThr = numThr + 1\n        D = np.matmul(self.C, D)\n        DT = np.transpose(D)\n        DDT = np.eye(3)\n        for i in range(0, numControlAxes):\n            for j in range(0, numControlAxes):\n                DDT[i][j] = 0.0\n                for k in range(0, numThr):\n                    DDT[i][j] += D[i][k] * D[j][k]\n        try:\n            DDTInv = np.linalg.inv(DDT)\n            if np.linalg.det(DDT) < self.epsilon:\n                raise np.linalg.LinAlgError()\n        except:\n            DDTInv = np.zeros((3, 3))\n            print(\"Singular Matrix! Outputting Zeros.\")\n\n        DDTInvLr_Bar = np.dot(DDTInv, Lr_Bar)\n        F = np.dot(DT, DDTInvLr_Bar)\n        return F",
  "def subtractPairwiseNullSpace(self, F, D):\n\n        for i in range(self.numThrusters):\n            if F[i] < 0.0:\n                for j in range(self.numThrusters):\n                    if (np.allclose(D[:, i], D[:, j], atol=self.epsilon) and i != j):\n                        F[j] -= F[i]\n                        break\n                F[i] = 0.0\n\n        return F",
  "def subtractMin(self, F, size):\n        minValue = 0.0\n        for i in range(size):\n            if F[i] < minValue:\n                minValue = F[i]\n\n        for i in range(size):\n            F[i] -= minValue\n\n        return F",
  "def test_dipoleMapping_module():     # update \"module\" in this function name to reflect the module name\n    r\"\"\"\n    **Validation Test Description**\n\n    This script tests the mapping of a 3x1 requested Body frame dipole, \n    ``dipole_B``, mapped correctly to individual torque bar requests and that the\n    algorithm doesn't fail when the inputs are given zero values.\n\n    **Description of Variables Being Tested**\n\n    In this file we are checking the values of the output message variable:\n\n    - ``mtbDipoleCmds[MAX_EFF_CNT]``\n    \"\"\"\n    # each test method requires a single assert method to be called\n    # pass on the testPlotFixture so that the main test function may set the DataStore attributes\n    [testResults, testMessage] = dipoleMappingModuleTestFunction()\n    assert testResults < 1, testMessage",
  "def dipoleMappingModuleTestFunction():\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.01)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Initialize module under test's config message and add module to runtime call list\n    module = dipoleMapping.dipoleMapping()\n    module.steeringMatrix = [1., 0., 0., 0., 1., 0., 0., 0., 1.]\n    module.ModelTag = \"dipoleMapping\"           # update python name of test module\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    \n    # Initialize DipoleRequestBodyMsg\n    dipoleRequestBodyInMsgContainer = messaging.DipoleRequestBodyMsgPayload()\n    dipoleRequestBodyInMsgContainer.dipole_B = [1., 2., 3.]\n    dipoleRequestBodyInMsg = messaging.DipoleRequestBodyMsg().write(dipoleRequestBodyInMsgContainer)    \n\n    # Initialize MTBArrayConfigMsg\n    mtbArrayConfigParamsInMsgContainer = messaging.MTBArrayConfigMsgPayload()\n    mtbArrayConfigParamsInMsgContainer.numMTB = 3\n    mtbArrayConfigParamsInMsgContainer.maxMtbDipoles = [1E3, 1E3, 1E3]\n    mtbArrayConfigParamsInMsgContainer.GtMatrix_B = [1., 0., 0., 0., 1., 0., 0., 0., 1.]  \n    mtbArrayConfigParamsInMsg = messaging.MTBArrayConfigMsg().write(mtbArrayConfigParamsInMsgContainer)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    resultDipoleRequestMtbOutMsg = module.dipoleRequestMtbOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, resultDipoleRequestMtbOutMsg)\n    \n    # connect the message interfaces\n    module.dipoleRequestBodyInMsg.subscribeTo(dipoleRequestBodyInMsg)\n    module.mtbArrayConfigParamsInMsg.subscribeTo(mtbArrayConfigParamsInMsg)\n    \n    # Set the simulation time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.0))        # seconds to stop simulation\n    unitTestSim.InitializeSimulation()                        \n    \n    '''\n        TEST 1: \n            Check that dipoles is non-zero expected value with trivial \n            steeringMatrix.\n    '''\n    unitTestSim.ExecuteSimulation()\n    expectedDipole = [0.] * messaging.MAX_EFF_CNT\n    expectedDipole[0:3] = [1., 2., 3.]\n    testFailCount, testMessages = unitTestSupport.compareVector(expectedDipole,\n                                                                resultDipoleRequestMtbOutMsg.mtbDipoleCmds[0],\n                                                                accuracy,\n                                                                \"dipoles\",\n                                                                testFailCount, testMessages)\n    '''\n        TEST 2: \n            Check that dipoles is non-zero with non-trivial steeringMatrix.\n    '''\n    beta = 45. * np.pi / 180.\n    Gt = np.array([[np.cos(beta), -np.sin(beta)],[np.sin(beta),  np.cos(beta)], [0., 0.]])\n    GtInverse = np.linalg.pinv(Gt)\n    mtbArrayConfigParamsInMsgContainer.numMTB = 2\n    mtbArrayConfigParamsInMsgContainer.GtMatrix_B = [Gt[0, 0], Gt[0, 1], \n                                                     Gt[1, 0], Gt[1, 1],\n                                                     Gt[2, 0], Gt[2, 1]]  \n    mtbArrayConfigParamsInMsg = messaging.MTBArrayConfigMsg().write(mtbArrayConfigParamsInMsgContainer)\n    module.mtbArrayConfigParamsInMsg.subscribeTo(mtbArrayConfigParamsInMsg)\n    \n    module.steeringMatrix = [GtInverse[0, 0], GtInverse[0, 1], GtInverse[0, 2],\n                                   GtInverse[1, 0], GtInverse[1, 1], GtInverse[1, 2]]\n    \n    unitTestSim.InitializeSimulation()\n    unitTestSim.ExecuteSimulation()\n    \n    expectedDipole = [0.] * messaging.MAX_EFF_CNT\n    expectedDipole[0:2] = GtInverse @ np.array(dipoleRequestBodyInMsgContainer.dipole_B)\n    testFailCount, testMessages = unitTestSupport.compareVector(expectedDipole,\n                                                            resultDipoleRequestMtbOutMsg.mtbDipoleCmds[0],\n                                                            accuracy,\n                                                            \"dipoles\",\n                                                            testFailCount, testMessages)\n    \n    '''\n        TEST 3: \n            Check that dipoles is zero with zero input dipole.\n    '''\n    dipoleRequestBodyInMsgContainer.dipole_B = [0., 0., 0.]\n    dipoleRequestBodyInMsg = messaging.DipoleRequestBodyMsg().write(dipoleRequestBodyInMsgContainer)\n    module.dipoleRequestBodyInMsg.subscribeTo(dipoleRequestBodyInMsg)\n    \n    unitTestSim.InitializeSimulation()\n    unitTestSim.ExecuteSimulation()\n    \n    unitTestSim.ExecuteSimulation()\n    expectedDipole = [0.] * messaging.MAX_EFF_CNT\n    testFailCount, testMessages = unitTestSupport.compareVector(expectedDipole,\n                                                                resultDipoleRequestMtbOutMsg.mtbDipoleCmds[0],\n                                                                accuracy,\n                                                                \"dipoles\",\n                                                                testFailCount, testMessages)\n\n    print(\"Accuracy used: \" + str(accuracy))\n    if testFailCount == 0:\n        print(\"PASSED: dipoleMapping unit test\")\n    else:\n        print(\"Failed: dipoleMapping unit test\")\n    return [testFailCount, ''.join(testMessages)]",
  "def test_prescribedRot1DOFTestFunction(show_plots, thetaInit, thetaRef, thetaDDotMax, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test ensures that the profiled 1 DOF attitude maneuver for a secondary rigid body connected\n    to the spacecraft hub is properly computed for a series of initial and reference PRV angles and maximum\n    angular accelerations. The final prescribed attitude and angular velocity magnitude are compared with\n    the reference values.\n\n    **Test Parameters**\n\n    Args:\n        thetaInit (float): [rad] Initial PRV angle of the F frame with respect to the M frame\n        thetaRef (float): [rad] Reference PRV angle of the F frame with respect to the M frame\n        thetaDDotMax (float): [rad/s^2] Maximum angular acceleration for the attitude maneuver\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    This unit test ensures that the profiled 1 DOF rotational attitude maneuver is properly computed for a series of\n    initial and reference PRV angles and maximum angular accelerations. The final prescribed angle ``theta_FM_Final``\n    and angular velocity magnitude ``thetaDot_Final`` are compared with the reference values ``theta_Ref`` and\n    ``thetaDot_Ref``, respectively.\n    \"\"\"\n    [testResults, testMessage] = prescribedRot1DOFTestFunction(show_plots, thetaInit, thetaRef, thetaDDotMax, accuracy)\n\n    assert testResults < 1, testMessage",
  "def prescribedRot1DOFTestFunction(show_plots, thetaInit, thetaRef, thetaDDotMax, accuracy):\n    \"\"\"Call this routine directly to run the unit test.\"\"\"\n    testFailCount = 0                                        # Zero the unit test result counter\n    testMessages = []                                        # Create an empty array to store the test log messages\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create the test thread\n    testProcessRate = macros.sec2nano(0.1)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Create an instance of the prescribedRot1DOF module to be tested\n    PrescribedRot1DOF = prescribedRot1DOF.prescribedRot1DOF()\n    PrescribedRot1DOF.ModelTag = \"prescribedRot1DOF\"\n\n    # Add the prescribedRot1DOF test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, PrescribedRot1DOF)\n\n    # Initialize the prescribedRot1DOF test module configuration data\n    rotAxisM = np.array([1.0, 0.0, 0.0])\n    prvInit_FM = thetaInit * rotAxisM\n    PrescribedRot1DOF.r_FM_M = np.array([1.0, 0.0, 0.0])\n    PrescribedRot1DOF.rPrime_FM_M = np.array([0.0, 0.0, 0.0])\n    PrescribedRot1DOF.rPrimePrime_FM_M = np.array([0.0, 0.0, 0.0])\n    PrescribedRot1DOF.rotAxis_M = rotAxisM\n    PrescribedRot1DOF.thetaDDotMax = thetaDDotMax\n    PrescribedRot1DOF.omega_FM_F = np.array([0.0, 0.0, 0.0])\n    PrescribedRot1DOF.omegaPrime_FM_F = np.array([0.0, 0.0, 0.0])\n    PrescribedRot1DOF.sigma_FM = rbk.PRV2MRP(prvInit_FM)\n\n    # Create the prescribedRot1DOF input message\n    thetaDotRef = 0.0  # [rad/s]\n    HingedRigidBodyMessageData = messaging.HingedRigidBodyMsgPayload()\n    HingedRigidBodyMessageData.theta = thetaRef\n    HingedRigidBodyMessageData.thetaDot = thetaDotRef\n    HingedRigidBodyMessage = messaging.HingedRigidBodyMsg().write(HingedRigidBodyMessageData)\n    PrescribedRot1DOF.spinningBodyInMsg.subscribeTo(HingedRigidBodyMessage)\n\n    # Log the test module output message for data comparison\n    dataLog = PrescribedRot1DOF.prescribedMotionOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time\n    simTime = np.sqrt(((0.5 * np.abs(thetaRef - thetaInit)) * 8) / thetaDDotMax) + 1\n    unitTestSim.ConfigureStopTime(macros.sec2nano(simTime))\n\n    # Begin the simulation\n    unitTestSim.ExecuteSimulation()\n\n    # Extract the logged data for plotting and data comparison\n    omega_FM_F = dataLog.omega_FM_F\n    sigma_FM = dataLog.sigma_FM\n    timespan = dataLog.times()\n\n    thetaDot_Final = np.linalg.norm(omega_FM_F[-1, :])\n    sigma_FM_Final = sigma_FM[-1, :]\n    theta_FM_Final = 4 * np.arctan(np.linalg.norm(sigma_FM_Final))\n\n    # Convert the logged sigma_FM MRPs to a scalar theta_FM array\n    n = len(timespan)\n    theta_FM = []\n    for i in range(n):\n        theta_FM.append(4 * np.arctan(np.linalg.norm(sigma_FM[i, :])))\n\n    # Plot theta_FM\n    thetaRef_plotting = np.ones(len(timespan)) * thetaRef\n    thetaInit_plotting = np.ones(len(timespan)) * thetaInit\n    plt.figure()\n    plt.clf()\n    plt.plot(timespan * macros.NANO2SEC, theta_FM, label=r\"$\\Phi$\")\n    plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * thetaRef_plotting, '--', label=r'$\\Phi_{Ref}$')\n    plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * thetaInit_plotting, '--', label=r'$\\Phi_{0}$')\n    plt.title(r'$\\Phi_{\\mathcal{F}/\\mathcal{M}}$ Profiled Trajectory', fontsize=14)\n    plt.ylabel('(deg)', fontsize=16)\n    plt.xlabel('Time (s)', fontsize=16)\n    plt.legend(loc='center right', prop={'size': 16})\n\n    # Plot omega_FM_F\n    plt.figure()\n    plt.clf()\n    plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omega_FM_F[:, 0], label=r'$\\omega_{1}$')\n    plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omega_FM_F[:, 1], label=r'$\\omega_{2}$')\n    plt.plot(timespan * macros.NANO2SEC, (180 / np.pi) * omega_FM_F[:, 2], label=r'$\\omega_{3}$')\n    plt.title(r'${}^\\mathcal{F} \\omega_{\\mathcal{F}/\\mathcal{M}}$ Profiled Trajectory', fontsize=14)\n    plt.ylabel('(deg/s)', fontsize=16)\n    plt.xlabel('Time (s)', fontsize=16)\n    plt.legend(loc='upper right', prop={'size': 16})\n\n    if show_plots:\n        plt.show()\n    plt.close(\"all\")\n\n    # Check to ensure the initial angle rate converged to the reference angle rate\n    if not unitTestSupport.isDoubleEqual(thetaDot_Final, thetaDotRef, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + PrescribedRot1DOF.ModelTag + \"thetaDot_Final and thetaDotRef do not match\")\n\n    # Check to ensure the initial angle converged to the reference angle\n    if not unitTestSupport.isDoubleEqual(theta_FM_Final, thetaRef, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + PrescribedRot1DOF.ModelTag + \"theta_FM_Final and thetaRef do not match\")\n    return [testFailCount, ''.join(testMessages)]",
  "def test_forceTorqueThrForceMapping1():\n    r\"\"\"\n    **Test Description**\n\n    This pytest ensures that the forceTorqueThrForce module can compute a valid solution for cases where:\n    1. There is a direction where no thrusters point - ensures matrix invertibility is handled\n\n    \"\"\"\n\n    # Test 1 - No thrusters pointing in one direction, CoM offset\n    rcsLocationData = [[-0.86360, -0.82550, 1.79070],\n                            [-0.82550, -0.86360, 1.79070],\n                            [0.82550, 0.86360, 1.79070],\n                            [0.86360, 0.82550, 1.79070],\n                            [-0.86360, -0.82550, -1.79070],\n                            [-0.82550, -0.86360, -1.79070],\n                            [0.82550, 0.86360, -1.79070],\n                            [0.86360, 0.82550, -1.79070]]\n\n    rcsDirectionData = [[1.0, 0.0, 0.0],\n                             [0.0, 1.0, 0.0],\n                             [0.0, -1.0, 0.0],\n                             [-1.0, 0.0, 0.0],\n                             [1.0, 0.0, 0.0],\n                             [0.0, 1.0, 0.0],\n                             [0.0, -1.0, 0.0],\n                             [-1.0, 0.0, 0.0]]\n\n    requested_torque = [0.4, 0.2, 0.4]\n\n    requested_force = [0.9, 1.1, 0.]\n\n    CoM_B = [0.1, 0.1, 0.1]\n\n    truth = np.array([[0.7082, 0.5500, 0.0810, 0.1772, 0.6272, 0.6310, 0., 0.2582]])\n\n    [testResults, testMessage] = forceTorqueThrForceMappingTestFunction(rcsLocationData, rcsDirectionData,\n                                                                        requested_torque, requested_force, CoM_B,\n                                                                        truth, True)\n\n    assert testResults < 1, testMessage",
  "def test_forceTorqueThrForceMapping2():\n    r\"\"\"\n    **Test Description**\n\n    This pytest ensures that the forceTorqueThrForce module can compute a valid solution for the case\n    where there is zero requested torque in a connected input message, but a requested non-zero force\n\n    \"\"\"\n\n    # Test 1 - No thrusters pointing in one direction, CoM offset\n    rcsLocationData = [[-0.86360, -0.82550, 1.79070],\n                       [-0.82550, -0.86360, 1.79070],\n                       [0.82550, 0.86360, 1.79070],\n                       [0.86360, 0.82550, 1.79070],\n                       [-0.86360, -0.82550, -1.79070],\n                       [-0.82550, -0.86360, -1.79070],\n                       [0.82550, 0.86360, -1.79070],\n                       [0.86360, 0.82550, -1.79070]]\n\n    rcsDirectionData = [[1.0, 0.0, 0.0],\n                        [0.0, 1.0, 0.0],\n                        [0.0, -1.0, 0.0],\n                        [-1.0, 0.0, 0.0],\n                        [1.0, 0.0, 0.0],\n                        [0.0, 1.0, 0.0],\n                        [0.0, -1.0, 0.0],\n                        [-1.0, 0.0, 0.0]]\n\n    requested_force = [0.9, 1.1, 0.]\n\n    CoM_B = [0.1, 0.1, 0.1]\n\n    requested_torque = [0.0, 0.0, 0.0]\n\n    truth = np.array([[0.5340, 0.5807, 0., 0.0588, 0.5088, 0.5500, 0.0307, 0.0840]])\n\n    [testResults, testMessage] = forceTorqueThrForceMappingTestFunction(rcsLocationData, rcsDirectionData,\n                                                                        requested_torque, requested_force, CoM_B,\n                                                                        truth, True)\n\n    assert testResults < 1, testMessage",
  "def test_forceTorqueThrForceMapping3():\n    r\"\"\"\n    **Test Description**\n\n    This pytest ensures that the forceTorqueThrForce module can compute a valid solution for the case\n    where there is no torque input message, but a requested non-zero force\n\n    \"\"\"\n\n    # Test 1 - No thrusters pointing in one direction, CoM offset\n    rcsLocationData = [[-0.86360, -0.82550, 1.79070],\n                       [-0.82550, -0.86360, 1.79070],\n                       [0.82550, 0.86360, 1.79070],\n                       [0.86360, 0.82550, 1.79070],\n                       [-0.86360, -0.82550, -1.79070],\n                       [-0.82550, -0.86360, -1.79070],\n                       [0.82550, 0.86360, -1.79070],\n                       [0.86360, 0.82550, -1.79070]]\n\n    rcsDirectionData = [[1.0, 0.0, 0.0],\n                        [0.0, 1.0, 0.0],\n                        [0.0, -1.0, 0.0],\n                        [-1.0, 0.0, 0.0],\n                        [1.0, 0.0, 0.0],\n                        [0.0, 1.0, 0.0],\n                        [0.0, -1.0, 0.0],\n                        [-1.0, 0.0, 0.0]]\n\n    requested_force = [0.9, 1.1, 0.]\n\n    CoM_B = [0.1, 0.1, 0.1]\n\n    requested_torque = [0.0, 0.0, 0.0]\n\n    truth = np.array([[0.5340, 0.5807, 0., 0.0588, 0.5088, 0.5500, 0.0307, 0.0840]])\n\n    [testResults, testMessage] = forceTorqueThrForceMappingTestFunction(rcsLocationData, rcsDirectionData,\n                                                                        requested_torque, requested_force, CoM_B,\n                                                                        truth, False)\n\n    assert testResults < 1, testMessage",
  "def test_forceTorqueThrForceMapping4():\n    r\"\"\"\n    **Test Description**\n\n    This pytest ensures that the forceTorqueThrForce module can compute a valid solution for the case where\n    Thrusters point in each direction\n\n    \"\"\"\n\n    rcsLocationData = [[-1, -1, 1],\n                        [-1, -1, 1],\n                        [-1, -1, 1],\n                        [1, 1, 1],\n                        [1, 1, 1],\n                        [1, 1, 1],\n                        [1, 1, -1],\n                        [1, 1, -1],\n                        [1, 1, -1],\n                        [-1, -1, -1],\n                        [-1, -1, -1],\n                        [-1, -1, -1]]\n\n    rcsDirectionData = [[1.0, 0.0, 0.0],\n                        [0.0, 1.0, 0.0],\n                        [0.0, 0.0, -1.0],\n                        [0.0, 0.0, -1.0],\n                        [0.0, -1.0, 0.0],\n                        [-1.0, 0.0, 0.0],\n                        [0.0, -1.0, 0.0],\n                        [-1.0, 0.0, 0.0],\n                        [0.0, 0.0, 1.0],\n                        [1.0, 0.0, 0.0],\n                        [0.0, 1.0, 0.0],\n                        [0.0, 0.0, 1.0]]\n\n    CoM_B = [0.1, 0.1, 0.1]\n    requested_torque = [0.0, 0.0, 0.0]\n    requested_force = [0.9, 1.1, 1.]\n\n    truth = np.array([[0.5050, 0.5550, 0.0300, 0.0300, 0., 0.0600, 0.0050, 0.0550, 0.5300, 0.5100, 0.5500, 0.5300]])\n\n    [testResults, testMessage] = forceTorqueThrForceMappingTestFunction(rcsLocationData, rcsDirectionData,\n                                                                        requested_torque, requested_force, CoM_B,\n                                                                        truth, True)\n    assert testResults < 1, testMessage",
  "def forceTorqueThrForceMappingTestFunction(rcsLocation, rcsDirection, requested_torque, requested_force, CoM_B,\n                                           truth, torqueInMsgFlag):\n    \"\"\"Test method\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(0.5)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    module = forceTorqueThrForceMapping.forceTorqueThrForceMapping()\n    module.ModelTag = \"forceTorqueThrForceMappingTag\"\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Configure blank module input messages\n    cmdTorqueInMsgData = messaging.CmdTorqueBodyMsgPayload()\n    cmdTorqueInMsgData.torqueRequestBody = requested_torque\n    cmdTorqueInMsg = messaging.CmdTorqueBodyMsg().write(cmdTorqueInMsgData)\n\n    cmdForceInMsgData = messaging.CmdForceBodyMsgPayload()\n    cmdForceInMsgData.forceRequestBody = requested_force\n    cmdForceInMsg = messaging.CmdForceBodyMsg().write(cmdForceInMsgData)\n\n    numThrusters = len(rcsLocation)\n    maxThrust = 3.0  # N\n    MAX_EFF_CNT = messaging.MAX_EFF_CNT\n    rcsLocationData = np.zeros((MAX_EFF_CNT, 3))\n    rcsDirectionData = np.zeros((MAX_EFF_CNT, 3))\n\n    rcsLocationData[0:len(rcsLocation)] = rcsLocation\n\n    rcsDirectionData[0:len(rcsLocation)] = rcsDirection\n\n    fswSetupThrusters.clearSetup()\n    for i in range(numThrusters):\n        fswSetupThrusters.create(rcsLocationData[i], rcsDirectionData[i], maxThrust)\n    thrConfigInMsg = fswSetupThrusters.writeConfigMessage()\n\n    vehConfigInMsgData = messaging.VehicleConfigMsgPayload()\n    vehConfigInMsgData.CoM_B = CoM_B\n    vehConfigInMsg = messaging.VehicleConfigMsg().write(vehConfigInMsgData)\n\n    # subscribe input messages to module\n    if torqueInMsgFlag:\n        module.cmdTorqueInMsg.subscribeTo(cmdTorqueInMsg)\n    module.cmdForceInMsg.subscribeTo(cmdForceInMsg)\n    module.thrConfigInMsg.subscribeTo(thrConfigInMsg)\n    module.vehConfigInMsg.subscribeTo(vehConfigInMsg)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.5))\n    unitTestSim.ExecuteSimulation()\n\n    testFailCount, testMessages = unitTestSupport.compareArray(truth, np.array([module.thrForceCmdOutMsg.read().thrForce[0:len(rcsLocation)]]), 1e-3,\n                                                                 \"CompareForces\", testFailCount, testMessages)\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, \"\".join(testMessages)]",
  "def test_etSphericalControl(show_plots, accuracy):     # update \"module\" in this function name to reflect the module name\n    r\"\"\"\n    **Validation Test Description**\n\n    The behavior of the Electrostatic Tractor Spherical Relative Motion Control is tested. The electrostatic force\n    between the servicer and the debris is calculated using a single sphere to represent each spacecraft. The simulation\n    is run for a single update cycle and the resulting forces and torques acting on each body\n    are compared to hand-computed truth values.\n\n    **Test Parameters**\n\n    Args:\n        accuracy (float): relative accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    The module output messages for the inertial control force vector and body control force vector are compared to\n    the truth values obtained from a Matlab simulation.\n    \"\"\"\n    # each test method requires a single assert method to be called\n    # pass on the testPlotFixture so that the main test function may set the DataStore attributes\n    [testResults, testMessage] = etSphericalControlTestFunction(show_plots, accuracy)\n    assert testResults < 1, testMessage",
  "def etSphericalControlTestFunction(show_plots, accuracy):\n    \"\"\"Test method\"\"\"\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = etSphericalControl.etSphericalControl()\n    module.ModelTag = \"ETcontrol\"           # update python name of test module\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    mu = 3.986004418e14  # [m^3/s^2] Earth's gravitational parameter\n\n    L0 = 20.\n    Ki = 4e-7\n    Pi = 1.85 * Ki ** 0.5\n    module.K = [Ki, 0.0, 0.0,\n                      0.0, Ki, 0.0,\n                      0.0, 0.0, Ki]\n    module.P = [Pi, 0.0, 0.0,\n                      0.0, Pi, 0.0,\n                      0.0, 0.0, Pi]\n    module.L_r = 30.\n    module.theta_r = 0.\n    module.phi_r = 0.\n    module.mu = mu\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n\n    oe = orbitalMotion.ClassicElements()\n    oe.a = 42164. * 1e3  # [m] geostationary orbit\n    oe.e = 0.\n    oe.i = 10.*macros.D2R\n    oe.Omega = 20.*macros.D2R\n    oe.omega = 30.*macros.D2R\n    oe.f = 40.*macros.D2R\n    r_TN_N, v_TN_N = orbitalMotion.elem2rv(mu, oe)\n    servicerNavTransOutData = messaging.NavTransMsgPayload()  # Create a structure for the input message\n    servicerNavTransOutData.r_BN_N = r_TN_N\n    servicerNavTransOutData.v_BN_N = v_TN_N\n    servicerTransMsg = messaging.NavTransMsg().write(servicerNavTransOutData)\n\n    r_DT_N = np.array([2., -L0, -3.])  # relative position between debris and servicer\n    r_DN_N = r_TN_N + r_DT_N\n    v_DN_N = v_TN_N\n    debrisNavTransOutData = messaging.NavTransMsgPayload()  # Create a structure for the input message\n    debrisNavTransOutData.r_BN_N = r_DN_N\n    debrisNavTransOutData.v_BN_N = v_DN_N\n    debrisTransMsg = messaging.NavTransMsg().write(debrisNavTransOutData)\n\n    beta_TH = [0.972960339471760, 0.107600839071972, -0.0289291519077161, 0.202319898714648]  # initial EP\n    sigma_TN = RigidBodyKinematics.EP2MRP(beta_TH)  # MRP\n    servicerNavAttOutData = messaging.NavAttMsgPayload()\n    servicerNavAttOutData.sigma_BN = sigma_TN\n    servicerAttMsg = messaging.NavAttMsg().write(servicerNavAttOutData)\n\n    servicerConfigOutData = messaging.VehicleConfigMsgPayload()\n    servicerConfigOutData.massSC = 500.\n    servicerVehicleConfigMsg = messaging.VehicleConfigMsg().write(servicerConfigOutData)\n\n    debrisConfigOutData = messaging.VehicleConfigMsgPayload()\n    debrisConfigOutData.massSC = 2000.\n    debrisVehicleConfigMsg = messaging.VehicleConfigMsg().write(debrisConfigOutData)\n\n    # compute electrostatic force between servicer and debris using single sphere for both S/C\n    R_T = 2.\n    R_D = 3.\n    V_T = 25000.\n    V_D = -25000.\n    kc = 8.9875517923e9\n    L = np.linalg.norm(r_DT_N)\n    q_T = (L*(L*R_T*V_T-R_T*R_D*V_D))/(kc*(L**2.-R_T*R_D))\n    q_D = (L * (L * R_D * V_D - R_T * R_D * V_T)) / (kc * (L ** 2. - R_T * R_D))\n    Fc = kc*q_T*q_D/L**2.\n    Fc_N = Fc*(-r_DT_N/np.linalg.norm(r_DT_N))  # electrostatic force acting on servicer\n    eForceOutData = messaging.CmdForceInertialMsgPayload()\n    eForceOutData.forceRequestInertial = Fc_N\n    eForceMsg = messaging.CmdForceInertialMsg().write(eForceOutData)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLogInertial = module.forceInertialOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLogInertial)\n    dataLogBody = module.forceBodyOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLogBody)\n\n    # connect the message interfaces\n    module.servicerTransInMsg.subscribeTo(servicerTransMsg)\n    module.debrisTransInMsg.subscribeTo(debrisTransMsg)\n    module.servicerAttInMsg.subscribeTo(servicerAttMsg)\n    module.servicerVehicleConfigInMsg.subscribeTo(servicerVehicleConfigMsg)\n    module.debrisVehicleConfigInMsg.subscribeTo(debrisVehicleConfigMsg)\n    module.eForceInMsg.subscribeTo(eForceMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n    unitTestSim.TotalSim.SingleStepProcesses()\n\n    # This pulls the actual data log from the simulation run.\n    forceInertialOutput = dataLogInertial.forceRequestInertial\n    forceBodyOutput = dataLogBody.forceRequestBody\n\n    # set the filtered output truth states\n    trueInertialVector = [[-0.00714223893615245,\n                           0.00267752848271998,\n                           0.000883681113161883]]\n    trueBodyVector = [[-0.00541988234898216,\n                       0.00542736415350300,\n                       0.000360862543207430]]\n\n    # compare the module results to the truth values\n    for i in range(0, len(trueInertialVector)):\n        # check vector values\n        if not unitTestSupport.isArrayEqual(forceInertialOutput[i], trueInertialVector[i], 3, accuracy):\n            testFailCount += 1\n            print(forceInertialOutput[i])\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed \"\n                                + \"Inertial Force Output\" + \" unit test at t=\"\n                                + str(forceInertialOutput[i, 0] * macros.NANO2SEC) + \"sec\\n\")\n        if not unitTestSupport.isArrayEqual(forceBodyOutput[i], trueBodyVector[i], 3, accuracy):\n            testFailCount += 1\n            print(forceBodyOutput[i])\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed \"\n                                + \"Body Force Output\" + \" unit test at t=\"\n                                + str(forceBodyOutput[i, 0] * macros.NANO2SEC) + \"sec\\n\")\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n        print(\"This test uses an accuracy value of \" + str(accuracy))\n    else:\n        print(\"FAILED \" + module.ModelTag)\n        print(testMessages)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_spacecraftPointing(show_plots, case):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = spacecraftPointingTestFunction(show_plots, case)\n    assert testResults < 1, testMessage",
  "def spacecraftPointingTestFunction(show_plots, case):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.1)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = spacecraftPointing.spacecraftPointing()\n    module.ModelTag = \"spacecraftPointing\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.alignmentVector_B = [1.0, 0.0, 0.0]\n    if (case == 2):\n        module.alignmentVector_B = [0.0, 0.0, 1.0]\n\n    r_BN_N = [[np.cos(0.0), np.sin(0.0), 0.0],\n              [np.cos(0.001), np.sin(0.001), 0.0],\n              [np.cos(0.002), np.sin(0.002), 0.0],\n              [np.cos(0.003), np.sin(0.003), 0.0],\n              [np.cos(0.004), np.sin(0.004), 0.0]]\n\n    r_BN_N2 = [[0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0]]\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n\n    #\n    #   Chief Input Message\n    #\n    chiefInputData = messaging.NavTransMsgPayload()  # Create a structure for the input message\n    chiefInputData.r_BN_N = r_BN_N[0]\n    chiefInMsg = messaging.NavTransMsg().write(chiefInputData)\n\n    #\n    #   Deputy Input Message\n    #\n    deputyInputData = messaging.NavTransMsgPayload()  # Create a structure for the input message\n    deputyInputData.r_BN_N = r_BN_N2[0]\n    deputyInMsg = messaging.NavTransMsg().write(deputyInputData)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.attReferenceOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.chiefPositionInMsg.subscribeTo(chiefInMsg)\n    module.deputyPositionInMsg.subscribeTo(deputyInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.1))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    # Because it is decided to give the module a set of coordinates for each timestep, a new message has\n    # to be send for each timestep.\n    unitTestSim.ExecuteSimulation()\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.2))\n\n    chiefInputData.r_BN_N = r_BN_N[1]\n    chiefInMsg.write(chiefInputData)\n\n    deputyInputData.r_BN_N = r_BN_N2[1]\n    deputyInMsg.write(deputyInputData)\n\n    unitTestSim.ExecuteSimulation()\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.3))\n\n    chiefInputData.r_BN_N = r_BN_N[2]\n    chiefInMsg.write(chiefInputData)\n\n    deputyInputData.r_BN_N = r_BN_N2[2]\n    deputyInMsg.write(deputyInputData)\n\n    unitTestSim.ExecuteSimulation()\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.4))\n\n    chiefInputData.r_BN_N = r_BN_N[3]\n    chiefInMsg.write(chiefInputData)\n\n    deputyInputData.r_BN_N = r_BN_N2[3]\n    deputyInMsg.write(deputyInputData)\n\n    unitTestSim.ExecuteSimulation()\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.5))\n\n    chiefInputData.r_BN_N = r_BN_N[4]\n    chiefInMsg.write(chiefInputData)\n\n    deputyInputData.r_BN_N = r_BN_N2[4]\n    deputyInMsg.write(deputyInputData)\n\n    unitTestSim.ExecuteSimulation()\n\n    if (case == 1):\n        # This pulls the actual data log from the simulation run.\n        # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n        #\n        # check sigma_RN\n        #\n\n        moduleOutput = dataLog.sigma_RN\n        # set the filtered output truth states\n        trueVector = [\n                   [0.,              0.,              0.0],\n                   [0.,              0.,              0.0],\n                   [0.,              0.,              0.0002500000052],\n                   [0.,              0.,              0.0005000000417],\n                   [0.,              0.,              0.0007500001406],\n                   [0.,              0.,              0.001000000333]\n                   ]\n        # compare the module results to the truth values\n        accuracy = 1e-12\n        unitTestSupport.writeTeXSnippet(\"toleranceValue1\", str(accuracy), path)\n        for i in range(0,len(trueVector)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqual(moduleOutput[i],trueVector[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_RN unit test at t=\" +\n                                    str(dataLog.times()[i]*macros.NANO2SEC) +\n                                    \"sec\\n\")\n\n        #\n        # check omega_RN_N\n        #\n        moduleOutput = dataLog.omega_RN_N\n\n        # set the filtered output truth states\n        trueVector = [\n                   [0.,              0.,              0.0],\n                   [0.,              0.,              0.0],\n                   [0.,              0.,              0.01],\n                   [0.,              0.,              0.01],\n                   [0.,              0.,              0.01],\n                   [0.,              0.,              0.01]\n                   ]\n\n        # compare the module results to the truth values\n        # The first three values of the simulation have to be ignored for omega_RN_N. For this reason, comparing from index 3.\n        accuracy = 1e-9\n        unitTestSupport.writeTeXSnippet(\"toleranceValue2\", str(accuracy), path)\n        for i in range(0,len(trueVector)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqual(moduleOutput[i],trueVector[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_RN_N unit test at t=\" +\n                                    str(dataLog.times()[i]*macros.NANO2SEC) +\n                                    \"sec\\n\")\n\n        #\n        # check domega_RN_N\n        #\n        moduleOutput = dataLog.domega_RN_N\n\n        # set the filtered output truth states\n        trueVector = [\n                      [0.0, 0.0, 0.0],\n                      [0.0, 0.0, 0.0],\n                      [0.0, 0.0, 0.0],\n                      [0.0, 0.0, 0.0],\n                      [0.0, 0.0, 0.0],\n                      [0.0, 0.0, 0.0]\n                      ]\n        # compare the module results to the truth values\n        # The first three values of the simulation have to be ignored for domega_RN_N. For this reason, comparing from index 3.\n        accuracy = 1e-12\n        unitTestSupport.writeTeXSnippet(\"toleranceValue3\", str(accuracy), path)\n        for i in range(0,len(trueVector)):\n            # check a vector values\n            if not unitTestSupport.isArrayEqual(moduleOutput[i],trueVector[i],3,accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed domega_RN_N unit test at t=\" +\n                                    str(dataLog.times()[i]*macros.NANO2SEC) +\n                                    \"sec\\n\")\n    elif (case == 2):\n        trueVector = [-1.0/3.0, 1.0/3.0, -1.0/3.0]\n        # compare the module results to the truth values\n        accuracy = 1e-12\n        unitTestSupport.writeTeXSnippet(\"toleranceValue4\", str(accuracy), path)\n        # check a vector values\n        if not unitTestSupport.isVectorEqual(np.array(module.sigma_BA), np.array(trueVector), accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed, sigma_BA is calculated incorrectly\\n\")\n\n    #   print out success message if no error were found\n    snippentName = \"passFail\" + str(case)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"FAILED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_formationBarycenter(show_plots, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test verifies the formationBarycenter module. It checks the barycenter of three spacecraft using both\n    cartesian coordinates and orbital elements weighted averaging.\n\n    **Test Parameters**\n\n    The test parameters used are the following:\n\n    Args:\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    In this file we are checking the values of the variables\n\n    - ``barycenter``\n    - ``barycenterVelocity``\n    - ``barycenterC``\n    - ``barycenterVelocityC``\n\n    which represent the center of mass position and velocity vectors. The variables ending in ``C`` are pulled from the\n    C-wrapped navigation output message, whereas the other two come from the usual C++ message. All these variables are\n    compared to ``trueBarycenter`` and ``trueBarycenterVelocity``, which contain their true values.\n\n    As stated, both the C and C++ wrapped message outputs are checked.\n    \"\"\"\n    [testResults, testMessage] = formationBarycenterTestFunction(show_plots, accuracy)\n    assert testResults < 1, testMessage",
  "def formationBarycenterTestFunction(show_plots, accuracy):\n    \"\"\"Test method\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(1.)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    barycenterModule = formationBarycenter.FormationBarycenter()\n    barycenterModule.ModelTag = \"barycenterModuleTag\"\n    unitTestSim.AddModelToTask(unitTaskName, barycenterModule)\n\n    # Configure each spacecraft's position and velocity\n    mu = astroFunctions.mu_E\n\n    oe1 = orbitalMotion.ClassicElements()\n    oe1.a = 1.1 * astroFunctions.E_radius  # meters\n    oe1.e = 0.01\n    oe1.i = 45.0 * macros.D2R\n    oe1.Omega = 48.2 * macros.D2R\n    oe1.omega = 347.8 * macros.D2R\n    oe1.f = 85.3 * macros.D2R\n    rN1, vN1 = orbitalMotion.elem2rv(mu, oe1)\n\n    oe2 = copy.deepcopy(oe1)\n    oe2.e = 1.05 * oe1.e\n    oe2.i = 1.05 * oe1.i\n    oe2.f = 1.05 * oe1.f\n    rN2, vN2 = orbitalMotion.elem2rv(mu, oe2)\n\n    oe3 = copy.deepcopy(oe1)\n    oe3.e = 0.95 * oe1.e\n    oe3.i = 0.90 * oe1.i\n    oe3.f = 1.10 * oe1.f\n    rN3, vN3 = orbitalMotion.elem2rv(mu, oe3)\n\n    # Configure spacecraft state input messages\n    scNavMsgData1 = messaging.NavTransMsgPayload()\n    scNavMsgData1.r_BN_N = rN1\n    scNavMsgData1.v_BN_N = vN1\n    scNavMsg1 = messaging.NavTransMsg().write(scNavMsgData1)\n\n    scNavMsgData2 = messaging.NavTransMsgPayload()\n    scNavMsgData2.r_BN_N = rN2\n    scNavMsgData2.v_BN_N = vN2\n    scNavMsg2 = messaging.NavTransMsg().write(scNavMsgData2)\n\n    scNavMsgData3 = messaging.NavTransMsgPayload()\n    scNavMsgData3.r_BN_N = rN3\n    scNavMsgData3.v_BN_N = vN3\n    scNavMsg3 = messaging.NavTransMsg().write(scNavMsgData3)\n\n    # Configure spacecraft mass input messages\n    scPayloadMsgData1 = messaging.VehicleConfigMsgPayload()\n    scPayloadMsgData1.massSC = 100\n    scPayloadMsg1 = messaging.VehicleConfigMsg().write(scPayloadMsgData1)\n\n    scPayloadMsgData2 = messaging.VehicleConfigMsgPayload()\n    scPayloadMsgData2.massSC = 150\n    scPayloadMsg2 = messaging.VehicleConfigMsg().write(scPayloadMsgData2)\n\n    scPayloadMsgData3 = messaging.VehicleConfigMsgPayload()\n    scPayloadMsgData3.massSC = 250\n    scPayloadMsg3 = messaging.VehicleConfigMsg().write(scPayloadMsgData3)\n\n    # add spacecraft input messages to module\n    barycenterModule.addSpacecraftToModel(scNavMsg1, scPayloadMsg1)\n    barycenterModule.addSpacecraftToModel(scNavMsg2, scPayloadMsg2)\n    barycenterModule.addSpacecraftToModel(scNavMsg3, scPayloadMsg3)\n\n    # setup output message recorder objects\n    barycenterOutMsg = barycenterModule.transOutMsg.recorder()\n    barycenterOutMsgC = barycenterModule.transOutMsgC.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, barycenterOutMsg)\n    unitTestSim.AddModelToTask(unitTaskName, barycenterOutMsgC)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.TotalSim.SingleStepProcesses()\n\n    barycenterModule.useOrbitalElements = True\n    barycenterModule.mu = mu\n\n    unitTestSim.TotalSim.SingleStepProcesses()\n\n    # Pull module data\n    barycenter = barycenterOutMsg.r_BN_N\n    barycenterVelocity = barycenterOutMsg.v_BN_N\n    barycenterC = barycenterOutMsgC.r_BN_N\n    barycenterVelocityC = barycenterOutMsgC.v_BN_N\n    elements = orbitalMotion.rv2elem(mu, barycenter[1], barycenterVelocity[1])\n    elementsArray = [elements.a, elements.e, elements.i, elements.Omega, elements.omega, elements.f]\n    elementsC = orbitalMotion.rv2elem(mu, barycenterC[1], barycenterVelocityC[1])\n    elementsArrayC = [elementsC.a, elementsC.e, elementsC.i, elementsC.Omega, elementsC.omega, elementsC.f]\n\n    # Set the true values\n    trueBarycenter = np.array([-2795.61091086, 4349.07305245, 4711.56751498])\n    trueBarycenterVelocity = np.array([-5.73871824, -4.74464078, 1.07961505])\n    trueElements = [7015.94993, 0.0099, 0.7579092276785376, 0.8412486994612671, 6.07025513843626, 1.5855546253383273]\n\n    # Verify the data\n    if not unitTestSupport.isArrayEqual(barycenter[0], trueBarycenter, 3, accuracy) or \\\n            not unitTestSupport.isArrayEqual(barycenterVelocity[0], trueBarycenterVelocity, 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: formationBarycenter cartesian unit test.\")\n\n    if not unitTestSupport.isArrayEqual(elementsArray, trueElements, 6, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: formationBarycenter orbital element unit test.\")\n\n    if not unitTestSupport.isArrayEqual(barycenterC[0], trueBarycenter, 3, accuracy) or \\\n            not unitTestSupport.isArrayEqual(barycenterVelocityC[0], trueBarycenterVelocity, 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: formationBarycenter C message cartesian unit test.\")\n\n    if not unitTestSupport.isArrayEqual(elementsArrayC, trueElements, 6, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: formationBarycenter C message orbital element unit test.\")\n\n    if testFailCount == 0:\n        print(\"PASSED: formationBarycenter unit test.\")\n    else:\n        print(testMessages)\n\n    return [testFailCount, \"\".join(testMessages)]",
  "def test_hillToAttRef(show_plots, use_limits, msg_type):\n        \"\"\"\n    **Validation Test Description**\n\n    Unit test for hillToAttRef. The unit test specifically covers:\n\n    1. Input message types: Does hillToAttRef accept either a NavAttMsg or an AttRefMsg and produce identical behavior with either one?\n\n    2. Limit enforcement: When set, does the module correctly use the limits specified by the user?\n\n    \"\"\"\n        runner(show_plots, use_limits, msg_type)",
  "def runner(show_plots, use_limits, msg_type):\n    sim = sbc.SimBaseClass()\n    procName = 'process'\n    taskName = 'task'\n    proc = sim.CreateNewProcess(procName)\n    task =  sim.CreateNewTask(taskName, macros.sec2nano(1.0))\n    proc.addTask(task)\n\n    #   Set up a test relative state vector\n    relative_state = [1000, 0, 0, \n                      0,    5, 0] # m / m/s\n    #   Set up a dummy gain matrix\n    lqr_gain_set = np.array([[0,1,0],\n                             [0,0,0],\n                             [0,0,0],\n                             [0,0,0],\n                             [0,0,0.25],\n                             [0,0,0],       ]).T\n    hillStateMsgData = messaging.HillRelStateMsgPayload()\n    hillStateMsgData.r_DC_H = relative_state[0:3]\n    hillStateMsgData.v_DC_H = relative_state[3:]\n    hillStateMsg = messaging.HillRelStateMsg().write(hillStateMsgData)\n    \n\n    #   Set up the hillStateConverter\n    depAttRef = hillToAttRef.hillToAttRef()\n    depAttRef.ModelTag = \"dep_hillControl\"\n    depAttRef.gainMatrix = hillToAttRef.MultiArray(lqr_gain_set)\n    depAttRef.hillStateInMsg.subscribeTo(hillStateMsg)\n    if msg_type == 'NavAttMsg':\n        attRefMsgData = messaging.NavAttMsgPayload()\n        attRefMsgData.sigma_BN = [0.5, 0.5, 0.5]\n        attRefMsg = messaging.NavAttMsg().write(attRefMsgData)\n        depAttRef.attNavInMsg.subscribeTo(attRefMsg)\n    else:\n        attRefMsgData = messaging.AttRefMsgPayload()\n        attRefMsgData.sigma_RN = [0.2, 0.2, 0.2]\n        attRefMsg = messaging.AttRefMsg().write(attRefMsgData)\n        depAttRef.attRefInMsg.subscribeTo(attRefMsg)\n    \n    if use_limits:\n        depAttRef.relMRPMin = -0.2 #    Configure minimum MRP\n        depAttRef.relMRPMax = 0.2  #    Configure maximum MRP\n\n        # ref_vals = [0.2, -0.2, 0.2]\n        if msg_type == 'NavAttMsg':\n            ref_vals = [-0.37398374, -0.25203252, -0.57723577]\n        else:\n            ref_vals = [0.2165725,  0.32956685, 0.51789077]\n    else:\n        # ref_vals = lqr_gain_set.dot(relative_state)\n        if msg_type == 'NavAttMsg':\n            ref_vals = [0.5, 0.5, 0.5]\n        else:\n            ref_vals = [0.2, 0.2, 0.2]\n    \n    #   Store the output att ref message\n    depAttRecorder = depAttRef.attRefOutMsg.recorder()\n    \n    sim.AddModelToTask(taskName, depAttRef)\n    sim.AddModelToTask(taskName, depAttRecorder)\n\n    sim.ConfigureStopTime(macros.sec2nano(1.0))\n    sim.InitializeSimulation()\n    sim.ExecuteSimulation()\n\n    hill_positions = depAttRecorder.sigma_RN\n    #   Test the attitude calculation:\n    for val1, val2 in zip(hill_positions[-1], ref_vals):\n        assert val1 == pytest.approx(val2)",
  "def test_spacecraftReconfig(show_plots, useRefAttitude, accuracy):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = spacecraftReconfigTestFunction(show_plots, useRefAttitude, accuracy)\n    assert testResults < 1, testMessage",
  "def spacecraftReconfigTestFunction(show_plots, useRefAttitude, accuracy):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n    # Create a sim spacecraftReconfig as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.1)  # process rate\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)  # create new process\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))  # create new task\n    # Construct algorithm and associated C++ container\n    module = spacecraftReconfig.spacecraftReconfig()\n    module.ModelTag = \"spacecraftReconfig\"  # update python name of test spacecraftReconfig\n    module.targetClassicOED = [0.0000, 0.0000, 0.0000, 0.0001, 0.0002, 0.0003]\n    module.attControlTime = 400  # [s]\n    module.mu = orbitalMotion.MU_EARTH * 1e9  # [m^3/s^2]\n    # Add test spacecraftReconfig to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    #\n    # Chief Navigation Message\n    #\n    oe = orbitalMotion.ClassicElements()\n    oe.a = 20000e3  # [m]\n    oe.e = 0.1\n    oe.i = 0.2\n    oe.Omega = 0.3\n    oe.omega = 0.4\n    oe.f = 0.5\n    (r_BN_N, v_BN_N) = orbitalMotion.elem2rv(orbitalMotion.MU_EARTH*1e9, oe)\n    chiefNavStateOutData = messaging.NavTransMsgPayload()  # Create a structure for the input message\n    chiefNavStateOutData.timeTag = 0\n    chiefNavStateOutData.r_BN_N = r_BN_N\n    chiefNavStateOutData.v_BN_N = v_BN_N\n    chiefNavStateOutData.vehAccumDV = [0, 0, 0]\n    chiefInMsg = messaging.NavTransMsg().write(chiefNavStateOutData)\n    module.chiefTransInMsg.subscribeTo(chiefInMsg)\n    #\n    # Deputy Navigation Message\n    #\n    oe2 = orbitalMotion.ClassicElements()\n    oe2.a = (1 + 0.0006) * 7000e3  # [m]\n    oe2.e = 0.2 + 0.0005\n    oe2.i = 0.0 + 0.0004\n    oe2.Omega = 0.0 + 0.0003\n    oe2.omega = 0.0 + 0.0002\n    oe2.f = 0.0001\n    (r_BN_N2, v_BN_N2) = orbitalMotion.elem2rv(orbitalMotion.MU_EARTH*1e9, oe2)\n    deputyNavStateOutData = messaging.NavTransMsgPayload()  # Create a structure for the input message\n    deputyNavStateOutData.timeTag = 0\n    deputyNavStateOutData.r_BN_N = r_BN_N2\n    deputyNavStateOutData.v_BN_N = v_BN_N2\n    deputyNavStateOutData.vehAccumDV = [0, 0, 0]\n    deputyInMsg = messaging.NavTransMsg().write(deputyNavStateOutData)\n    module.deputyTransInMsg.subscribeTo(deputyInMsg)\n\n    #\n    # Deputy Vehicle Config Message\n    #\n    vehicleConfigInData = messaging.VehicleConfigMsgPayload()\n    vehicleConfigInData.massSC = 500\n    vehicleConfigMsg = messaging.VehicleConfigMsg().write(vehicleConfigInData)\n    module.vehicleConfigInMsg.subscribeTo(vehicleConfigMsg)\n\n    #\n    # reference attitude message\n    #\n    if useRefAttitude:\n        attRefInData = messaging.AttRefMsgPayload()\n        attRefInData.sigma_RN = [1.0, 0.0, 0.0]\n        attRefInData.omega_RN_N = [0.0, 0.0, 0.0]\n        attRefInData.domega_RN_N = [0.0, 0.0, 0.0]\n        attRefInMsg = messaging.AttRefMsg().write(attRefInData)\n        module.attRefInMsg.subscribeTo(attRefInMsg)\n\n    #\n    # thruster configuration message\n    #\n    location = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]\n    direction = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]  # get thrust in +z direction\n    fswSetupThrusters.clearSetup()\n    for i in range(len(location)):\n        fswSetupThrusters.create(location[i], direction[i], 22.6)\n    thrConfMsg = fswSetupThrusters.writeConfigMessage()\n    module.thrustConfigInMsg.subscribeTo(thrConfMsg)\n\n    # Setup logging on the test spacecraftReconfig output message so that we get all the writes to it\n    dataLog = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n    unitTestSim.AddVariableForLogging(module.ModelTag + \".resetPeriod\", testProcessRate)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(testProcessRate)  # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    attOutput = dataLog.sigma_RN\n    resetPeriod = unitTestSim.GetLogVariableData(module.ModelTag + \".resetPeriod\")\n    # set the filtered output truth states\n    if useRefAttitude:\n        trueVector = [[1.0,0.0,0.0]]\n    else:\n        trueVector = [[0.38532697209248595,\n                       -0.7016349090839732,\n                       -0.4026194572440069]]\n    trueResetPeriod = 28148.5466910579925752244889736\n    # compare the spacecraftReconfig results to the truth values\n    for i in range(0, len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(attOutput[i], trueVector[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_RN\" + \" unit test at t=\"\n                                + str(attOutput[i, 0]*macros.NANO2SEC) + \"sec\\n\")\n\n    if (not unitTestSupport.isDoubleEqualRelative(resetPeriod[0,1], trueResetPeriod, accuracy)):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed \" + \"resetPeriod\")\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n        print(\"This test uses an accuracy value of \" + str(accuracy))\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_meanOEFeedback(show_plots, useClassicElem, accuracy):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = meanOEFeedbackTestFunction(show_plots, useClassicElem, accuracy)\n    assert testResults < 1, testMessage",
  "def meanOEFeedbackTestFunction(show_plots, useClassicElem, accuracy):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n    # Create a sim meanOEFeedback as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.1)  # process rate\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)  # create new process\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))  # create new task\n    # Construct algorithm and associated C++ container\n    module = meanOEFeedback.meanOEFeedback()\n    module.ModelTag = \"meanOEFeedback\"  # update python name of test meanOEFeedback\n    module.targetDiffOeMean = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    module.mu = orbitalMotion.MU_EARTH * 1e9  # [m^3/s^2]\n    module.req = orbitalMotion.REQ_EARTH * 1e3  # [m]\n    module.J2 = orbitalMotion.J2_EARTH      # []\n    module.K = [1e7, 0.0, 0.0, 0.0, 0.0, 0.0,\n                      0.0, 1e7, 0.0, 0.0, 0.0, 0.0,\n                      0.0, 0.0, 1e7, 0.0, 0.0, 0.0,\n                      0.0, 0.0, 0.0, 1e7, 0.0, 0.0,\n                      0.0, 0.0, 0.0, 0.0, 1e7, 0.0,\n                      0.0, 0.0, 0.0, 0.0, 0.0, 1e7]\n    if(useClassicElem):\n        module.oeType = 0  # 0: classic\n    else:\n        module.oeType = 1  # 1: equinoctial\n    # Add test meanOEFeedback to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    #\n    # Chief Navigation Message\n    #\n    oe = orbitalMotion.ClassicElements()\n    oe.a = 20000e3  # [m]\n    oe.e = 0.1\n    oe.i = 0.2\n    oe.Omega = 0.3\n    oe.omega = 0.4\n    oe.f = 0.5\n    (r_BN_N, v_BN_N) = orbitalMotion.elem2rv(orbitalMotion.MU_EARTH*1e9, oe)\n    chiefNavStateOutData = messaging.NavTransMsgPayload()  # Create a structure for the input message\n    chiefNavStateOutData.timeTag = 0\n    chiefNavStateOutData.r_BN_N = r_BN_N\n    chiefNavStateOutData.v_BN_N = v_BN_N\n    chiefNavStateOutData.vehAccumDV = [0, 0, 0]\n    chiefInMsg = messaging.NavTransMsg().write(chiefNavStateOutData)\n\n    #\n    # Deputy Navigation Message\n    #\n    oe2 = orbitalMotion.ClassicElements()\n    oe2.a = (1 + 0.0006) * 7000e3  # [m]\n    oe2.e = 0.2 + 0.0005\n    oe2.i = 0.0 + 0.0004\n    oe2.Omega = 0.0 + 0.0003\n    oe2.omega = 0.0 + 0.0002\n    oe2.f = 0.0001\n    (r_BN_N2, v_BN_N2) = orbitalMotion.elem2rv(orbitalMotion.MU_EARTH*1e9, oe2)\n    deputyNavStateOutData = messaging.NavTransMsgPayload()  # Create a structure for the input message\n    deputyNavStateOutData.timeTag = 0\n    deputyNavStateOutData.r_BN_N = r_BN_N2\n    deputyNavStateOutData.v_BN_N = v_BN_N2\n    deputyNavStateOutData.vehAccumDV = [0, 0, 0]\n    deputyInMsg = messaging.NavTransMsg().write(deputyNavStateOutData)\n\n    # Setup logging on the test meanOEFeedback output message so that we get all the writes to it\n    dataLog = module.forceOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.chiefTransInMsg.subscribeTo(chiefInMsg)\n    module.deputyTransInMsg.subscribeTo(deputyInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(testProcessRate)  # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    forceOutput = dataLog.forceRequestInertial\n\n    # set the filtered output truth states\n    if useClassicElem:\n        trueVector = [[-849.57347406544340628897771239280701,\n                       1849.77641265032843875815160572528839,\n                       136.07817734479317550722043961286545]]\n    else:\n        trueVector = [[-1655.37188207880308254971168935298920,\n                       1788.61776379042521512019447982311249,\n                       52.54814237453938119415397522971034]]\n\n    # compare the meanOEFeedback results to the truth values\n    for i in range(0, len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(forceOutput[i], trueVector[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed \"\n                                + \".forceRequestInertial\" + \" unit test at t=\"\n                                + str(dataLog.times()[i]*macros.NANO2SEC) + \"sec\\n\")\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n        print(\"This test uses an accuracy value of \" + str(accuracy))\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_hillStateConverter(show_plots):\n    \"\"\"\n    Tests the hillStateConverter module for the following:\n    1. Accepts both a hill and deputy message;\n    2. Correctly converts those messages into the hill frame.\n    \"\"\"\n    sim = sbc.SimBaseClass()\n    procName = 'process'\n    taskName = 'task'\n    proc = sim.CreateNewProcess(procName)\n    task =  sim.CreateNewTask(taskName, macros.sec2nano(1.0))\n    proc.addTask(task)\n\n    #   Set up two spacecraft position messages\n    chief_r = [7100,0,0]\n    chief_v = [0,7.000,0]\n    dep_r = [7101, 0, 0]\n    dep_v = [0,7.010,0]\n\n    chiefNavMsgData = messaging.NavTransMsgPayload()\n    chiefNavMsgData.r_BN_N = chief_r\n    chiefNavMsgData.v_BN_N = chief_v\n    chiefNavMsg = messaging.NavTransMsg().write(chiefNavMsgData)\n\n    depNavMsgData = messaging.NavTransMsgPayload()\n    depNavMsgData.r_BN_N = dep_r \n    depNavMsgData.v_BN_N = dep_v\n    depNavMsg = messaging.NavTransMsg().write(depNavMsgData)\n\n    #   Set up the hillStateConverter\n    hillStateNav = hillStateConverter.hillStateConverter()\n    hillStateNav.ModelTag = \"dep_hillStateNav\"\n    hillStateNav.chiefStateInMsg.subscribeTo(chiefNavMsg)\n    hillStateNav.depStateInMsg.subscribeTo(depNavMsg)\n    hillRecorder = hillStateNav.hillStateOutMsg.recorder()\n    \n    sim.AddModelToTask(taskName, hillStateNav)\n    sim.AddModelToTask(taskName, hillRecorder)\n\n    sim.ConfigureStopTime(macros.sec2nano(1.0))\n    sim.InitializeSimulation()\n    sim.ExecuteSimulation()\n\n    hill_positions = hillRecorder.r_DC_H\n    hill_velocities = hillRecorder.v_DC_H\n\n    ref_pos = [1,0,0]\n    ref_vel = [0,0.00901408,0]\n    #   Test the position calculation:\n    for val1, val2 in zip(hill_positions[-1], ref_pos):\n        assert  val1 == pytest.approx(val2)\n\n    for val1, val2  in zip(hill_velocities[-1], ref_vel):\n        assert val1 == pytest.approx(val2)",
  "def test_rwConfigData():\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = rwConfigDataTestFunction()\n    assert testResults < 1, testMessage",
  "def rwConfigDataTestFunction():\n    \"\"\" Test the rwConfigData module \"\"\"\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # This is needed if multiple unit test scripts are run\n    # This create a fresh and consistent simulation environment for each test run\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate)) # Add a new task to the process\n\n    # Construct the cssComm module\n    module = rwConfigData.rwConfigData()\n\n    # Create the messages\n    rwConstellationFswMsg = messaging.RWConstellationMsgPayload()\n    numRW = 3\n    rwConstellationFswMsg.numRW = 3\n    gsHat_initial = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    js_initial = np.array([0.08, 0.09, 0.07])\n    uMax_initial = np.array([0.2, 0.1, 0.3])\n\n    # Iterate over all of the reaction wheels, create a rwConfigElementFswMsg, and add them to the rwConstellationFswMsg\n    rwConfigElementList = list()\n    for rw in range(numRW):\n        rwConfigElementMsg = messaging.RWConfigElementMsgPayload()\n        rwConfigElementMsg.gsHat_B = gsHat_initial[rw]  # Spin axis unit vector of the wheel in structure # [1, 0, 0]\n        rwConfigElementMsg.Js = js_initial[rw]  # Spin axis inertia of wheel [kgm2]\n        rwConfigElementMsg.uMax = uMax_initial[rw]  # maximum RW motor torque [Nm]\n\n        # Add this to the list\n        rwConfigElementList.append(rwConfigElementMsg)\n\n    # Set the array of the reaction wheels in RWConstellationFswMsg to the list created above\n    rwConstellationFswMsg.reactionWheels = rwConfigElementList\n\n    # Set these messages\n    rwConstInMsg = messaging.RWConstellationMsg().write(rwConstellationFswMsg)\n    module.rwConstellationInMsg.subscribeTo(rwConstInMsg)\n\n    module.ModelTag = \"rwConfigData\"\n\n    # Add the module to the task\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Log the output message\n    dataLog = module.rwParamsOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.ConfigureStopTime(testProcessRate)\n    unitTestSim.ExecuteSimulation()\n\n    # Get the output from this simulation\n    JsListLog = dataLog.JsList[:, :numRW]\n    uMaxLog = dataLog.uMax[:, :numRW]\n    GsMatrix_B_Log = dataLog.GsMatrix_B[:, :(3*numRW)]\n\n    accuracy = 1e-6\n    # At each timestep, make sure the vehicleConfig values haven't changed from the initial values\n    testFailCount, testMessages = unitTestSupport.compareArrayND([js_initial]*2, JsListLog, accuracy,\n                                                                 \"rwConfigData JsList\",\n                                                                 3, testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArrayND([uMax_initial]*2, uMaxLog, accuracy,\n                                                                 \"rwConfigData uMax\",\n                                                                 3, testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArrayND([gsHat_initial.flatten()]*2, GsMatrix_B_Log, accuracy,\n                                                                 \"rwConfigData GsMatrix_B\",\n                                                                 3*numRW, testFailCount, testMessages)\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_vehicleConfigData():\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = vehicleConfigDataTestFunction()\n\n    assert testResults < 1, testMessage",
  "def vehicleConfigDataTestFunction():\n    \"\"\" Test the vehicleConfigData module \"\"\"\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate)) # Add a new task to the process\n\n    # Construct the cssComm module\n    module = vehicleConfigData.vehicleConfigData()\n    # Populate the config\n    I = [1000., 0., 0.,\n         0., 800., 0.,\n         0., 0., 800.]\n    module.ISCPntB_B = I\n    initialCoM = [1, 1, 1]\n    module.CoM_B = initialCoM\n    mass = 300.\n    module.massSC = mass\n\n    module.ModelTag = \"vehicleConfigData\"\n\n    # Add the module to the task\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Log the output message\n    dataLog = module.vecConfigOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.ConfigureStopTime(testProcessRate)\n    unitTestSim.ExecuteSimulation()\n\n    # Get the output from this simulation\n    Ilog = dataLog.ISCPntB_B\n    CoMLog = dataLog.CoM_B\n    MassLog = dataLog.massSC\n\n    accuracy = 1e-6\n\n    # At each timestep, make sure the vehicleConfig values haven't changed from the initial values\n    testFailCount, testMessages = unitTestSupport.compareArrayND([initialCoM for _ in range(len(CoMLog))], CoMLog, accuracy,\n                                                                 \"VehicleConfigData CoM\",\n                                                                 3, testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArrayND([I for _ in range(len(Ilog))], Ilog, accuracy,\n                                                                 \"VehicleConfigData I\",\n                                                                 3, testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray([mass for _ in range(len(MassLog))], MassLog, accuracy,\n                                                                 \"VehicleConfigData Mass\",\n                                                                 testFailCount, testMessages)\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_hillPoint(show_plots, celMsgSet):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = hillPointTestFunction(show_plots, celMsgSet)\n    assert testResults < 1, testMessage",
  "def hillPointTestFunction(show_plots, celMsgSet):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = hillPoint.hillPoint()\n    module.ModelTag = \"hillPoint\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n\n    a = af.E_radius * 2.8\n    e = 0.0\n    i = 0.0\n    Omega = 0.0\n    omega = 0.0\n    f = 60 * af.D2R\n    (r, v) = af.OE2RV(af.mu_E, a, e, i, Omega, omega, f)\n    r_BN_N = r\n    v_BN_N = v\n    planetPos = np.array([0.0, 0.0, 0.0])\n    planetVel = np.array([0.0, 0.0, 0.0])\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    #\n    #   Navigation Input Message\n    #\n    NavStateOutData = messaging.NavTransMsgPayload()  # Create a structure for the input message\n    NavStateOutData.r_BN_N = r_BN_N\n    NavStateOutData.v_BN_N = v_BN_N\n    navMsg = messaging.NavTransMsg().write(NavStateOutData)\n    module.transNavInMsg.subscribeTo(navMsg)\n\n    #\n    #   Spice Input Message\n    #\n    if (celMsgSet):\n        CelBodyData = messaging.EphemerisMsgPayload()\n        CelBodyData.r_BdyZero_N = planetPos\n        CelBodyData.v_BdyZero_N = planetVel\n        celBodyMsg = messaging.EphemerisMsg().write(CelBodyData)\n        module.celBodyInMsg.subscribeTo(celBodyMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    #\n    # check sigma_RN\n    #\n    moduleOutput = dataLog.sigma_RN\n\n    # set the filtered output truth states\n    trueVector = [\n               [0.,              0.,              0.267949192431],\n               [0.,              0.,              0.267949192431],\n               [0.,              0.,              0.267949192431]\n               ]\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleOutput[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_RN unit test at t=\" +\n                                str(moduleOutput[i,0]*macros.NANO2SEC) +\n                                \"sec\\n\")\n    #\n    # check omega_RN_N\n    #\n    moduleOutput = dataLog.omega_RN_N\n    # set the filtered output truth states\n    trueVector = [\n               [0.,              0.,              0.000264539877],\n               [0.,              0.,              0.000264539877],\n               [0.,              0.,              0.000264539877]\n               ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleOutput[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_RN_N unit test at t=\" +\n                                str(moduleOutput[i,0]*macros.NANO2SEC) +\n                                \"sec\\n\")\n    #\n    # check domega_RN_N\n    #\n    moduleOutput = dataLog.domega_RN_N\n    # set the filtered output truth states\n    trueVector = [\n               [0.0, 0.0, 1.315647475046e-23],\n               [0.0, 0.0, 1.315647475046e-23],\n               [0.0, 0.0, 1.315647475046e-23]\n               ]\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleOutput[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed domega_RN_N unit test at t=\" +\n                                str(moduleOutput[i,0]*macros.NANO2SEC) +\n                                \"sec\\n\")\n\n    # Note that we can continue to step the simulation however we feel like.\n    # Just because we stop and query data does not mean everything has to stop for good\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.6))    # run an additional 0.6 seconds\n    unitTestSim.ExecuteSimulation()\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def normalize(v):\n    norm=np.linalg.norm(v)\n    if norm==0:\n       return v\n    return v/norm",
  "def printResults_HillPoint(r_BN_N, v_BN_N, celBodyPosVec, celBodyVelVec):\n    r = r_BN_N - celBodyPosVec\n    v = v_BN_N - celBodyVelVec\n    h = np.cross(r, v)\n    i_r = normalize(r)\n    i_h = normalize(h)\n    i_theta = np.cross(i_h, i_r)\n    HN = np.array([ i_r, i_theta, i_h ])\n    sigma_HN = rbk.C2MRP(HN)\n\n    hm = la.norm(h)\n    rm = la.norm(r)\n    drdt = np.dot(v, i_r)\n    dfdt = hm / (rm * rm)\n    ddfdt2 = -2.0 * drdt / rm * dfdt\n\n    omega_HN_N = dfdt * i_h\n    domega_HN_N = ddfdt2 * i_h\n\n    print('sigma_HN = ', sigma_HN)\n    print('omega_HN_N = ', omega_HN_N)\n    print('domega_HN_N = ', domega_HN_N)\n\n    HN = rbk.MRP2C(sigma_HN)\n    M = rbk.Mi(0.5*np.pi, 1)\n    sigma = rbk.C2MRP(np.dot(M, HN))\n    print(sigma)\n    return (sigma_HN, omega_HN_N, domega_HN_N)",
  "def test_waypointReference(show_plots, attType, MRPswitching, useReferenceFrame, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test script tests the capability of the WaypointReference module to correctly read time-tagged\n    attitude parameters, angular rates and angular accelerations from a text file. \n    First a text file is generated that contains a sequence of time-tagged attitude parameters, angular rates \n    and angular accelerations; subsequently, the same file is fed to the waypointReference module.\n    The module is tested against all the attitude types that it supports:\n    - MRPs\n    - Euler Parameters (quaternion) [q0, q1, q2, q3]\n    - Euler Parameters (quaternion) [q1, q2, q3, qs]\n    and with angular rates and accelerations that can be expressed either in the inertial frame N or in the \n    reference frame R.\n    This unit test writes 5 time-tagged attitudes at times t = [1.0, 2.0, 3.0, 4.0, 5.0]s. Real values of \n    attitude parameters, angular rates and angular accelerations in inertial frames are stored in \n    ``attReal_RN``, ``omegaReal_RN_N`` and ``omegaDotReal_RN_N`` respectively.\n\n    **Test Parameters**\n\n    Args:\n        attType (int): 0 - MRPs; 1 - EP [q0, q1, q2, q3]; 2 - [q1, q2, q3, qs]\n        MRPswitching : False: every waypoint is within 180 deg from the inertial frame; True: some waipoints exceed 180 deg rotation from the inertial frame and ``attRefOutMsg.sigma_RN`` presents a discontinuity in correspondence of MRP switching;\n        useReferenceFrame (bool): False: ang. rates and accelerations expressed in inertial frame; True: ang. rates and accelerations expressed in reference frame;\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    This unit test checks the correctness of the output attitude reference message \n\n    - ``attRefMsg``\n\n    compared to the real values stored in the data file  ``attReal_RN``, ``omegaReal_RN_N`` and ``omegaDotReal_RN_N``.\n    The simulation is run with a sampling frequency of 0.25 s, which is higher than the frequency with which the attitude\n    waypoints are saved in the data file (1.0 s), starting at t = 0. \n\n    For t < 1.0 s we check that the attitude in ``attRefMsg`` coincides with ``attReal_RN`` at time t = 1.0 s, \n    while rates and accelerations in ``attRefMsg`` are zero.\n\n    For t > 5.0 s we check that the attitude in ``attRefMsg`` coincides with ``attReal_RN`` at time t = 5.0 s, \n    while rates and accelerations in ``attRefMsg`` are zero.\n\n    For 1.0 s <= t <= 5.0 s we check that the attitude, rates and accelerations in ``attRefMsg`` coincide with \n    the linear interpolation of ``attReal_RN``, ``omegaReal_RN_N`` and ``omegaDotReal_RN_N``.\n    \"\"\"\n\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = waypointReferenceTestFunction(attType, MRPswitching, useReferenceFrame, accuracy)\n    global dataFileName\n    if os.path.exists(dataFileName):\n        os.remove(dataFileName)\n    assert testResults < 1, testMessage",
  "def waypointReferenceTestFunction(attType, MRPswitching, useReferenceFrame, accuracy):\n\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    dtSeconds = 0.25\n    simTimeSeconds = 6\n    testProcessRate = macros.sec2nano(dtSeconds)\n    simulationTime = macros.sec2nano(simTimeSeconds)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # create the simulation data file\n    # dataFileName\n    global dataFileName\n    dataFileName = \"data\" + str(attType) + str(int(MRPswitching))\n    if useReferenceFrame == True:\n        dataFileName += \"R.txt\"\n    else:\n        dataFileName += \"N.txt\"\n\n    dataFileName = os.path.join(path, dataFileName)\n    delimiter = \",\"\n    fDataFile = open(dataFileName, \"w+\")\n    \n    # create the datafile and store the real attitude, rate and acceleration values\n    t = []\n    attReal_RN = []\n    omegaReal_RN_N = []\n    omegaDotReal_RN_N = []\n    for i in range(0, 5):\n        t.append(i + 1)\n        if MRPswitching:\n            s = 0.8\n        else:\n            s = 0.1\n        attRealMRP = np.array([s + 0.05*i, 0.2 + 0.05*i, 0.3 + 0.05*i])\n        if np.linalg.norm(attRealMRP) <= 1:\n            attReal_RN.append(attRealMRP)\n        else:\n            attReal_RN.append(-attRealMRP / (np.linalg.norm(attRealMRP))**2 )\n        omegaReal_RN_N.append(np.array([0.4 + 0.05*i, 0.5 + 0.05*i, 0.6 + 0.05*i]))\n        omegaDotReal_RN_N.append(np.array([0.7 + 0.05*i, 0.8 + 0.05*i, 0.9 + 0.05*i]))\n\n        lineString = str(t[-1]) + delimiter\n\n        if attType == 0:\n            lineString += str(attReal_RN[-1].tolist())[1:-1] + delimiter\n        elif attType == 1:\n            q = rbk.MRP2EP(attReal_RN[-1])\n            lineString += str(q.tolist())[1:-1] + delimiter\n        elif attType == 2:\n            q = rbk.MRP2EP(attReal_RN[-1])\n            qs = [q[1], q[2], q[3], q[0]]\n            lineString += str(qs)[1:-1] + delimiter\n        else:\n            print(\"Invalid attitude type\")\n            return\n        \n        if not useReferenceFrame:\n            lineString += str(omegaReal_RN_N[-1].tolist())[1:-1] + delimiter + str(omegaDotReal_RN_N[-1].tolist())[1:-1] + '\\n'\n        else:\n            RN = rbk.MRP2C(attReal_RN[-1])\n            omegaReal_RN_R = np.matmul(RN, omegaReal_RN_N[-1])\n            omegaDotReal_RN_R = np.matmul(RN, omegaDotReal_RN_N[-1])\n            lineString += str(omegaReal_RN_R.tolist())[1:-1] + delimiter + str(omegaDotReal_RN_R.tolist())[1:-1] + '\\n'\n        \n        # write line on file\n        fDataFile.write(lineString)\n\n    # close file\n    fDataFile.close()\n\n    # Construct algorithm and associated C++ container\n    testModule = waypointReference.WaypointReference()\n    testModule.ModelTag = \"testModule\"\n\n    # load the data path from the same folder where this python script is\n    testModule.dataFileName = dataFileName\n    testModule.delimiter = delimiter\n    testModule.attitudeType = attType\n    testModule.useReferenceFrame = useReferenceFrame\n    testModule.headerLines = 0\n\n    # Add module to the task\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = testModule.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(simulationTime) \n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the sampling times from the simulation run.\n    timeData = dataLog.times() * macros.NANO2SEC\n    \n    # Check if logged data matches the real attitude, rates and accelerations\n    j = 0\n    \n    sigma_RN = [[], [], []]\n    # checking attitude msg for t < t_min\n    for i in range(len(timeData)-1):\n\n        for n in range(3):\n            sigma_RN[n].append(dataLog.sigma_RN[i][n])\n\n        if timeData[i] < t[0]:\n            if not unitTestSupport.isVectorEqual(dataLog.sigma_RN[i], attReal_RN[0], accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed attitude check at time t = {}\".format(timeData[i]))\n            if not unitTestSupport.isVectorEqual(dataLog.omega_RN_N[i], np.array([0.0, 0.0, 0.0]), accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed angular rate check at time t = {}\".format(timeData[i]))\n            if not unitTestSupport.isVectorEqual(dataLog.domega_RN_N[i], np.array([0.0, 0.0, 0.0]), accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed angular acceleration check at time t = {}\".format(timeData[i]))\n        \n        # checking attitude msg for t_min <= t <= t_max\n        elif timeData[i] >= t[0] and timeData[i] <= t[-1]:\n            while (timeData[i] >= t[j] and timeData[i] <= t[j+1]) == False:\n                j += 1\n            sigma_RN_int = np.array([0.0, 0.0, 0.0])\n            omega_RN_N_int = np.array([0.0, 0.0, 0.0])\n            omegaDot_RN_N_int = np.array([0.0, 0.0, 0.0])\n\n            # interpolating between attitudes for times t = timeData[i]\n            if np.linalg.norm( attReal_RN[j+1] - attReal_RN[j] ) <= 1:\n                sigma_RN_int = attReal_RN[j] + (attReal_RN[j+1] - attReal_RN[j]) / (t[j+1] - t[j]) * (timeData[i] - t[j])\n            else:\n                attReal_RN_SS = -attReal_RN[j+1] / (np.linalg.norm(attReal_RN[j+1]))**2\n                sigma_RN_int = attReal_RN[j] + (attReal_RN_SS - attReal_RN[j]) / (t[j+1] - t[j]) * (timeData[i] - t[j])\n            omega_RN_N_int = omegaReal_RN_N[j] + (omegaReal_RN_N[j+1] - omegaReal_RN_N[j]) / (t[j+1] - t[j]) * (timeData[i] - t[j])\n            omegaDot_RN_N_int = omegaDotReal_RN_N[j] + (omegaDotReal_RN_N[j+1] - omegaDotReal_RN_N[j]) / (t[j+1] - t[j]) * (timeData[i] - t[j])\n            if not unitTestSupport.isVectorEqual(dataLog.sigma_RN[i], sigma_RN_int, accuracy):\n                print(timeData[i], dataLog.sigma_RN[i], sigma_RN_int)\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed attitude check at time t = {}\".format(timeData[i]))\n            if not unitTestSupport.isVectorEqual(dataLog.omega_RN_N[i], omega_RN_N_int, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed angular rate check at time t = {}\".format(timeData[i]))\n            if not unitTestSupport.isVectorEqual(dataLog.domega_RN_N[i], omegaDot_RN_N_int, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed angular acceleration check at time t = {}\".format(timeData[i]))\n        \n        # checking attitude msg for t < t_max\n        else:\n            if not unitTestSupport.isVectorEqual(dataLog.sigma_RN[i], attReal_RN[-1], accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed attitude check at time t = {}\".format(timeData[i]))\n            if not unitTestSupport.isVectorEqual(dataLog.omega_RN_N[i], [0.0, 0.0, 0.0], accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed angular rate check at time t = {}\".format(timeData[i]))\n            if not unitTestSupport.isVectorEqual(dataLog.domega_RN_N[i], [0.0, 0.0, 0.0], accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Module failed angular acceleration check at time t = {}\".format(timeData[i]))\n\n    # print out success or failure message\n    if testFailCount == 0:\n        print(\"PASSED: \" + testModule.ModelTag)\n    else:\n        print(\"FAILED: \" + testModule.ModelTag)\n        print(testMessages)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_inertial3D(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = subModuleTestFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def subModuleTestFunction(show_plots):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = inertial3D.inertial3D()\n    module.ModelTag = \"inertial3D\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    vector = [0.1, 0.2, 0.3]\n    module.sigma_R0N = vector\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    #\n    # check sigma_BR\n    #\n    moduleOutput = dataLog.sigma_RN\n    # set the filtered output truth states\n    trueVector = [\n               [0.1, 0.2, 0.3],\n               [0.1, 0.2, 0.3],\n               [0.1, 0.2, 0.3]\n               ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleOutput[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_RN unit test at t=\" +\n                                str(moduleOutput[i,0]*macros.NANO2SEC) +\n                                \"sec\\n\")\n    #\n    # check omega_RN_N\n    #\n    moduleOutput = dataLog.omega_RN_N\n    # set the filtered output truth states\n    trueVector = [\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0]\n               ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleOutput[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_RN_N unit test at t=\" +\n                                str(moduleOutput[i,0]*macros.NANO2SEC) +\n                                \"sec\\n\")\n\n    #\n    # check domega_RN_B\n    #\n    moduleOutput = dataLog.domega_RN_N\n    # set the filtered output truth states\n    trueVector = [\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0]\n               ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleOutput[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed domega_RN_N unit test at t=\" +\n                                str(moduleOutput[i,0]*macros.NANO2SEC) +\n                                \"sec\\n\")\n\n    snippentName = \"passFail\"\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def shadowSetMap(sigma, switch):\n    sigma = np.array(sigma)\n    if switch:\n        s2 = (sigma[0]**2 + sigma[1]**2 + sigma[2]**2)\n        if not s2 == 0:\n            return -sigma / s2\n        else:\n            return sigma\n    else:\n        return sigma",
  "class constraint:\n    def __init__(self, axis, color):\n        self.axis =  axis / np.linalg.norm(axis)\n        self.color = color",
  "class node:\n    def __init__(self, sigma_BN, constraints, **kwargs):\n        self.sigma_BN = np.array(sigma_BN)\n        s = np.linalg.norm(self.sigma_BN)\n        if s > 1:\n            self.sigma_BN = shadowSetMap(sigma_BN, True)  # mapping to shadow set if |sigma| > 1\n        if np.abs(s-1) < 1e-5:\n            s = 1.\n        self.isBoundary = False\n        self.s = s\n        if s == 1:\n            self.isBoundary = True\n        self.isFree = True\n        self.color = ''\n        self.neighbors = {}\n        self.heuristic = 0\n        self.priority = 0\n        self.backpointer = self\n        # check cosntraint compliance\n        sigma_tilde = np.array([ [0,           -sigma_BN[2], sigma_BN[1]],\n                                 [sigma_BN[2],      0,      -sigma_BN[0]],\n                                 [-sigma_BN[1], sigma_BN[0],     0      ] ])\n        BN = np.identity(3) + ( 8*np.matmul(sigma_tilde, sigma_tilde) -4*(1-s**2)*sigma_tilde ) / (1 + s**2)**2\n        NB = BN.transpose()\n        # checking for keepOut constraint violation\n        if 'keepOut_b' in kwargs:\n            for i in range(len(kwargs['keepOut_b'])):\n                b_B = np.array(kwargs['keepOut_b'][i])\n                b_N = np.matmul(NB, b_B)\n                for c in constraints['keepOut']:\n                    if np.dot(b_N, c.axis) >= np.cos(kwargs['keepOut_fov'][i]):\n                        self.isFree = False\n                        self.color = c.color\n                        return\n        # checking for keepIn constraint violation (at least one SS must see the Sun)\n        if 'keepIn_b' in kwargs:\n            b_N = []\n            for i in range(len(kwargs['keepIn_b'])):\n                b_B = np.array(kwargs['keepIn_b'][i])\n                b_N.append(np.matmul(NB, b_B))\n            isIn = False\n            for c in constraints['keepIn']:\n                for i in range(len(b_N)):\n                    if np.dot(b_N[i], c.axis) >= np.cos(kwargs['keepIn_fov'][i]):\n                        isIn = True\n                        self.color = c.color\n            if not isIn:\n                self.isFree = False",
  "def distanceCart(n1, n2):\n    d1 = np.linalg.norm(n1.sigma_BN - n2.sigma_BN)\n    sigma1norm2 = n1.sigma_BN[0]**2 + n1.sigma_BN[1]**2 + n1.sigma_BN[2]**2\n    sigma2norm2 = n2.sigma_BN[0]**2 + n2.sigma_BN[1]**2 + n2.sigma_BN[2]**2\n    if sigma2norm2 > 1e-8:\n        sigma2_SS = shadowSetMap(n2.sigma_BN, True)\n        d2 = np.linalg.norm(n1.sigma_BN - sigma2_SS)\n    else:\n        d2 = d1\n    if sigma1norm2 > 1e-8:\n        sigma1_SS = shadowSetMap(n1.sigma_BN, True)\n        d3 = np.linalg.norm(sigma1_SS - n2.sigma_BN)\n    else:\n        d3 = d1\n    if sigma1norm2 > 1e-8 and sigma2norm2 > 1e-8:\n        d4 = np.linalg.norm(sigma1_SS - sigma2_SS)\n    else:\n        d4 = d1\n\n    return min(d1, d2, d3, d4)",
  "def distanceMRP(n1, n2):    \n    s1 = n1.sigma_BN\n    s2 = n2.sigma_BN\n    sigma1norm2 = n1.sigma_BN[0]**2 + n1.sigma_BN[1]**2 + n1.sigma_BN[2]**2\n    sigma2norm2 = n2.sigma_BN[0]**2 + n2.sigma_BN[1]**2 + n2.sigma_BN[2]**2\n\n    D = 1 + (sigma1norm2*sigma2norm2)**2 + 2*np.dot(s1, s2)\n\n    if abs(D) < 1e-5:\n        s2 = shadowSetMap(s2, True)\n        sigma2norm2 = 1 / sigma2norm2\n        D = 1 + (sigma1norm2*sigma2norm2)**2 + 2*np.dot(s1, s2)\n\n    s12 = ( (1-sigma2norm2)*s1 - (1-sigma1norm2)*s2 + 2*np.cross(s1, s2) ) / D\n    sigma12norm2 = np.linalg.norm(s12)**2\n\n    if sigma12norm2 > 1:\n        s12 = shadowSetMap(s12, True)\n\n    return 4*np.arctan(np.linalg.norm(s12))",
  "def mirrorFunction(i, j, k):\n    return [ [i, j, k], [-i, j, k], [i, -j, k], [i, j, -k], [-i, -j, k], [-i, j, -k], [i, -j, -k], [-i, -j, -k] ]",
  "def neighboringNodes(i, j, k):\n    return [ [i-1,  j,  k], [i+1,  j,  k], [i,  j-1,  k], [i,  j+1,  k], [i,  j,  k-1], [i,  j,  k+1],\n             [i-1, j-1, k], [i+1, j-1, k], [i-1, j+1, k], [i+1, j+1, k], [i-1, j, k-1], [i+1, j, k-1],\n             [i-1, j, k+1], [i+1, j, k+1], [i, j-1, k-1], [i, j+1, k-1], [i, j-1, k+1], [i, j+1, k+1],\n             [i-1,j-1,k-1], [i+1,j-1,k-1], [i-1,j+1,k-1], [i-1,j-1,k+1], [i+1,j+1,k-1], [i+1,j-1,k+1], [i-1,j+1,k+1], [i+1,j+1,k+1] ]",
  "def generateGrid(n_start, n_goal, N, constraints, data):\n    \n    u = np.linspace(0, 1, N, endpoint = True)\n    nodes = {}\n\n    # add internal nodes (|sigma| <= 1)\n    for i in range(N):\n        for j in range(N):\n            for k in range(N):\n                if (u[i]**2+u[j]**2+u[k]**2) <= 1:\n                    for m in mirrorFunction(i, j, k):\n                        if (m[0], m[1], m[2]) not in nodes:\n                            nodes[(m[0], m[1], m[2])] = node([np.sign(m[0])*u[i], np.sign(m[1])*u[j], np.sign(m[2])*u[k]], constraints, **data)\n    # add missing boundary nodes (|sigma| = 1)\n    for i in range(N-1):\n        for j in range(N-1):\n            for k in range(N-1):\n                if (i, j, k) in nodes:\n                    if not nodes[(i, j, k)].isBoundary:\n                        if (i+1, j, k) not in nodes:\n                            for m in mirrorFunction(i+1, j, k):\n                                if (m[0], m[1], m[2]) not in nodes:\n                                    nodes[(m[0], m[1], m[2])] = node([np.sign(m[0])*(1-u[j]**2-u[k]**2)**0.5, np.sign(m[1])*u[j], np.sign(m[2])*u[k]], constraints, **data)\n                        if (i, j+1, k) not in nodes:\n                            for m in mirrorFunction(i, j+1, k):\n                                if (m[0], m[1], m[2]) not in nodes:\n                                    nodes[(m[0], m[1], m[2])] = node([np.sign(m[0])*u[i], np.sign(m[1])*(1-u[i]**2-u[k]**2)**0.5, np.sign(m[2])*u[k]], constraints, **data)\n                        if (i, j, k+1) not in nodes:\n                            for m in mirrorFunction(i, j, k+1):\n                                if (m[0], m[1], m[2]) not in nodes:\n                                    nodes[(m[0], m[1], m[2])] = node([np.sign(m[0])*u[i], np.sign(m[1])*u[j], np.sign(m[2])*(1-u[i]**2-u[j]**2)**0.5], constraints, **data)\n    \n    # link nodes\n    for key1 in nodes:\n        i = key1[0]\n        j = key1[1]\n        k = key1[2]\n        # link nodes to immediate neighbors\n        for n in neighboringNodes(i, j, k):\n            key2 = (n[0], n[1], n[2])\n            if key2 in nodes:\n                if nodes[key1].isFree and nodes[key2].isFree:\n                    nodes[key1].neighbors[key2] = nodes[key2]\n        # link boundary nodes to neighbors of respective shadow sets\n        if nodes[key1].isBoundary:\n            if (-i, -j, -k) in nodes:\n                for key2 in nodes[(-i, -j, -k)].neighbors:\n                    if nodes[key1].isFree and nodes[key2].isFree and key2 not in nodes[key1].neighbors:\n                        nodes[key1].neighbors[key2] = nodes[key2]\n\n    # add start and goal nodes\n    # looking for closest nodes to start and goal\n    ds = 10\n    dg = 10\n    for key in nodes:\n        if nodes[key].isFree:\n            d1 = distanceCart(nodes[key], n_start)\n            if abs(d1-ds) < 1e-6:\n                if np.linalg.norm(nodes[key].sigma_BN) < np.linalg.norm(nodes[key_s].sigma_BN):\n                    ds = d1\n                    n_s = nodes[key]\n                    key_s = key\n            else:\n                if d1 < ds:\n                    ds = d1\n                    n_s = nodes[key]\n                    key_s = key\n            d2 = distanceCart(nodes[key], n_goal)\n            if abs(d2-dg) < 1e-6:\n                if np.linalg.norm(nodes[key].sigma_BN) < np.linalg.norm(nodes[key_g].sigma_BN):\n                    dg = d2\n                    n_g = nodes[key]\n                    key_g = key\n            else:\n                if d2 < dg:\n                    dg = d2\n                    n_g = nodes[key]\n                    key_g = key\n    for key in n_s.neighbors:\n        n_start.neighbors[key] = n_s.neighbors[key]\n    for key in n_g.neighbors:\n        nodes[key].neighbors[key_g] = n_goal\n    nodes[key_s] = n_start \n    nodes[key_g] = n_goal\n\n    return nodes",
  "def backtrack(n, n_start):\n    if n == n_start:\n        path = [n]\n        return path\n    else:\n        path = backtrack(n.backpointer, n_start)\n        path.append(n)\n        return path",
  "def pathHandle(path, avgOmega):\n\n    T = [0]\n    S = 0\n    for n in range(len(path)-1):\n        T.append(T[n] + distanceCart(path[n], path[n+1]))\n        S += T[n+1] - T[n]\n\n    X1 = []\n    X2 = []\n    X3 = []\n\n    shadowSet = False\n    for n in range(len(path)-1):\n        if not shadowSet:\n            sigma = path[n].sigma_BN\n        else:\n            if unitTestSupport.isVectorEqual(path[n].sigma_BN, [0,0,0], 1e-6):\n                for m in range(0,n):\n                    s2 = (X1[m]**2 + X2[m]**2 + X3[m]**2)**0.5\n                    X1[m] = -X1[m] / s2\n                    X2[m] = -X2[m] / s2\n                    X3[m] = -X3[m] / s2\n                shadowSet = not shadowSet\n            sigma = rbk.MRPswitch(path[n].sigma_BN, 0)\n        delSigma = path[n+1].sigma_BN - path[n].sigma_BN\n        if (np.linalg.norm(delSigma) > 1):\n            shadowSet = not shadowSet\n        X1.append(sigma[0])\n        X2.append(sigma[1])\n        X3.append(sigma[2])\n    if shadowSet:\n        sigma = rbk.MRPswitch(path[-1].sigma_BN, 0)\n    else:\n        sigma = path[-1].sigma_BN\n    X1.append(sigma[0])\n    X2.append(sigma[1])\n    X3.append(sigma[2])\n\n    Input = BSpline.InputDataSet(X1, X2, X3)\n    Input.setT( np.array(T) * 4 * S / (T[-1] * avgOmega) )\n\n    return Input",
  "def spline(Input, omegaS, omegaG):\n\n    sigmaS = [Input.X1[0][0],  Input.X2[0][0],  Input.X3[0][0]]\n    sigmaG = [Input.X1[-1][0], Input.X2[-1][0], Input.X3[-1][0]]\n    sigmaDotS = rbk.dMRP(sigmaS, omegaS)\n    sigmaDotG = rbk.dMRP(sigmaG, omegaG)\n\n    Input.setXDot_0(sigmaDotS)\n    Input.setXDot_N(sigmaDotG)\n\n    Output = BSpline.OutputDataSet()\n    BSpline.interpolate(Input, 100, 4, Output)\n\n    return Output",
  "def computeTorque(sigma, sigmaDot, sigmaDDot, I):\n\n    omega = rbk.dMRP2Omega(sigma, sigmaDot)\n    omegaDot = rbk.ddMRP2dOmega(sigma, sigmaDot, sigmaDDot)\n\n    return np.matmul(I, omegaDot) + np.cross(omega, np.matmul(I, omega))",
  "def effortEvaluation(Output, I):\n\n    effort = 0\n    sigma     = [Output.X1[0][0], Output.X2[0][0], Output.X3[0][0]]\n    sigmaDot  = [Output.XD1[0][0], Output.XD2[0][0], Output.XD3[0][0]]\n    sigmaDDot = [Output.XDD1[0][0], Output.XDD2[0][0], Output.XDD3[0][0]]\n    L_a = computeTorque(sigma, sigmaDot, sigmaDDot, I)\n\n    for n in range(len(Output.T)-1):\n        sigma     = [Output.X1[n+1][0], Output.X2[n+1][0], Output.X3[n+1][0]]\n        sigmaDot  = [Output.XD1[n+1][0], Output.XD2[n+1][0], Output.XD3[n+1][0]]\n        sigmaDDot = [Output.XDD1[n+1][0], Output.XDD2[n+1][0], Output.XDD3[n+1][0]]\n        L_b = computeTorque(sigma, sigmaDot, sigmaDDot, I)\n        effort += (np.linalg.norm(L_a) + np.linalg.norm(L_b)) * (Output.T[n+1][0] - Output.T[n][0]) / 2\n\n        L_a = L_b\n\n    return effort",
  "def AStar(nodes, n_start, n_goal):\n\n    for key in nodes:\n        nodes[key].heuristic = distanceCart(nodes[key], n_goal)\n\n    O = [n_start]\n    C = []\n    n = 0\n\n    while O[0] != n_goal and n < 10000:\n        n += 1\n        C.append(O[0])\n        for key in O[0].neighbors:\n            if nodes[key] not in C:\n                p = nodes[key].heuristic + distanceCart(O[0], nodes[key]) + O[0].priority - O[0].heuristic\n                if nodes[key] in O:\n                    if p < nodes[key].priority:\n                        nodes[key].priority = p\n                        nodes[key].backpointer = O[0]\n                else:\n                    nodes[key].priority = p\n                    nodes[key].backpointer = O[0]\n                    O.append(nodes[key])\n        O.pop(0)\n\n        if not O:\n            print(\"Dead end\")\n        else:\n            O.sort(key = lambda x: x.priority)\n\n    path = backtrack(O[0], n_start)\n\n    return path",
  "def effortBasedAStar(nodes, n_start, n_goal, omegaS, omegaG, avgOmega, I):\n\n    O = [n_start]\n    C = []\n    n = 0\n\n    while O[0] != n_goal and n < 10000:\n        n += 1\n        print(n)\n        C.append(O[0])\n        for key in O[0].neighbors:\n            if nodes[key] not in C:\n                path = backtrack(O[0], n_start)\n                path.append(nodes[key])\n                if nodes[key] != n_goal:\n                    path.append(n_goal)\n                Input = pathHandle(path, avgOmega)\n                Output = spline(Input, omegaS, omegaG)\n                p = effortEvaluation(Output, I)\n                if nodes[key] in O:\n                    if p < nodes[key].priority:\n                        nodes[key].priority = p\n                        nodes[key].backpointer = O[0]\n                else:\n                    nodes[key].priority = p\n                    nodes[key].backpointer = O[0]\n                    O.append(nodes[key])\n        O.pop(0)\n\n        if not O:\n            print(\"Dead end\")\n        else:\n            O.sort(key = lambda x: x.priority)\n\n    path = backtrack(O[0], n_start)\n\n    return path",
  "def test_constrainedAttitudeManeuver(show_plots, N, keepOutFov, keepInFov, costFcnType, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test script tests the correctness of the path computed by the ConstrainedAttitudeManeuver module.\n    The module is tested against Python scripts that mirror the same functions contained in the module. Tests are run for\n    different grid coarseness levels, different keep-out fields of view, and one keep-in field of view.\n\n    **Test Parameters**\n\n    Args:\n        N (int) : grid coarseness;\n        keepOutFov (float) : Field of View (in radiants) of the keep-out boresight;\n        keepInFov (float) : Field of View (in radiants) of the keep-in boresight;\n        costFcnType (int) : 0 for the minimum MRP cartesian distance graph search, 1 for the effort-based graph search.\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    The tests to show the correctness of the module are the following:\n    \n    - First of all, an equivalent grid is built in python. The first test consists in comparing the nodes generated\n      in Python versus the nodes generated in C++. The check consists in verifying whether the same key indices\n      :math:`(i,j,k)` generate the same node coordinates :math:`\\sigma_{BN}`. Secondly, it is checked whether \n      the same node is constraint-compliant or -incompliant both in Python and in C++.\n\n    - After running the graph-search algorithm, a check is conduced to ensure the equivalence of the computed paths.\n      Note that this unit test does not run the effort-based version of A*, due to the slow nature of the Python \n      implementation. If the user wishes, it is possible to uncomment line 429 to also test the effort-based\n      graph-search algorithm.\n\n    - The interpolated trajectory obtained in Python is checked versus the interpolated trajectory\n      obtained in C++. The Python code uses the BSK-native :ref:`BSpline` library, which has its own unit test.\n\n    - Lastly, a check is run on the norm of the required control torque for each time step of the\n      interpolated trajectory.  The correctness of this check should imply the correctness of the\n      functions used in the effort-based graph-search algorithm as well.\n    \"\"\"\n\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = CAMTestFunction(N, keepOutFov, keepInFov, costFcnType, accuracy)\n\n    assert testResults < 1, testMessage",
  "def CAMTestFunction(N, keepOutFov, keepInFov, costFcnType, accuracy):\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    Inertia = [0.02 / 3,  0.,         0.,\n               0.,        0.1256 / 3, 0.,\n               0.,        0.,         0.1256 / 3]\n    InertiaTensor = unitTestSupport.np2EigenMatrix3d(Inertia)\n    PlanetInertialPosition = np.array([10, 0, 0])\n    SCInertialPosition = np.array([1, 0, 0])\n    SCInitialAttitude = np.array([0, 0, -0.5])\n    SCTargetAttitude = np.array([0, 0.5, 0])\n    SCInitialAngRate = np.array([0, 0, 0])\n    SCTargetAngRate = np.array([0, 0, 0])\n    SCAvgAngRate = 0.03\n    keepOutBoresight_B = [[1, 0, 0]]\n    keepInBoresight_B = [[0, 1, 0], [0, 0, 1]]\n    # convert Fov angles to radiants\n    keepOutFov = keepOutFov * macros.D2R\n    keepInFov = keepInFov * macros.D2R\n\n    constraints = {'keepOut' : [], 'keepIn' : []}\n    constraints['keepOut'].append( constraint(PlanetInertialPosition-SCInertialPosition, 'r') )\n    constraints['keepIn'].append( constraint(PlanetInertialPosition-SCInertialPosition, 'g') )\n    data =  {'keepOut_b' : keepOutBoresight_B, 'keepOut_fov' : [keepOutFov], \n             'keepIn_b' : keepInBoresight_B, 'keepIn_fov' : [keepInFov, keepInFov]}\n    n_start = node(SCInitialAttitude, constraints, **data)\n    n_goal  = node(SCTargetAttitude, constraints, **data)\n    nodes = generateGrid(n_start, n_goal, N, constraints, data)\n    if costFcnType == 0:\n        path = AStar(nodes, n_start, n_goal)\n    else:\n        path = effortBasedAStar(nodes, n_start, n_goal, SCInitialAngRate, SCTargetAngRate, SCAvgAngRate, InertiaTensor)\n    Input = pathHandle(path, SCAvgAngRate)\n    Output = spline(Input, SCInitialAngRate, SCTargetAngRate)\n    pathCost = effortEvaluation(Output, InertiaTensor)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    simulationTime = macros.min2nano(2)\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n    \n    testModule = constrainedAttitudeManeuver.ConstrainedAttitudeManeuver(N)\n    testModule.sigma_BN_goal = SCTargetAttitude\n    testModule.omega_BN_B_goal = SCTargetAngRate\n    testModule.avgOmega = SCAvgAngRate\n    testModule.BSplineType = 0\n    testModule.costFcnType = costFcnType\n    testModule.appendKeepOutDirection(keepOutBoresight_B[0], keepOutFov)\n    testModule.appendKeepInDirection(keepInBoresight_B[0], keepInFov)\n    testModule.appendKeepInDirection(keepInBoresight_B[1], keepInFov)\n    testModule.ModelTag = \"testModule\"\n    unitTestSim.AddModelToTask(unitTaskName, testModule)\n\t\n    # connect messages\n    SCStatesMsgData = messaging.SCStatesMsgPayload()\n    SCStatesMsgData.r_BN_N = SCInertialPosition\n    SCStatesMsgData.sigma_BN = SCInitialAttitude\n    SCStatesMsgData.omega_BN_B = SCInitialAngRate\n    SCStatesMsg = messaging.SCStatesMsg().write(SCStatesMsgData)\n    VehicleConfigMsgData = messaging.VehicleConfigMsgPayload()\n    VehicleConfigMsgData.ISCPntB_B = Inertia\n    VehicleConfigMsg = messaging.VehicleConfigMsg().write(VehicleConfigMsgData)\n    PlanetStateMsgData = messaging.SpicePlanetStateMsgPayload()\n    PlanetStateMsgData.PositionVector = PlanetInertialPosition\n    PlanetStateMsg = messaging.SpicePlanetStateMsg().write(PlanetStateMsgData)\n    testModule.scStateInMsg.subscribeTo(SCStatesMsg)\n    testModule.vehicleConfigInMsg.subscribeTo(VehicleConfigMsg)\n    testModule.keepOutCelBodyInMsg.subscribeTo(PlanetStateMsg)\n    testModule.keepInCelBodyInMsg.subscribeTo(PlanetStateMsg)\n\n    numDataPoints = 200\n    samplingTime = unitTestSupport.samplingTime(simulationTime, testProcessRate, numDataPoints)\n\n    CAMLog = testModule.attRefOutMsg.recorder(samplingTime)\n    unitTestSim.AddModelToTask(unitTaskName, CAMLog)\n    CAMLogC = testModule.attRefOutMsgC.recorder(samplingTime)\n    unitTestSim.AddModelToTask(unitTaskName, CAMLogC)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(simulationTime)        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    timeData = CAMLog.times() * macros.NANO2SEC\n    print(timeData)\n    # print(len(CAMLog.sigma_RN))\n\n    # check correctness of grid points:\n    for i in range(-N,N+1):\n        for j in range(-N,N+1):\n            for k in range(-N,N+1):\n                if (i, j, k) in nodes:\n                    sigma_BN = nodes[(i, j, k)].sigma_BN\n                    sigma_BN_BSK = []\n                    for p in range(3):\n                        sigma_BN_BSK.append( testModule.returnNodeCoord([i, j, k], p) )\n                    if not unitTestSupport.isVectorEqual(sigma_BN, sigma_BN_BSK, accuracy):\n                        testFailCount += 1\n                        testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in the coordinates of node ({},{},{}) \\n\".format(i, j, k))\n                    if not nodes[(i, j, k)].isFree == testModule.returnNodeState([i, j, k]):\n                        testFailCount += 1\n                        testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in the state of node ({},{},{}) \\n\".format(i, j, k))\n\n    # check that the same path is produced\n    for p in range(len(path)):\n        sigma_BN = path[p].sigma_BN\n        sigma_BN_BSK = []\n        for j in range(3):\n            sigma_BN_BSK.append(testModule.returnPathCoord(p,j))\n        if not unitTestSupport.isVectorEqual(sigma_BN, sigma_BN_BSK, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in waypoint number {} in path \\n\".format(p))\n\n    # check interpolated path compliance\n    for n in range(len(Output.T)):\n        T_BSK = testModule.Output.T[n][0]\n        sigma_BSK = np.array([testModule.Output.X1[n][0], testModule.Output.X2[n][0], testModule.Output.X3[n][0]])\n        sigmaDot_BSK = np.array([testModule.Output.XD1[n][0], testModule.Output.XD2[n][0], testModule.Output.XD3[n][0]])\n        sigmaDDot_BSK = np.array([testModule.Output.XDD1[n][0], testModule.Output.XDD2[n][0], testModule.Output.XDD3[n][0]])\n\n        T         = Output.T[n][0]\n        sigma     = np.array([Output.X1[n][0], Output.X2[n][0], Output.X3[n][0]])\n        sigmaDot  = np.array([Output.XD1[n][0], Output.XD2[n][0], Output.XD3[n][0]])\n        sigmaDDot = np.array([Output.XDD1[n][0], Output.XDD2[n][0], Output.XDD3[n][0]])\n\n        if not unitTestSupport.isDoubleEqual(T, T_BSK, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in time at index #{} in trajectory \\n\".format(n))\n        if not unitTestSupport.isVectorEqual(sigma, sigma_BSK, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in sigma at index #{} in trajectory \\n\".format(n))\n        if not unitTestSupport.isVectorEqual(sigmaDot, sigmaDot_BSK, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in sigmaDot at index #{} in trajectory \\n\".format(n))\n        if not unitTestSupport.isVectorEqual(sigmaDDot, sigmaDDot_BSK, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in sigmaDDot at index #{} in trajectory \\n\".format(n))\n\n    # check same path cost for every spline point\n    for n in range(len(Output.T)):\n        c1 = testModule.computeTorqueNorm(n, Inertia)\n\n        sigma     = [Output.X1[n][0], Output.X2[n][0], Output.X3[n][0]]\n        sigmaDot  = [Output.XD1[n][0], Output.XD2[n][0], Output.XD3[n][0]]\n        sigmaDDot = [Output.XDD1[n][0], Output.XDD2[n][0], Output.XDD3[n][0]]\n        c2 = np.linalg.norm(computeTorque(sigma, sigmaDot, sigmaDDot, InertiaTensor))\n\n        if not unitTestSupport.isDoubleEqual(c1, c2, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error torque norm in point {} in trajectory \\n\".format(n))\n\n    if not unitTestSupport.isDoubleEqual(pathCost, testModule.pathCost, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in path cost \\n\")\n\n    # check correctness of output message\n    for n in range(len(timeData)):\n        t = timeData[n]\n        sigma_RN     = [Output.getStates(t,0,0), Output.getStates(t,0,1), Output.getStates(t,0,2)]\n        sigmaDot_RN  = [Output.getStates(t,1,0), Output.getStates(t,1,1), Output.getStates(t,1,2)]\n        sigmaDDot_RN = [Output.getStates(t,2,0), Output.getStates(t,2,1), Output.getStates(t,2,2)]\n        RN = rbk.MRP2C(sigma_RN)\n        omega_RN_R = rbk.dMRP2Omega(sigma_RN, sigmaDot_RN)\n        omega_RN_N = np.matmul(omega_RN_R, RN)\n        omegaDot_RN_R = rbk.ddMRP2dOmega(sigma_RN, sigmaDot_RN, sigmaDDot_RN)\n        omegaDot_RN_N = np.matmul(omegaDot_RN_R, RN)\n\n        if not unitTestSupport.isVectorEqual(sigma_RN, CAMLog.sigma_RN[n], accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in attitude reference message at t = {} sec \\n\".format(t))\n        if not unitTestSupport.isVectorEqual(omega_RN_N, CAMLog.omega_RN_N[n], accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in attitude reference message at t = {} sec \\n\".format(t))\n        if not unitTestSupport.isVectorEqual(omegaDot_RN_N, CAMLog.domega_RN_N[n], accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in attitude reference message at t = {} sec \\n\".format(t))\n\n        if not unitTestSupport.isVectorEqual(sigma_RN, CAMLogC.sigma_RN[n], accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in C attitude reference message at t = {} sec \\n\".format(t))\n        if not unitTestSupport.isVectorEqual(omega_RN_N, CAMLogC.omega_RN_N[n], accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in C attitude reference message at t = {} sec \\n\".format(t))\n        if not unitTestSupport.isVectorEqual(omegaDot_RN_N, CAMLogC.domega_RN_N[n], accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + testModule.ModelTag + \" Error in C attitude reference message at t = {} sec \\n\".format(t)) \n\n\n    return [testFailCount, ''.join(testMessages)]",
  "def __init__(self, axis, color):\n        self.axis =  axis / np.linalg.norm(axis)\n        self.color = color",
  "def __init__(self, sigma_BN, constraints, **kwargs):\n        self.sigma_BN = np.array(sigma_BN)\n        s = np.linalg.norm(self.sigma_BN)\n        if s > 1:\n            self.sigma_BN = shadowSetMap(sigma_BN, True)  # mapping to shadow set if |sigma| > 1\n        if np.abs(s-1) < 1e-5:\n            s = 1.\n        self.isBoundary = False\n        self.s = s\n        if s == 1:\n            self.isBoundary = True\n        self.isFree = True\n        self.color = ''\n        self.neighbors = {}\n        self.heuristic = 0\n        self.priority = 0\n        self.backpointer = self\n        # check cosntraint compliance\n        sigma_tilde = np.array([ [0,           -sigma_BN[2], sigma_BN[1]],\n                                 [sigma_BN[2],      0,      -sigma_BN[0]],\n                                 [-sigma_BN[1], sigma_BN[0],     0      ] ])\n        BN = np.identity(3) + ( 8*np.matmul(sigma_tilde, sigma_tilde) -4*(1-s**2)*sigma_tilde ) / (1 + s**2)**2\n        NB = BN.transpose()\n        # checking for keepOut constraint violation\n        if 'keepOut_b' in kwargs:\n            for i in range(len(kwargs['keepOut_b'])):\n                b_B = np.array(kwargs['keepOut_b'][i])\n                b_N = np.matmul(NB, b_B)\n                for c in constraints['keepOut']:\n                    if np.dot(b_N, c.axis) >= np.cos(kwargs['keepOut_fov'][i]):\n                        self.isFree = False\n                        self.color = c.color\n                        return\n        # checking for keepIn constraint violation (at least one SS must see the Sun)\n        if 'keepIn_b' in kwargs:\n            b_N = []\n            for i in range(len(kwargs['keepIn_b'])):\n                b_B = np.array(kwargs['keepIn_b'][i])\n                b_N.append(np.matmul(NB, b_B))\n            isIn = False\n            for c in constraints['keepIn']:\n                for i in range(len(b_N)):\n                    if np.dot(b_N[i], c.axis) >= np.cos(kwargs['keepIn_fov'][i]):\n                        isIn = True\n                        self.color = c.color\n            if not isIn:\n                self.isFree = False",
  "def test_module(show_plots, case):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = opNavPointTestFunction(show_plots, case)\n    assert testResults < 1, testMessage",
  "def opNavPointTestFunction(show_plots, case):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = mc.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = opNavPoint.opNavPoint()\n    module.ModelTag = \"opNavPoint\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    camera_Z = [0.,0.,1.]\n    module.alignAxis_C = camera_Z\n    module.minUnitMag = 0.01\n    module.smallAngle = 0.01*mc.D2R\n    module.timeOut = 100\n\n    # Create input messages\n    #\n    planet_B = [1.,1.,0.]\n    inputOpNavData = messaging.OpNavMsgPayload()  # Create a structure for the input message\n    inputOpNavData.r_BN_C = planet_B\n    inputOpNavData.valid = 1\n    if (case == 2): #No valid measurement\n        inputOpNavData.valid = 0\n    if (case == 3): #No valid measurement\n        inputOpNavData.r_BN_C = [0.,0.,-1.]\n    if (case == 4): #No valid measurement\n        inputOpNavData.valid = 0\n    opnavInMsg = messaging.OpNavMsg().write(inputOpNavData)\n\n    inputIMUData = messaging.NavAttMsgPayload()  # Create a structure for the input message\n    omega_BN_B = np.array([0.01, 0.50, -0.2])\n    inputIMUData.omega_BN_B = omega_BN_B\n    imuInMsg = messaging.NavAttMsg().write(inputIMUData)\n    omega_RN_B_Search = np.array([0.0, 0.0, 0.1])\n    if (case ==2 or case==4):\n        module.omega_RN_B = omega_RN_B_Search\n\n    cam = messaging.CameraConfigMsgPayload()  # Create a structure for the input message\n    cam.sigma_CB = [0.,0.,0]\n    camInMsg = messaging.CameraConfigMsg().write(cam)\n\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.attGuidanceOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.opnavDataInMsg.subscribeTo(opnavInMsg)\n    module.imuInMsg.subscribeTo(imuInMsg)\n    module.cameraConfigInMsg.subscribeTo(camInMsg)\n\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(mc.sec2nano(1.))  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    #\n    # check sigma_BR\n    #\n    # set the filtered output truth states\n\n    eHat = np.cross(-np.array(planet_B), np.array(camera_Z))\n    eHat = eHat / np.linalg.norm(eHat)\n    Phi = np.arccos(np.dot(-np.array(planet_B)/np.linalg.norm(-np.array(planet_B)),np.array(camera_Z)))\n    sigmaTrue = eHat * np.tan(Phi/4.0)\n    trueVector = [\n                sigmaTrue.tolist(),\n                sigmaTrue.tolist(),\n                sigmaTrue.tolist()\n               ]\n    if (case == 2 or case == 3 or case == 4):\n        trueVector = [\n            [0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0]\n        ]\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.sigma_BR[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_BR unit test at t=\" +\n                                str(dataLog.times()[i] * mc.NANO2SEC) +\n                                \"sec\\n\")\n\n    #\n    # check omega_BR_B\n    #\n    # set the filtered output truth states\n    trueVector = [\n        omega_BN_B.tolist(),\n        omega_BN_B.tolist(),\n        omega_BN_B.tolist()\n    ]\n    if (case == 2 or case==4):\n        trueVector = [\n            (omega_BN_B - omega_RN_B_Search).tolist(),\n            (omega_BN_B - omega_RN_B_Search).tolist(),\n            (omega_BN_B - omega_RN_B_Search).tolist()\n        ]\n    # compare the module results to the truth values\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.omega_BR_B[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_BR_B unit test at t=\" +\n                                str(dataLog.times()[i] * mc.NANO2SEC) +\n                                \"sec\\n\")\n    #\n    # check omega_RN_B\n    #\n    # set the filtered output truth states\n    trueVector = [\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0]\n    ]\n    if (case == 2 or case == 4):\n        trueVector = [\n            omega_RN_B_Search,\n            omega_RN_B_Search,\n            omega_RN_B_Search\n        ]\n    # compare the module results to the truth values\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.omega_RN_B[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_RN_B unit test at t=\" +\n                                str(dataLog.times()[i] * mc.NANO2SEC) +\n                                \"sec\\n\")\n\n    #\n    # check domega_RN_B\n    #\n    # set the filtered output truth states\n    trueVector = [\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0]\n               ]\n\n    # compare the module results to the truth values\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.domega_RN_B[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed domega_RN_B unit test at t=\" +\n                                str(dataLog.times()[i] * mc.NANO2SEC) +\n                                \"sec\\n\")\n\n    #   print out success message if no error were found\n    snippentName = \"passFail\" + str(case)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"FAILED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def computeCelestialTwoBodyPoint(R_P1, v_P1, a_P1, R_P2, v_P2, a_P2):\n\n    # Beforehand computations\n    R_n = np.cross(R_P1, R_P2)\n    v_n = np.cross(v_P1, R_P2) + np.cross(R_P1, v_P2)\n    a_n = np.cross(a_P1, R_P2) + np.cross(R_P1, a_P2) + 2 * np.cross(v_P1, v_P2)\n\n    # Reference Frame generation\n    r1_hat = R_P1/la.norm(R_P1)\n    r3_hat = R_n/la.norm(R_n)\n    r2_hat = np.cross(r3_hat, r1_hat)\n    RN = np.array([r1_hat, r2_hat, r3_hat])\n    sigma_RN = rbk.C2MRP(RN)\n\n    # Reference base-vectors first time-derivative\n    I_33 = np.identity(3)\n    C1 = I_33 - np.outer(r1_hat, r1_hat)\n    dr1_hat = 1.0 / la.norm(R_P1) * np.dot(C1, v_P1)\n    C3 = I_33 - np.outer(r3_hat, r3_hat)\n    dr3_hat = 1.0 / la.norm(R_n) * np.dot(C3, v_n)\n    dr2_hat = np.cross(dr3_hat, r1_hat) + np.cross(r3_hat, dr1_hat)\n\n    # Angular Velocity computation\n    omega_RN_R = np.array([\n        np.dot(r3_hat, dr2_hat),\n        np.dot(r1_hat, dr3_hat),\n        np.dot(r2_hat, dr1_hat)\n    ])\n    omega_RN_N = np.dot(RN.T, omega_RN_R)\n\n    # Reference base-vectors second time-derivative\n    temp33_1 = 2 * np.outer(dr1_hat, r1_hat) + np.outer(r1_hat, dr1_hat)\n    ddr1_hat = 1.0 / la.norm(R_P1) * (np.dot(C1, a_P1) - np.dot(temp33_1, v_P1))\n    temp33_3 = 2 * np.outer(dr3_hat, r3_hat) + np.outer(r3_hat, dr3_hat)\n    ddr3_hat = 1.0 / la.norm(R_n) * (np.dot(C3, a_n) - np.dot(temp33_3, v_n))\n    ddr2_hat = np.cross(ddr3_hat, r1_hat) + np.cross(ddr1_hat, r3_hat) + 2 * np.cross(dr3_hat, dr1_hat)\n\n    # Angular Acceleration computation\n    domega_RN_R = np.array([\n        np.dot(dr3_hat, dr2_hat) + np.dot(r3_hat, ddr2_hat) - np.dot(omega_RN_R, dr1_hat),\n        np.dot(dr1_hat, dr3_hat) + np.dot(r1_hat, ddr3_hat) - np.dot(omega_RN_R, dr2_hat),\n        np.dot(dr2_hat, dr1_hat) + np.dot(r2_hat, ddr1_hat) - np.dot(omega_RN_R, dr3_hat)\n\n    ])\n    domega_RN_N = np.dot(RN.T, domega_RN_R)\n\n    return sigma_RN, omega_RN_N, domega_RN_N",
  "def test_celestialTwoBodyPointTestFunction(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n\n    [testResults, testMessage] = celestialTwoBodyPointTestFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def celestialTwoBodyPointTestFunction(show_plots):\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = celestialTwoBodyPoint.celestialTwoBodyPoint()\n    module.ModelTag = \"celestialTwoBodyPoint\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.singularityThresh = 1.0 * af.D2R\n\n\n    # Previous Computation of Initial Conditions for the test\n    a = af.E_radius * 2.8\n    e = 0.0\n    i = 0.0\n    Omega = 0.0\n    omega = 0.0\n    f = 60 * af.D2R\n    (r, v) = af.OE2RV(af.mu_E, a, e, i, Omega, omega, f)\n    r_BN_N = np.array([0., 0., 0.])\n    v_BN_N = np.array([0., 0., 0.])\n    celPositionVec = r\n    celVelocityVec = v\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    #   Navigation Input Message\n\n    NavStateOutData = messaging.NavTransMsgPayload()  # Create a structure for the input message\n    NavStateOutData.r_BN_N = r_BN_N\n    NavStateOutData.v_BN_N = v_BN_N\n    navMsg = messaging.NavTransMsg().write(NavStateOutData)\n\n    #   Spice Input Message of Primary Body\n\n    CelBodyData = messaging.EphemerisMsgPayload()\n    CelBodyData.r_BdyZero_N = celPositionVec\n    CelBodyData.v_BdyZero_N = celVelocityVec\n    celBodyMsg = messaging.EphemerisMsg().write(CelBodyData)\n\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.transNavInMsg.subscribeTo(navMsg)\n    module.celBodyInMsg.subscribeTo(celBodyMsg)\n\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.))  # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    ## Set truth values\n    a = af.E_radius * 2.8\n    e = 0.0\n    i = 0.0\n    Omega = 0.0\n    omega = 0.0\n    f = 60 * af.D2R\n    (r, v) = af.OE2RV(af.mu_E, a, e, i, Omega, omega, f)\n    r_BN_N = np.array([0., 0., 0.])\n    v_BN_N = np.array([0., 0., 0.])\n    celPositionVec = r\n    celVelocityVec = v\n\n    # Begin Method\n    R_P1 = celPositionVec - r_BN_N\n    v_P1 = celVelocityVec - v_BN_N\n    a_P1 = np.array([0., 0., 0.])\n    R_P2 = np.cross(R_P1, v_P1)\n    v_P2 = np.cross(R_P1, a_P1)\n    a_P2 = np.cross(v_P1, a_P1)\n\n    sigma_RN, omega_RN_N, domega_RN_N = computeCelestialTwoBodyPoint(R_P1, v_P1, a_P1, R_P2, v_P2, a_P2)\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    # check sigma_RN\n    moduleOutput = dataLog.sigma_RN\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    # check a vector values\n    for i in range(0, len(moduleOutput)):\n        if not unitTestSupport.isArrayEqual(moduleOutput[i], sigma_RN, 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_RN unit test at t=\" +\n                                str(moduleOutput[i, 0] * macros.NANO2SEC) +\n                                \"sec\\n\")\n            unitTestSupport.writeTeXSnippet('passFail11', textSnippetFailed, path)\n        else:\n            unitTestSupport.writeTeXSnippet('passFail11', textSnippetPassed, path)\n\n    # check omega_RN_N\n    moduleOutput = dataLog.omega_RN_N\n\n    # compare the module results to the truth values\n    # check a vector values\n    for i in range(0, len(moduleOutput)):\n        if not unitTestSupport.isArrayEqual(moduleOutput[i], omega_RN_N, 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_RN_N unit test at t=\" +\n                                str(moduleOutput[i, 0] * macros.NANO2SEC) +\n                                \"sec\\n\")\n            unitTestSupport.writeTeXSnippet('passFail12', textSnippetFailed, path)\n        else:\n            unitTestSupport.writeTeXSnippet('passFail12', textSnippetPassed, path)\n\n    # check domega_RN_N\n    moduleOutput = dataLog.domega_RN_N\n\n    # compare the module results to the truth values\n    # check a vector values\n    for i in range(0, len(moduleOutput)):\n        if not unitTestSupport.isArrayEqual(moduleOutput[i], domega_RN_N, 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed domega_RN_N unit test at t=\" +\n                                str(moduleOutput[i, 0] * macros.NANO2SEC) +\n                                \"sec\\n\")\n            unitTestSupport.writeTeXSnippet('passFail13', textSnippetFailed, path)\n        else:\n            unitTestSupport.writeTeXSnippet('passFail13', textSnippetPassed, path)\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"celestialTwoBodyPointTestFunction\")\n    else:\n        print(testMessages)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_secBodyCelestialTwoBodyPointTestFunction(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = secBodyCelestialTwoBodyPointTestFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def secBodyCelestialTwoBodyPointTestFunction(show_plots):\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = celestialTwoBodyPoint.celestialTwoBodyPoint()\n    module.ModelTag = \"secBodyCelestialTwoBodyPoint\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.singularityThresh = 1.0 * af.D2R\n\n    # Previous Computation of Initial Conditions for the test\n    a = af.E_radius * 2.8\n    e = 0.0\n    i = 0.0\n    Omega = 0.0\n    omega = 0.0\n    f = 60 * af.D2R\n    (r, v) = af.OE2RV(af.mu_E, a, e, i, Omega, omega, f)\n    r_BN_N = np.array([0., 0., 0.])\n    v_BN_N = np.array([0., 0., 0.])\n    celPositionVec = r\n    celVelocityVec = v\n\n    # Create input message and size it because the regular creator of that message\n\n    # is not part of the test.\n\n    #   Navigation Input Message\n    NavStateOutData = messaging.NavTransMsgPayload()  # Create a structure for the input message\n    NavStateOutData.r_BN_N = r_BN_N\n    NavStateOutData.v_BN_N = v_BN_N\n    navMsg = messaging.NavTransMsg().write(NavStateOutData)\n\n    #   Spice Input Message of Primary Body\n    CelBodyData = messaging.EphemerisMsgPayload()\n    CelBodyData.r_BdyZero_N = celPositionVec\n    CelBodyData.v_BdyZero_N = celVelocityVec\n    celBodyMsg = messaging.EphemerisMsg().write(CelBodyData)\n\n    #   Spice Input Message of Secondary Body\n    SecBodyData = messaging.EphemerisMsgPayload()\n    secPositionVec = [500., 500., 500.]\n    SecBodyData.r_BdyZero_N = secPositionVec\n    secVelocityVec = [0., 0., 0.]\n    SecBodyData.v_BdyZero_N = secVelocityVec\n    cel2ndBodyMsg = messaging.EphemerisMsg().write(SecBodyData)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.transNavInMsg.subscribeTo(navMsg)\n    module.celBodyInMsg.subscribeTo(celBodyMsg)\n    module.secCelBodyInMsg.subscribeTo(cel2ndBodyMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.))  # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    # check sigma_RN\n    moduleOutput = dataLog.sigma_RN\n\n    # set the filtered output truth states\n    trueVector = [0.474475084038,  0.273938317493,  0.191443718765]\n\n    # compare the module results to the truth values\n    accuracy = 1e-10\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    for i in range(0, len(moduleOutput)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleOutput[i], trueVector, 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_RN unit test at t=\" +\n                                str(dataLog.times()[i] * macros.NANO2SEC) +\n                                \"sec\\n\")\n            unitTestSupport.writeTeXSnippet('passFail21', textSnippetFailed, path)\n        else:\n            unitTestSupport.writeTeXSnippet('passFail21', textSnippetPassed, path)\n\n    # check omega_RN_N\n    moduleOutput = dataLog.omega_RN_N\n\n    # set the filtered output truth states\n    trueVector = [1.59336987e-04,   2.75979758e-04,   2.64539877e-04]\n    # compare the module results to the truth values\n    for i in range(0, len(moduleOutput)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleOutput[i], trueVector, 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_RN_N unit test at t=\" +\n                                str(dataLog.times()[i] * macros.NANO2SEC) +\n                                \"sec\\n\")\n            unitTestSupport.writeTeXSnippet('passFail22', textSnippetFailed, path)\n        else:\n            unitTestSupport.writeTeXSnippet('passFail22', textSnippetPassed, path)\n\n    # check domega_RN_N\n    moduleOutput = dataLog.domega_RN_N\n\n    # set the filtered output truth states\n    trueVector = [-2.12284893e-07,   5.69968291e-08,  -4.83648052e-08]\n\n    # compare the module results to the truth values\n    for i in range(0, len(moduleOutput)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleOutput[i], trueVector, 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed domega_RN_N unit test at t=\" +\n                                str(dataLog.times()[i] * macros.NANO2SEC) +\n                                \"sec\\n\")\n            unitTestSupport.writeTeXSnippet('passFail23', textSnippetFailed, path)\n        else:\n            unitTestSupport.writeTeXSnippet('passFail23', textSnippetPassed, path)\n\n    # Note that we can continue to step the simulation however we feel like.\n    # Just because we stop and query data does not mean everything has to stop for good\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.6))  # run an additional 0.6 seconds\n    unitTestSim.ExecuteSimulation()\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"secBodyCelestialTwoBodyPointTestFunction\")\n    else:\n        print(testMessages)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, case):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = sunSafePointTestFunction(show_plots, case)\n    assert testResults < 1, testMessage",
  "def sunSafePointTestFunction(show_plots, case):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = mc.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = sunSafePoint.sunSafePoint()\n    module.ModelTag = \"sunSafePoint\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    sHat_Cmd_B = np.array([0.0, 0.0 ,1.0])\n    if case == 5:\n        sHat_Cmd_B = np.array([1.0, 0.0, 0.0])\n    module.sHatBdyCmd = sHat_Cmd_B\n    module.minUnitMag = 0.1\n    if case == 2:\n        omega_RN_B_Search = np.array([0.0, 0.0, 0.1])\n        module.omega_RN_B = omega_RN_B_Search\n    module.smallAngle = 0.01*mc.D2R\n\n    # Create input messages\n    #\n    inputSunVecData = messaging.NavAttMsgPayload()  # Create a structure for the input message\n    sunVec_B = np.array([1.0, 1.0, 0.0])\n    if (case == 2 or case == 6): # no sun visible, providing a near zero norm direction vector */\n        sunVec_B = [0.0, module.minUnitMag/2, 0.0]\n    if (case == 3):\n        sunVec_B = sHat_Cmd_B\n    if (case == 4 or case == 5):\n        sunVec_B = -sHat_Cmd_B\n    inputSunVecData.vehSunPntBdy = sunVec_B\n    sunInMsg = messaging.NavAttMsg().write(inputSunVecData)\n\n    inputIMUData = messaging.NavAttMsgPayload()  # Create a structure for the input message\n    omega_BN_B = np.array([0.01, 0.50, -0.2])\n    inputIMUData.omega_BN_B = omega_BN_B\n    imuInMsg = messaging.NavAttMsg().write(inputIMUData)\n\n    if case == 7:\n        module.sunAxisSpinRate = 1.5*mc.D2R\n        omega_RN_B_Search = sunVec_B/np.linalg.norm(sunVec_B) * module.sunAxisSpinRate\n\n\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.attGuidanceOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.sunDirectionInMsg.subscribeTo(sunInMsg)\n    module.imuInMsg.subscribeTo(imuInMsg)\n\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(mc.sec2nano(1.))  # seconds to stop simulation\n\n    # run the Reset() routine\n    module.Reset(0)     # this module reset function needs a time input (in NanoSeconds)\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    #\n    # check sigma_BR\n    #\n    # set the filtered output truth states\n    if (case == 1 or case == 7):\n        eHat = np.cross(sunVec_B,sHat_Cmd_B)\n        eHat = eHat / np.linalg.norm(eHat)\n        Phi = np.arccos(np.dot(sunVec_B/np.linalg.norm(sunVec_B),sHat_Cmd_B))\n        sigmaTrue = eHat * np.tan(Phi/4.0)\n        trueVector = [\n                    sigmaTrue.tolist(),\n                    sigmaTrue.tolist(),\n                    sigmaTrue.tolist()\n                   ]\n    if (case == 2 or case == 3 or case == 6):\n        trueVector = [\n            [0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0]\n        ]\n    if (case == 4):\n        eHat = np.cross(sHat_Cmd_B,np.array([1,0,0]))\n        eHat = eHat / np.linalg.norm(eHat)\n        Phi = np.arccos(np.dot(sunVec_B/np.linalg.norm(sunVec_B),sHat_Cmd_B))\n        sigmaTrue = eHat * np.tan(Phi/4.0)\n        trueVector = [\n                    sigmaTrue.tolist(),\n                    sigmaTrue.tolist(),\n                    sigmaTrue.tolist()\n               ]\n    if (case == 5):\n        eHat = np.cross(sHat_Cmd_B, np.array([0, 1, 0]))\n        eHat = eHat / np.linalg.norm(eHat)\n        Phi = np.arccos(np.dot(sunVec_B/np.linalg.norm(sunVec_B), sHat_Cmd_B))\n        sigmaTrue = eHat * np.tan(Phi / 4.0)\n        trueVector = [\n            sigmaTrue.tolist(),\n            sigmaTrue.tolist(),\n            sigmaTrue.tolist()\n        ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.sigma_BR[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_BR unit test at t=\" +\n                                str(dataLog.times()[i] * mc.NANO2SEC) +\n                                \"sec\\n\")\n\n    #\n    # check omega_BR_B\n    #\n    # set the filtered output truth states\n    if (case == 1 or case == 3 or case == 4 or case == 5 or case == 6):\n        trueVector = [\n            omega_BN_B.tolist(),\n            omega_BN_B.tolist(),\n            omega_BN_B.tolist()\n        ]\n    if (case == 2 or case == 7):\n        trueVector = [\n            (omega_BN_B - omega_RN_B_Search).tolist(),\n            (omega_BN_B - omega_RN_B_Search).tolist(),\n            (omega_BN_B - omega_RN_B_Search).tolist()\n        ]\n    # compare the module results to the truth values\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.omega_BR_B[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_BR_B unit test at t=\" +\n                                str(dataLog.times()[i] * mc.NANO2SEC) +\n                                \"sec\\n\")\n\n\n    #\n    # check omega_RN_B\n    #\n    # set the filtered output truth states\n    if (case == 1 or case == 3 or case == 4 or case == 5 or case == 6):\n        trueVector = [\n            [0.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0]\n        ]\n    if (case == 2 or case == 7):\n        trueVector = [\n            omega_RN_B_Search,\n            omega_RN_B_Search,\n            omega_RN_B_Search\n        ]\n    # compare the module results to the truth values\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.omega_RN_B[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_RN_B unit test at t=\" +\n                                str(dataLog.times()[i] * mc.NANO2SEC) +\n                                \"sec\\n\")\n\n    #\n    # check domega_RN_B\n    #\n    # set the filtered output truth states\n    trueVector = [\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0]\n               ]\n\n    # compare the module results to the truth values\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.domega_RN_B[i],trueVector[i],3,accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed domega_RN_B unit test at t=\" +\n                                str(dataLog.times()[i] * mc.NANO2SEC) +\n                                \"sec\\n\")\n\n    #   print out success message if no error were found\n    snippentName = \"passFail\" + str(case)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"FAILED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n        print(testMessages)\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_mrpRotation(show_plots, cmdStateFlag, testReset):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = run(show_plots, cmdStateFlag, testReset)\n    assert testResults < 1, testMessage",
  "def run(show_plots, cmdStateFlag, testReset):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Test times\n    updateTime = 0.5     # update process rate update time\n    totalTestSimTime = 1.5\n\n    # Create test thread\n    testProcessRate = mc.sec2nano(updateTime)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = mrpRotation.mrpRotation()\n    module.ModelTag = \"mrpRotation\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    sigma_RR0 = np.array([0.3, .5, 0.0])\n    module.mrpSet = sigma_RR0\n    omega_RR0_R = np.array([0.1, 0.0, 0.0]) * mc.D2R\n    module.omega_RR0_R = omega_RR0_R\n    unitTestSupport.writeTeXSnippet(\"sigma_RR0\", str(sigma_RR0), path)\n    unitTestSupport.writeTeXSnippet(\"omega_RR0_R\", str(omega_RR0_R*mc.R2D) + \"deg/sec\", path)\n\n\n    if cmdStateFlag:\n        desiredAtt = messaging.AttStateMsgPayload()\n        sigma_RR0 = np.array([0.1, 0.0, -0.2])\n        desiredAtt.state = sigma_RR0\n        omega_RR0_R = np.array([0.1, 1.0, 0.5]) * mc.D2R\n        desiredAtt.rate = omega_RR0_R\n        desInMsg = messaging.AttStateMsg().write(desiredAtt)\n        module.desiredAttInMsg.subscribeTo(desInMsg)\n\n        unitTestSupport.writeTeXSnippet(\"sigma_RR0Cmd\", str(sigma_RR0), path)\n        unitTestSupport.writeTeXSnippet(\"omega_RR0_RCmd\", str(omega_RR0_R * mc.R2D) + \"deg/sec\", path)\n\n\n    #\n    # Reference Frame Message\n    #\n    RefStateInData = messaging.AttRefMsgPayload()  # Create a structure for the input message\n    sigma_R0N = np.array([0.1, 0.2, 0.3])\n    RefStateInData.sigma_RN = sigma_R0N\n    omega_R0N_N = np.array([0.1, 0.0, 0.0])\n    RefStateInData.omega_RN_N = omega_R0N_N\n    domega_R0N_N = np.array([0.0, 0.0, 0.0])\n    RefStateInData.domega_RN_N = domega_R0N_N\n    attRefMsg = messaging.AttRefMsg().write(RefStateInData)\n    module.attRefInMsg.subscribeTo(attRefMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(mc.sec2nano(totalTestSimTime))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    if testReset:\n        module.Reset(1)\n        unitTestSim.ConfigureStopTime(mc.sec2nano(totalTestSimTime+1.0))        # seconds to stop simulation\n        unitTestSim.ExecuteSimulation()\n\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    accuracy = 1e-12\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n    trueSigma, trueOmega, truedOmega, \\\n        = truth.results(sigma_RR0,omega_RR0_R,RefStateInData,updateTime, cmdStateFlag, testReset)\n\n    #\n    # check sigma_RN\n    #\n    testFailCount, testMessages = unitTestSupport.compareArray(trueSigma, dataLog.sigma_RN,\n                                                               accuracy, \"sigma_RN Set\",\n                                                               testFailCount, testMessages)\n    #\n    # check omega_RN_N\n    #\n    testFailCount, testMessages = unitTestSupport.compareArray(trueOmega, dataLog.omega_RN_N,\n                                                               accuracy, \"omega_RN_N Vector\",\n                                                               testFailCount, testMessages)\n\n    #\n    # check domega_RN_N\n    #\n    testFailCount, testMessages = unitTestSupport.compareArray(truedOmega, dataLog.domega_RN_N,\n                                                               accuracy, \"domega_RN_N Vector\",\n                                                               testFailCount, testMessages)\n\n\n    snippentName = \"passFail\" + str(cmdStateFlag) + str(testReset)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def results(sigma_RR0, omega_RR0_R, RefStateInData, dt, cmdStateFlag, testReset):\n\n    ansSigma = []\n    ansOmega_RN_N = []\n    ansdOmega_RN_N = []\n\n    sigma_R0N = RefStateInData.sigma_RN\n    R0N = rbk.MRP2C(sigma_R0N)\n    omega_R0N_N = RefStateInData.omega_RN_N\n    domega_R0N_N = RefStateInData.domega_RN_N\n\n    # compute 0th time step\n    s0 = np.array(sigma_RR0)\n    s1=rbk.addMRP(np.array(sigma_R0N), np.array(sigma_RR0))\n    RR0 = rbk.MRP2C(sigma_RR0)\n    RN = np.dot(RR0, R0N)\n\n    omega_RR0_N = np.dot(RN.T, omega_RR0_R)\n    omega_RN_N = omega_RR0_N + omega_R0N_N\n\n    domega_RR0_N = np.cross(omega_R0N_N, omega_RR0_N)\n    domega_RN_N = domega_RR0_N + domega_R0N_N\n\n    ansSigma.append(s1.tolist())\n    ansOmega_RN_N.append(omega_RN_N.tolist())\n    ansdOmega_RN_N.append(domega_RN_N.tolist())\n    ansSigma.append(s1.tolist())\n    ansOmega_RN_N.append(omega_RN_N.tolist())\n    ansdOmega_RN_N.append(domega_RN_N.tolist())\n\n    # compute 1st time step\n    B =  rbk.BmatMRP(sigma_RR0)\n    sigma_RR0 += dt * 0.25 * np.dot(B, omega_RR0_R)\n    RR0 = rbk.MRP2C(sigma_RR0)\n    RN = np.dot(RR0, R0N)\n    sigma_RN = rbk.C2MRP(RN)\n    ansSigma.append(sigma_RN.tolist())\n\n    omega_RR0_N = np.dot(RN.T, omega_RR0_R)\n    omega_RN_N = omega_RR0_N + omega_R0N_N\n    ansOmega_RN_N.append(omega_RN_N.tolist())\n\n    domega_RR0_N = np.cross(omega_R0N_N, omega_RR0_N)\n    domega_RN_N = domega_RR0_N + domega_R0N_N\n    ansdOmega_RN_N.append(domega_RN_N.tolist())\n\n\n    # compute 2nd time step\n    B =  rbk.BmatMRP(sigma_RR0)\n    sigma_RR0 += dt * 0.25 * np.dot(B, omega_RR0_R)\n    RR0 = rbk.MRP2C(sigma_RR0)\n    RN = np.dot(RR0, R0N)\n    sigma_RN = rbk.C2MRP(RN)\n    ansSigma.append(sigma_RN.tolist())\n\n    omega_RR0_N = np.dot(RN.T, omega_RR0_R)\n    omega_RN_N = omega_RR0_N + omega_R0N_N\n    ansOmega_RN_N.append(omega_RN_N.tolist())\n\n    domega_RR0_N = np.cross(omega_R0N_N, omega_RR0_N)\n    domega_RN_N = domega_RR0_N + domega_R0N_N\n    ansdOmega_RN_N.append(domega_RN_N.tolist())\n\n\n    # Testing Reset function\n    if testReset:\n        if cmdStateFlag:\n            sigma_RR0 = s0\n        # compute 0th time step\n        s1 = rbk.addMRP(np.array(sigma_R0N), np.array(sigma_RR0))\n        RR0 = rbk.MRP2C(sigma_RR0)\n        RN = np.dot(RR0, R0N)\n\n        omega_RR0_N = np.dot(RN.T, omega_RR0_R)\n        omega_RN_N = omega_RR0_N + omega_R0N_N\n\n        domega_RR0_N = np.cross(omega_R0N_N, omega_RR0_N)\n        domega_RN_N = domega_RR0_N + domega_R0N_N\n\n        ansSigma.append(s1.tolist())\n        ansOmega_RN_N.append(omega_RN_N.tolist())\n        ansdOmega_RN_N.append(domega_RN_N.tolist())\n\n        # compute 1st time step\n        B = rbk.BmatMRP(sigma_RR0)\n        sigma_RR0 += dt * 0.25 * np.dot(B, omega_RR0_R)\n        RR0 = rbk.MRP2C(sigma_RR0)\n        RN = np.dot(RR0, R0N)\n        sigma_RN = rbk.C2MRP(RN)\n        ansSigma.append(sigma_RN.tolist())\n\n        omega_RR0_N = np.dot(RN.T, omega_RR0_R)\n        omega_RN_N = omega_RR0_N + omega_R0N_N\n        ansOmega_RN_N.append(omega_RN_N.tolist())\n\n        domega_RR0_N = np.cross(omega_R0N_N, omega_RR0_N)\n        domega_RN_N = domega_RR0_N + domega_R0N_N\n        ansdOmega_RN_N.append(domega_RN_N.tolist())\n\n\n    return ansSigma, ansOmega_RN_N, ansdOmega_RN_N",
  "def test_velocityPoint(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = velocityPointTestFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def velocityPointTestFunction(show_plots):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = velocityPoint.velocityPoint()\n    module.ModelTag = \"velocityPoint\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.mu = af.mu_E\n\n    a = af.E_radius * 2.8\n    e = 0.0\n    i = 0.0\n    Omega = 0.0\n    omega = 0.0\n    f = 60 * af.D2R\n    (r, v) = af.OE2RV(af.mu_E, a, e, i, Omega, omega, f)\n    r_BN_N = r\n    v_BN_N = v\n    planetPos = np.array([0.0, 0.0, 0.0])\n    planetVel = np.array([0.0, 0.0, 0.0])\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    #\n    #   Navigation Input Message\n    #\n    NavStateOutData = messaging.NavTransMsgPayload()  # Create a structure for the input message\n    NavStateOutData.r_BN_N = r_BN_N\n    NavStateOutData.v_BN_N = v_BN_N\n    navInMsg = messaging.NavTransMsg().write(NavStateOutData)\n\n    #\n    #   Spice Input Message\n    #\n    CelBodyData = messaging.EphemerisMsgPayload()\n    CelBodyData.r_BdyZero_N = planetPos\n    CelBodyData.v_BdyZero_N = planetVel\n    celBodyInMsg = messaging.EphemerisMsg().write(CelBodyData)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect Messages\n    module.transNavInMsg.subscribeTo(navInMsg)\n    module.celBodyInMsg.subscribeTo(celBodyInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    #\n    # check sigma_RN\n    #\n    # set the filtered output truth states\n    trueVector = [\n               [0.,              0.,              0.267949192431],\n               [0.,              0.,              0.267949192431],\n               [0.,              0.,              0.267949192431]\n               ]\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, dataLog.sigma_RN, accuracy,\n                                                               'sigma_RN', testFailCount, testMessages)\n\n    #\n    # check omega_RN_N\n    #\n    # set the filtered output truth states\n    trueVector = [\n               [0.,              0.,              0.000264539877],\n               [0.,              0.,              0.000264539877],\n               [0.,              0.,              0.000264539877]\n               ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, dataLog.omega_RN_N, accuracy,\n                                                               'omega_RN_N', testFailCount, testMessages)\n\n    #\n    # check domega_RN_N\n    #\n    # set the filtered output truth states\n    trueVector = [\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0]\n               ]\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, dataLog.domega_RN_N, accuracy,\n                                                               'domega_RN_N', testFailCount, testMessages)\n\n    # Note that we can continue to step the simulation however we feel like.\n    # Just because we stop and query data does not mean everything has to stop for good\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.6))    # run an additional 0.6 seconds\n    unitTestSim.ExecuteSimulation()\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Passed\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def normalize(v):\n    norm=np.linalg.norm(v)\n    if norm==0:\n       return v\n    return v/norm",
  "def printResults_VelocityPoint(r_BN_N, v_BN_N, celBodyPosVec, celBodyVelVec, mu):\n    r = r_BN_N - celBodyPosVec\n    v = v_BN_N - celBodyVelVec\n\n    h = np.cross(r, v)\n    i_r = af.normalize(r)\n    i_v = normalize(v)\n    i_h = normalize(h)\n    i_n = np.cross(i_v, i_h)\n    VN = np.array([ i_n, i_v, i_h ])\n    sigma_VN = rbk.C2MRP(VN)\n\n    hm = la.norm(h)\n    rm = la.norm(r)\n    drdt = np.dot(v, i_r)\n    dfdt = hm / (rm * rm)\n    ddfdt2 = -2.0 * drdt / rm * dfdt\n\n    (a, e, i, Omega, omega, f) = af.RV2OE(mu, r, v)\n    den = 1 + e * e + 2 * e * cos(f)\n    temp = e * (e + cos(f)) / den\n    dBdt = temp * dfdt\n    ddBdt2 = temp * ddfdt2 + (e * (e * e - 1) * sin(f)) / (den * den) * dfdt * dfdt\n\n    omega_VN_N = (-dBdt + dfdt) * i_h\n    domega_VN_N = (-ddBdt2 + ddfdt2) * i_h\n\n    print('sigma_VN = ', sigma_VN)\n    print('omega_VN_N = ', omega_VN_N)\n    print('domega_VN_N = ', domega_VN_N)\n\n    return (sigma_VN, omega_VN_N, domega_VN_N)",
  "def test_attRefCorrection(show_plots, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    Checks the output of the module that the correct orientation adjustment is applied\n\n    **Test Parameters**\n\n    Args:\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    The ``sigma_RN`` variable of the output message is tested\n    \"\"\"\n    [testResults, testMessage] = attRefCorrectionTestFunction(show_plots, accuracy)\n    assert testResults < 1, testMessage",
  "def attRefCorrectionTestFunction(show_plots, accuracy):\n    \"\"\"Test method\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(0.5)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    module = attRefCorrection.attRefCorrection()\n    module.ModelTag = \"attRefCorrectionTag\"\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    module.sigma_BcB = [math.tan(math.pi/4), 0.0, 0.0]\n\n    # Configure blank module input messages\n    attRefInMsgData = messaging.AttRefMsgPayload()\n    attRefInMsgData.sigma_RN = [math.tan(math.pi/8), 0.0, 0.0]\n    attRefInMsg = messaging.AttRefMsg().write(attRefInMsgData)\n\n    # subscribe input messages to module\n    module.attRefInMsg.subscribeTo(attRefInMsg)\n\n    # setup output message recorder objects\n    attRefOutMsgRec = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, attRefOutMsgRec)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))\n    unitTestSim.ExecuteSimulation()\n\n    # pull module data and make sure it is correct\n    trueVector = [\n        [-math.tan(math.pi / 8), 0.0, 0.0],\n        [-math.tan(math.pi / 8), 0.0, 0.0],\n        [-math.tan(math.pi / 8), 0.0, 0.0]\n    ]\n    # compare the module results to the truth values\n    for i in range(0, len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(attRefOutMsgRec.sigma_RN[i], trueVector[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_RN unit test at t=\" +\n                                str(attRefOutMsgRec.times()[i] * macros.NANO2SEC) +\n                                \"sec\\n\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, \"\".join(testMessages)]",
  "def test_all_test_eulerRotation(show_plots, function):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = eval(function + '(show_plots)')\n    assert testResults < 1, testMessage",
  "def run(show_plots):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Test times\n    updateTime = 0.5     # update process rate update time\n    totalTestSimTime = 1.5\n\n    # Create test thread\n    testProcessRate = mc.sec2nano(updateTime)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = eulerRotation.eulerRotation()\n    module.ModelTag = \"eulerRotation\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    angleSet = np.array([0.0, 90.0, 0.0]) * mc.D2R\n    module.angleSet = angleSet\n    angleRates = np.array([0.1, 0.0, 0.0]) * mc.D2R\n    module.angleRates = angleRates\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n\n    #\n    # Reference Frame Message\n    #\n    RefStateOutData = messaging.AttRefMsgPayload()  # Create a structure for the input message\n    sigma_R0N = np.array([0.1, 0.2, 0.3])\n    RefStateOutData.sigma_RN = sigma_R0N\n    omega_R0N_N = np.array([0.1, 0.0, 0.0])\n    RefStateOutData.omega_RN_N = omega_R0N_N\n    domega_R0N_N = np.array([0.0, 0.0, 0.0])\n    RefStateOutData.domega_RN_N = domega_R0N_N\n    attRefInMsg = messaging.AttRefMsg().write(RefStateOutData)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.attRefInMsg.subscribeTo(attRefInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(mc.sec2nano(totalTestSimTime))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    accuracy = 1e-12\n    #\n    # check sigma_RN\n    #\n    moduleOutput = dataLog.sigma_RN\n\n    # set the filtered output truth states\n    trueVector = [\n        [-0.193031238249, 0.608048400483, 0.386062476497],\n        [-0.193031238249, 0.608048400483, 0.386062476497],\n        [-0.193144351314,  0.607931107381,  0.386360300559],\n        [-0.193257454832,  0.607813704445,  0.386658117585]\n    ]\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput,\n                                                               accuracy, \"sigma_RN Set\",\n                                                               testFailCount, testMessages)\n    # print '\\n sigma_RN = ', moduleOutput[:, 1:], '\\n'\n    #\n    # check omega_RN_N\n    #\n    moduleOutput = dataLog.omega_RN_N\n    # set the filtered output truth states\n    trueVector = [\n        [0.101246280045,  0.000182644489,  0.001208139578],\n        [0.101246280045,  0.000182644489,  0.001208139578],\n        [0.101246280045,  0.000182644489,  0.001208139578],\n        [0.101246280045,  0.000182644489,  0.001208139578]\n    ]\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput,\n                                                               accuracy, \"omega_RN_N Vector\",\n                                                               testFailCount, testMessages)\n\n    #\n    # check domega_RN_N\n    #\n    moduleOutput = dataLog.domega_RN_N\n    # set the filtered output truth states\n    trueVector = [\n        [0.000000000000e+00,  -1.208139577635e-04,   1.826444892823e-05],\n        [0.000000000000e+00,  -1.208139577635e-04,   1.826444892823e-05],\n        [0.000000000000e+00,  -1.208139577635e-04,   1.826444892823e-05],\n        [0.000000000000e+00,  -1.208139577635e-04,   1.826444892823e-05]\n    ]\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput,\n                                                               accuracy, \"domega_RN_N Vector\",\n                                                               testFailCount, testMessages)\n\n\n    # If the argument provided at commandline \"--show_plots\" evaluates as true,\n    # plot all figures\n#    if show_plots:\n#        # plot a sample variable.\n#        plt.figure(1)\n#        plt.plot(variableState[:,0]*macros.NANO2SEC, variableState[:,1], label='Sample Variable')\n#        plt.legend(loc='upper left')\n#        plt.xlabel('Time [s]')\n#        plt.ylabel('Variable Description [unit]')\n#        plt.show()\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def run2(show_plots):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Test times\n    updateTime = 0.5  # update process rate update time\n    totalTestSimTime = 1.5\n\n    # Create test thread\n    testProcessRate = mc.sec2nano(updateTime)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = eulerRotation.eulerRotation()\n    module.ModelTag = \"eulerRotation\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    angleSet = np.array([0.0, 90.0, 0.0]) * mc.D2R\n    module.angleSet = angleSet\n    angleRates = np.array([0.1, 0.0, 0.0]) * mc.D2R\n    module.angleRates = angleRates\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n\n    #\n    # Reference Frame Message\n    #\n    RefStateOutData = messaging.AttRefMsgPayload()  # Create a structure for the input message\n    sigma_R0N = np.array([0.1, 0.2, 0.3])\n    RefStateOutData.sigma_RN = sigma_R0N\n    omega_R0N_N = np.array([0.1, 0.0, 0.0])\n    RefStateOutData.omega_RN_N = omega_R0N_N\n    domega_R0N_N = np.array([0.0, 0.0, 0.0])\n    RefStateOutData.domega_RN_N = domega_R0N_N\n    attRefMsg = messaging.AttRefMsg().write(RefStateOutData)\n\n    # Set the desired state and rate to 0.\n    desiredAtt = messaging.AttStateMsgPayload()\n    desiredState = np.array([0, 0, 0])\n    desiredAtt.state = desiredState\n    desiredRate = np.array([0, 0, 0])\n    desiredAtt.rate = desiredRate\n    desInMsg = messaging.AttStateMsg().write(desiredAtt)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.attRefInMsg.subscribeTo(attRefMsg)\n    module.desiredAttInMsg.subscribeTo(desInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(mc.sec2nano(totalTestSimTime))  # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    accuracy = 1e-12\n    #\n    # check sigma_RN\n    #\n    moduleOutput = dataLog.sigma_RN\n    # set the filtered output truth states\n    trueVector = [\n        [-0.193031238249, 0.608048400483, 0.386062476497],\n        [-0.193031238249, 0.608048400483, 0.386062476497],\n        [-0.193144351314, 0.607931107381, 0.386360300559],\n        [-0.193257454832, 0.607813704445, 0.386658117585]\n    ]\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput,\n                                                               accuracy, \"sigma_RN Set\",\n                                                               testFailCount, testMessages)\n    # print '\\n sigma_RN = ', moduleOutput[:, 1:], '\\n'\n    #\n    # check omega_RN_N\n    #\n    moduleOutput = dataLog.omega_RN_N\n    # set the filtered output truth states\n    trueVector = [\n        [0.101246280045, 0.000182644489, 0.001208139578],\n        [0.101246280045, 0.000182644489, 0.001208139578],\n        [0.101246280045, 0.000182644489, 0.001208139578],\n        [0.101246280045, 0.000182644489, 0.001208139578]\n    ]\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput,\n                                                               accuracy, \"omega_RN_N Vector\",\n                                                               testFailCount, testMessages)\n\n    #\n    # check domega_RN_N\n    #\n    moduleOutput = dataLog.domega_RN_N\n    # set the filtered output truth states\n    trueVector = [\n        [0.000000000000e+00, -1.208139577635e-04, 1.826444892823e-05],\n        [0.000000000000e+00, -1.208139577635e-04, 1.826444892823e-05],\n        [0.000000000000e+00, -1.208139577635e-04, 1.826444892823e-05],\n        [0.000000000000e+00, -1.208139577635e-04, 1.826444892823e-05]\n    ]\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput,\n                                                               accuracy, \"domega_RN_N Vector\",\n                                                               testFailCount, testMessages)\n\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def printResults_eulerRotation(configData, sigma_R0N, omega_R0N_N, domega_R0N_N, callTime):\n    def computeEuler321_Binv_derivative(angleSet, angleRates):\n        theta = angleSet[1]\n        phi = angleSet[2]\n        thetaDot = angleRates[1]\n        phiDot = angleRates[2]\n        B_inv_deriv = [\n            [-thetaDot*cos(theta), 0, 0],\n            [phiDot*cos(phi)*cos(theta)-thetaDot*sin(phi)*sin(theta), -phiDot*sin(phi), 0],\n            [-phiDot*sin(phi)*cos(theta)-thetaDot*cos(phi)*cos(theta), -phiDot*cos(phi), 0]\n        ]\n        return B_inv_deriv\n\n    angleSet = configData[0]\n    angleRates = configData[1]\n    dt = configData[2]\n\n    # Compute attitude set\n    R0N = rbk.MRP2C(sigma_R0N)\n    angleSet += dt * angleRates\n    RR0 = rbk.euler3212C(angleSet)\n    RN = np.dot(RR0, R0N)\n    sigma_RN = rbk.C2MRP(RN)\n\n    # Compute angular velocity\n    B_inv = rbk.BinvEuler321(angleSet)\n    omega_RR0_R = np.dot(B_inv, angleRates)\n    omega_RR0_N = np.dot(RN.T, omega_RR0_R)\n    omega_RN_N = omega_RR0_N + omega_R0N_N\n\n    # Compute angular acceleration\n    B_inv_deriv = computeEuler321_Binv_derivative(angleSet, angleRates)\n    domega_RR0_R = np.dot(B_inv_deriv, angleRates)\n    domega_RR0_N = np.dot(RN.T, domega_RR0_R) + np.cross(omega_R0N_N, omega_RR0_N)\n    domega_RN_N = domega_RR0_N + domega_R0N_N\n\n    # Print results\n    def printData():\n        print('callTime = ', callTime)\n        print('eulerAngleSet = ', angleSet)\n        print('B_inv_deriv = ', B_inv_deriv)\n        print('sigma_RN = ', sigma_RN)\n        print('omega_RN_N = ', omega_RN_N)\n        print('domega_RN_N = ', domega_RN_N)\n        print('\\n')\n    printData()\n    return angleSet",
  "def computeEuler321_Binv_derivative(angleSet, angleRates):\n        theta = angleSet[1]\n        phi = angleSet[2]\n        thetaDot = angleRates[1]\n        phiDot = angleRates[2]\n        B_inv_deriv = [\n            [-thetaDot*cos(theta), 0, 0],\n            [phiDot*cos(phi)*cos(theta)-thetaDot*sin(phi)*sin(theta), -phiDot*sin(phi), 0],\n            [-phiDot*sin(phi)*cos(theta)-thetaDot*cos(phi)*cos(theta), -phiDot*cos(phi), 0]\n        ]\n        return B_inv_deriv",
  "def printData():\n        print('callTime = ', callTime)\n        print('eulerAngleSet = ', angleSet)\n        print('B_inv_deriv = ', B_inv_deriv)\n        print('sigma_RN = ', sigma_RN)\n        print('omega_RN_N = ', omega_RN_N)\n        print('domega_RN_N = ', domega_RN_N)\n        print('\\n')",
  "def test_attTrackingError(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = subModuleTestFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def subModuleTestFunction(show_plots):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = attTrackingError.attTrackingError()\n    module.ModelTag = \"attTrackingError\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    vector = [0.01, 0.05, -0.55]\n    module.sigma_R0R = vector\n\n    #\n    # Navigation Message\n    #\n    NavStateOutData = messaging.NavAttMsgPayload()  # Create a structure for the input message\n    sigma_BN = [0.25, -0.45, 0.75]\n    NavStateOutData.sigma_BN = sigma_BN\n    omega_BN_B = [-0.015, -0.012, 0.005]\n    NavStateOutData.omega_BN_B = omega_BN_B\n    navStateInMsg = messaging.NavAttMsg().write(NavStateOutData)\n\n    #\n    # Reference Frame Message\n    #\n    RefStateOutData = messaging.AttRefMsgPayload()  # Create a structure for the input message\n    sigma_RN = [0.35, -0.25, 0.15]\n    RefStateOutData.sigma_RN = sigma_RN\n    omega_RN_N = [0.018, -0.032, 0.015]\n    RefStateOutData.omega_RN_N = omega_RN_N\n    domega_RN_N = [0.048, -0.022, 0.025]\n    RefStateOutData.domega_RN_N = domega_RN_N\n    refInMsg = messaging.AttRefMsg().write(RefStateOutData)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.attGuidOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.attNavInMsg.subscribeTo(navStateInMsg)\n    module.attRefInMsg.subscribeTo(refInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.3))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    #\n    # check sigma_BR\n    #\n    moduleOutput = dataLog.sigma_BR[0]\n\n    sigma_RN2 = rbk.addMRP(np.array(sigma_RN), -np.array(vector))\n    RN = rbk.MRP2C(sigma_RN2)\n    BN = rbk.MRP2C(np.array(sigma_BN))\n    BR = np.dot(BN, RN.T)\n    # set the filtered output truth states\n    trueVector = rbk.C2MRP(BR)\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    if not unitTestSupport.isArrayEqual(moduleOutput, trueVector, 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_BR unit test\\n\")\n        unitTestSupport.writeTeXSnippet(\"passFail_sigBR\", \"FAILED\", path)\n    else:\n        unitTestSupport.writeTeXSnippet(\"passFail_sigBR\", \"PASSED\", path)\n\n    #\n    # check omega_BR_B\n    #\n    moduleOutput = dataLog.omega_BR_B[0]\n\n    # set the filtered output truth states\n    trueVector = np.array(omega_BN_B) - np.dot(BN, np.array(omega_RN_N))\n\n    # compare the module results to the truth values\n    if not unitTestSupport.isArrayEqual(moduleOutput, trueVector, 3, accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_BR_B unit test\\n\")\n        unitTestSupport.writeTeXSnippet(\"passFail_omega_BR_B\", \"FAILED\", path)\n    else:\n        unitTestSupport.writeTeXSnippet(\"passFail_omega_BR_B\", \"PASSED\", path)\n\n    #\n    # check omega_RN_B\n    #\n    moduleOutput = dataLog.omega_RN_B[0]\n\n    # set the filtered output truth states\n    trueVector = np.dot(BN, np.array(omega_RN_N))\n\n    # compare the module results to the truth values\n    if not unitTestSupport.isArrayEqual(moduleOutput,trueVector,3,accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_RN_N unit test\\n\")\n        unitTestSupport.writeTeXSnippet(\"passFail_omega_RN_B\", \"FAILED\", path)\n    else:\n        unitTestSupport.writeTeXSnippet(\"passFail_omega_RN_B\", \"PASSED\", path)\n\n    #\n    # check domega_RN_B\n    #\n    moduleOutput = dataLog.domega_RN_B[0]\n\n    # set the filtered output truth states\n    trueVector = np.dot(BN, np.array(domega_RN_N))\n\n    # compare the module results to the truth values\n    if not unitTestSupport.isArrayEqual(moduleOutput,trueVector,3,accuracy):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed domega_RN_B unit test\\n\")\n        unitTestSupport.writeTeXSnippet(\"passFail_domega_RN_B\", \"FAILED\", path)\n    else:\n        unitTestSupport.writeTeXSnippet(\"passFail_domega_RN_B\", \"PASSED\", path)\n\n    # Note that we can continue to step the simulation however we feel like.\n    # Just because we stop and query data does not mean everything has to stop for good\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.6))    # run an additional 0.6 seconds\n    unitTestSim.ExecuteSimulation()\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"attTrackingError test\")\n    else:\n        print(testMessages)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_stateArchitectureAllTests(show_plots, function):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = eval(function + '(show_plots)')\n    assert testResults < 1, testMessage",
  "def subModuleTestFunction(show_plots):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = mc.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = inertial3DSpin.inertial3DSpin()\n    module.ModelTag = \"inertial3DSpin\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    omega_RR0_R0 = np.array([1., -1., 0.5]) * mc.D2R\n    module.omega_RR0_R0 = omega_RR0_R0\n\n    #\n    # Reference Frame Message\n    #\n    RefStateOutData = messaging.AttRefMsgPayload()  # Create a structure for the input message\n    sigma_R0N = np.array([0.1, 0.2, 0.3])\n    RefStateOutData.sigma_RN = sigma_R0N\n    omega_R0N_N = np.array([0.0, 0.0, 0.0])\n    RefStateOutData.omega_RN_N = omega_R0N_N\n    domega_R0N_N = np.array([0.0, 0.0, 0.0])\n    RefStateOutData.domega_RN_N = domega_R0N_N\n    refStateMsg = messaging.AttRefMsg().write(RefStateOutData)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    moduleLog = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, moduleLog)\n\n    # connect messages\n    module.attRefInMsg.subscribeTo(refStateMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(mc.sec2nano(1.5))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    #\n    # check sigma_RN\n    #\n    trueVector = [\n               [0.1, 0.2, 0.3],\n               [0.1, 0.2, 0.3],\n               [0.103643374814, 0.199258235068, 0.299694567381],\n               [0.10728593457, 0.198511279747, 0.299381655572]\n               ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0, len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleLog.sigma_RN[i], trueVector[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_RN unit test at t=\" +\n                                str(moduleLog.times()[i] * mc.NANO2SEC) + \"sec\\n\")\n\n\n    #\n    # check omega_RN_N\n    #\n    trueVector = [\n        [0.02142849611, 0.01021197571, -0.011041933756],\n        [0.02142849611, 0.01021197571, -0.011041933756],\n        [0.02142849611, 0.01021197571, -0.011041933756],\n        [0.021428270863,  0.010212299678, -0.011042071256]\n    ]\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleLog.omega_RN_N[i], trueVector[i] , 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_RN_N  unit test at t=\" +\n                                str(moduleLog.times()[i] * mc.NANO2SEC) + \"sec\\n\")\n\n    #\n    # check domega_RN_N\n    #\n    trueVector = [\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0],\n               [0.0, 0.0, 0.0]\n               ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleLog.domega_RN_N[i], trueVector[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed domega_RN_N unit test at t=\" +\n                                str(moduleLog.times()[i] * mc.NANO2SEC) +\"sec\\n\")\n\n    # Note that we can continue to step the simulation however we feel like.\n    # Just because we stop and query data does not mean everything has to stop for good\n    unitTestSim.ConfigureStopTime(mc.sec2nano(0.6))    # run an additional 0.6 seconds\n    unitTestSim.ExecuteSimulation()\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Passed\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def subModuleTestFunction2(show_plots):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = mc.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = inertial3DSpin.inertial3DSpin()\n    module.ModelTag = \"inertial3DSpin\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    omega_RR0_R0 = np.array([1., -1., 0.5]) * mc.D2R\n    module.omega_RR0_R0 = omega_RR0_R0\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    #\n    # Reference Frame Message\n    #\n    RefStateOutData = messaging.AttRefMsgPayload()  # Create a structure for the input message\n\n    sigma_R0N = np.array([0.1, 0.2, 0.3])\n    RefStateOutData.sigma_RN = sigma_R0N\n    omega_R0N_N = np.array([0.0, 0.0, 0.0])\n    RefStateOutData.omega_RN_N = omega_R0N_N\n    domega_R0N_N = np.array([0.0, 0.0, 0.0])\n    RefStateOutData.domega_RN_N = domega_R0N_N\n    refStateMsg = messaging.AttRefMsg().write(RefStateOutData)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    moduleLog = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, moduleLog)\n\n    # connect messages\n    module.attRefInMsg.subscribeTo(refStateMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(mc.sec2nano(1.5))  # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    # Note that range(3) will provide [0, 1, 2]  Those are the elements you get from the vector (all of them)\n    #\n    # check sigma_RN\n    #\n    # set the filtered output truth states\n    trueVector = [\n        [0.1, 0.2, 0.3],\n        [0.1, 0.2, 0.3],\n        [0.103643374814, 0.199258235068, 0.299694567381],\n        [0.10728593457, 0.198511279747, 0.299381655572]\n    ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0, len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleLog.sigma_RN[i], trueVector[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_RN unit test at t=\" +\n                                str(moduleLog.times()[i] * mc.NANO2SEC) +\n                                \"sec\\n\")\n\n    #\n    # check omega_RN_N\n    #\n    # set the filtered output truth states\n    trueVector = [\n        [0.02142849611, 0.01021197571, -0.011041933756],\n        [0.02142849611, 0.01021197571, -0.011041933756],\n        [0.02142849611, 0.01021197571, -0.011041933756],\n        [0.021428270863, 0.010212299678, -0.011042071256]\n    ]\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0, len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleLog.omega_RN_N[i], trueVector[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_RN_N unit test at t=\" +\n                                str(moduleLog.times()[i] * mc.NANO2SEC) +\n                                \"sec\\n\")\n\n    #\n    # check domega_RN_N\n    #\n\n    # set the filtered output truth states\n    trueVector = [\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0]\n    ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0, len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(moduleLog.domega_RN_N[i], trueVector[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed domega_RN_N unit test at t=\" +\n                                str(moduleLog.times()[i] * mc.NANO2SEC) +\n                                \"sec\\n\")\n\n    # Note that we can continue to step the simulation however we feel like.\n    # Just because we stop and query data does not mean everything has to stop for good\n    unitTestSim.ConfigureStopTime(mc.sec2nano(0.6))  # run an additional 0.6 seconds\n    unitTestSim.ExecuteSimulation()\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Passed\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def printResults3DSpin(sigma_R0N, omega_R0N_N, domega_R0N_N, omega_RR0_R, dt):\n\n    # Compute angular Rate\n    RN = rbk.MRP2C(sigma_R0N)\n    omega_RR0_N = np.dot(RN.T, omega_RR0_R)\n    omega_RN_N = omega_RR0_N + omega_R0N_N\n\n    # Compute angular acceleration\n    domega_RN_N = np.cross(omega_R0N_N, omega_RR0_N) + domega_R0N_N\n\n    # Compute attitude\n    omega_RN_R = np.dot(RN, omega_RN_N)\n    B = rbk.BmatMRP(sigma_R0N)\n    dsigma_RN = 0.25 * np.dot(B, omega_RN_R)\n    sigma_RN =  sigma_R0N + dsigma_RN * dt\n    rbk.MRPswitch(sigma_RN, 1)\n\n    # Print results\n    print('sigma_RN = ', sigma_RN)\n    print('omega_RN_N = ', omega_RN_N)\n    print('domega_RN_N = ', domega_RN_N)\n    print('\\n')\n    return sigma_RN",
  "def test_locationPointing(show_plots, r_LS_N, locationType, use3DRate, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test ensures that the Attitude Guidance and Attitude Reference messages content are properly computed\n    for a series of desired inertial target locations\n    \n\n    **Test Parameters**\n\n    Discuss the test parameters used.\n\n    Args:\n        r_LS_N (float): position vector of location relative to spacecraft\n        locationType (int): choose whether to use ``locationInMsg``, ``celBodyInMsg`` or ``scTargetInMsg``\n        use3DRate (bool): choose between 2D or 3D rate control\n        accuracy (float): absolute accuracy value used in the validation tests\n\n    **Description of Variables Being Tested**\n\n    The script checks the attitude and rate outputs.\n\n    \"\"\"\n    [testResults, testMessage] = locationPointingTestFunction(show_plots, r_LS_N, locationType,\n                                                              use3DRate, accuracy)\n    assert testResults < 1, testMessage",
  "def locationPointingTestFunction(show_plots, r_LS_NIn, locationType, use3DRate, accuracy):\n    \"\"\"Test method\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    timeStep = 0.1\n    testProcessRate = macros.sec2nano(timeStep)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup\n    pHat_B = np.array([1, 0, 0])\n    r_SN_N = np.array([10, 11, 12])\n    r_LS_N = np.array(r_LS_NIn)\n    omega_BN_B = np.array([0.001, 0.002, 0.003])\n    sigma_BN = np.array([0., 0., 0.])\n    r_LN_N = r_LS_N + r_SN_N\n\n    # setup module to be tested\n    module = locationPointing.locationPointing()\n    module.ModelTag = \"locationPointingTag\"\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    module.pHat_B = pHat_B\n    eps = 0.1 * macros.D2R\n    module.smallAngle = eps\n    if use3DRate:\n        module.useBoresightRateDamping = 1\n\n    # Configure input messages\n    scTransInMsgData = messaging.NavTransMsgPayload()\n    scTransInMsgData.r_BN_N = r_SN_N\n    scTransInMsg = messaging.NavTransMsg().write(scTransInMsgData)\n    scAttInMsgData = messaging.NavAttMsgPayload()\n    scAttInMsgData.omega_BN_B = omega_BN_B\n    scAttInMsgData.sigma_BN = sigma_BN\n    scAttInMsg = messaging.NavAttMsg().write(scAttInMsgData)\n\n    if locationType == 0:\n        locationInMsgData = messaging.GroundStateMsgPayload()\n        locationInMsgData.r_LN_N = r_LN_N\n        locationInMsg = messaging.GroundStateMsg().write(locationInMsgData)\n        module.locationInMsg.subscribeTo(locationInMsg)\n    elif locationType == 1:\n        locationInMsgData = messaging.EphemerisMsgPayload()\n        locationInMsgData.r_BdyZero_N = r_LN_N\n        locationInMsg = messaging.EphemerisMsg().write(locationInMsgData)\n        module.celBodyInMsg.subscribeTo(locationInMsg)\n    elif locationType == 2:\n        locationInMsgData = messaging.NavTransMsgPayload()\n        locationInMsgData.r_BN_N = r_LN_N\n        locationInMsg = messaging.NavTransMsg().write(locationInMsgData)\n        module.scTargetInMsg.subscribeTo(locationInMsg)\n\n    # subscribe input messages to module\n    module.scTransInMsg.subscribeTo(scTransInMsg)\n    module.scAttInMsg.subscribeTo(scAttInMsg)\n\n    # setup output message recorder objects\n    attGuidOutMsgRec = module.attGuidOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, attGuidOutMsgRec)\n    attRefOutMsgRec = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, attRefOutMsgRec)\n    scTransRec = scTransInMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, scTransRec)\n    scAttRec = scAttInMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, scAttRec)\n\n    # setup and execute simulation\n    unitTestSim.InitializeSimulation()\n    counter = 0\n    while counter < 3:\n        scAttInMsgData.sigma_BN = sigma_BN + omega_BN_B * timeStep * counter\n        scAttInMsg.write(scAttInMsgData)\n        unitTestSim.ConfigureStopTime(macros.sec2nano(counter * timeStep))\n        unitTestSim.ExecuteSimulation()\n        counter += 1\n\n    truthSigmaBR, truthOmegaBR, truthSigmaRN, truthOmegaRN = \\\n        truthValues(pHat_B, r_LN_N, r_SN_N, scAttRec.sigma_BN, scAttRec.omega_BN_B, eps, timeStep,\n                    use3DRate)\n\n    # compare the module results to the truth values\n    for i in range(0, len(truthSigmaBR)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(attGuidOutMsgRec.sigma_BR[i], truthSigmaBR[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_BR unit test at t=\" +\n                                str(attGuidOutMsgRec.times()[i] * macros.NANO2SEC) +\n                                \"sec\\n\")\n\n    for i in range(0, len(truthOmegaBR)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(attGuidOutMsgRec.omega_BR_B[i], truthOmegaBR[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_BR_B unit test at t=\" +\n                                str(attGuidOutMsgRec.times()[i] * macros.NANO2SEC) +\n                                \"sec\\n\")\n\n    for i in range(0, len(truthSigmaRN)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(attRefOutMsgRec.sigma_RN[i], truthSigmaRN[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed sigma_RN unit test at t=\" +\n                                str(attRefOutMsgRec.times()[i] * macros.NANO2SEC) +\n                                \"sec\\n\")\n\n    for i in range(0, len(truthOmegaRN)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(attRefOutMsgRec.omega_RN_N[i], truthOmegaRN[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_RN_N unit test at t=\" +\n                                str(attRefOutMsgRec.times()[i] * macros.NANO2SEC) +\n                                \"sec\\n\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, \"\".join(testMessages)]",
  "def truthValues(pHat_B, r_LN_N, r_SN_N, sigma_BNList, omega_BNList, smallAngle, dt, use3DRate):\n    # setup eHat180_B\n    eHat180_B = np.cross(pHat_B, np.array([1., 0., 0.]))\n    if np.linalg.norm(eHat180_B) < 0.1:\n        eHat180_B = np.cross(pHat_B, np.array([0., 1., 0.]))\n    eHat180_B = eHat180_B / np.linalg.norm(eHat180_B)\n\n    r_LS_N = r_LN_N - r_SN_N\n\n    counter = 0\n    omega_BR_B = np.array([0., 0., 0.])\n    sigma_BR_Out = []\n    omega_BR_B_Out = []\n    sigma_RN_Out = []\n    omega_RN_N_Out = []\n    while counter <= 2:\n        sigma_BN = sigma_BNList[counter]\n        dcmBN = RigidBodyKinematics.MRP2C(sigma_BN)\n        r_LS_B = dcmBN.dot(r_LS_N)\n        phi = math.acos(pHat_B.dot(r_LS_B) / np.linalg.norm(r_LS_B))\n        if phi < smallAngle:\n            sigma_BR = np.array([0., 0., 0.])\n        else:\n            if math.pi - phi < smallAngle:\n                eHat_B = eHat180_B\n            else:\n                eHat_B = np.cross(pHat_B, r_LS_B)\n            eHat_B = eHat_B / np.linalg.norm(eHat_B)\n            sigma_BR = - math.tan(phi / 4.) * eHat_B\n\n        if counter >= 1:\n            dsigma = (sigma_BR - sigma_BR_Out[counter - 1]) / dt\n            Binv = RigidBodyKinematics.BinvMRP(sigma_BR)\n            omega_BR_B = Binv.dot(dsigma) * 4\n\n        if use3DRate:\n            rHat_LS_B = r_LS_B / np.linalg.norm(r_LS_B)\n            omega_BR_B = omega_BR_B + (omega_BNList[counter].dot(rHat_LS_B))*rHat_LS_B\n\n        # store truth results\n        sigma_BR_Out.append(sigma_BR)\n        omega_BR_B_Out.append(omega_BR_B)\n        sigma_RN_Out.append(RigidBodyKinematics.addMRP(sigma_BNList[counter], -sigma_BR))\n        omega_RN_N_Out.append(np.transpose(dcmBN).dot(omega_BNList[counter] - omega_BR_B_Out[counter]))\n\n        counter += 1\n\n    return sigma_BR_Out, omega_BR_B_Out, sigma_RN_Out, omega_RN_N_Out",
  "def computeGamma(alpha, delta):\n\n    if alpha >= 0 and alpha <= np.pi/2:\n        if delta < np.pi/2 - alpha:\n            gamma = np.pi/2 - alpha - delta\n        elif delta > alpha + np.pi/2:\n            gamma = - np.pi/2 - alpha + delta\n        else:\n            gamma = 0\n    else:\n        if delta < alpha - np.pi/2:\n            gamma = - np.pi/2 + alpha - delta \n        elif delta > 3/2*np.pi - alpha:\n            gamma = alpha + delta - 3/2*np.pi\n        else:\n            gamma = 0\n\n    return gamma",
  "def test_oneAxisSolarArrayPointTestFunction(show_plots, alpha, delta, bodyAxisInput, inertialAxisInput, alignmentPriority, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test script tests the correctness of the reference attitude computed by :ref:`oneAxisSolarArrayPoint`.\n    The correctness of the output is determined based on whether the reference attitude causes the solar array drive\n    axis :math:`\\hat{a}_1` to be at an angle :math:`\\gamma` from the Sun direction :math:`\\hat{r}_{S/B}`.\n\n    **Test Parameters**\n\n    This test generates an array ``ang`` of linearly-spaced points between 0 and :math:`\\pi`. Values of \n    :math:`\\alpha` and :math:`\\delta` are drawn from all possible combinations of such lineaarly spaced values.\n    In the test, values of :math:`\\alpha` and :math:`\\delta` are used to set the angular distance between the vectors\n    :math:`{}^\\mathcal{N}\\hat{r}_{S/B}` and :math:`{}^\\mathcal{N}\\hat{h}_\\text{ref}`, and :math:`{}^\\mathcal{B}\\hat{h}_1`\n    and :math:`{}^\\mathcal{B}\\hat{a}_1`. All possible inputs are provided to the module, in terms of input parameters\n    and input messages, using the same combinations of inertial and body-fixed direction vectors.\n\n    Args:\n        alpha (rad): angle between :math:`{}^\\mathcal{N}\\hat{r}_{S/B}` and :math:`{}^\\mathcal{N}\\hat{h}_\\text{ref}`\n        delta (rad): angle between :math:`{}^\\mathcal{B}\\hat{h}_1` and :math:`{}^\\mathcal{B}\\hat{a}_1`\n        bodyAxisInput (int): passes the body axis input as parameter or as input msg\n        inertialAxisInput (int): passes the inertial axis input as parameter, as input msg, or with :ref:`NavTransMsgPayload` and :ref:`EphemerisMsgPayload`\n        alignmentPriority (int): 0 to prioritize body heading alignment, 1 to prioritize solar array power; if 1, correct result is :math:`\\gamma = 0`.\n\n    **Description of Variables Being Tested**\n\n    The angle :math:`\\gamma` is a function of the angles :math:`\\alpha` and :math:`\\delta`, where :math:`\\alpha` is the\n    angle between the Sun direction :math:`{}^\\mathcal{N}\\hat{r}_{S/B}` and the reference inertial heading\n    :math:`{}^\\mathcal{N}\\hat{h}_\\text{ref}`, whereas :math:`\\delta` is the angle between the body-frame heading\n    :math:`{}^\\mathcal{B}\\hat{h}_1` and the solar array axis drive :math:`{}^\\mathcal{B}\\hat{a}_1`.\n    The angle :math:`\\gamma` is computed from the output reference attitude and compared with the results of a \n    python function that computes the correct output based on the geometry of the problem. For a description of how\n    such correct result is obtained, see R. Calaon, C. Allard and H. Schaub, \"Attitude Reference Generation for Spacecraft\n    with Rotating Solar Arrays and Pointing Constraints\", in preparation for Journal of Spacecraft and Rockets.\n\n    **General Documentation Comments**\n\n    This unit test verifies the correctness of the generated reference attitude. It does not test the correctness of the\n    reference angular rates and accelerations contained in the ``attRefOutMsg``, because this would require to run the\n    module for multiple update calls. To ensure fast execution of the unit test, this is avoided.\n    \"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = oneAxisSolarArrayPointTestFunction(show_plots, alpha, delta, bodyAxisInput, inertialAxisInput, alignmentPriority, accuracy)\n\n    assert testResults < 1, testMessage",
  "def oneAxisSolarArrayPointTestFunction(show_plots, alpha, delta, bodyAxisInput, inertialAxisInput, alignmentPriority, accuracy):\n\n    gamma_true = computeGamma(alpha, delta)\n\n    rHat_SB_N = np.array([1, 2, 3])                            # Sun direction in inertial coordinates\n    rHat_SB_N = rHat_SB_N / np.linalg.norm(rHat_SB_N)\n    a1Hat_B = np.array([9, 8, 7])                            # array axis direction in body frame\n    a1Hat_B = a1Hat_B / np.linalg.norm(a1Hat_B)\n\n    a = np.cross(rHat_SB_N, [4, 5, 6])\n    a = a / np.linalg.norm(a)\n    \n    d = np.cross(a1Hat_B, [6, 5, 4])\n    d = d / np.linalg.norm(d)\n    \n    DCM1 = rbk.PRV2C(a * alpha)\n    DCM2 = rbk.PRV2C(d * delta)\n\n    hHat_N = np.matmul(DCM1, rHat_SB_N)             # required thrust direction in inertial frame, at an angle alpha from rHat_SB_N\n    hHat_B = np.matmul(DCM2, a1Hat_B)               # required thrust direction in inertial frame, at an angle alpha from rHat_SB_N\n\n    testFailCount = 0                                        # zero unit test result counter\n    testMessages = []                                        # create empty array to store test log messages\n    unitTaskName = \"unitTask\"                                # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"                          # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(1.1)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    attReferenceCongfig = oneAxisSolarArrayPoint.oneAxisSolarArrayPoint()\n    attReferenceCongfig.ModelTag = \"oneAxisSolarArrayPoint\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, attReferenceCongfig)\n\n    # Initialize the test module configuration data\n    # These will eventually become input messages\n    attReferenceCongfig.a1Hat_B = a1Hat_B\n    attReferenceCongfig.alignmentPriority = alignmentPriority\n\n    # Create input navigation message\n    sigma_BN = np.array([0, 0, 0])\n    BN = rbk.MRP2C(sigma_BN)\n    rS_B = np.matmul(BN, rHat_SB_N)\n    NavAttMessageData = messaging.NavAttMsgPayload()     \n    NavAttMessageData.sigma_BN = sigma_BN\n    NavAttMessageData.vehSunPntBdy = rS_B\n    NavAttMsg = messaging.NavAttMsg().write(NavAttMessageData)\n    attReferenceCongfig.attNavInMsg.subscribeTo(NavAttMsg)\n\n    if bodyAxisInput == 0:\n        attReferenceCongfig.h1Hat_B = hHat_B\n    else:\n        # Create input bodyHeadingMsg\n        bodyHeadingData = messaging.BodyHeadingMsgPayload()\n        bodyHeadingData.rHat_XB_B = hHat_B\n        bodyHeadingMsg = messaging.BodyHeadingMsg().write(bodyHeadingData)\n        attReferenceCongfig.bodyHeadingInMsg.subscribeTo(bodyHeadingMsg)\n\n    if inertialAxisInput == 0:\n        attReferenceCongfig.hHat_N = hHat_N\n    elif inertialAxisInput == 1:\n        # Create input inertialHeadingMsg\n        inertialHeadingData = messaging.InertialHeadingMsgPayload()\n        inertialHeadingData.rHat_XN_N = hHat_N\n        inertialHeadingMsg = messaging.InertialHeadingMsg().write(inertialHeadingData)\n        attReferenceCongfig.inertialHeadingInMsg.subscribeTo(inertialHeadingMsg)\n    else:\n        # Create input translation navigation\n        transNavData = messaging.NavTransMsgPayload()\n        transNavData.r_BN_N = [0, 0, 0]\n        transNavMsg = messaging.NavTransMsg().write(transNavData)\n        attReferenceCongfig.transNavInMsg.subscribeTo(transNavMsg)\n        ephemerisData = messaging.EphemerisMsgPayload()\n        ephemerisData.r_BdyZero_N = hHat_N\n        ephemerisMsg = messaging.EphemerisMsg().write(ephemerisData)\n        attReferenceCongfig.ephemerisInMsg.subscribeTo(ephemerisMsg)\n\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = attReferenceCongfig.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    moduleOutput = dataLog.sigma_RN\n    sigma_RN = moduleOutput[0]\n    RN = rbk.MRP2C(sigma_RN)\n    NR = RN.transpose()\n    a1Hat_N = np.matmul(NR, a1Hat_B)\n    gamma_sim = np.arcsin( abs( np.clip( np.dot(rHat_SB_N, a1Hat_N), -1, 1 ) ) )\n\n    # set the filtered output truth states\n    if alignmentPriority == 0:\n        if not unitTestSupport.isDoubleEqual(gamma_sim, gamma_true, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + attReferenceCongfig.ModelTag + \" Module failed incidence angle for \" \n                \"bodyAxisInput = {}, inertialAxisInput = {} and priorityFlag = {}\".format(\n                    bodyAxisInput, inertialAxisInput, alignmentPriority))\n    else:\n        if not unitTestSupport.isDoubleEqual(gamma_sim, 0, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + attReferenceCongfig.ModelTag + \" Module failed incidence angle for \" \n                \"bodyAxisInput = {}, inertialAxisInput = {} and priorityFlag = {}\".format(\n                    bodyAxisInput, inertialAxisInput, alignmentPriority))\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Unit Test Passed\")\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_smallBodyWaypointFeedback(show_plots):\n    r\"\"\"\n    **Validation Test Description**\n\n    This test checks two things: a large force output when the spacecraft is far from the waypoint, and a small force\n    output when the spacecraft is at the waypoint.\n\n    **Test Parameters**\n\n    Args:\n        :param show_plots: flag if plots should be shown.\n\n    **Description of Variables Being Tested**\n\n    In this test, the ``forceRequestBody`` variable in the :ref:`CmdForceBodyMsgPayload` output by the module is tested.\n    When far away from the waypoint, the force request should be larger than 1 N. When close to the waypoint, the force\n    request should only account for third body perturbations and SRP.\n    \"\"\"\n    [testResults1, testMessages1] = smallBodyWaypointFeedbackTestFunction1()\n    [testResults2, testMessages2] = smallBodyWaypointFeedbackTestFunction2()\n    assert (testResults1 + testResults2) < 1, [testMessages1, testMessages2]",
  "def smallBodyWaypointFeedbackTestFunction1():\n    \"\"\"This test checks for a large force return when far away from the waypoint\"\"\"\n    testFailCount = 0\n    testMessages = []\n\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(0.5)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    module = smallBodyWaypointFeedback.SmallBodyWaypointFeedback()\n    module.ModelTag = \"smallBodyWaypointFeedback1\"\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    module.A_sc = 1.  # Surface area of the spacecraft, m^2\n    module.M_sc = 300  # Mass of the spacecraft, kg\n    module.IHubPntC_B = unitTestSupport.np2EigenMatrix3d([82.12, 0.0, 0.0, 0.0, 98.40, 0.0, 0.0, 0.0, 121.0])  # sc inertia\n    module.mu_ast = 4.892  # Gravitational constant of the asteroid\n    module.x1_ref = [-2000., 0., 0.]\n    module.x2_ref = [0.0, 0.0, 0.0]\n    module.K1 = unitTestSupport.np2EigenMatrix3d([5e-4, 0e-5, 0e-5, 0e-5, 5e-4, 0e-5, 0e-5, 0e-5, 5e-4])\n    module.K2 = unitTestSupport.np2EigenMatrix3d([1., 0., 0., 0., 1., 0., 0., 0., 1.])\n\n    # Set the orbital parameters of the asteroid\n    oeAsteroid = planetEphemeris.ClassicElementsMsgPayload()\n    oeAsteroid.a = 1.1259 * orbitalMotion.AU * 1000  # meters\n    oeAsteroid.e = 0.20373\n    oeAsteroid.i = 6.0343 * macros.D2R\n    oeAsteroid.Omega = 2.01820 * macros.D2R\n    oeAsteroid.omega = 66.304 * macros.D2R\n    oeAsteroid.f = 346.32 * macros.D2R\n    r_ON_N, v_ON_N = orbitalMotion.elem2rv(orbitalMotion.MU_SUN*(1000.**3), oeAsteroid)\n\n    # Create the position and velocity of states of the s/c wrt the small body hill frame origin\n    r_BO_N = np.array([-2000., 1500., 1000.]) # Position of the spacecraft relative to the body\n    v_BO_N = np.array([0., 0., 0.])  # Velocity of the spacecraft relative to the body\n\n    # Create the inertial position and velocity of the s/c\n    r_BN_N = np.add(r_BO_N, r_ON_N)\n    v_BN_N = np.add(v_BO_N, v_ON_N)\n\n    # Configure blank module input messages\n    asteroidEphemerisInMsgData = messaging.EphemerisMsgPayload()\n    asteroidEphemerisInMsgData.r_BdyZero_N = r_ON_N\n    asteroidEphemerisInMsgData.v_BdyZero_N = v_ON_N\n    asteroidEphemerisInMsg = messaging.EphemerisMsg().write(asteroidEphemerisInMsgData)\n\n    navTransInMsgData = messaging.NavTransMsgPayload()\n    navTransInMsgData.r_BN_N = r_BN_N\n    navTransInMsgData.v_BN_N = v_BN_N\n    navTransInMsg = messaging.NavTransMsg().write(navTransInMsgData)\n\n    navAttInMsgData = messaging.NavAttMsgPayload()\n    navAttInMsgData.sigma_BN = np.array([0.1, 0.0, 0.0])\n    navAttInMsg = messaging.NavAttMsg().write(navAttInMsgData)\n\n    sunEphemerisInMsgData = messaging.EphemerisMsgPayload()\n    sunEphemerisInMsg = messaging.EphemerisMsg().write(sunEphemerisInMsgData)\n\n    # subscribe input messages to module\n    module.navTransInMsg.subscribeTo(navTransInMsg)\n    module.navAttInMsg.subscribeTo(navAttInMsg)\n    module.asteroidEphemerisInMsg.subscribeTo(asteroidEphemerisInMsg)\n    module.sunEphemerisInMsg.subscribeTo(sunEphemerisInMsg)\n\n    # setup output message recorder objects\n    forceOutMsgRec = module.forceOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, forceOutMsgRec)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.))\n    unitTestSim.ExecuteSimulation()\n\n    if np.linalg.norm(forceOutMsgRec.forceRequestBody) <= 1:\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed \"\n                            + \"force output\" + \" unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, \"\".join(testMessages)]",
  "def smallBodyWaypointFeedbackTestFunction2():\n    \"\"\"This test checks that the force output is near zero when at the waypoint\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(0.5)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    module = smallBodyWaypointFeedback.SmallBodyWaypointFeedback()\n    module.ModelTag = \"smallBodyWaypointFeedback2\"\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    module.A_sc = 1.  # Surface area of the spacecraft, m^2\n    module.M_sc = 300  # Mass of the spacecraft, kg\n    module.IHubPntC_B = unitTestSupport.np2EigenMatrix3d([82.12, 0.0, 0.0, 0.0, 98.40, 0.0, 0.0, 0.0, 121.0])  # sc inertia\n    module.mu_ast = 4.892  # Gravitational constant of the asteroid\n    module.x1_ref = [-2000., 0., 0.]\n    module.x2_ref = [0.0, 0.0, 0.0]\n    module.K1 = unitTestSupport.np2EigenMatrix3d([5e-4, 0e-5, 0e-5, 0e-5, 5e-4, 0e-5, 0e-5, 0e-5, 5e-4])\n    module.K2 = unitTestSupport.np2EigenMatrix3d([1., 0., 0., 0., 1., 0., 0., 0., 1.])\n\n    # Set the orbital parameters of the asteroid\n    oeAsteroid = planetEphemeris.ClassicElementsMsgPayload()\n    oeAsteroid.a = 1.1259 * orbitalMotion.AU * 1000  # meters\n    oeAsteroid.e = 0.20373\n    oeAsteroid.i = 6.0343 * macros.D2R\n    oeAsteroid.Omega = 2.01820 * macros.D2R\n    oeAsteroid.omega = 66.304 * macros.D2R\n    oeAsteroid.f = 346.32 * macros.D2R\n    r_ON_N, v_ON_N = orbitalMotion.elem2rv(orbitalMotion.MU_SUN*(1000.**3), oeAsteroid)\n\n    # Create the position and velocity of states of the s/c wrt the small body hill frame\n    r_BO_H = np.array([-2000., 0., 0.]) # Position of the spacecraft relative to the body\n    v_BO_H = np.array([0., 0., 0.])  # Velocity of the spacecraft relative to the body\n\n    r_BN_N, v_BN_N = orbitalMotion.hill2rv(r_ON_N, v_ON_N, r_BO_H, v_BO_H)\n\n    # Configure blank module input messages\n    asteroidEphemerisInMsgData = messaging.EphemerisMsgPayload()\n    asteroidEphemerisInMsgData.r_BdyZero_N = r_ON_N\n    asteroidEphemerisInMsgData.v_BdyZero_N = v_ON_N\n    asteroidEphemerisInMsg = messaging.EphemerisMsg().write(asteroidEphemerisInMsgData)\n\n    navTransInMsgData = messaging.NavTransMsgPayload()\n    navTransInMsgData.r_BN_N = r_BN_N\n    navTransInMsgData.v_BN_N = v_BN_N\n    navTransInMsg = messaging.NavTransMsg().write(navTransInMsgData)\n\n    navAttInMsgData = messaging.NavAttMsgPayload()\n    navAttInMsgData.sigma_BN = np.array([0.1, 0.0, 0.0])\n    navAttInMsg = messaging.NavAttMsg().write(navAttInMsgData)\n\n    sunEphemerisInMsgData = messaging.EphemerisMsgPayload()\n    sunEphemerisInMsg = messaging.EphemerisMsg().write(sunEphemerisInMsgData)\n\n    # subscribe input messages to module\n    module.navTransInMsg.subscribeTo(navTransInMsg)\n    module.navAttInMsg.subscribeTo(navAttInMsg)\n    module.asteroidEphemerisInMsg.subscribeTo(asteroidEphemerisInMsg)\n    module.sunEphemerisInMsg.subscribeTo(sunEphemerisInMsg)\n\n    # setup output message recorder objects\n    forceOutMsgRec = module.forceOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, forceOutMsgRec)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.))\n    unitTestSim.ExecuteSimulation()\n\n    if np.linalg.norm(forceOutMsgRec.forceRequestBody) >= 1e-8:\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed \"\n                            + \"force output\" + \" unit test\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, \"\".join(testMessages)]",
  "class DataStore:\n    \"\"\"Container for developer defined variables to be used in test data post-processing and plotting.\n\n        Attributes:\n            variableState (list): an example variable to hold test result data.\n    \"\"\"\n\n    def __init__(self):\n        self.variableState = None  # replace/add with appropriate variables for test result data storing\n\n    def plotData(self):\n        \"\"\"All test plotting to be performed here.\n\n        \"\"\"\n        plt.figure(1) # plot a sample variable.\n        plt.plot(self.variableState[:, 0]*macros.NANO2SEC, self.variableState[:, 1], label='Sample Variable')\n        plt.legend(loc='upper left')\n        plt.xlabel('Time [s]')\n        plt.ylabel('Variable Description [unit]')\n        plt.show()",
  "def plotFixture(show_plots):\n    dataStore = DataStore()\n    yield dataStore\n    if show_plots:\n        dataStore.plotData()",
  "def test_module(show_plots):     # update \"module\" in this function name to reflect the module name\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    # pass on the testPlotFixture so that the main test function may set the DataStore attributes\n    [testResults, testMessage] = sunlineEphemTestFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def sunlineEphemTestFunction(show_plots):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    sunlineEphemObj = sunlineEphem.sunlineEphem()\n    sunlineEphemObj.ModelTag = \"sunlineEphem\"           # update python name of test module\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, sunlineEphemObj)\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n\n    vehAttData = messaging.NavAttMsgPayload()\n    vehPosData = messaging.NavTransMsgPayload()\n    sunData = messaging.EphemerisMsgPayload()\n\n\n    # Artificially put sun at the origin.\n    sunData.r_BdyZero_N = [0.0, 0.0, 0.0]\n    vehAttInMsg = messaging.NavAttMsg().write(vehAttData)\n\n\n    # Place spacecraft unit length away on each coordinate axis\n    vehAttData.sigma_BN = [0.0, 0.0, 0.0]\n    TestVectors = [[-1.0, 0.0, 0.0],\n                   [0.0, -1.0, 0.0],\n                   [0.0, 0.0, -1.0],\n                   [1.0, 0.0, 0.0],\n                   [0.0, 1.0, 0.0],\n                   [0.0, 0.0, 1.0]]\n\n    estVector = np.zeros((6, 3))\n\n    vehPosInMsg = messaging.NavTransMsg()\n    sunDataInMsg = messaging.EphemerisMsg().write(sunData)\n    sunlineEphemObj.sunPositionInMsg.subscribeTo(sunDataInMsg)\n    sunlineEphemObj.scPositionInMsg.subscribeTo(vehPosInMsg)\n    sunlineEphemObj.scAttitudeInMsg.subscribeTo(vehAttInMsg)\n\n    dataLog = sunlineEphemObj.navStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    for i in range(len(TestVectors)):\n        testVec = TestVectors[i]\n        vehPosData.r_BN_N = testVec\n        vehPosInMsg.write(vehPosData)\n\n        # Need to call the self-init and cross-init methods\n        unitTestSim.InitializeSimulation()\n        unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n        unitTestSim.ExecuteSimulation()\n        estVector[i] = dataLog.vehSunPntBdy[-1]\n\n        # reset the module to test this functionality\n        sunlineEphemObj.Reset(1)\n\n\n    # set the filtered output truth states\n    trueVector = [\n               [1.0, 0.0, 0.0],\n               [0.0, 1.0, 0.0],\n               [0.0, 0.0, 1.0],\n               [-1.0, 0.0, 0.0],\n               [0.0, -1.0, 0.0],\n                [0.0, 0.0, -1.0]\n               ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(estVector[i], trueVector[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + sunlineEphemObj.ModelTag + \" Module failed sunlineEphem \" +\n                                \" unit test at t=\" + str(dataLog.times()[i]*macros.NANO2SEC) + \"sec\\n\")\n\n\n\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + sunlineEphemObj.ModelTag)\n    else:\n        print(testMessages)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def __init__(self):\n        self.variableState = None",
  "def plotData(self):\n        \"\"\"All test plotting to be performed here.\n\n        \"\"\"\n        plt.figure(1) # plot a sample variable.\n        plt.plot(self.variableState[:, 0]*macros.NANO2SEC, self.variableState[:, 1], label='Sample Variable')\n        plt.legend(loc='upper left')\n        plt.xlabel('Time [s]')\n        plt.ylabel('Variable Description [unit]')\n        plt.show()",
  "def StatesPlot(time, x, Pflat, show_plots):\n\n    P = np.zeros([len(Pflat[:,0]),3,3])\n    t = np.zeros(len(Pflat[:,0]))\n    for i in range(len(Pflat[:,0])):\n        t[i] = time[i]*1E-9\n        P[i, :, :] = Pflat[i, 0:3*3].reshape([3, 3])\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(311)\n    plt.plot(t , x[:, 1], \"b\", label='Error Filter')\n    plt.plot(t , 3 * np.sqrt(P[:, 0, 0]), 'r--',  label='Covar Filter')\n    plt.plot(t , -3 * np.sqrt(P[:, 0, 0]), 'r--')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n    plt.subplot(312)\n    plt.plot(t , x[:, 2], \"b\")\n    plt.plot(t , 3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.plot(t , -3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.title('First rate component')\n    plt.grid()\n\n    plt.subplot(313)\n    plt.plot(t , x[:, 3], \"b\")\n    plt.plot(t , 3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.plot(t , -3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.title('Second LOS component')\n    plt.grid()\n\n\n\n    unitTestSupport.writeFigureLaTeX('StatesPlot', 'State error and covariance', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n    plt.close('all')",
  "def StatesPlotCompare(x, x2, Pflat, Pflat2, show_plots):\n\n\n    P = np.zeros([len(Pflat[:,0]),3,3])\n    P2 = np.zeros([len(Pflat[:,0]),3,3])\n    t= np.zeros(len(Pflat[:,0]))\n    for i in range(len(Pflat[:,0])):\n        t[i] = x[i, 0]*1E-9\n        P[i,:,:] = Pflat[i,1:3*3+1].reshape([3,3])\n        P2[i, :, :] = Pflat2[i, 1:3*3+1].reshape([3, 3])\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(311)\n    plt.plot(t[0:30] , x[0:30, 1], \"b\", label='Error Filter')\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 0, 0]), 'r--',  label='Covar Filter')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 0, 0]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 1], \"g\", label='Error Expected')\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 0, 0]), 'c--', label='Covar Expected')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 0, 0]), 'c--')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n    plt.subplot(312)\n    plt.plot(t[0:30] , x[0:30, 2], \"b\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 1, 1]), 'r--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 1, 1]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 2], \"g\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 1, 1]), 'c--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 1, 1]), 'c--')\n    plt.title('First rate component')\n    plt.grid()\n\n    plt.subplot(313)\n    plt.plot(t[0:30] , x[0:30, 3], \"b\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 2, 2]), 'r--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 2, 2]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 3], \"g\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 2, 2]), 'c--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 2, 2]), 'c--')\n    plt.title('Second LOS component')\n    plt.grid()\n\n\n\n    unitTestSupport.writeFigureLaTeX('StatesCompare', 'State error and covariance vs expected Values', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def PostFitResiduals(time, Res, noise, show_plots):\n\n    MeasNoise = np.zeros(len(Res[:,0]))\n    t= np.zeros(len(Res[:,0]))\n    for i in range(len(Res[:,0])):\n        t[i] = time[i]*1E-9\n        MeasNoise[i] = 3*noise\n        # Don't plot zero values, since they mean that no measurement is taken\n        for j in range(len(Res[0,:])-1):\n            if -1E-10 < Res[i,j+1] < 1E-10:\n                Res[i, j+1] = np.nan\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(421)\n    plt.plot(t , Res[:, 0], \"b.\", label='Residual')\n    plt.plot(t , MeasNoise, 'r--', label='Covar')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.legend(loc='lower right')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('First CSS')\n    plt.grid()\n\n    plt.subplot(422)\n    plt.plot(t , Res[:, 4], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Fifth CSS')\n    plt.grid()\n\n    plt.subplot(423)\n    plt.plot(t , Res[:, 1], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Second CSS')\n    plt.grid()\n\n    plt.subplot(424)\n    plt.plot(t , Res[:, 5], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Sixth CSS')\n    plt.grid()\n\n    plt.subplot(425)\n    plt.plot(t , Res[:, 2], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Third CSS')\n    plt.grid()\n\n    plt.subplot(426)\n    plt.plot(t , Res[:, 6], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Seventh CSS')\n    plt.grid()\n\n    plt.subplot(427)\n    plt.plot(t , Res[:, 3], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.xlabel('t(s)')\n    plt.title('Fourth CSS')\n    plt.grid()\n\n    plt.subplot(428)\n    plt.plot(t , Res[:, 7], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.xlabel('t(s)')\n    plt.title('Eight CSS')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('PostFit', 'Post Fit Residuals', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def StatesVsExpected(stateLog, expectedStateArray, show_plots):\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(311)\n    plt.plot(stateLog[:, 0] * 1.0E-9, expectedStateArray[:,  1], 'b--', label='Expected')\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:,  1], 'r', label='Filter')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n    plt.subplot(312)\n    plt.plot(stateLog[:, 0] * 1.0E-9, expectedStateArray[:,  2], 'b--')\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:,  2], 'r')\n    plt.title('First rate component')\n    plt.grid()\n\n    plt.subplot(313)\n    plt.plot(stateLog[:, 0] * 1.0E-9, expectedStateArray[:,  3], 'b--')\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:,  3], 'r')\n    plt.title('Second LOS component')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesExpected', 'States vs true states in static case', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def StatesVsTargets(time, target1, target2, stateLog, show_plots):\n\n\n    target = np.ones([len(stateLog[:, 0]),3])\n    for i in range((len(stateLog[:, 0])-1)//2):\n        target[i, :] = target1\n        target[i+(len(stateLog[:, 0]) - 1) // 2,:] = target2\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(311)\n    plt.plot(time[:] * 1.0E-9, stateLog[:, 0], 'b', label='Filter')\n    plt.plot(time[:] * 1.0E-9, target[:, 0], 'r--', label='Expected')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n    plt.subplot(312)\n    plt.plot(time[:] * 1.0E-9, stateLog[:, 1], 'b')\n    plt.plot(time[:] * 1.0E-9, target[:, 1], 'r--')\n    plt.title('First rate component')\n    plt.grid()\n\n    plt.subplot(313)\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:, 2], 'b')\n    plt.plot(stateLog[:, 0] * 1.0E-9, target[:, 2], 'r--')\n    plt.title('Second LOS component')\n    plt.grid()\n\n\n\n    unitTestSupport.writeFigureLaTeX('StatesTarget', 'States tracking target values', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def OmegaVsExpected(omegaExp, omegaSim, show_plots):\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(311)\n    plt.plot(omegaSim[:, 0] * 1.0E-9, omegaSim[:, 1], 'b', label='Filter')\n    plt.plot(omegaSim[:, 0] * 1.0E-9, omegaExp[:, 1], 'r--', label='Expected')\n    plt.legend(loc='lower right')\n    plt.title('First omega component')\n    plt.grid()\n\n    plt.subplot(312)\n    plt.plot(omegaSim[:, 0] * 1.0E-9, omegaSim[:, 2], 'b')\n    plt.plot(omegaSim[:, 0] * 1.0E-9, omegaExp[:, 2], 'r--')\n    plt.title('Second omega component')\n    plt.grid()\n\n    plt.subplot(313)\n    plt.plot(omegaSim[:, 0] * 1.0E-9, omegaSim[:, 3], 'b')\n    plt.plot(omegaSim[:, 0] * 1.0E-9, omegaExp[:, 3], 'r--')\n    plt.title('Third omega component')\n    plt.grid()\n\n\n\n    unitTestSupport.writeFigureLaTeX('StatesTarget', 'States tracking target values', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def setupFilterData(filterObject):\n    filterObject.sensorUseThresh = 0.\n    filterObject.state = [1.0, 1.0, 1.0]\n    filterObject.omega = [0.1, 0.2, 0.1]\n    filterObject.x = [1.0, 0.0, 1.0]\n    filterObject.covar = [0.4, 0.0, 0.0,\n                          0.0, 0.4, 0.0,\n                          0.0, 0.0, 0.4]\n\n    filterObject.qProcVal = 0.1**2\n    filterObject.qObsVal = 0.001\n    filterObject.eKFSwitch = 5.",
  "def test_all_functions_oekf(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = sunline_individual_test()\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = StatePropStatic()\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = StatePropVariable(show_plots)\n    assert testResults < 1, testMessage",
  "def test_all_sunline_oekf(show_plots, SimHalfLength, AddMeasNoise, testVector1, testVector2, stateGuess):\n    [testResults, testMessage] = StateUpdateSunLine(show_plots, SimHalfLength, AddMeasNoise, testVector1, testVector2, stateGuess)\n    assert testResults < 1, testMessage",
  "def sunline_individual_test():\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    NUMSTATES = 3\n    ###################################################################################\n    ## Testing dynamics matrix computation\n    ###################################################################################\n\n    inputOmega = [0.1, 0.2, 0.1]\n    dt =0.5\n\n    expDynMat = - np.array([[0., -inputOmega[2], inputOmega[1]],\n                            [inputOmega[2], 0., -inputOmega[0]],\n                            [ -inputOmega[1], inputOmega[0], 0.]])\n\n\n    dynMat = okeefeEKF.new_doubleArray(3*3)\n    for i in range(9):\n        okeefeEKF.doubleArray_setitem(dynMat, i, 0.0)\n    okeefeEKF.sunlineDynMatrixOkeefe(inputOmega, dt, dynMat)\n\n    DynOut = []\n    for i in range(NUMSTATES*NUMSTATES):\n        DynOut.append(okeefeEKF.doubleArray_getitem(dynMat, i))\n\n    DynOut = np.array(DynOut).reshape(3, 3)\n    errorNorm = np.linalg.norm(expDynMat - DynOut)\n    if(errorNorm > 1.0E-12):\n        print(errorNorm)\n        testFailCount += 1\n        testMessages.append(\"Dynamics Matrix generation Failure \\n\")\n\n\n    ###################################################################################\n    ## Testing omega computation\n    ###################################################################################\n\n    inputStates = [2,1,0.75]\n    inputPrevStates = [1,0.1,0.5]\n    norm1 = np.linalg.norm(np.array(inputStates))\n    norm2 =  np.linalg.norm(np.array(inputPrevStates))\n    dt =0.5\n\n    expOmega = 1./dt*np.cross(np.array(inputStates),np.array(inputPrevStates))/(norm1*norm2)*np.arccos(np.dot(np.array(inputStates),np.array(inputPrevStates))/(norm1*norm2))\n\n    omega = okeefeEKF.new_doubleArray(NUMSTATES)\n    for i in range(3):\n        okeefeEKF.doubleArray_setitem(omega, i, 0.0)\n    okeefeEKF.sunlineRateCompute(inputStates, dt, inputPrevStates, omega)\n\n    omegaOut = []\n    for i in range(NUMSTATES):\n        omegaOut.append(okeefeEKF.doubleArray_getitem(omega, i))\n\n    omegaOut = np.array(omegaOut)\n    errorNorm = np.linalg.norm(expOmega - omegaOut)\n    if(errorNorm > 1.0E-12):\n        print(errorNorm)\n        testFailCount += 1\n        testMessages.append(\"Dynamics Matrix generation Failure \\n\")\n\n    ###################################################################################\n    ## STM and State Test\n    ###################################################################################\n\n    inputStates = [2,1,0.75]\n    inputOmega = [0.1, 0.2, 0.1]\n    dt =0.5\n    stateTransition = okeefeEKF.new_doubleArray(NUMSTATES*NUMSTATES)\n    states = okeefeEKF.new_doubleArray(NUMSTATES)\n    prev_states = okeefeEKF.new_doubleArray(NUMSTATES)\n    for i in range(NUMSTATES):\n        okeefeEKF.doubleArray_setitem(states, i, inputStates[i])\n        for j in range(NUMSTATES):\n            if i==j:\n                okeefeEKF.doubleArray_setitem(stateTransition, NUMSTATES*i+j, 1.0)\n            else:\n                okeefeEKF.doubleArray_setitem(stateTransition, NUMSTATES*i+j, 0.0)\n\n    okeefeEKF.sunlineStateSTMProp(expDynMat.flatten().tolist(), dt, inputOmega, states, prev_states, stateTransition)\n\n    PropStateOut = []\n    PropSTMOut = []\n    for i in range(NUMSTATES):\n        PropStateOut.append(okeefeEKF.doubleArray_getitem(states, i))\n    for i in range(NUMSTATES*NUMSTATES):\n        PropSTMOut.append(okeefeEKF.doubleArray_getitem(stateTransition, i))\n\n    STMout = np.array(PropSTMOut).reshape([NUMSTATES,NUMSTATES])\n    StatesOut = np.array(PropStateOut)\n\n    expectedSTM = dt*np.dot(expDynMat, np.eye(NUMSTATES)) + np.eye(NUMSTATES)\n    expectedStates = np.zeros(NUMSTATES)\n    inputStatesArray = np.array(inputStates)\n    ## Equations when removing the unobservable states from d_dot\n    expectedStates[0:3] = np.array(inputStatesArray - dt*(np.cross(np.array(inputOmega), np.array(inputStatesArray))))\n    errorNormSTM = np.linalg.norm(expectedSTM - STMout)\n    errorNormStates = np.linalg.norm(expectedStates - StatesOut)\n\n    if(errorNormSTM > 1.0E-12):\n        print(errorNormSTM)\n        testFailCount += 1\n        testMessages.append(\"STM Propagation Failure \\n\")\n\n\n    if(errorNormStates > 1.0E-12):\n        print(errorNormStates)\n        testFailCount += 1\n        testMessages.append(\"State Propagation Failure \\n\")\n\n\n\n    ###################################################################################\n    # ## Test the H and yMeas matrix generation as well as the observation count\n    # ###################################################################################\n    numCSS = 4\n    cssCos = [np.cos(np.deg2rad(10.)), np.cos(np.deg2rad(25.)), np.cos(np.deg2rad(5.)), np.cos(np.deg2rad(90.))]\n    sensorTresh = np.cos(np.deg2rad(50.))\n    cssNormals = [1.,0.,0.,0.,1.,0., 0.,0.,1., 1./np.sqrt(2), 1./np.sqrt(2),0.]\n    cssBias = [1.0 for i in range(numCSS)]\n\n    measMat = okeefeEKF.new_doubleArray(8*NUMSTATES)\n    obs = okeefeEKF.new_doubleArray(8)\n    yMeas = okeefeEKF.new_doubleArray(8)\n    numObs = okeefeEKF.new_intArray(1)\n\n    for i in range(8*NUMSTATES):\n        okeefeEKF.doubleArray_setitem(measMat, i, 0.)\n    for i in range(8):\n        okeefeEKF.doubleArray_setitem(obs, i, 0.0)\n        okeefeEKF.doubleArray_setitem(yMeas, i, 0.0)\n\n    okeefeEKF.sunlineHMatrixYMeas(inputStates, numCSS, cssCos, sensorTresh, cssNormals, cssBias, obs, yMeas, numObs, measMat)\n\n    obsOut = []\n    yMeasOut = []\n    numObsOut = []\n    HOut = []\n    for i in range(8*NUMSTATES):\n        HOut.append(okeefeEKF.doubleArray_getitem(measMat, i))\n    for i in range(8):\n        yMeasOut.append(okeefeEKF.doubleArray_getitem(yMeas, i))\n        obsOut.append(okeefeEKF.doubleArray_getitem(obs, i))\n    numObsOut.append(okeefeEKF.intArray_getitem(numObs, 0))\n\n    #Fill in expected values for test\n    expectedH = np.zeros([8,NUMSTATES])\n    expectedY = np.zeros(8)\n    for j in range(3):\n        expectedH[j,0:3] = np.eye(3)[j,:]\n        expectedY[j] =np.array(cssCos[j]) - np.dot(np.array(inputStates)[0:3], np.array(cssNormals)[j*3:(j+1)*3])\n    expectedObs = np.array([np.cos(np.deg2rad(10.)), np.cos(np.deg2rad(25.)), np.cos(np.deg2rad(5.)),0.,0.,0.,0.,0.])\n    expectedNumObs = 3\n\n    HOut = np.array(HOut).reshape([8, NUMSTATES])\n    errorNorm = np.zeros(4)\n    errorNorm[0] = np.linalg.norm(HOut - expectedH)\n    errorNorm[1] = np.linalg.norm(yMeasOut - expectedY)\n    errorNorm[2] = np.linalg.norm(obsOut - expectedObs)\n    errorNorm[3] = np.linalg.norm(numObsOut[0] - expectedNumObs)\n    for i in range(4):\n        if(errorNorm[i] > 1.0E-12):\n            testFailCount += 1\n            testMessages.append(\"H and yMeas update failure \\n\")\n\n    # ###################################################################################\n    # ## Test the Kalman Gain\n    # ###################################################################################\n\n    numObs = 3\n    h = [1., 0., 0., 0., 1., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n         0., 0., 0., 0., 0., 0.]\n    covar = [1., 0., 1.,\n        0., 1., 0.,\n        1., 0., 1. ]\n    noise= 0.01\n\n    Kalman = okeefeEKF.new_doubleArray(NUMSTATES * 8)\n\n    for i in range(8 * NUMSTATES):\n        okeefeEKF.doubleArray_setitem(Kalman, i, 0.)\n\n    okeefeEKF.sunlineKalmanGainOkeefe(covar, h, noise, numObs, Kalman)\n\n    KalmanOut = []\n    for i in range(8 * NUMSTATES):\n        KalmanOut.append(okeefeEKF.doubleArray_getitem(Kalman, i))\n\n    # Fill in expected values for test\n    Hmat = np.array(h).reshape([8,NUMSTATES])\n    Pk = np.array(covar).reshape([NUMSTATES,NUMSTATES])\n    R = noise*np.eye(3)\n    expectedK = np.dot(np.dot(Pk, Hmat[0:numObs,:].T), np.linalg.inv(np.dot(np.dot(Hmat[0:numObs,:], Pk), Hmat[0:numObs,:].T) + R[0:numObs,0:numObs]))\n\n    KalmanOut = np.array(KalmanOut)[0:NUMSTATES*numObs].reshape([NUMSTATES, 3])\n    errorNorm = np.linalg.norm(KalmanOut[:,0:numObs] - expectedK)\n\n\n    if (errorNorm > 1.0E-12):\n        print(errorNorm)\n        testFailCount += 1\n        testMessages.append(\"Kalman Gain update failure \\n\")\n\n    # ###################################################################################\n    # ## Test the EKF update\n    # ###################################################################################\n\n    KGain = [1.,2.,3., 0., 1., 2., 1., 0., 1.]\n    for i in range(NUMSTATES*8-NUMSTATES*3):\n        KGain.append(0.)\n    inputStates = [2,1,0.75]\n    xbar = [0.1, 0.2, 0.01]\n    numObs = 3\n    h = [1., 0., 0., 0., 1., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0.,\n         0., 0., 0., 0., 0., 0., 0., 0., 0.]\n    covar = [1., 0., 1.,\n             0., 1., 0.,\n             1., 0., 1.,\n             ]\n    noise = 0.01\n    inputY = np.zeros(3)\n    for j in range(3):\n        inputY[j] = np.array(cssCos[j]) - np.dot(np.array(inputStates)[0:3], np.array(cssNormals)[j * 3:(j + 1) * 3])\n    inputY = inputY.tolist()\n\n    stateError = okeefeEKF.new_doubleArray(NUMSTATES)\n    covarMat = okeefeEKF.new_doubleArray(NUMSTATES*NUMSTATES)\n    inputs = okeefeEKF.new_doubleArray(NUMSTATES)\n\n\n    for i in range(NUMSTATES):\n        okeefeEKF.doubleArray_setitem(stateError, i, 0.)\n        okeefeEKF.doubleArray_setitem(inputs, i, inputStates[i])\n        for j in range(NUMSTATES):\n            okeefeEKF.doubleArray_setitem(covarMat,i+j,0.)\n\n    okeefeEKF.okeefeEKFUpdate(KGain, covar, noise, numObs, inputY, h, inputs, stateError, covarMat)\n\n    stateOut = []\n    covarOut = []\n    errorOut = []\n    for i in range(NUMSTATES):\n        stateOut.append(okeefeEKF.doubleArray_getitem(inputs, i))\n        errorOut.append(okeefeEKF.doubleArray_getitem(stateError, i))\n    for j in range(NUMSTATES*NUMSTATES):\n        covarOut.append(okeefeEKF.doubleArray_getitem(covarMat, j))\n\n    # Fill in expected values for test\n    KK = np.array(KGain)[0:NUMSTATES*3].reshape([NUMSTATES,3])\n    expectedStates = np.array(inputStates) + np.dot(KK, np.array(inputY))\n    H = np.array(h).reshape([8,NUMSTATES])[0:3,:]\n    Pk = np.array(covar).reshape([NUMSTATES, NUMSTATES])\n    R = noise * np.eye(3)\n    expectedP = np.dot(np.dot(np.eye(NUMSTATES) - np.dot(KK, H), Pk), np.transpose(np.eye(NUMSTATES) - np.dot(KK, H))) + np.dot(KK, np.dot(R,KK.T))\n\n    errorNorm = np.zeros(2)\n    errorNorm[0] = np.linalg.norm(np.array(stateOut) - expectedStates)\n    errorNorm[1] = np.linalg.norm(expectedP - np.array(covarOut).reshape([NUMSTATES,NUMSTATES]))\n    for i in range(2):\n        if(errorNorm[i] > 1.0E-12):\n            testFailCount += 1\n            testMessages.append(\"EKF update failure \\n\")\n    #\n    # ###################################################################################\n    # ## Test the CKF update\n    # ###################################################################################\n\n    KGain = [1., 2., 3.]\n    for i in range(NUMSTATES * 8 - NUMSTATES * 3):\n        KGain.append(0.)\n    inputStates = [2, 1, 0.75]\n    xbar = [0.1, 0.2, 0.01]\n    numObs = 3\n    h = [1., 0., 0., 0., 1., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n         0., 0., 0., 0., 0., 0.]\n    covar = [1., 0., 1.,\n             0., 1., 0.,\n             1., 0., 1.]\n    noise =0.01\n    inputY = np.zeros(3)\n    for j in range(3):\n        inputY[j] = np.array(cssCos[j]) - np.dot(np.array(inputStates)[0:3],\n                                                 np.array(cssNormals)[j * 3:(j + 1) * 3])\n    inputY = inputY.tolist()\n\n    stateError = okeefeEKF.new_doubleArray(NUMSTATES)\n    covarMat = okeefeEKF.new_doubleArray(NUMSTATES * NUMSTATES)\n\n    for i in range(NUMSTATES):\n        okeefeEKF.doubleArray_setitem(stateError, i, xbar[i])\n        for j in range(NUMSTATES):\n            okeefeEKF.doubleArray_setitem(covarMat, i + j, 0.)\n\n    okeefeEKF.sunlineCKFUpdateOkeefe(xbar, KGain, covar, noise, numObs, inputY, h, stateError, covarMat)\n\n    covarOut = []\n    errorOut = []\n    for i in range(NUMSTATES):\n        errorOut.append(okeefeEKF.doubleArray_getitem(stateError, i))\n    for j in range(NUMSTATES*NUMSTATES):\n        covarOut.append(okeefeEKF.doubleArray_getitem(covarMat, j))\n\n    # Fill in expected values for test\n    KK = np.array(KGain)[0:NUMSTATES * 3].reshape([NUMSTATES, 3])\n    H = np.array(h).reshape([8, NUMSTATES])[0:3, :]\n    expectedStateError = np.array(xbar) + np.dot(KK, (np.array(inputY) - np.dot(H, np.array(xbar))))\n    Pk = np.array(covar).reshape([NUMSTATES, NUMSTATES])\n    expectedP = np.dot(np.dot(np.eye(NUMSTATES) - np.dot(KK, H), Pk), np.transpose(np.eye(NUMSTATES) - np.dot(KK, H))) + np.dot(KK,\n                                                                                                                np.dot(\n                                                                                                                    R,\n                                                                                                                    KK.T))\n\n    errorNorm = np.zeros(2)\n    errorNorm[0] = np.linalg.norm(np.array(errorOut) - expectedStateError)\n    errorNorm[1] = np.linalg.norm(expectedP - np.array(covarOut).reshape([NUMSTATES, NUMSTATES]))\n    for i in range(2):\n        if (errorNorm[i] > 1.0E-12):\n            testFailCount += 1\n            testMessages.append(\"CKF update failure \\n\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" EKF individual tests\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StatePropStatic():\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    NUMSTATES=3\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = okeefeEKF.okeefeEKF()\n    module.ModelTag = \"okeefeEKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n    module.omega = [0.,0.,0.]\n\n    unitTestSim.AddVariableForLogging('okeefeEKF.covar', testProcessRate * 10, 0, 8)\n    unitTestSim.AddVariableForLogging('okeefeEKF.state', testProcessRate * 10, 0, 2)\n\n    # connect messages\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n    cssConfigInMsg = messaging.CSSConfigMsg()\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConfigInMsg)\n\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(8000.0))\n    unitTestSim.ExecuteSimulation()\n\n    stateLog = unitTestSim.GetLogVariableData('okeefeEKF.state')\n\n\n    for i in range(NUMSTATES):\n        if (abs(stateLog[-1, i + 1] - stateLog[0, i + 1]) > 1.0E-10):\n            print(abs(stateLog[-1, i + 1] - stateLog[0, i + 1]))\n            testFailCount += 1\n            testMessages.append(\"Static state propagation failure \\n\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"EKF static state propagation\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StatePropVariable(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    NUMSTATES=3\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = okeefeEKF.okeefeEKF()\n    module.ModelTag = \"okeefeEKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n\n    InitialState = module.state\n    Initialx = module.x\n    InitialCovar = module.covar\n    InitOmega = module.omega\n\n    module.state = InitialState\n    unitTestSim.AddVariableForLogging('okeefeEKF.covar', testProcessRate, 0, 8)\n    unitTestSim.AddVariableForLogging('okeefeEKF.stateTransition', testProcessRate, 0, 8)\n    unitTestSim.AddVariableForLogging('okeefeEKF.state', testProcessRate , 0, 2)\n    unitTestSim.AddVariableForLogging('okeefeEKF.x', testProcessRate , 0, 2)\n    unitTestSim.AddVariableForLogging('okeefeEKF.omega', testProcessRate , 0, 2)\n\n    # connect messages\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n    cssConfigInMsg = messaging.CSSConfigMsg()\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConfigInMsg)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1000.0))\n    unitTestSim.ExecuteSimulation()\n\n\n    covarLog = unitTestSim.GetLogVariableData('okeefeEKF.covar')\n    stateLog = unitTestSim.GetLogVariableData('okeefeEKF.state')\n    stateErrorLog = unitTestSim.GetLogVariableData('okeefeEKF.x')\n    stmLog = unitTestSim.GetLogVariableData('okeefeEKF.stateTransition')\n    omegaLog = unitTestSim.GetLogVariableData('okeefeEKF.omega')\n\n    dt = 0.5\n    expectedOmega = np.zeros([2001, (NUMSTATES + 1)])\n    expectedStateArray = np.zeros([2001,(NUMSTATES+1)])\n    expectedPrevArray = np.zeros([2001,(NUMSTATES+1)])\n    expectedStateArray[0,1:(NUMSTATES+1)] = np.array(InitialState)\n    expectedOmega[0,1:(NUMSTATES+1)] = np.array(InitOmega)\n\n    expectedXBar = np.zeros([2001,NUMSTATES+1])\n    expectedXBar[0,1:(NUMSTATES+1)] = np.array(Initialx)\n\n    expectedSTM = np.zeros([2001,NUMSTATES,NUMSTATES])\n    expectedSTM[0,:,:] = np.eye(NUMSTATES)\n\n    expectedCovar = np.zeros([2001,NUMSTATES*NUMSTATES+1])\n    expectedCovar[0,1:(NUMSTATES*NUMSTATES+1)] = np.array(InitialCovar)\n\n    expDynMat = np.zeros([2001,NUMSTATES,NUMSTATES])\n    Gamma = dt ** 2. / 2. * np.eye(3)\n    ProcNoiseCovar = np.dot(Gamma, np.dot(module.qProcVal*np.eye(3),Gamma.T))\n\n    for i in range(1,2001):\n        expectedStateArray[i,0] = dt*i*1E9\n        expectedPrevArray[i,0] = dt*i*1E9\n        expectedOmega[i,0] = dt*i*1E9\n        expectedCovar[i,0] =  dt*i*1E9\n        expectedXBar[i,0] = dt*i*1E9\n\n        #Simulate sunline Dyn Mat\n        expDynMat[i-1, :, :] = - np.array([[0., -expectedOmega[i-1, 3], expectedOmega[i-1,2]],\n                                         [expectedOmega[i-1,3], 0., -expectedOmega[i-1,1]],\n                                         [ -expectedOmega[i-1,2], expectedOmega[i-1,1], 0.]])\n\n        #Simulate STM State prop\n        expectedStateArray[i,1:(NUMSTATES+1)] =  np.array(expectedStateArray[i-1,1:(NUMSTATES+1)] - dt*(np.cross(np.array(expectedOmega[i-1,1:(NUMSTATES+1)]), np.array(expectedStateArray[i-1,1:(NUMSTATES+1)]))))\n        expectedPrevArray[i, 1:(NUMSTATES + 1)] = expectedStateArray[i-1,1:(NUMSTATES+1)]\n        expectedSTM[i,:,:] = dt * np.dot(expDynMat[i-1,:,:], np.eye(NUMSTATES)) + np.eye(NUMSTATES)\n\n        # Simulate Rate compute\n        normdk = np.linalg.norm(expectedStateArray[i, 1:(NUMSTATES + 1)])\n        nomrdkmin1 = np.linalg.norm(expectedPrevArray[i, 1:(NUMSTATES + 1)])\n        arg = np.dot(expectedStateArray[i, 1:(NUMSTATES + 1)], expectedPrevArray[i , 1:(NUMSTATES + 1)]) / (normdk * nomrdkmin1)\n        if arg>1:\n            expectedOmega[i, 1:(NUMSTATES + 1)] = 1./dt*np.cross(expectedStateArray[i, 1:(NUMSTATES + 1)],\n                                                           expectedPrevArray[i, 1:(NUMSTATES + 1)]) / (normdk * nomrdkmin1) * np.arccos(1)\n        elif arg<-1:\n            expectedOmega[i, 1:(NUMSTATES + 1)] = 1./dt*np.cross(expectedStateArray[i, 1:(NUMSTATES + 1)],\n                                                           expectedPrevArray[i, 1:(NUMSTATES + 1)]) / (\n                                                  normdk * nomrdkmin1) * np.arccos(-1)\n\n        else:\n            expectedOmega[i, 1:(NUMSTATES + 1)] = 1./dt*np.cross(expectedStateArray[i, 1:(NUMSTATES + 1)],expectedPrevArray[i, 1:(NUMSTATES + 1)]) / (normdk * nomrdkmin1) * np.arccos(arg)\n\n        expectedXBar[i, 1:(NUMSTATES+1)] = np.dot(expectedSTM[i, :, :], expectedXBar[i - 1, 1:(NUMSTATES+1)])\n        expectedCovar[i,1:(NUMSTATES*NUMSTATES+1)] = (np.dot(expectedSTM[i,:,:], np.dot(np.reshape(expectedCovar[i-1,1:(NUMSTATES*NUMSTATES+1)],[NUMSTATES,NUMSTATES]), np.transpose(expectedSTM[i,:,:])))+ ProcNoiseCovar).flatten()\n\n    FilterPlots.StatesVsExpected(stateLog, expectedStateArray, show_plots)\n    FilterPlots.StatesPlotCompare(stateErrorLog, expectedXBar, covarLog, expectedCovar, show_plots)\n    FilterPlots.OmegaVsExpected(expectedOmega, omegaLog, show_plots)\n\n    for j in range(1,2001):\n        for i in range(NUMSTATES):\n            if (abs(stateLog[j, i + 1] - expectedStateArray[j, i + 1]) > 1.0E-10):\n                testFailCount += 1\n                testMessages.append(\"General state propagation failure: State Prop \\n\")\n            if (abs(stateErrorLog[j, i + 1] - expectedXBar[j, i + 1]) > 1.0E-10):\n                testFailCount += 1\n                testMessages.append(\"General state propagation failure: State Error Prop \\n\")\n\n        for i in range(NUMSTATES*NUMSTATES):\n            if (abs(covarLog[j, i + 1] - expectedCovar[j, i + 1]) > 1.0E-8):\n                print(abs(covarLog[j, i + 1] - expectedCovar[j, i + 1]))\n                abs(covarLog[j, i + 1] - expectedCovar[j, i + 1])\n                testFailCount += 1\n                # testMessages.append(\"General state propagation failure: Covariance Prop \\n\")\n            if (abs(stmLog[j, i + 1] - expectedSTM[j,:].flatten()[i]) > 1.0E-10):\n                testFailCount += 1\n                testMessages.append(\"General state propagation failure: STM Prop \\n\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"EKF general state propagation\")\n    else:\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StateUpdateSunLine(show_plots, SimHalfLength, AddMeasNoise, testVector1, testVector2, stateGuess):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n    NUMSTATES=3\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = okeefeEKF.okeefeEKF()\n    module.ModelTag = \"okeefeEKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    setupFilterData(module)\n    module.omega = [0.,0.,0.]\n\n    # Set up some test parameters\n\n    cssConstelation = messaging.CSSConfigMsgPayload()\n\n    CSSOrientationList = [\n        [0.70710678118654746, -0.5, 0.5],\n        [0.70710678118654746, -0.5, -0.5],\n        [0.70710678118654746, 0.5, -0.5],\n        [0.70710678118654746, 0.5, 0.5],\n        [-0.70710678118654746, 0, 0.70710678118654757],\n        [-0.70710678118654746, 0.70710678118654757, 0.0],\n        [-0.70710678118654746, 0, -0.70710678118654757],\n        [-0.70710678118654746, -0.70710678118654757, 0.0],\n    ]\n    CSSBias = [1.0 for i in range(len(CSSOrientationList))]\n    totalCSSList = []\n    i=0\n    for CSSHat in CSSOrientationList:\n        newCSS = messaging.CSSUnitConfigMsgPayload()\n        newCSS.CBias = CSSBias[i]\n        newCSS.nHat_B = CSSHat\n        totalCSSList.append(newCSS)\n        i = i + 1\n    cssConstelation.nCSS = len(CSSOrientationList)\n    cssConstelation.cssVals = totalCSSList\n    inputData = messaging.CSSArraySensorMsgPayload()\n\n    cssConstInMsg = messaging.CSSConfigMsg().write(cssConstelation)\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n\n    # connect messages\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConstInMsg)\n\n    dt =0.5\n    stateTarget1 = testVector1\n    module.state = stateGuess\n    module.x = (np.array(stateTarget1) - np.array(stateGuess)).tolist()\n    unitTestSim.AddVariableForLogging('okeefeEKF.x', testProcessRate , 0, 2, 'double')\n    dataLog = module.filtDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n\n\n\n    for i in range(SimHalfLength):\n        if i > 20:\n            dotList = []\n            for element in CSSOrientationList:\n                if AddMeasNoise:\n                    dotProd = np.dot(np.array(element), np.array(testVector1)[0:3]) + np.random.normal(0., module.qObsVal)\n                else:\n                    dotProd = np.dot(np.array(element), np.array(testVector1)[0:3])\n                dotList.append(dotProd)\n            inputData.CosValue = dotList\n            cssDataInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i + 1) * 0.5))\n        unitTestSim.ExecuteSimulation()\n\n    stateLog = dataLog.state\n    covarLog = dataLog.covar\n\n    if not AddMeasNoise:\n        for i in range(NUMSTATES):\n            if (abs(covarLog[-1, i * NUMSTATES + i] - covarLog[0, i * NUMSTATES  + i] / 100.) > 1E-1):\n                testFailCount += 1\n                testMessages.append(\"Covariance update failure\")\n            if (abs(stateLog[-1, i] - stateTarget1[i]) > 1.0E-10):\n                testFailCount += 1\n                testMessages.append(\"State update failure\")\n    else:\n        for i in range(NUMSTATES):\n            if (abs(covarLog[-1, i * NUMSTATES + i] - covarLog[0, i * NUMSTATES + i] / 100.) > 1E-1):\n                testFailCount += 1\n                testMessages.append(\"Covariance update failure with noise\")\n            if (abs(stateLog[-1, i] - stateTarget1[i]) > 1.0E-2):\n                testFailCount += 1\n                testMessages.append(\"State update failure with noise\")\n\n\n    stateTarget2 = testVector2\n\n    inputData = messaging.CSSArraySensorMsgPayload()\n    for i in range(SimHalfLength):\n        if i > 20:\n            dotList = []\n            for element in CSSOrientationList:\n                if AddMeasNoise:\n                    dotProd = np.dot(np.array(element), np.array(testVector2)[0:3]) + np.random.normal(0., module.qObsVal)\n                else:\n                    dotProd = np.dot(np.array(element), np.array(testVector2)[0:3])\n                dotList.append(dotProd)\n            inputData.CosValue = dotList\n            cssDataInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i + SimHalfLength+1) * 0.5))\n        unitTestSim.ExecuteSimulation()\n\n    stateErrorLog = unitTestSim.GetLogVariableData('okeefeEKF.x')\n    stateLog = dataLog.state\n    postFitLog = dataLog.postFitRes\n    covarLog = dataLog.covar\n\n\n    if not AddMeasNoise:\n        for i in range(NUMSTATES):\n            if (abs(covarLog[-1, i * NUMSTATES + i] - covarLog[0, i * NUMSTATES + i] / 100.) > 1E-1):\n                testFailCount += 1\n                testMessages.append(\"Covariance update failure\")\n            if (abs(stateLog[-1, i] - stateTarget2[i]) > 1.0E-10):\n                testFailCount += 1\n                testMessages.append(\"State update failure\")\n    else:\n        for i in range(NUMSTATES):\n            if (abs(covarLog[-1, i * NUMSTATES + i] - covarLog[0, i * NUMSTATES + i] / 100.) > 1E-1):\n                testFailCount += 1\n                testMessages.append(\"Covariance update failure\")\n            if (abs(stateLog[-1, i] - stateTarget2[i]) > 1.0E-2):\n                testFailCount += 1\n                testMessages.append(\"State update failure\")\n\n\n    target1 = np.array(testVector1)\n    target2 = np.array(testVector2)\n    FilterPlots.StatesPlot(dataLog.times(), stateErrorLog, covarLog, show_plots)\n    FilterPlots.StatesVsTargets(dataLog.times(), target1, target2, stateLog, show_plots)\n    FilterPlots.PostFitResiduals(dataLog.times(), postFitLog, module.qObsVal, show_plots)\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"EKF full test\")\n    else:\n        print((testMessages))\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def setupFilterData(filterObject):\n\n    filterObject.alpha = 0.02\n    filterObject.beta = 2.0\n    filterObject.kappa = 0.0\n    filterObject.switchMag = 1.2\n\n    ST1Data = inertialUKF.STMessage()\n\n    ST1Data.noise = [0.00017 * 0.00017, 0.0, 0.0,\n                     0.0, 0.00017 * 0.00017, 0.0,\n                     0.0, 0.0, 0.00017 * 0.00017]\n\n    ST2Data = inertialUKF.STMessage()\n\n    ST2Data.noise = [0.00017 * 0.00017, 0.0, 0.0,\n                     0.0, 0.00017 * 0.00017, 0.0,\n                     0.0, 0.0, 0.00017 * 0.00017]\n    STList = [ST1Data, ST2Data]\n    filterObject.STDatasStruct.STMessages = STList\n    filterObject.STDatasStruct.numST = len(STList)\n\n    filterObject.stateInit = [1.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    filterObject.covarInit = [0.04, 0.0, 0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.04, 0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.04, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.004, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0, 0.004, 0.0,\n                              0.0, 0.0, 0.0, 0.0, 0.0, 0.004]\n    qNoiseIn = numpy.identity(6)\n    qNoiseIn[0:3, 0:3] = qNoiseIn[0:3, 0:3]*0.0017*0.0017\n    qNoiseIn[3:6, 3:6] = qNoiseIn[3:6, 3:6]*0.00017*0.00017\n    filterObject.qNoise = qNoiseIn.reshape(36).tolist()\n\n    lpDataUse = inertialUKF.LowPassFilterData()\n    lpDataUse.hStep = 0.5\n    lpDataUse.omegCutoff = 15.0/(2.0*math.pi)\n    filterObject.gyroFilt = [lpDataUse, lpDataUse, lpDataUse]",
  "def all_inertial_kfTest(show_plots):\n    \"\"\"Module Unit Tests\"\"\"\n    # the following two tests appear to be broken\n    # [testResults, testMessage] = statePropInertialAttitude(show_plots)\n    # assert testResults < 1, testMessage\n    # [testResults, testMessage] = statePropRateInertialAttitude(show_plots)\n    # assert testResults < 1, testMessage\n    [testResults, testMessage] = stateUpdateInertialAttitude(show_plots)\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = stateUpdateRWInertialAttitude(show_plots)\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = filterMethods()\n    assert testResults < 1, testMessage",
  "def test_FilterMethods():\n    [testResults, testMessage] = filterMethods()\n    assert testResults < 1, testMessage",
  "def filterMethods():\n    \"\"\"Module Unit Test\"\"\"\n    testFailCount = 0\n    testMessages = []\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(1.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    accuracy = 1E-10\n    # Construct algorithm and associated C++ container\n    module = inertialUKF.inertialUKF()\n    module.ModelTag = \"inertialUKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    st1 = messaging.STAttMsgPayload()\n    st1.timeTag = macros.sec2nano(1.25)\n    st1.MRP_BdyInrtl = [0.1, 0.2, 0.3]\n    st2 = messaging.STAttMsgPayload()\n    st2.timeTag = macros.sec2nano(1.0)\n    st2.MRP_BdyInrtl = [0.2, 0.2, 0.3]\n    st3 = messaging.STAttMsgPayload()\n    st3.timeTag = macros.sec2nano(0.75)\n    st3.MRP_BdyInrtl = [0.3, 0.2, 0.3]\n\n    ST1Data = inertialUKF.STMessage()\n    ST2Data = inertialUKF.STMessage()\n    ST3Data = inertialUKF.STMessage()\n\n    STList = [ST1Data, ST2Data, ST3Data]\n\n    state = inertialUKF.new_doubleArray(6)\n    stateInput = numpy.array([1., 0., 0., 0.1, 0.1, 0.1])\n    for i in range(len(stateInput)):\n        inertialUKF.doubleArray_setitem(state, i, stateInput[i])\n\n    wheelAccel = numpy.array([-5, 5]) / 1. * numpy.array([1., 1])\n    angAccel = -0.5 * (wheelAccel[0] + wheelAccel[1]) * numpy.array([1., 0., 0])\n    expectedRate = numpy.array(stateInput[3:]) + angAccel\n\n    inertialUKF.inertialStateProp(module.getConfig(), state, 0.5)\n    stateOut = []\n    for j in range(6):\n        stateOut.append(inertialUKF.doubleArray_getitem(state, j))\n\n    if numpy.linalg.norm(expectedRate - numpy.array(stateOut)[3:]) > accuracy:\n        testFailCount += 1\n        testMessages.append(\"Failed to capture wheel acceleration in inertialStateProp\")\n\n    setupFilterData(module)\n    vehicleConfigOut = messaging.VehicleConfigMsgPayload()\n    I = [1000., 0., 0.,\n     0., 800., 0.,\n     0., 0., 800.]\n    vehicleConfigOut.ISCPntB_B = I\n    vcInMsg = messaging.VehicleConfigMsg().write(vehicleConfigOut)\n\n    module.STDatasStruct.STMessages = STList\n    module.STDatasStruct.numST = len(STList)\n    unitTestSim.AddVariableForLogging('inertialUKF.stSensorOrder', testProcessRate, 0, 3, 'double')\n\n    # create ST input messages\n    st1InMsg = messaging.STAttMsg().write(st1)\n    st2InMsg = messaging.STAttMsg().write(st2)\n    st3InMsg = messaging.STAttMsg().write(st3)\n\n    # make input messages but don't write to them\n    rwSpeedInMsg = messaging.RWSpeedMsg()\n    rwConfigInMsg = messaging.RWArrayConfigMsg()\n    gyroInMsg = messaging.AccDataMsg()\n\n    # connect messages\n    module.STDatasStruct.STMessages[0].stInMsg.subscribeTo(st1InMsg)\n    module.STDatasStruct.STMessages[1].stInMsg.subscribeTo(st2InMsg)\n    module.STDatasStruct.STMessages[2].stInMsg.subscribeTo(st3InMsg)\n    module.massPropsInMsg.subscribeTo(vcInMsg)\n    module.rwSpeedsInMsg.subscribeTo(rwSpeedInMsg)\n    module.rwParamsInMsg.subscribeTo(rwConfigInMsg)\n    module.gyrBuffInMsgName.subscribeTo(gyroInMsg)\n\n    # Star Tracker Read Message and Order method\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(1E9)\n    unitTestSim.ExecuteSimulation()\n\n    stOrdered = unitTestSim.GetLogVariableData('inertialUKF.stSensorOrder')\n    if numpy.linalg.norm(numpy.array(stOrdered[0]) - numpy.array([0., 2, 1, 0, 0])) > accuracy:\n        testFailCount += 1\n        testMessages.append(\"ST order test failed\")\n\n    unitTestSupport.writeTeXSnippet(\"toleranceValue00\", str(accuracy), path)\n    if testFailCount == 0:\n        print('Passed: test_FilterMethods')\n        unitTestSupport.writeTeXSnippet(\"passFail00\", textSnippetPassed, path)\n    else:\n        print('Failed: test_FilterMethods')\n        unitTestSupport.writeTeXSnippet(\"passFail00\", textSnippetFailed, path)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_stateUpdateInertialAttitude(show_plots):\n    [testResults, testMessage] = stateUpdateInertialAttitude(show_plots)\n    assert testResults < 1, testMessage",
  "def stateUpdateInertialAttitude(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = inertialUKF.inertialUKF()\n    module.ModelTag = \"InertialUKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n    module.maxTimeJump = 10\n\n    vehicleConfigOut = messaging.VehicleConfigMsgPayload()\n    I = [1000., 0., 0.,\n         0., 800., 0.,\n         0., 0., 800.]\n    vehicleConfigOut.ISCPntB_B = I\n    vcInMsg = messaging.VehicleConfigMsg().write(vehicleConfigOut)\n\n    stMessage1 = messaging.STAttMsgPayload()\n    stMessage1.MRP_BdyInrtl = [0.3, 0.4, 0.5]\n    st1InMsg = messaging.STAttMsg()\n\n    stMessage2 = messaging.STAttMsgPayload()\n    stMessage2.MRP_BdyInrtl = [0.3, 0.4, 0.5]\n    st2InMsg = messaging.STAttMsg()\n\n#    stateTarget = testVector.tolist()\n#    stateTarget.extend([0.0, 0.0, 0.0])\n#    module.state = [0.7, 0.7, 0.0]\n    unitTestSim.AddVariableForLogging('InertialUKF.covar', testProcessRate*10, 0, 35, 'double')\n    unitTestSim.AddVariableForLogging('InertialUKF.state', testProcessRate*10, 0, 5, 'double')\n\n    # make input messages but don't write to them\n    rwSpeedInMsg = messaging.RWSpeedMsg()\n    rwConfigInMsg = messaging.RWArrayConfigMsg()\n    gyroInMsg = messaging.AccDataMsg()\n\n    # connect messages\n    module.STDatasStruct.STMessages[0].stInMsg.subscribeTo(st1InMsg)\n    module.STDatasStruct.STMessages[1].stInMsg.subscribeTo(st2InMsg)\n    module.massPropsInMsg.subscribeTo(vcInMsg)\n    module.rwSpeedsInMsg.subscribeTo(rwSpeedInMsg)\n    module.rwParamsInMsg.subscribeTo(rwConfigInMsg)\n    module.gyrBuffInMsgName.subscribeTo(gyroInMsg)\n\n    unitTestSim.InitializeSimulation()\n\n    for i in range(20000):\n        if i > 21:\n            stMessage1.timeTag = int(i*0.5*1E9)\n            stMessage2.timeTag = int(i*0.5*1E9)\n            st1InMsg.write(stMessage1, unitTestSim.TotalSim.CurrentNanos)\n            st2InMsg.write(stMessage2, unitTestSim.TotalSim.CurrentNanos)\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i+1)*0.5))\n        unitTestSim.ExecuteSimulation()\n\n    covarLog = unitTestSim.GetLogVariableData('InertialUKF.covar')\n    stateLog = unitTestSim.GetLogVariableData('InertialUKF.state')\n    accuracy = 1.0E-5\n    unitTestSupport.writeTeXSnippet(\"toleranceValue11\", str(accuracy), path)\n    for i in range(3):\n        if(covarLog[-1, i*6+1+i] > covarLog[0, i*6+1+i]):\n            testFailCount += 1\n            testMessages.append(\"Covariance update failure\")\n            unitTestSupport.writeTeXSnippet('passFail11', textSnippetFailed, path)\n        else:\n            unitTestSupport.writeTeXSnippet('passFail11', textSnippetPassed, path)\n        if(abs(stateLog[-1, i+1] - stMessage1.MRP_BdyInrtl[i]) > accuracy):\n            print(abs(stateLog[-1, i+1] - stMessage1.MRP_BdyInrtl[i]))\n            testFailCount += 1\n            testMessages.append(\"State update failure\")\n            unitTestSupport.writeTeXSnippet('passFail11', textSnippetFailed, path)\n        else:\n            unitTestSupport.writeTeXSnippet('passFail11', textSnippetPassed, path)\n\n    stMessage1.MRP_BdyInrtl = [1.2, 0.0, 0.0]\n    stMessage2.MRP_BdyInrtl = [1.2, 0.0, 0.0]\n\n    for i in range(20000):\n        if i > 20:\n            stMessage1.timeTag = int((i+20000)*0.25*1E9)\n            stMessage2.timeTag = int((i+20000)*0.5*1E9)\n            st1InMsg.write(stMessage1, unitTestSim.TotalSim.CurrentNanos)\n            st2InMsg.write(stMessage2, unitTestSim.TotalSim.CurrentNanos)\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i+20000+1)*0.5))\n        unitTestSim.ExecuteSimulation()\n\n\n    covarLog = unitTestSim.GetLogVariableData('InertialUKF.covar')\n    stateLog = unitTestSim.GetLogVariableData('InertialUKF.state')\n    for i in range(3):\n        if(covarLog[-1, i*6+1+i] > covarLog[0, i*6+1+i]):\n            testFailCount += 1\n            testMessages.append(\"Covariance update large failure\")\n            unitTestSupport.writeTeXSnippet('passFail11', textSnippetFailed, path)\n        else:\n            unitTestSupport.writeTeXSnippet('passFail11', textSnippetPassed, path)\n    plt.figure()\n    for i in range(module.numStates):\n        plt.plot(stateLog[:,0]*1.0E-9, stateLog[:,i+1], label='State_' +str(i))\n        plt.legend()\n        plt.ylim([-1, 1])\n\n    unitTestSupport.writeFigureLaTeX('Test11', 'Test 1 State convergence', plt, 'width=0.9\\\\textwidth, keepaspectratio', path)\n    plt.figure()\n    for i in range(module.numStates):\n        plt.plot(covarLog[:,0]*1.0E-9, covarLog[:,i*module.numStates+i+1], label='Covar_' +str(i))\n        plt.legend()\n        plt.ylim([0, 2.E-7])\n\n    unitTestSupport.writeFigureLaTeX('Test12', 'Test 1 Covariance convergence', plt, 'width=0.9\\\\textwidth, keepaspectratio', path)\n    if(show_plots):\n        plt.show()\n        plt.close('all')\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print('Passed: test_StateUpdateInertialAttitude')\n    else:\n        print('Failed: test_StateUpdateInertialAttitude')\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def BROKENtest_statePropInertialAttitude(show_plots):\n    [testResults, testMessage] = statePropInertialAttitude(show_plots)\n    assert testResults < 1, testMessage",
  "def statePropInertialAttitude(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = inertialUKF.inertialUKF()\n    module.ModelTag = \"InertialUKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n    vehicleConfigOut = messaging.VehicleConfigMsgPayload()\n    I = [1000., 0., 0.,\n         0., 800., 0.,\n         0., 0., 800.]\n    vehicleConfigOut.ISCPntB_B = I\n    vcInMsg = messaging.VehicleConfigMsg().write(vehicleConfigOut)\n\n\n    unitTestSim.AddVariableForLogging('InertialUKF.covar', testProcessRate*10, 0, 35)\n    unitTestSim.AddVariableForLogging('InertialUKF.state', testProcessRate*10, 0, 5)\n\n    # make input messages but don't write to them\n    rwSpeedInMsg = messaging.RWSpeedMsg()\n    rwConfigInMsg = messaging.RWArrayConfigMsg()\n    gyroInMsg = messaging.AccDataMsg()\n    st1InMsg = messaging.STAttMsg()\n    st2InMsg = messaging.STAttMsg()\n\n    # connect messages\n    module.STDatasStruct.STMessages[0].stInMsg.subscribeTo(st1InMsg)\n    module.STDatasStruct.STMessages[1].stInMsg.subscribeTo(st2InMsg)\n    module.massPropsInMsg.subscribeTo(vcInMsg)\n    module.rwSpeedsInMsg.subscribeTo(rwSpeedInMsg)\n    module.rwParamsInMsg.subscribeTo(rwConfigInMsg)\n    module.gyrBuffInMsgName.subscribeTo(gyroInMsg)\n\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(8000.0))\n    unitTestSim.ExecuteSimulation()\n\n    covarLog = unitTestSim.GetLogVariableData('InertialUKF.covar')\n    stateLog = unitTestSim.GetLogVariableData('InertialUKF.state')\n\n    accuracy = 1.0E-10\n    unitTestSupport.writeTeXSnippet(\"toleranceValue22\", str(accuracy), path)\n    for i in range(6):\n        if(abs(stateLog[-1, i+1] - stateLog[0, i+1]) > accuracy):\n            testFailCount += 1\n            testMessages.append(\"State propagation failure\")\n            unitTestSupport.writeTeXSnippet('passFail22', textSnippetFailed, path)\n        else:\n            unitTestSupport.writeTeXSnippet('passFail22', textSnippetPassed, path)\n\n    for i in range(6):\n       if(covarLog[-1, i*6+i+1] <= covarLog[0, i*6+i+1]):\n           testFailCount += 1\n           testMessages.append(\"State covariance failure i=\"+str(i))\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag + \" state propagation\")\n    else:\n        print('Failed: test_StatePropInertialAttitude')\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def test_stateUpdateRWInertialAttitude(show_plots):\n    [testResults, testMessage] = stateUpdateRWInertialAttitude(show_plots)\n    assert testResults < 1, testMessage",
  "def stateUpdateRWInertialAttitude(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = inertialUKF.inertialUKF()\n    module.ModelTag = \"InertialUKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n\n    vehicleConfigOut = messaging.VehicleConfigMsgPayload()\n    I = [1000., 0., 0.,\n         0., 800., 0.,\n         0., 0., 800.]\n    vehicleConfigOut.ISCPntB_B = I\n    vcInMsg = messaging.VehicleConfigMsg().write(vehicleConfigOut)\n\n    rwArrayConfigOut = messaging.RWArrayConfigMsgPayload()\n    rwArrayConfigOut.numRW = 3\n    rwConfigInMsg = messaging.RWArrayConfigMsg().write(rwArrayConfigOut)\n\n\n    rwSpeedIntMsg = messaging.RWSpeedMsgPayload()\n    rwSpeedIntMsg.wheelSpeeds = [0.1, 0.01, 0.1]\n    rwSpeedIntMsg.wheelThetas = [0.,0.,0.]\n    rwSpeedInMsg = messaging.RWSpeedMsg().write(rwSpeedIntMsg)\n\n    stMessage1 = messaging.STAttMsgPayload()\n    stMessage1.MRP_BdyInrtl = [0.3, 0.4, 0.5]\n    st1InMsg = messaging.STAttMsg()\n\n    stMessage2 = messaging.STAttMsgPayload()\n    stMessage2.MRP_BdyInrtl = [0.3, 0.4, 0.5]\n    st2InMsg = messaging.STAttMsg()\n\n    #    stateTarget = testVector.tolist()\n    #    stateTarget.extend([0.0, 0.0, 0.0])\n    #    module.state = [0.7, 0.7, 0.0]\n    unitTestSim.AddVariableForLogging('InertialUKF.covar', testProcessRate * 10, 0, 35, 'double')\n    unitTestSim.AddVariableForLogging('InertialUKF.state', testProcessRate * 10, 0, 5, 'double')\n\n    # make input messages but don't write to them\n    gyroInMsg = messaging.AccDataMsg()\n\n    # connect messages\n    module.STDatasStruct.STMessages[0].stInMsg.subscribeTo(st1InMsg)\n    module.STDatasStruct.STMessages[1].stInMsg.subscribeTo(st2InMsg)\n    module.massPropsInMsg.subscribeTo(vcInMsg)\n    module.rwSpeedsInMsg.subscribeTo(rwSpeedInMsg)\n    module.rwParamsInMsg.subscribeTo(rwConfigInMsg)\n    module.gyrBuffInMsgName.subscribeTo(gyroInMsg)\n\n    unitTestSim.InitializeSimulation()\n\n    for i in range(20000):\n        if i > 20:\n            stMessage1.timeTag = int(i * 0.5 * 1E9)\n            stMessage2.timeTag = int(i * 0.5 * 1E9)\n            st1InMsg.write(stMessage1, unitTestSim.TotalSim.CurrentNanos)\n            st2InMsg.write(stMessage2, unitTestSim.TotalSim.CurrentNanos)\n\n        if i==10000:\n            rwSpeedIntMsg.wheelSpeeds = [0.5, 0.1, 0.05]\n            rwSpeedInMsg.write(rwSpeedIntMsg, 0)\n\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i + 1) * 0.5))\n        unitTestSim.ExecuteSimulation()\n\n    covarLog = unitTestSim.GetLogVariableData('InertialUKF.covar')\n    stateLog = unitTestSim.GetLogVariableData('InertialUKF.state')\n    accuracy = 1.0E-5\n    unitTestSupport.writeTeXSnippet(\"toleranceValue33\", str(accuracy), path)\n    for i in range(3):\n        if (covarLog[-1, i * 6 + 1 + i] > covarLog[0, i * 6 + 1 + i]):\n            testFailCount += 1\n            testMessages.append(\"Covariance update with RW failure\")\n        if (abs(stateLog[-1, i + 1] - stMessage1.MRP_BdyInrtl[i]) > accuracy):\n            print(abs(stateLog[-1, i + 1] - stMessage1.MRP_BdyInrtl[i]))\n            testFailCount += 1\n            testMessages.append(\"State update with RW failure\")\n            unitTestSupport.writeTeXSnippet('passFail33', textSnippetFailed, path)\n        else:\n            unitTestSupport.writeTeXSnippet('passFail33', textSnippetPassed, path)\n\n    stMessage1.MRP_BdyInrtl = [1.2, 0.0, 0.0]\n    stMessage2.MRP_BdyInrtl = [1.2, 0.0, 0.0]\n\n    for i in range(20000):\n        if i > 20:\n            stMessage1.timeTag = int((i + 20000) * 0.25 * 1E9)\n            stMessage2.timeTag = int((i + 20000) * 0.5 * 1E9)\n            st1InMsg.write(stMessage1, unitTestSim.TotalSim.CurrentNanos)\n            st2InMsg.write(stMessage2, unitTestSim.TotalSim.CurrentNanos)\n\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i + 20000 + 1) * 0.5))\n        unitTestSim.ExecuteSimulation()\n\n    covarLog = unitTestSim.GetLogVariableData('InertialUKF.covar')\n    stateLog = unitTestSim.GetLogVariableData('InertialUKF.state')\n    for i in range(3):\n        if (covarLog[-1, i * 6 + 1 + i] > covarLog[0, i * 6 + 1 + i]):\n            testFailCount += 1\n            testMessages.append(\"Covariance update large failure\")\n            unitTestSupport.writeTeXSnippet('passFail33', textSnippetFailed, path)\n        else:\n            unitTestSupport.writeTeXSnippet('passFail33', textSnippetPassed, path)\n    plt.figure()\n    for i in range(module.numStates):\n        plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:, i + 1], label='State_' +str(i))\n        plt.legend()\n        plt.ylim([-1, 1])\n\n    unitTestSupport.writeFigureLaTeX('Test31', 'Test 3 State convergence', plt, 'width=0.7\\\\textwidth, keepaspectratio', path)\n    plt.figure()\n    for i in range(module.numStates):\n        plt.plot(covarLog[:, 0] * 1.0E-9, covarLog[:, i * module.numStates + i + 1], label='Covar_' +str(i))\n        plt.legend()\n        plt.ylim([0., 2E-7])\n\n    unitTestSupport.writeFigureLaTeX('Test32', 'Test 3 Covariance convergence', plt, 'width=0.7\\\\textwidth, keepaspectratio', path)\n    if (show_plots):\n        plt.show()\n        plt.close('all')\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag + \" state update with RW\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def BROKENtest_StatePropRateInertialAttitude(show_plots):\n    [testResults, testMessage] = statePropRateInertialAttitude(show_plots)\n    assert testResults < 1, testMessage",
  "def statePropRateInertialAttitude(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = inertialUKF.inertialUKF()\n    module.ModelTag = \"InertialUKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    module.alpha = 0.02\n    module.beta = 2.0\n    module.kappa = 0.0\n    module.switchMag = 1.2\n\n    module.stateInit = [1.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    module.covarInit = [0.04, 0.0, 0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.04, 0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.04, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.004, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0, 0.004, 0.0,\n                              0.0, 0.0, 0.0, 0.0, 0.0, 0.004]\n    qNoiseIn = numpy.identity(6)\n    qNoiseIn[0:3, 0:3] = qNoiseIn[0:3, 0:3] * 0.0017 * 0.0017\n    qNoiseIn[3:6, 3:6] = qNoiseIn[3:6, 3:6] * 0.00017 * 0.00017\n    module.qNoise = qNoiseIn.reshape(36).tolist()\n\n    ST1Data = inertialUKF.STMessage()\n    ST1Data.noise = [0.00017 * 0.00017, 0.0, 0.0,\n                         0.0, 0.00017 * 0.00017, 0.0,\n                         0.0, 0.0, 0.00017 * 0.00017]\n    STList = [ST1Data]\n    module.STDatasStruct.STMessages = STList\n    module.STDatasStruct.numST = len(STList)\n\n    lpDataUse = inertialUKF.LowPassFilterData()\n    lpDataUse.hStep = 0.5\n    lpDataUse.omegCutoff = 15.0 / (2.0 * math.pi)\n    module.gyroFilt = [lpDataUse, lpDataUse, lpDataUse]\n\n    vehicleConfigOut = messaging.VehicleConfigMsgPayload()\n    I = [1000., 0., 0.,\n         0., 800., 0.,\n         0., 0., 800.]\n    vehicleConfigOut.ISCPntB_B = I\n    vcInMsg = messaging.VehicleConfigMsg().write(vehicleConfigOut)\n\n    stateInit = [0.0, 0.0, 0.0, math.pi/18.0, 0.0, 0.0]\n    module.stateInit = stateInit\n    unitTestSim.AddVariableForLogging('InertialUKF.covar', testProcessRate*10, 0, 35)\n    unitTestSim.AddVariableForLogging('InertialUKF.sigma_BNOut', testProcessRate*10, 0, 2)\n    unitTestSim.AddVariableForLogging('InertialUKF.omega_BN_BOut', testProcessRate*10, 0, 2)\n\n    stMessage1 = messaging.STAttMsgPayload()\n    stMessage1.MRP_BdyInrtl = [0., 0., 0.]\n    stMessage1.timeTag = int(1* 1E9)\n    st1InMsg = messaging.STAttMsg()\n\n    # make input messages but don't write to them\n    rwSpeedInMsg = messaging.RWSpeedMsg()\n    rwConfigInMsg = messaging.RWArrayConfigMsg()\n    gyroInMsg = messaging.AccDataMsg()\n\n    # connect messages\n    module.STDatasStruct.STMessages[0].stInMsg.subscribeTo(st1InMsg)\n    module.massPropsInMsg.subscribeTo(vcInMsg)\n    module.rwSpeedsInMsg.subscribeTo(rwSpeedInMsg)\n    module.rwParamsInMsg.subscribeTo(rwConfigInMsg)\n    module.gyrBuffInMsgName.subscribeTo(gyroInMsg)\n\n    unitTestSim.InitializeSimulation()\n    st1InMsg.write(stMessage1, int(1 * 1E9))\n    gyroBufferData = messaging.AccDataMsgPayload()\n    for i in range(3600*2+1):\n        gyroBufferData.accPkts[i%inertialUKF.MAX_ACC_BUF_PKT].measTime = (int(i*0.5*1E9))\n        gyroBufferData.accPkts[i%inertialUKF.MAX_ACC_BUF_PKT].gyro_B = \\\n            [math.pi/18.0, 0.0, 0.0]\n        gyroInMsg.write(gyroBufferData, (int(i*0.5*1E9)))\n\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i+1)*0.5))\n        unitTestSim.ExecuteSimulation()\n\n    covarLog = unitTestSim.GetLogVariableData('InertialUKF.covar')\n    sigmaLog = unitTestSim.GetLogVariableData('InertialUKF.sigma_BNOut')\n    omegaLog = unitTestSim.GetLogVariableData('InertialUKF.omega_BN_BOut')\n    accuracy = 1.0E-3\n    unitTestSupport.writeTeXSnippet(\"toleranceValue44\", str(accuracy), path)\n    for i in range(3):\n        if(abs(omegaLog[-1, i+1] - stateInit[i+3]) > accuracy):\n            print(abs(omegaLog[-1, i+1] - stateInit[i+3]))\n            testFailCount += 1\n            testMessages.append(\"State omega propagation failure\")\n            unitTestSupport.writeTeXSnippet('passFail44', textSnippetFailed, path)\n        else:\n            unitTestSupport.writeTeXSnippet('passFail44', textSnippetPassed, path)\n\n    for i in range(6):\n       if(covarLog[-1, i*6+i+1] <= covarLog[0, i*6+i+1]):\n           testFailCount += 1\n           testMessages.append(\"State covariance failure\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag + \" state rate propagation\")\n    else:\n        print(\"Failed: \" + testMessages[0])\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def BROKENtest_FaultScenarios(show_plots):\n    [testResults, testMessage] = faultScenarios(show_plots)\n    assert testResults < 1, testMessage",
  "def faultScenarios(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Clean methods for Measurement and Time Updates\n    moduleConfigClean1 = inertialUKF.InertialUKFConfig()\n    moduleConfigClean1.numStates = 6\n    moduleConfigClean1.state = [0., 0., 0., 0., 0., 0.]\n    moduleConfigClean1.statePrev = [0., 0., 0., 0., 0., 0.]\n    moduleConfigClean1.sBar = [0., 0., 0., 0., 0., 0.,\n                               0., 0., 0., 0., 0., 0.,\n                               0., 0., 0., 0., 0., 0.,\n                               0., 0., 0., 0., 0., 0.,\n                               0., 0., 0., 0., 0., 0.,\n                               0., 0., 0., 0., 0., 0.]\n    moduleConfigClean1.sBarPrev = [1., 0., 0., 0., 0., 0.,\n                                   0., 1., 0., 0., 0., 0.,\n                                   0., 0., 1., 0., 0., 0.,\n                                   0., 0., 0., 1., 0., 0.,\n                                   0., 0., 0., 0., 1., 0.,\n                                   0., 0., 0., 0., 0., 1.]\n    moduleConfigClean1.covar = [0., 0., 0., 0., 0., 0.,\n                                0., 0., 0., 0., 0., 0.,\n                                0., 0., 0., 0., 0., 0.,\n                                0., 0., 0., 0., 0., 0.,\n                                0., 0., 0., 0., 0., 0.,\n                                0., 0., 0., 0., 0., 0.]\n    moduleConfigClean1.covarPrev = [2., 0., 0., 0., 0., 0.,\n                                    0., 2., 0., 0., 0., 0.,\n                                    0., 0., 2., 0., 0., 0.,\n                                    0., 0., 0., 2., 0., 0.,\n                                    0., 0., 0., 0., 2., 0.,\n                                    0., 0., 0., 0., 0., 2.]\n\n    inertialUKF.inertialUKFCleanUpdate(moduleConfigClean1)\n\n    if numpy.linalg.norm(numpy.array(moduleConfigClean1.covarPrev) - numpy.array(moduleConfigClean1.covar)) > 1E10:\n        testFailCount += 1\n        testMessages.append(\"inertialUKFClean Covar failed\")\n    if numpy.linalg.norm(numpy.array(moduleConfigClean1.statePrev) - numpy.array(moduleConfigClean1.state)) > 1E10:\n        testFailCount += 1\n        testMessages.append(\"inertialUKFClean States failed\")\n    if numpy.linalg.norm(numpy.array(moduleConfigClean1.sBar) - numpy.array(moduleConfigClean1.sBarPrev)) > 1E10:\n        testFailCount += 1\n        testMessages.append(\"inertialUKFClean sBar failed\")\n\n    # inertialStateProp rate test with time step difference\n    moduleConfigClean1.rwConfigParams.numRW = 2\n    moduleConfigClean1.rwSpeeds.wheelSpeeds = [10, 5]\n    moduleConfigClean1.rwSpeedPrev.wheelSpeeds = [15, 10]\n    moduleConfigClean1.rwConfigParams.JsList = [1., 1.]\n    moduleConfigClean1.rwConfigParams.GsMatrix_B = [1., 0., 0., 1., 0., 0.]\n    moduleConfigClean1.speedDt = 1.\n    #moduleConfigClean1.IInv = [1., 0., 0., 0., 1., 0., 0., 0., 1.]\n\n    # Bad Time and Measurement Update\n    st1 = messaging.STAttMsgPayload()\n    st1.timeTag = macros.sec2nano(1.)\n    st1.MRP_BdyInrtl = [0.1, 0.2, 0.3]\n\n    ST1Data = inertialUKF.STMessage()\n    ST1Data.noise = [1., 0., 0.,\n                     0., 1., 0.,\n                     0., 0., 1.]\n\n    STList = [ST1Data]\n\n    # make input messages but don't write to them\n    # rwSpeedInMsg = messaging.RWSpeedMsg()\n    # rwConfigInMsg = messaging.RWArrayConfigMsg()\n    # gyroInMsg = messaging.AccDataMsg()\n\n    # connect messages\n    # moduleConfig.STDatasStruct.STMessages[0].stInMsg.subscribeTo(st1InMsg)\n    # moduleConfig.massPropsInMsg.subscribeTo(vcInMsg)\n    # moduleConfig.rwSpeedsInMsg.subscribeTo(rwSpeedInMsg)\n    # moduleConfig.rwParamsInMsg.subscribeTo(rwConfigInMsg)\n    # moduleConfig.gyrBuffInMsgName.subscribeTo(gyroInMsg)\n    #\n    # moduleConfigClean1.navStateOutMsgName = \"inertial_state_estimate\"\n    # moduleConfigClean1.filtDataOutMsgName = \"inertial_filter_data\"\n    # moduleConfigClean1.massPropsInMsgName = \"adcs_config_data\"\n    # moduleConfigClean1.rwSpeedsInMsgName = \"reactionwheel_output_states\"\n    # moduleConfigClean1.rwParamsInMsgName = \"rwa_config_data_parsed\"\n    # moduleConfigClean1.gyrBuffInMsgName = \"gyro_buffer_data\"\n\n    moduleConfigClean1.alpha = 0.02\n    moduleConfigClean1.beta = 2.0\n    moduleConfigClean1.kappa = 0.0\n    moduleConfigClean1.switchMag = 1.2\n\n    moduleConfigClean1.countHalfSPs = moduleConfigClean1.numStates\n    moduleConfigClean1.STDatasStruct.STMessages = STList\n    moduleConfigClean1.STDatasStruct.numST = len(STList)\n    moduleConfigClean1.wC = [-1] * (moduleConfigClean1.numStates * 2 + 1)\n    moduleConfigClean1.wM = [-1] * (moduleConfigClean1.numStates * 2 + 1)\n    retTime = inertialUKF.inertialUKFTimeUpdate(moduleConfigClean1, 1)\n    retMease = inertialUKF.inertialUKFMeasUpdate(moduleConfigClean1, 1)\n    if retTime == 0:\n        testFailCount += 1\n        testMessages.append(\"Failed to catch bad Update and clean in Time update\")\n    if retMease == 0:\n        testFailCount += 1\n        testMessages.append(\"Failed to catch bad Update and clean in Meas update\")\n    moduleConfigClean1.wC = [1] * (moduleConfigClean1.numStates * 2 + 1)\n    moduleConfigClean1.wM = [1] * (moduleConfigClean1.numStates * 2 + 1)\n    qNoiseIn = numpy.identity(6)\n    qNoiseIn[0:3, 0:3] = -qNoiseIn[0:3, 0:3] * 0.0017 * 0.0017\n    qNoiseIn[3:6, 3:6] = -qNoiseIn[3:6, 3:6] * 0.00017 * 0.00017\n    moduleConfigClean1.qNoise = qNoiseIn.reshape(36).tolist()\n    retTime = inertialUKF.inertialUKFTimeUpdate(moduleConfigClean1, 1)\n    retMease = inertialUKF.inertialUKFMeasUpdate(moduleConfigClean1, 1)\n\n    if retTime == 0:\n        testFailCount += 1\n        testMessages.append(\"Failed to catch bad Update and clean in Time update\")\n    if retMease == 0:\n        testFailCount += 1\n        testMessages.append(\"Failed to catch bad Update and clean in Meas update\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: state rate propagation\")\n    else:\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StatesPlot(x, Pflat, show_plots):\n\n    numStates = len(x[0,:])-1\n\n    P = np.zeros([len(Pflat[:,0]),numStates,numStates])\n    t= np.zeros(len(Pflat[:,0]))\n    for i in range(len(Pflat[:,0])):\n        t[i] = x[i, 0]*1E-9\n        P[i,:,:] = Pflat[i,1:(numStates*numStates+1)].reshape([numStates,numStates])\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(t , x[:, 1], \"b\", label='Error Filter')\n    plt.plot(t , 3 * np.sqrt(P[:, 0, 0]), 'r--',  label='Covar Filter')\n    plt.plot(t , -3 * np.sqrt(P[:, 0, 0]), 'r--')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n\n    plt.subplot(323)\n    plt.plot(t , x[:, 2], \"b\")\n    plt.plot(t , 3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.plot(t , -3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.title('Second LOS component')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(t , x[:, 4], \"b\")\n    plt.plot(t , 3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.plot(t , -3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.title('Second rate component')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(t , x[:, 3], \"b\")\n    plt.plot(t , 3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.plot(t , -3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third LOS component')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(t , x[:, 5], \"b\")\n    plt.plot(t , 3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.plot(t , -3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesPlot', 'State error and covariance', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def StatesPlotCompare(x, x2, Pflat, Pflat2, show_plots):\n\n    numStates = len(x[0,:])-1\n\n    P = np.zeros([len(Pflat[:,0]),numStates,numStates])\n    P2 = np.zeros([len(Pflat[:,0]),numStates,numStates])\n    t= np.zeros(len(Pflat[:,0]))\n    for i in range(len(Pflat[:,0])):\n        t[i] = x[i, 0]*1E-9\n        P[i,:,:] = Pflat[i,1:(numStates*numStates+1)].reshape([numStates,numStates])\n        P2[i, :, :] = Pflat2[i, 1:(numStates*numStates+1)].reshape([numStates, numStates])\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(t[0:30] , x[0:30, 1], \"b\", label='Error Filter')\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 0, 0]), 'r--',  label='Covar Filter')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 0, 0]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 1], \"g\", label='Error Expected')\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 0, 0]), 'c--', label='Covar Expected')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 0, 0]), 'c--')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n    plt.subplot(323)\n    plt.plot(t[0:30] , x[0:30, 2], \"b\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 1, 1]), 'r--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 1, 1]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 2], \"g\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 1, 1]), 'c--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 1, 1]), 'c--')\n    plt.title('Second LOS component')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(t[0:30] , x[0:30, 4], \"b\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 3, 3]), 'r--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 3, 3]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 4], \"g\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 3, 3]), 'c--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 3, 3]), 'c--')\n    plt.title('Second rate component')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(t[0:30] , x[0:30, 3], \"b\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 2, 2]), 'r--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 2, 2]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 3], \"g\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 2, 2]), 'c--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 2, 2]), 'c--')\n    plt.xlabel('t(s)')\n    plt.title('Third LOS component')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(t[0:30] , x[0:30, 5], \"b\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 4, 4]), 'r--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 4, 4]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 5], \"g\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 4, 4]), 'c--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 4, 4]), 'c--')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesCompare', 'State error and covariance vs expected Values', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def PostFitResiduals(Res, noise, show_plots):\n\n    MeasNoise = np.zeros(len(Res[:,0]))\n    t= np.zeros(len(Res[:,0]))\n    for i in range(len(Res[:,0])):\n        t[i] = Res[i, 0]*1E-9\n        MeasNoise[i] = 3*noise\n        # Don't plot zero values, since they mean that no measurement is taken\n        for j in range(len(Res[0,:])-1):\n            if -1E-10 < Res[i,j+1] < 1E-10:\n                Res[i, j+1] = np.nan\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(421)\n    plt.plot(t , Res[:, 1], \"b.\", label='Residual')\n    plt.plot(t , MeasNoise, 'r--', label='Covar')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.legend(loc='lower right')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('First CSS')\n    plt.grid()\n\n    plt.subplot(422)\n    plt.plot(t , Res[:, 5], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Fifth CSS')\n    plt.grid()\n\n    plt.subplot(423)\n    plt.plot(t , Res[:, 2], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Second CSS')\n    plt.grid()\n\n    plt.subplot(424)\n    plt.plot(t , Res[:, 6], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Sixth CSS')\n    plt.grid()\n\n    plt.subplot(425)\n    plt.plot(t , Res[:, 3], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Third CSS')\n    plt.grid()\n\n    plt.subplot(426)\n    plt.plot(t , Res[:, 7], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Seventh CSS')\n    plt.grid()\n\n    plt.subplot(427)\n    plt.plot(t , Res[:, 4], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.xlabel('t(s)')\n    plt.title('Fourth CSS')\n    plt.grid()\n\n    plt.subplot(428)\n    plt.plot(t , Res[:, 8], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.xlabel('t(s)')\n    plt.title('Eight CSS')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('PostFit', 'Post Fit Residuals', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def StatesVsExpected(stateLog, expectedStateArray, show_plots):\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(stateLog[:, 0] * 1.0E-9, expectedStateArray[:,  1], 'b--', label='Expected')\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:,  1], 'r', label='Filter')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n    plt.subplot(323)\n    plt.plot(stateLog[:, 0] * 1.0E-9, expectedStateArray[:,  2], 'b--')\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:,  2], 'r')\n    plt.title('Second LOS component')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(stateLog[:, 0] * 1.0E-9, expectedStateArray[:,  4], 'b--')\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:,  4], 'r')\n    plt.title('Second rate component')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(stateLog[:, 0] * 1.0E-9, expectedStateArray[:,  3], 'b--')\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:,  3], 'r')\n    plt.xlabel('t(s)')\n    plt.title('Third LOS component')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(stateLog[:, 0] * 1.0E-9, expectedStateArray[:,  5], 'b--')\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:,  5], 'r')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesExpected', 'States vs true states in static case', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def StatesVsTargets(target1, target2, stateLog, show_plots):\n\n    numStates = len(stateLog[0,:])-1\n\n    target = np.ones([len(stateLog[:, 0]),5])\n    for i in range((len(stateLog[:, 0])-1)//2):\n        target[i, :] = target1\n        target[i+(len(stateLog[:, 0]) - 1) // 2,:] = target2\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:, 1], 'b', label='Filter')\n    plt.plot(stateLog[:, 0] * 1.0E-9, target[:, 0], 'r--', label='Expected')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n    plt.subplot(323)\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:, 2], 'b')\n    plt.plot(stateLog[:, 0] * 1.0E-9, target[:, 1], 'r--')\n    plt.title('Second LOS component')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:, 4], 'b')\n    plt.plot(stateLog[:, 0] * 1.0E-9, target[:, 3], 'r--')\n    plt.title('Second rate component')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:, 3], 'b')\n    plt.plot(stateLog[:, 0] * 1.0E-9, target[:, 2], 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third LOS component')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:, 5], 'b')\n    plt.plot(stateLog[:, 0] * 1.0E-9, target[:, 4], 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesTarget', 'States tracking target values', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def addTimeColumn(time, data):\n    return np.transpose(np.vstack([[time], np.transpose(data)]))",
  "def setupFilterData(filterObject):\n\n    filterObject.sensorUseThresh = 0.\n    filterObject.state = [0.1, 0.9, 0.1, 0.0, 0.0]\n    filterObject.x = [1.0, 0.0, 1.0, 0.0, 0.1]\n    filterObject.covar = [0.4, 0.0, 0.0, 0.0, 0.0,\n                          0.0, 0.4, 0.0, 0.0, 0.0,\n                          0.0, 0.0, 0.4, 0.0, 0.0,\n                          0.0, 0.0, 0.0, 0.004, 0.0,\n                          0.0, 0.0, 0.0, 0.0, 0.004]\n\n    filterObject.qProcVal = 0.1**2\n    filterObject.qObsVal = 0.001\n    filterObject.eKFSwitch = (4./3)**2",
  "def test_all_functions_sekf(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = sunline_individual_test()\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = StatePropStatic()\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = StatePropVariable(show_plots)\n    assert testResults < 1, testMessage",
  "def test_all_sunline_sekf(show_plots, SimHalfLength, AddMeasNoise, testVector1, testVector2, stateGuess):\n    [testResults, testMessage] = StateUpdateSunLine(show_plots, SimHalfLength, AddMeasNoise, testVector1, testVector2, stateGuess)\n    assert testResults < 1, testMessage",
  "def sunline_individual_test():\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    numStates = 5\n    numObs = 3\n\n    ###################################################################################\n    ## Testing dynamics matrix computation\n    ###################################################################################\n    inputStates = [2,1,0.75,0.1,0.4]\n    inputOmega_SB_S = [0.,0.1, 0.4]\n    bVec = [1.,0.,0.]\n    dt =0.5\n\n    dcm_BS = [1., 0., 0.,\n             0., 1., 0.,\n             0., 0., 1.]\n\n    # Fill in the variables for the test\n    dcm = sunlineSEKF.new_doubleArray(3 * 3)\n    for j in range(9):\n        sunlineSEKF.doubleArray_setitem(dcm, j, dcm_BS[j])\n    sunlineSEKF.sunlineSEKFComputeDCM_BS(inputStates[:3], bVec, dcm)\n\n    dcmOut = []\n    for j in range(9):\n        dcmOut.append(sunlineSEKF.doubleArray_getitem(dcm, j))\n\n    DCM_BS = np.array(dcmOut).reshape([3,3])\n\n    omega_SB_B = np.dot(DCM_BS, np.array(inputOmega_SB_S))\n    dtilde = RigidBodyKinematics.v3Tilde(np.array(inputStates)[:3])\n    dBS = np.dot(dtilde, DCM_BS)\n\n    expDynMat = np.zeros([numStates,numStates])\n    expDynMat[0:3, 0:3] =  np.array(RigidBodyKinematics.v3Tilde(omega_SB_B))\n    expDynMat[0:3, 3:numStates] = -dBS[:, 1:]\n\n    dynMat = sunlineSEKF.new_doubleArray(numStates*numStates)\n    for i in range(numStates*numStates):\n        sunlineSEKF.doubleArray_setitem(dynMat, i, 0.0)\n    sunlineSEKF.sunlineDynMatrix(inputStates, bVec, dt, dynMat)\n\n    DynOut = []\n    for i in range(numStates*numStates):\n        DynOut.append(sunlineSEKF.doubleArray_getitem(dynMat, i))\n\n    DynOut = np.array(DynOut).reshape(numStates, numStates)\n    errorNorm = np.linalg.norm(expDynMat - DynOut)\n    if(errorNorm > 1.0E-10):\n        print(errorNorm, \"Dyn Matrix\")\n        testFailCount += 1\n        testMessages.append(\"Dynamics Matrix generation Failure Dyn \" + \"\\n\")\n\n    ###################################################################################\n    ## STM and State Test\n    ###################################################################################\n\n    inputStates = [2,1,0.75,0.1,0.4]\n    inputOmega = [0.,0.1, 0.4]\n    bVec_test = [1,0,0]\n    dt = 0.5\n    stateTransition = sunlineSEKF.new_doubleArray(numStates*numStates)\n    states = sunlineSEKF.new_doubleArray(numStates)\n    bVec = sunlineSEKF.new_doubleArray(3)\n    for k in range(3):\n        sunlineSEKF.doubleArray_setitem(bVec, k, bVec_test[k])\n    for i in range(numStates):\n        sunlineSEKF.doubleArray_setitem(states, i, inputStates[i])\n        for j in range(numStates):\n            if i==j:\n                sunlineSEKF.doubleArray_setitem(stateTransition, numStates*i+j, 1.0)\n            else:\n                sunlineSEKF.doubleArray_setitem(stateTransition, numStates*i+j, 0.0)\n\n    sunlineSEKF.sunlineStateSTMProp(expDynMat.flatten().tolist(), bVec_test, dt, states, stateTransition)\n\n    PropStateOut = []\n    PropSTMOut = []\n    for i in range(numStates):\n        PropStateOut.append(sunlineSEKF.doubleArray_getitem(states, i))\n    for i in range(numStates*numStates):\n        PropSTMOut.append(sunlineSEKF.doubleArray_getitem(stateTransition, i))\n\n    dcm_BS = [1., 0., 0.,\n             0., 1., 0.,\n             0., 0., 1.]\n\n    # Fill in the variables for the test\n    dcm = sunlineSEKF.new_doubleArray(3 * 3)\n\n    for j in range(9):\n        sunlineSEKF.doubleArray_setitem(dcm, j, dcm_BS[j])\n\n    sunlineSEKF.sunlineSEKFComputeDCM_BS(inputStates[:3], bVec_test, dcm)\n\n    dcmOut = []\n    for j in range(9):\n        dcmOut.append(sunlineSEKF.doubleArray_getitem(dcm, j))\n\n    DCM_BS = np.array(dcmOut).reshape([3,3])\n    STMout = np.array(PropSTMOut).reshape([numStates,numStates])\n    StatesOut = np.array(PropStateOut)\n\n    expectedSTM = dt*np.dot(expDynMat, np.eye(numStates)) + np.eye(numStates)\n    expectedStates = np.zeros(numStates)\n    ## Equations when removing the unobservable states from d_dot\n    expectedStates[3:numStates] = np.array(inputOmega)[1:3]\n    expectedStates[0:3] = np.array(inputStates)[0:3]+dt*np.cross(np.dot(DCM_BS,np.array(inputOmega)), np.array(inputStates)[0:3])\n    errorNormSTM = np.linalg.norm(expectedSTM - STMout)\n    errorNormStates = np.linalg.norm(expectedStates - StatesOut)\n\n    if(errorNormSTM > 1.0E-10):\n        testFailCount += 1\n        testMessages.append(\"STM Propagation Failure Dyn \"  + \"\\n\")\n\n    if(errorNormStates > 1.0E-10):\n        testFailCount += 1\n        testMessages.append(\"State Propagation Failure Dyn \" + \"\\n\")\n\n    ###################################################################################\n    ## Test the H and yMeas matrix generation as well as the observation count\n    ###################################################################################\n\n    numCSS = 4\n    cssCos = [np.cos(np.deg2rad(10.)), np.cos(np.deg2rad(25.)), np.cos(np.deg2rad(5.)), np.cos(np.deg2rad(90.))]\n    sensorTresh = np.cos(np.deg2rad(50.))\n    cssNormals = [1.,0.,0.,0.,1.,0., 0.,0.,1., 1./np.sqrt(2), 1./np.sqrt(2),0.]\n    dcmArray_BS = RigidBodyKinematics.MRP2C([0.1,-0.15,0.2])\n    dcm_BS = (dcmArray_BS.flatten()).tolist()\n\n    measMat = sunlineSEKF.new_doubleArray(8*numStates)\n    obs = sunlineSEKF.new_doubleArray(8)\n    yMeas = sunlineSEKF.new_doubleArray(8)\n    numObs = sunlineSEKF.new_intArray(1)\n\n    for i in range(8*numStates):\n        sunlineSEKF.doubleArray_setitem(measMat, i, 0.)\n    for i in range(8):\n        sunlineSEKF.doubleArray_setitem(obs, i, 0.0)\n        sunlineSEKF.doubleArray_setitem(yMeas, i, 0.0)\n\n    sunlineSEKF.sunlineHMatrixYMeas(inputStates, numCSS, cssCos, sensorTresh, cssNormals, obs, yMeas, numObs, measMat)\n\n    obsOut = []\n    yMeasOut = []\n    numObsOut = []\n    HOut = []\n    for i in range(8*numStates):\n        HOut.append(sunlineSEKF.doubleArray_getitem(measMat, i))\n    for i in range(8):\n        yMeasOut.append(sunlineSEKF.doubleArray_getitem(yMeas, i))\n        obsOut.append(sunlineSEKF.doubleArray_getitem(obs, i))\n    numObsOut.append(sunlineSEKF.intArray_getitem(numObs, 0))\n\n    #Fill in expected values for test\n    expectedH = np.zeros([8,numStates])\n    expectedY = np.zeros(8)\n    for j in range(3):\n        expectedH[j,0:3] = np.eye(3)[j,:]\n        expectedY[j] =np.array(cssCos[j]) - np.dot( np.array(inputStates)[0:3], np.array(cssNormals)[j*3:(j+1)*3])\n    expectedObs = np.array([np.cos(np.deg2rad(10.)), np.cos(np.deg2rad(25.)), np.cos(np.deg2rad(5.)),0.,0.,0.,0.,0.])\n    expectedNumObs = 3\n\n    HOut = np.array(HOut).reshape([8, numStates])\n    errorNorm = np.zeros(4)\n    errorNorm[0] = np.linalg.norm(HOut - expectedH)\n    errorNorm[1] = np.linalg.norm(yMeasOut - expectedY)\n    errorNorm[2] = np.linalg.norm(obsOut - expectedObs)\n    errorNorm[3] = np.linalg.norm(numObsOut[0] - expectedNumObs)\n\n    for i in range(4):\n        if(errorNorm[i] > 1.0E-10):\n            testFailCount += 1\n            testMessages.append(\"H and yMeas update failure \\n\")\n\n    ###################################################################################\n    ## Test the Kalman Gain\n    ###################################################################################\n\n    numObs = 3\n    h = [1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0.,\n         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]\n    covar = [1., 0., 0., 1., 0.,\n             0., 1., 0., 0., 1.,\n             0., 0., 1., 0., 0.,\n             1., 0., 0., 1., 0.,\n             0., 1., 0., 0., 1.]\n    noise= 0.01\n\n    Kalman = sunlineSEKF.new_doubleArray(numStates * 8)\n\n    for i in range(8 * numStates):\n        sunlineSEKF.doubleArray_setitem(Kalman, i, 0.)\n\n    sunlineSEKF.sunlineKalmanGain(covar, h, noise, numObs, Kalman)\n\n    KalmanOut = []\n    for i in range(8 * numStates):\n        KalmanOut.append(sunlineSEKF.doubleArray_getitem(Kalman, i))\n\n    # Fill in expected values for test\n    Hmat = np.array(h).reshape([8,numStates])\n    Pk = np.array(covar).reshape([numStates,numStates])\n    R = noise*np.eye(numObs)\n    expectedK = np.dot(np.dot(Pk, Hmat[0:numObs,:].T), np.linalg.inv(np.dot(np.dot(Hmat[0:numObs,:], Pk), Hmat[0:numObs,:].T) + R[0:numObs,0:numObs]))\n\n    KalmanOut = np.array(KalmanOut)[0:numStates*numObs].reshape([numStates, numObs])\n    errorNorm = np.linalg.norm(KalmanOut[:,0:numObs] - expectedK)\n\n    if (errorNorm > 1.0E-10):\n        print(errorNorm, \"Kalman Gain Error\")\n        testFailCount += 1\n        testMessages.append(\"Kalman Gain update failure \\n\")\n\n    ###################################################################################\n    ## Test the EKF update\n    ###################################################################################\n\n    KGain = [1., 2., 3., 0., 1., 1., 0., 1., 0., 1., 3., 0., 1., 0., 2.]\n    for i in range(numStates*8-numStates*numObs):\n        KGain.append(0.)\n    inputStates = [2,1,0.75,0.1,0.4]\n    xbar = [0.1, 0.2, 0.01, 0.005, 0.009]\n    numObs = 3\n    h = [1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0.,\n         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]\n    covar = [1., 0., 0., 1., 0.,\n             0., 1., 0., 0., 1.,\n             0., 0., 1., 0., 0.,\n             1., 0., 0., 1., 0.,\n             0., 1., 0., 0., 1.]\n    noise = 0.01\n    inputY = np.zeros(3)\n    for j in range(3):\n        inputY[j] = np.array(cssCos[j]) - np.dot(np.array(inputStates)[0:3], np.array(cssNormals)[j * 3:(j + 1) * 3])\n    inputY = inputY.tolist()\n\n    stateError = sunlineSEKF.new_doubleArray(numStates)\n    covarMat = sunlineSEKF.new_doubleArray(numStates*numStates)\n    inputs = sunlineSEKF.new_doubleArray(numStates)\n\n\n    for i in range(numStates):\n        sunlineSEKF.doubleArray_setitem(stateError, i, 0.)\n        sunlineSEKF.doubleArray_setitem(inputs, i, inputStates[i])\n        for j in range(numStates):\n            sunlineSEKF.doubleArray_setitem(covarMat,i+j,0.)\n\n    sunlineSEKF.sunlineSEKFUpdate(KGain, covar, noise, numObs, inputY, h, inputs, stateError, covarMat)\n\n    stateOut = []\n    covarOut = []\n    errorOut = []\n    for i in range(numStates):\n        stateOut.append(sunlineSEKF.doubleArray_getitem(inputs, i))\n        errorOut.append(sunlineSEKF.doubleArray_getitem(stateError, i))\n    for j in range(numStates*numStates):\n        covarOut.append(sunlineSEKF.doubleArray_getitem(covarMat, j))\n\n    # Fill in expected values for test\n    KK = np.array(KGain)[0:numStates*3].reshape([numStates,3])\n    expectedStates = np.array(inputStates) + np.dot(KK, np.array(inputY))\n    H = np.array(h).reshape([8,numStates])[0:3,:]\n    Pk = np.array(covar).reshape([numStates, numStates])\n    R = noise * np.eye(3)\n    expectedP = np.dot(np.dot(np.eye(numStates) - np.dot(KK, H), Pk), np.transpose(np.eye(numStates) - np.dot(KK, H))) + np.dot(KK, np.dot(R,KK.T))\n\n    errorNorm = np.zeros(2)\n    errorNorm[0] = np.linalg.norm(np.array(stateOut) - expectedStates)\n    errorNorm[1] = np.linalg.norm(expectedP - np.array(covarOut).reshape([numStates,numStates]))\n\n    for i in range(2):\n        if(errorNorm[i] > 1.0E-10):\n            testFailCount += 1\n            testMessages.append(\"EKF update failure \\n\")\n\n    ###################################################################################\n    ## Test the CKF update\n    ###################################################################################\n\n    KGain = [1., 2., 3., 0., 1., 1., 0., 1., 0., 1., 3., 0., 1., 0., 2.]\n    for i in range(numStates * 8 - numStates * 3):\n        KGain.append(0.)\n    inputStates = [2,1,0.75,0.1,0.4]\n    xbar = [0.1, 0.2, 0.01, 0.005, 0.009]\n    h = [1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0.,\n         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]\n    covar = [1., 0., 0., 1., 0.,\n             0., 1., 0., 0., 1.,\n             0., 0., 1., 0., 0.,\n             1., 0., 0., 1., 0.,\n             0., 1., 0., 0., 1.]\n    noise =0.01\n    inputY = np.zeros(numObs)\n    for j in range(numObs):\n        inputY[j] = np.array(cssCos[j]) - np.dot(np.array(inputStates)[0:3],\n                                                 np.array(cssNormals)[j * 3:(j + 1) * 3])\n    inputY = inputY.tolist()\n\n    stateError = sunlineSEKF.new_doubleArray(numStates)\n    covarMat = sunlineSEKF.new_doubleArray(numStates * numStates)\n\n    for i in range(numStates):\n        sunlineSEKF.doubleArray_setitem(stateError, i, xbar[i])\n        for j in range(numStates):\n            sunlineSEKF.doubleArray_setitem(covarMat, i + j, 0.)\n\n    sunlineSEKF.sunlineCKFUpdate(xbar, KGain, covar, noise, numObs, inputY, h, stateError, covarMat)\n\n    covarOut = []\n    errorOut = []\n    for i in range(numStates):\n        errorOut.append(sunlineSEKF.doubleArray_getitem(stateError, i))\n    for j in range(numStates*numStates):\n        covarOut.append(sunlineSEKF.doubleArray_getitem(covarMat, j))\n\n    # Fill in expected values for test\n    KK = np.array(KGain)[0:numStates * numObs].reshape([numStates, numObs])\n    H = np.array(h).reshape([8, numStates])[0:3, :]\n    expectedStateError = np.array(xbar) + np.dot(KK, (np.array(inputY) - np.dot(H, np.array(xbar))))\n    Pk = np.array(covar).reshape([numStates, numStates])\n    expectedP = np.dot(np.dot(np.eye(numStates) - np.dot(KK, H), Pk), np.transpose(np.eye(numStates) - np.dot(KK, H))) + np.dot(KK,\n                                                                                                                np.dot(\n                                                                                                                    R,\n                                                                                                                    KK.T))\n\n    errorNorm = np.zeros(2)\n    errorNorm[0] = np.linalg.norm(np.array(errorOut) - expectedStateError)\n    errorNorm[1] = np.linalg.norm(expectedP - np.array(covarOut).reshape([numStates, numStates]))\n\n    for i in range(2):\n        if (errorNorm[i] > 1.0E-10):\n            testFailCount += 1\n            testMessages.append(\"CKF update failure \\n\")\n\n    ###################################################################################\n    ## Test the sunlineSEKFComputeDCM_BS method\n    ###################################################################################\n\n    inputStates = [2, 1, 0.75, 0.1, 0.4]\n    sunheading = inputStates[:3]\n    bvec1 = [0., 1., 0.]\n    b1 = np.array(bvec1)\n\n    dcm_BS = [1., 0., 0.,\n             0., 1., 0.,\n             0., 0., 1.]\n\n    # Fill in expected values for test\n\n    DCM_exp = np.zeros([3,3])\n    W_exp = np.eye(numStates)\n\n    DCM_exp[:, 0] = np.array(inputStates[0:3]) / (np.linalg.norm(np.array(inputStates[0:3])))\n    DCM_exp[:, 1] = np.cross(DCM_exp[:, 0], b1) / np.linalg.norm(np.array(np.cross(DCM_exp[:, 0], b1)))\n    DCM_exp[:, 2] = np.cross(DCM_exp[:, 0], DCM_exp[:, 1]) / np.linalg.norm(\n        np.cross(DCM_exp[:, 0], DCM_exp[:, 1]))\n\n    # Fill in the variables for the test\n    dcm = sunlineSEKF.new_doubleArray(3 * 3)\n\n    for j in range(9):\n        sunlineSEKF.doubleArray_setitem(dcm, j, dcm_BS[j])\n\n    sunlineSEKF.sunlineSEKFComputeDCM_BS(sunheading, bvec1, dcm)\n\n    switchBSout = []\n    dcmOut = []\n    for j in range(9):\n        dcmOut.append(sunlineSEKF.doubleArray_getitem(dcm, j))\n\n\n    errorNorm = np.zeros(1)\n    errorNorm[0] = np.linalg.norm(DCM_exp - np.array(dcmOut).reshape([3, 3]))\n\n    for i in range(len(errorNorm)):\n        if (errorNorm[i] > 1.0E-10):\n            testFailCount += 1\n            testMessages.append(\"Frame switch failure \\n\")\n\n    ###################################################################################\n    ## Test the Switching method\n    ###################################################################################\n\n    inputStates = [2,1,0.75,0.1,0.4]\n    bvec1 = [0.,1.,0.]\n    b1 = np.array(bvec1)\n    covar = [1., 0., 0., 1., 0.,\n             0., 1., 0., 0., 1.,\n             0., 0., 1., 0., 0.,\n             1., 0., 0., 1., 0.,\n             0., 1., 0., 0., 1.]\n    noise =0.01\n\n    # Fill in expected values for test\n\n    DCM_BSold = np.zeros([3,3])\n    DCM_BSnew = np.zeros([3,3])\n    Switch = np.eye(numStates)\n    SwitchBSold = np.eye(numStates)\n    SwitchBSnew = np.eye(numStates)\n\n    DCM_BSold[:,0] = np.array(inputStates[0:3])/(np.linalg.norm(np.array(inputStates[0:3])))\n    DCM_BSold[:,1] = np.cross(DCM_BSold[:,0], b1)/np.linalg.norm(np.array(np.cross(DCM_BSold[:,0], b1)))\n    DCM_BSold[:,2] = np.cross(DCM_BSold[:,0], DCM_BSold[:,1])/np.linalg.norm(np.cross(DCM_BSold[:,0], DCM_BSold[:,1]))\n    SwitchBSold[3:5, 3:5] = DCM_BSold[1:3, 1:3]\n\n    b2 = np.array([1.,0.,0.])\n    DCM_BSnew[:,0] = np.array(inputStates[0:3])/(np.linalg.norm(np.array(inputStates[0:3])))\n    DCM_BSnew[:,1] = np.cross(DCM_BSnew[:,0], b2)/np.linalg.norm(np.array(np.cross(DCM_BSnew[:,0], b2)))\n    DCM_BSnew[:,2] = np.cross(DCM_BSnew[:,0], DCM_BSnew[:,1])/np.linalg.norm(np.cross(DCM_BSnew[:,0], DCM_BSnew[:,1]))\n    SwitchBSnew[3:5, 3:5] = DCM_BSnew[1:3, 1:3]\n\n    DCM_newOld = np.dot(DCM_BSnew.T, DCM_BSold)\n    Switch[3:5, 3:5] = DCM_newOld[1:3,1:3]\n\n    # Fill in the variables for the test\n    bvec = sunlineSEKF.new_doubleArray(3)\n    states = sunlineSEKF.new_doubleArray(numStates)\n    covarMat = sunlineSEKF.new_doubleArray(numStates * numStates)\n    # switchBS = sunlineSEKF.new_doubleArray(numStates * numStates)\n\n    for i in range(3):\n        sunlineSEKF.doubleArray_setitem(bvec, i, bvec1[i])\n    for i in range(numStates):\n        sunlineSEKF.doubleArray_setitem(states, i, inputStates[i])\n    for j in range(numStates*numStates):\n        sunlineSEKF.doubleArray_setitem(covarMat, j, covar[j])\n        # sunlineSEKF.doubleArray_setitem(switchBS, j, switchInput[j])\n\n    sunlineSEKF.sunlineSEKFSwitch(bvec, states, covarMat)\n\n    switchBSout = []\n    covarOut = []\n    stateOut = []\n    bvecOut = []\n    for i in range(3):\n        bvecOut.append(sunlineSEKF.doubleArray_getitem(bvec, i))\n    for i in range(numStates):\n        stateOut.append(sunlineSEKF.doubleArray_getitem(states, i))\n    for j in range(numStates*numStates):\n        covarOut.append(sunlineSEKF.doubleArray_getitem(covarMat, j))\n\n\n    expectedState = np.dot(Switch, np.array(inputStates))\n    Pk = np.array(covar).reshape([numStates, numStates])\n    expectedP = np.dot(Switch, np.dot(Pk, Switch.T))\n\n    errorNorm = np.zeros(3)\n    errorNorm[0] = np.linalg.norm(np.array(stateOut) - expectedState)\n    errorNorm[1] = np.linalg.norm(expectedP - np.array(covarOut).reshape([numStates, numStates]))\n    errorNorm[2] = np.linalg.norm(np.array(bvecOut) - b2)\n    # errorNorm[3] = np.linalg.norm(SwitchBSnew - np.array(switchBSout).reshape([numStates, numStates]))\n\n    for i in range(len(errorNorm)):\n        if (errorNorm[i] > 1.0E-10):\n            testFailCount += 1\n            testMessages.append(\"Frame switch failure \\n\")\n\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" SEKF individual tests\")\n    else:\n        print(str(testFailCount) + ' tests failed')\n        print(testMessages)\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StatePropStatic():\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n    numStates = 5\n    numObs = 3\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = sunlineSEKF.sunlineSEKF()\n    module.ModelTag = \"sunlineSEKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n\n    unitTestSim.AddVariableForLogging('sunlineSEKF.covar', testProcessRate * 10, 0, 24)\n    unitTestSim.AddVariableForLogging('sunlineSEKF.state', testProcessRate * 10, 0, 4)\n\n    # connect messages\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n    cssConfigInMsg = messaging.CSSConfigMsg()\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConfigInMsg)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(8000.0))\n    unitTestSim.ExecuteSimulation()\n\n    stateLog = unitTestSim.GetLogVariableData('sunlineSEKF.state')\n\n    for i in range(numStates):\n        if (abs(stateLog[-1, i + 1] - stateLog[0, i + 1]) > 1.0E-10):\n            testFailCount += 1\n            testMessages.append(\"State propagation failure \\n\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"SEKF static state propagation\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StatePropVariable(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    numStates = 5\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = sunlineSEKF.sunlineSEKF()\n    module.ModelTag = \"sunlineSEKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n\n    InitialState =  (np.array(module.state)+ +np.array([0.,0.,0.,0.0001,0.002])).tolist()\n    Initialx = module.x\n    InitialCovar = module.covar\n    module.state = InitialState\n\n    unitTestSim.AddVariableForLogging('sunlineSEKF.covar', testProcessRate, 0, 24)\n    unitTestSim.AddVariableForLogging('sunlineSEKF.stateTransition', testProcessRate, 0, 24)\n    unitTestSim.AddVariableForLogging('sunlineSEKF.state', testProcessRate , 0, 4)\n    unitTestSim.AddVariableForLogging('sunlineSEKF.x', testProcessRate , 0, 4)\n\n    # connect messages\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n    cssConfigInMsg = messaging.CSSConfigMsg()\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConfigInMsg)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1000.0))\n    unitTestSim.ExecuteSimulation()\n\n\n    covarLog = unitTestSim.GetLogVariableData('sunlineSEKF.covar')\n    stateLog = unitTestSim.GetLogVariableData('sunlineSEKF.state')\n    stateErrorLog = unitTestSim.GetLogVariableData('sunlineSEKF.x')\n    stmLog = unitTestSim.GetLogVariableData('sunlineSEKF.stateTransition')\n\n    bVec = [1.,0.,0.]\n    dt = 0.5\n    expectedStateArray = np.zeros([2001,numStates+1])\n    DCM_BS = np.zeros([2001,3,3])\n    omega_S = np.zeros([2001,3])\n    omega_B = np.zeros([2001,3])\n    expectedStateArray[0,1:numStates+1] = np.array(InitialState)\n    expDynMat = np.zeros([2001,numStates,numStates])\n\n    DCM_BS[0,:,0] = np.array(InitialState[0:3])/(np.linalg.norm(np.array(InitialState[0:3])))\n    DCM_BS[0,:,1] = np.cross(DCM_BS[0,:,0], bVec)/np.linalg.norm(np.array(np.cross(DCM_BS[0,:,0], bVec)))\n    DCM_BS[0,:,2] = np.cross(DCM_BS[0,:,0], DCM_BS[0,:,1])/np.linalg.norm(np.cross(DCM_BS[0,:,0], DCM_BS[0,:,1]))\n    omega_S[0,1:] = InitialState[3:]\n    omega_B[0,:] = np.dot(DCM_BS[0, :, :], omega_S[0,:])\n\n    for i in range(1,2001):\n        expectedStateArray[i,0] = dt*i*1E9\n        expectedStateArray[i,1:4] = expectedStateArray[i-1,1:4] + dt * np.cross(omega_B[i-1,:],\n                                                                                expectedStateArray[i - 1, 1:4])\n        expectedStateArray[i, 4:6] = expectedStateArray[i-1, 4:6]\n\n        # Fill in the variables for the test\n        dcm = sunlineSEKF.new_doubleArray(3 * 3)\n        for j in range(9):\n            sunlineSEKF.doubleArray_setitem(dcm, j, 0)\n        sunlineSEKF.sunlineSEKFComputeDCM_BS(expectedStateArray[i, 1:4], bVec, dcm)\n        dcmOut = []\n        for j in range(9):\n            dcmOut.append(sunlineSEKF.doubleArray_getitem(dcm, j))\n        DCM_BS[i,:,:] = np.array(dcmOut).reshape([3, 3])\n        omega_S[i, 1:] = expectedStateArray[i, 4:]\n        omega_B[i,:] = np.dot(DCM_BS[i, :, :], omega_S[i,:])\n\n    for i in range(0, 2001):\n        dtilde = -np.array(RigidBodyKinematics.v3Tilde(expectedStateArray[i, 1:4]))\n        dBS = np.dot(dtilde, DCM_BS[i,:,:])\n\n        expDynMat[i,0:3, 0:3] = np.array(RigidBodyKinematics.v3Tilde(omega_B[i,:]))\n        expDynMat[i, 0:3, 3:numStates] = dBS[:, 1:]\n    expectedSTM = np.zeros([2001,numStates,numStates])\n    expectedSTM[0,:,:] = np.eye(numStates)\n    for i in range(1,2001):\n        expectedSTM[i,:,:] = dt * np.dot(expDynMat[i-1,:,:], np.eye(numStates)) + np.eye(numStates)\n\n    expectedXBar = np.zeros([2001,numStates+1])\n    expectedXBar[0,1:6] = np.array(Initialx)\n    for i in range(1,2001):\n        expectedXBar[i,0] = dt*i*1E9\n        expectedXBar[i, 1:6] = np.dot(expectedSTM[i, :, :], expectedXBar[i - 1, 1:6])\n\n    expectedCovar = np.zeros([2001,26])\n    expectedCovar[0,1:26] = np.array(InitialCovar)\n    Gamma = np.zeros([2001,numStates, 2])\n    ProcNoiseCovar = np.zeros([2001,numStates,numStates])\n    for i in range(0,2001):\n        s_skew = np.array([[0., -expectedStateArray[i,3], expectedStateArray[i,2]],\n                           [expectedStateArray[i,3], 0., -expectedStateArray[i,1]],\n                           [-expectedStateArray[i,2], expectedStateArray[i,1], 0.]])\n        s_BS = np.dot(s_skew, DCM_BS[i,:,:])\n        Gamma[i, 0:3, 0:2] = dt ** 2. / 2. * s_BS[:,1:3]\n        Gamma[i,3:numStates, 0:2] = dt * np.eye(2)\n        ProcNoiseCovar[i,:,:] = np.dot(Gamma[i,:,:], np.dot(module.qProcVal*np.eye(2),Gamma[i,:,:].T))\n    for i in range(1,2001):\n        expectedCovar[i,0] =  dt*i*1E9\n        expectedCovar[i,1:26] = (np.dot(expectedSTM[i,:,:], np.dot(np.reshape(expectedCovar[i-1,1:26],[numStates,numStates]), np.transpose(expectedSTM[i,:,:])))+ ProcNoiseCovar[i,:,:]).flatten()\n    FilterPlots.StatesVsExpected(stateLog, expectedStateArray, show_plots)\n    FilterPlots.StatesPlotCompare(stateErrorLog, expectedXBar, covarLog, expectedCovar, show_plots)\n\n    if (np.linalg.norm(np.array(stateLog)[:, 1:] - expectedStateArray[:, 1:]) > 1.0E-10):\n        testFailCount += 1\n        testMessages.append(\"General state propagation failure: State Prop \\n\")\n\n    if (np.linalg.norm(np.array(stateErrorLog)[:, 1:] - expectedXBar[:,1:]) > 1.0E-4):\n        testFailCount += 1\n        testMessages.append(\"General state propagation failure: State Error Prop \\n\")\n\n    if (np.linalg.norm(np.array(covarLog)[:, 1:] - expectedCovar[:, 1:]) > 1.0E-4):\n        testFailCount += 1\n        testMessages.append(\"General state propagation failure: Covariance Prop \\n\")\n    if (np.linalg.norm(np.array(stmLog)[:, 1:] - expectedSTM[:,:,:].reshape([2001,25])) > 1.0E-4):\n        testFailCount += 1\n        testMessages.append(\"General state propagation failure: STM Prop \\n\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"SEKF general state propagation\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StateUpdateSunLine(show_plots, SimHalfLength, AddMeasNoise, testVector1, testVector2, stateGuess):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    numStates = 5\n    numObs = 3\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = sunlineSEKF.sunlineSEKF()\n    module.ModelTag = \"sunlineSEKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    setupFilterData(module)\n\n    # Set up some test parameters\n\n    cssConstelation = messaging.CSSConfigMsgPayload()\n\n    CSSOrientationList = [\n        [0.70710678118654746, -0.5, 0.5],\n        [0.70710678118654746, -0.5, -0.5],\n        [0.70710678118654746, 0.5, -0.5],\n        [0.70710678118654746, 0.5, 0.5],\n        [-0.70710678118654746, 0, 0.70710678118654757],\n        [-0.70710678118654746, 0.70710678118654757, 0.0],\n        [-0.70710678118654746, 0, -0.70710678118654757],\n        [-0.70710678118654746, -0.70710678118654757, 0.0],\n    ]\n    CSSBias = [1 for i in range(len(CSSOrientationList))]\n\n    totalCSSList = []\n    # Initializing a 2D double array is hard with SWIG.  That's why there is this\n    # layer between the above list and the actual C variables.\n    i = 0\n    for CSSHat in CSSOrientationList:\n        newCSS = messaging.CSSUnitConfigMsgPayload()\n        newCSS.CBias = CSSBias[i]\n        newCSS.nHat_B = CSSHat\n        totalCSSList.append(newCSS)\n        i = i + 1\n    cssConstelation.nCSS = len(CSSOrientationList)\n    cssConstelation.cssVals = totalCSSList\n\n    inputData = messaging.CSSArraySensorMsgPayload()\n\n    cssConstInMsg = messaging.CSSConfigMsg().write(cssConstelation)\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n\n    # connect messages\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConstInMsg)\n\n    stateTarget1 = testVector1\n    stateTarget1 += [0.0, 0.0]\n    module.state = stateGuess\n    module.x = (np.array(stateTarget1) - np.array(stateGuess)).tolist()\n\n    unitTestSim.AddVariableForLogging('sunlineSEKF.x', testProcessRate , 0, 4, 'double')\n    dataLog = module.filtDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n\n    for i in range(SimHalfLength):\n        if i > 20:\n            dotList = []\n            for element in CSSOrientationList:\n                if AddMeasNoise:\n                    dotProd = np.dot(np.array(element), np.array(testVector1)[0:3]) + np.random.normal(0., module.qObsVal)\n                else:\n                    dotProd = np.dot(np.array(element), np.array(testVector1)[0:3])\n                dotList.append(dotProd)\n            inputData.CosValue = dotList\n            cssDataInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i + 1) * 0.5))\n        unitTestSim.ExecuteSimulation()\n\n    stateLog = addTimeColumn(dataLog.times(), dataLog.state)\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n    for i in range(numStates):\n        if (abs(covarLog[-1, i *numStates  + 1 + i] - covarLog[0, i * numStates + 1 + i] / 100.) > 1E-1):\n            print(abs(covarLog[-1, i *numStates  + 1 + i] - covarLog[0, i * numStates + 1 + i] / 100.))\n            testFailCount += 1\n            testMessages.append(\"Covariance update failure\")\n        if (abs(stateLog[-1, i + 1] - stateTarget1[i]) > 1.0E-1):\n            testFailCount += 1\n            testMessages.append(\"State update failure\")\n\n\n    stateTarget2 = testVector2\n    stateTarget2 = stateTarget2+[0.,0.]\n\n    inputData = messaging.CSSArraySensorMsgPayload()\n    for i in range(SimHalfLength):\n        if i > 20:\n            dotList = []\n            for element in CSSOrientationList:\n                if AddMeasNoise:\n                    dotProd = np.dot(np.array(element), np.array(testVector2)[0:3])  + np.random.normal(0., module.qObsVal)\n                else:\n                    dotProd = np.dot(np.array(element), np.array(testVector2)[0:3])\n                dotList.append(dotProd)\n            inputData.CosValue = dotList\n            cssDataInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i + SimHalfLength+1) * 0.5))\n        unitTestSim.ExecuteSimulation()\n\n    stateErrorLog = unitTestSim.GetLogVariableData('sunlineSEKF.x')\n    stateLog = addTimeColumn(dataLog.times(), dataLog.state)\n    postFitLog = addTimeColumn(dataLog.times(), dataLog.postFitRes)\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n\n\n    for i in range(numStates):\n        if (abs(covarLog[-1, i * numStates + 1 + i] - covarLog[0, i * numStates + 1 + i] / 100.) > 1E-1):\n            testFailCount += 1\n            testMessages.append(\"Covariance update failure at end\")\n        if (abs(stateLog[-1, i + 1] - stateTarget2[i]) > 1.0E-1):\n            testFailCount += 1\n            testMessages.append(\"State update failure at end\")\n\n    target1 = np.array(testVector1)\n    target2 = np.array(testVector2+[0.,0.])\n    FilterPlots.StatesPlot(stateErrorLog, covarLog, show_plots)\n    FilterPlots.StatesVsTargets(target1, target2, stateLog, show_plots)\n    FilterPlots.PostFitResiduals(postFitLog, module.qObsVal, show_plots)\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"SEKF full test\")\n    else:\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StateCovarPlot(x, Pflat, testNum, show_plots):\n\n    numStates = len(x[0,:])-1\n\n    P = np.zeros([len(Pflat[:,0]),numStates,numStates])\n    t= np.zeros(len(Pflat[:,0]))\n    for i in range(len(Pflat[:,0])):\n        t[i] = x[i, 0]*1E-9\n        P[i,:,:] = Pflat[i,1:(numStates*numStates+1)].reshape([numStates,numStates])\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(t , x[:, 1], \"b\", label='Error Filter')\n    plt.plot(t , x[:, 1]+3 * np.sqrt(P[:, 0, 0]), 'r--',  label='Covar Filter')\n    plt.plot(t , x[:, 1]-3 * np.sqrt(P[:, 0, 0]), 'r--')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n\n    plt.subplot(323)\n    plt.plot(t , x[:, 2], \"b\")\n    plt.plot(t , x[:, 2]+3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.plot(t , x[:, 2]-3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.title('Second LOS component')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(t , x[:, 4], \"b\")\n    plt.plot(t , x[:, 4]+3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.plot(t , x[:, 4]-3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.title('Second rate component')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(t , x[:, 3], \"b\")\n    plt.plot(t , x[:, 3]+3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.plot(t , x[:, 3]-3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third LOS component')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(t , x[:, 5], \"b\")\n    plt.plot(t , x[:, 5]+3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.plot(t , x[:, 5]-3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesPlot' + str(testNum), 'State error and covariance', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def PostFitResiduals(Res, noise, testNum, show_plots):\n\n    MeasNoise = np.zeros(len(Res[:,0]))\n    t= np.zeros(len(Res[:,0]))\n    for i in range(len(Res[:,0])):\n        t[i] = Res[i, 0]*1E-9\n        MeasNoise[i] = 3*noise\n        # Don't plot zero values, since they mean that no measurement is taken\n        for j in range(len(Res[0,:])-1):\n            if -1E-10 < Res[i,j+1] < 1E-10:\n                Res[i, j+1] = np.nan\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(421)\n    plt.plot(t , Res[:, 1], \"b.\", label='Residual')\n    plt.plot(t , MeasNoise, 'r--', label='Covar')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.legend(loc='lower right')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('First CSS')\n    plt.grid()\n\n    plt.subplot(422)\n    plt.plot(t , Res[:, 5], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Fifth CSS')\n    plt.grid()\n\n    plt.subplot(423)\n    plt.plot(t , Res[:, 2], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Second CSS')\n    plt.grid()\n\n    plt.subplot(424)\n    plt.plot(t , Res[:, 6], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Sixth CSS')\n    plt.grid()\n\n    plt.subplot(425)\n    plt.plot(t , Res[:, 3], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Third CSS')\n    plt.grid()\n\n    plt.subplot(426)\n    plt.plot(t , Res[:, 7], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Seventh CSS')\n    plt.grid()\n\n    plt.subplot(427)\n    plt.plot(t , Res[:, 4], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.xlabel('t(s)')\n    plt.title('Fourth CSS')\n    plt.grid()\n\n    plt.subplot(428)\n    plt.plot(t , Res[:, 8], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.xlabel('t(s)')\n    plt.title('Eight CSS')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('PostFit' + str(testNum), 'Post Fit Residuals', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def addTimeColumn(time, data):\n    return numpy.transpose(numpy.vstack([[time], numpy.transpose(data)]))",
  "def setupFilterData(filterObject):\n    filterObject.alpha = 0.02\n    filterObject.beta = 2.0\n    filterObject.kappa = 0.0\n\n    filterObject.state = [1.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    filterObject.covar = [0.4, 0.0, 0.0, 0.0, 0.0, 0.0,\n                          0.0, 0.4, 0.0, 0.0, 0.0, 0.0,\n                          0.0, 0.0, 0.4, 0.0, 0.0, 0.0,\n                          0.0, 0.0, 0.0, 0.04, 0.0, 0.0,\n                          0.0, 0.0, 0.0, 0.0, 0.04, 0.0,\n                          0.0, 0.0, 0.0, 0.0, 0.0, 0.04]\n    qNoiseIn = numpy.identity(6)\n    qNoiseIn[0:3, 0:3] = qNoiseIn[0:3, 0:3]*0.01*0.01\n    qNoiseIn[3:6, 3:6] = qNoiseIn[3:6, 3:6]*0.001*0.001\n    filterObject.qNoise = qNoiseIn.reshape(36).tolist()\n    filterObject.qObsVal = 0.001",
  "def test_all_sunline_kf(show_plots, function):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = eval(function + '(show_plots)')\n    assert testResults < 1, testMessage",
  "def sunline_utilities_test(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    # Initialize the test module configuration data\n    AMatrix = [0.488894, 0.888396, 0.325191, 0.319207,\n                1.03469, -1.14707, -0.754928, 0.312859,\n                0.726885, -1.06887, 1.3703, -0.86488,\n               -0.303441, -0.809499, -1.71152, -0.0300513,\n                0.293871, -2.94428, -0.102242, -0.164879,\n               -0.787283, 1.43838, -0.241447, 0.627707]\n\n    RVector = sunlineUKF.new_doubleArray(len(AMatrix))\n    AVector = sunlineUKF.new_doubleArray(len(AMatrix))\n    for i in range(len(AMatrix)):\n        sunlineUKF.doubleArray_setitem(AVector, i, AMatrix[i])\n        sunlineUKF.doubleArray_setitem(RVector, i, 0.0)\n\n    sunlineUKF.ukfQRDJustR(AVector, 6, 4, RVector)\n    RMatrix = []\n    for i in range(4*4):\n        RMatrix.append(sunlineUKF.doubleArray_getitem(RVector, i))\n    RBaseNumpy = numpy.array(RMatrix).reshape(4,4)\n    AMatNumpy = numpy.array(AMatrix).reshape(6,4)\n    q,r = numpy.linalg.qr(AMatNumpy)\n    for i in range(r.shape[0]):\n        if r[i,i] < 0.0:\n            r[i,:] *= -1.0\n    if numpy.linalg.norm(r - RBaseNumpy) > 1.0E-15:\n        testFailCount += 1\n        testMessages.append(\"QR Decomposition accuracy failure\")\n\n    AMatrix = [1.09327, 1.10927, -0.863653, 1.32288,\n     -1.21412, -1.1135, -0.00684933, -2.43508,\n     -0.769666, 0.371379, -0.225584, -1.76492,\n     -1.08906, 0.0325575, 0.552527, -1.6256,\n     1.54421, 0.0859311, -1.49159, 1.59683]\n\n    RVector = sunlineUKF.new_doubleArray(len(AMatrix))\n    AVector = sunlineUKF.new_doubleArray(len(AMatrix))\n    for i in range(len(AMatrix)):\n        sunlineUKF.doubleArray_setitem(AVector, i, AMatrix[i])\n        sunlineUKF.doubleArray_setitem(RVector, i, 0.0)\n\n    sunlineUKF.ukfQRDJustR(AVector, 5, 4, RVector)\n    RMatrix = []\n    for i in range(4*4):\n        RMatrix.append(sunlineUKF.doubleArray_getitem(RVector, i))\n    RBaseNumpy = numpy.array(RMatrix).reshape(4,4)\n    AMatNumpy = numpy.array(AMatrix).reshape(5,4)\n    q,r = numpy.linalg.qr(AMatNumpy)\n    for i in range(r.shape[0]):\n        if r[i,i] < 0.0:\n            r[i,:] *= -1.0\n    if numpy.linalg.norm(r - RBaseNumpy) > 1.0E-14:\n        testFailCount += 1\n        testMessages.append(\"QR Decomposition accuracy failure\")\n\n    AMatrix = [ 0.2236,         0,\n               0,    0.2236,\n               -0.2236,         0,\n               0,   -0.2236,\n               0.0170,         0,\n               0,    0.0170]\n\n    RVector = sunlineUKF.new_doubleArray(len(AMatrix))\n    AVector = sunlineUKF.new_doubleArray(len(AMatrix))\n    for i in range(len(AMatrix)):\n        sunlineUKF.doubleArray_setitem(AVector, i, AMatrix[i])\n        sunlineUKF.doubleArray_setitem(RVector, i, 0.0)\n\n    sunlineUKF.ukfQRDJustR(AVector, 6, 2, RVector)\n    RMatrix = []\n    for i in range(2*2):\n        RMatrix.append(sunlineUKF.doubleArray_getitem(RVector, i))\n    RBaseNumpy = numpy.array(RMatrix).reshape(2,2)\n    AMatNumpy = numpy.array(AMatrix).reshape(6,2)\n    q,r = numpy.linalg.qr(AMatNumpy)\n    for i in range(r.shape[0]):\n        if r[i,i] < 0.0:\n            r[i,:] *= -1.0\n\n    if numpy.linalg.norm(r - RBaseNumpy) > 1.0E-15:\n        testFailCount += 1\n        testMessages.append(\"QR Decomposition accuracy failure\")\n\n\n    LUSourceMat = [8,1,6,3,5,7,4,9,2]\n    LUSVector = sunlineUKF.new_doubleArray(len(LUSourceMat))\n    LVector = sunlineUKF.new_doubleArray(len(LUSourceMat))\n    UVector = sunlineUKF.new_doubleArray(len(LUSourceMat))\n    intSwapVector = sunlineUKF.new_intArray(3)\n\n    for i in range(len(LUSourceMat)):\n        sunlineUKF.doubleArray_setitem(LUSVector, i, LUSourceMat[i])\n        sunlineUKF.doubleArray_setitem(UVector, i, 0.0)\n        sunlineUKF.doubleArray_setitem(LVector, i, 0.0)\n\n    exCount = sunlineUKF.ukfLUD(LUSVector, 3, 3, LVector, intSwapVector)\n    #sunlineUKF.ukfUInv(LUSVector, 3, 3, UVector)\n    LMatrix = []\n    UMatrix = []\n    #UMatrix = []\n    for i in range(3):\n        currRow = sunlineUKF.intArray_getitem(intSwapVector, i)\n        for j in range(3):\n            if(j<i):\n                LMatrix.append(sunlineUKF.doubleArray_getitem(LVector, i*3+j))\n                UMatrix.append(0.0)\n            elif(j>i):\n                LMatrix.append(0.0)\n                UMatrix.append(sunlineUKF.doubleArray_getitem(LVector, i*3+j))\n            else:\n                LMatrix.append(1.0)\n                UMatrix.append(sunlineUKF.doubleArray_getitem(LVector, i*3+j))\n    #    UMatrix.append(sunlineUKF.doubleArray_getitem(UVector, i))\n\n    LMatrix = numpy.array(LMatrix).reshape(3,3)\n    UMatrix = numpy.array(UMatrix).reshape(3,3)\n    outMat = numpy.dot(LMatrix, UMatrix)\n    outMatSwap = numpy.zeros((3,3))\n    for i in range(3):\n        currRow = sunlineUKF.intArray_getitem(intSwapVector, i)\n        outMatSwap[i,:] = outMat[currRow, :]\n        outMat[currRow,:] = outMat[i, :]\n    LuSourceArray = numpy.array(LUSourceMat).reshape(3,3)\n\n    if(numpy.linalg.norm(outMatSwap - LuSourceArray) > 1.0E-14):\n        testFailCount += 1\n        testMessages.append(\"LU Decomposition accuracy failure\")\n\n    EqnSourceMat = [2.0, 1.0, 3.0, 2.0, 6.0, 8.0, 6.0, 8.0, 18.0]\n    BVector = [1.0, 3.0, 5.0]\n    EqnVector = sunlineUKF.new_doubleArray(len(EqnSourceMat))\n    EqnBVector = sunlineUKF.new_doubleArray(len(LUSourceMat)//3)\n    EqnOutVector = sunlineUKF.new_doubleArray(len(LUSourceMat)//3)\n\n    for i in range(len(EqnSourceMat)):\n        sunlineUKF.doubleArray_setitem(EqnVector, i, EqnSourceMat[i])\n        sunlineUKF.doubleArray_setitem(EqnBVector, i//3, BVector[i//3])\n        sunlineUKF.intArray_setitem(intSwapVector, i//3, 0)\n        sunlineUKF.doubleArray_setitem(LVector, i, 0.0)\n\n    exCount = sunlineUKF.ukfLUD(EqnVector, 3, 3, LVector, intSwapVector)\n\n    sunlineUKF.ukfLUBckSlv(LVector, 3, 3, intSwapVector, EqnBVector, EqnOutVector)\n\n    expectedSol = [3.0/10.0, 4.0/10.0, 0.0]\n    errorVal = 0.0\n    for i in range(3):\n        errorVal += abs(sunlineUKF.doubleArray_getitem(EqnOutVector, i) -expectedSol[i])\n\n    if(errorVal > 1.0E-14):\n        testFailCount += 1\n        testMessages.append(\"LU Back-Solve accuracy failure\")\n\n\n    InvSourceMat = [8,1,6,3,5,7,4,9,2]\n    SourceVector = sunlineUKF.new_doubleArray(len(InvSourceMat))\n    InvVector = sunlineUKF.new_doubleArray(len(InvSourceMat))\n    for i in range(len(InvSourceMat)):\n        sunlineUKF.doubleArray_setitem(SourceVector, i, InvSourceMat[i])\n        sunlineUKF.doubleArray_setitem(InvVector, i, 0.0)\n    nRow = int(math.sqrt(len(InvSourceMat)))\n    sunlineUKF.ukfMatInv(SourceVector, nRow, nRow, InvVector)\n\n    InvOut = []\n    for i in range(len(InvSourceMat)):\n        InvOut.append(sunlineUKF.doubleArray_getitem(InvVector, i))\n\n    InvOut = numpy.array(InvOut).reshape(nRow, nRow)\n    expectIdent = numpy.dot(InvOut, numpy.array(InvSourceMat).reshape(3,3))\n    errorNorm = numpy.linalg.norm(expectIdent - numpy.identity(3))\n    if(errorNorm > 1.0E-14):\n        testFailCount += 1\n        testMessages.append(\"LU Matrix Inverse accuracy failure\")\n\n\n    cholTestMat = [1.0, 0.0, 0.0, 0.0, 10.0, 5.0, 0.0, 5.0, 10.0]\n    SourceVector = sunlineUKF.new_doubleArray(len(cholTestMat))\n    CholVector = sunlineUKF.new_doubleArray(len(cholTestMat))\n    for i in range(len(cholTestMat)):\n        sunlineUKF.doubleArray_setitem(SourceVector, i, cholTestMat[i])\n        sunlineUKF.doubleArray_setitem(CholVector, i, 0.0)\n    nRow = int(math.sqrt(len(cholTestMat)))\n    sunlineUKF.ukfCholDecomp(SourceVector, nRow, nRow, CholVector)\n    cholOut = []\n    for i in range(len(cholTestMat)):\n        cholOut.append(sunlineUKF.doubleArray_getitem(CholVector, i))\n\n    cholOut = numpy.array(cholOut).reshape(nRow, nRow)\n    cholComp = numpy.linalg.cholesky(numpy.array(cholTestMat).reshape(nRow, nRow))\n    errorNorm = numpy.linalg.norm(cholOut - cholComp)\n    if(errorNorm > 1.0E-14):\n        testFailCount += 1\n        testMessages.append(\"Cholesky Matrix Decomposition accuracy failure\")\n\n\n    InvSourceMat = [2.1950926119414667, 0.0, 0.0, 0.0,\n               1.0974804773131115, 1.9010439702743847, 0.0, 0.0,\n               0.0, 1.2672359635912551, 1.7923572711881284, 0.0,\n               1.0974804773131113, -0.63357997864171967, 1.7920348101787789, 0.033997451205364251]\n\n    SourceVector = sunlineUKF.new_doubleArray(len(InvSourceMat))\n    InvVector = sunlineUKF.new_doubleArray(len(InvSourceMat))\n    for i in range(len(InvSourceMat)):\n        sunlineUKF.doubleArray_setitem(SourceVector, i, InvSourceMat[i])\n        sunlineUKF.doubleArray_setitem(InvVector, i, 0.0)\n    nRow = int(math.sqrt(len(InvSourceMat)))\n    sunlineUKF.ukfLInv(SourceVector, nRow, nRow, InvVector)\n\n    InvOut = []\n    for i in range(len(InvSourceMat)):\n        InvOut.append(sunlineUKF.doubleArray_getitem(InvVector, i))\n\n    InvOut = numpy.array(InvOut).reshape(nRow, nRow)\n    expectIdent = numpy.dot(InvOut, numpy.array(InvSourceMat).reshape(nRow,nRow))\n    errorNorm = numpy.linalg.norm(expectIdent - numpy.identity(nRow))\n    if(errorNorm > 1.0E-12):\n        print(errorNorm)\n        testFailCount += 1\n        testMessages.append(\"L Matrix Inverse accuracy failure\")\n\n    InvSourceMat = numpy.transpose(numpy.array(InvSourceMat).reshape(nRow, nRow)).reshape(nRow*nRow).tolist()\n    SourceVector = sunlineUKF.new_doubleArray(len(InvSourceMat))\n    InvVector = sunlineUKF.new_doubleArray(len(InvSourceMat))\n    for i in range(len(InvSourceMat)):\n        sunlineUKF.doubleArray_setitem(SourceVector, i, InvSourceMat[i])\n        sunlineUKF.doubleArray_setitem(InvVector, i, 0.0)\n    nRow = int(math.sqrt(len(InvSourceMat)))\n    sunlineUKF.ukfUInv(SourceVector, nRow, nRow, InvVector)\n\n    InvOut = []\n    for i in range(len(InvSourceMat)):\n        InvOut.append(sunlineUKF.doubleArray_getitem(InvVector, i))\n\n    InvOut = numpy.array(InvOut).reshape(nRow, nRow)\n    expectIdent = numpy.dot(InvOut, numpy.array(InvSourceMat).reshape(nRow,nRow))\n    errorNorm = numpy.linalg.norm(expectIdent - numpy.identity(nRow))\n    if(errorNorm > 1.0E-12):\n        print(errorNorm)\n        testFailCount += 1\n        testMessages.append(\"U Matrix Inverse accuracy failure\")\n\n\n    # If the argument provided at commandline \"--show_plots\" evaluates as true,\n    # plot all figures\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" UKF utilities\")\n    else:\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def checkStateUpdateSunLine(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = sunlineUKF.sunlineUKF()\n    module.ModelTag = \"SunlineUKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n\n    cssConstelation = messaging.CSSConfigMsgPayload()\n\n    CSSOrientationList = [\n       [0.70710678118654746, -0.5, 0.5],\n       [0.70710678118654746, -0.5, -0.5],\n       [0.70710678118654746, 0.5, -0.5],\n       [0.70710678118654746, 0.5, 0.5],\n       [-0.70710678118654746, 0, 0.70710678118654757],\n       [-0.70710678118654746, 0.70710678118654757, 0.0],\n       [-0.70710678118654746, 0, -0.70710678118654757],\n       [-0.70710678118654746, -0.70710678118654757, 0.0],\n    ]\n    totalCSSList = []\n    for CSSHat in CSSOrientationList:\n        newCSS = messaging.CSSUnitConfigMsgPayload()\n        newCSS.CBias = 1.0\n        newCSS.nHat_B = CSSHat\n        totalCSSList.append(newCSS)\n    cssConstelation.nCSS = len(CSSOrientationList)\n    cssConstelation.cssVals = totalCSSList\n    cssConstInMsg = messaging.CSSConfigMsg().write(cssConstelation)\n\n\n    testVector = numpy.array([-0.7, 0.7, 0.0])\n    inputData = messaging.CSSArraySensorMsgPayload()\n    dotList = []\n    for element in CSSOrientationList:\n        dotProd = numpy.dot(numpy.array(element), testVector)\n        dotList.append(dotProd)\n    inputData.CosValue = dotList\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n\n    stateTarget = testVector.tolist()\n    stateTarget.extend([0.0, 0.0, 0.0])\n    module.state = [0.7, 0.7, 0.0]\n\n    dataLog = module.filtDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConstInMsg)\n\n    unitTestSim.InitializeSimulation()\n\n    for i in range(400):\n        if i > 20:\n            cssDataInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i+1)*0.5))\n        unitTestSim.ExecuteSimulation()\n\n    stateLog = addTimeColumn(dataLog.times(), dataLog.state)\n    postFitLog = addTimeColumn(dataLog.times(), dataLog.postFitRes)\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n    for i in range(6):\n        if(covarLog[-1, i*6+1+i] > covarLog[0, i*6+1+i]/100):\n            testFailCount += 1\n            testMessages.append(\"Covariance update failure\")\n        if(abs(stateLog[-1, i+1] - stateTarget[i]) > 1.0E-5):\n            print(abs(stateLog[-1, i+1] - stateTarget[i]))\n            testFailCount += 1\n            testMessages.append(\"State update failure\")\n\n    testVector = numpy.array([-0.8, -0.9, 0.0])\n    inputData = messaging.CSSArraySensorMsgPayload()\n    dotList = []\n    for element in CSSOrientationList:\n        dotProd = numpy.dot(numpy.array(element), testVector)\n        dotList.append(dotProd)\n    inputData.CosValue = dotList\n\n    for i in range(400):\n        if i > 20:\n            cssDataInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i+401)*0.5))\n        unitTestSim.ExecuteSimulation()\n\n    stateLog = addTimeColumn(dataLog.times(), dataLog.state)\n    postFitLog = addTimeColumn(dataLog.times(), dataLog.postFitRes)\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n    stateTarget = testVector.tolist()\n    stateTarget.extend([0.0, 0.0, 0.0])\n    for i in range(6):\n        if(covarLog[-1, i*6+1+i] > covarLog[0, i*6+1+i]/100):\n            testFailCount += 1\n            testMessages.append(\"Covariance update failure\")\n        if(abs(stateLog[-1, i+1] - stateTarget[i]) > 1.0E-5):\n            print(abs(stateLog[-1, i+1] - stateTarget[i]))\n            testFailCount += 1\n            testMessages.append(\"State update failure\")\n\n    FilterPlots.StateCovarPlot(stateLog, covarLog, 'update', show_plots)\n    FilterPlots.PostFitResiduals(postFitLog, module.qObsVal, 'update', show_plots)\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag + \" state update\")\n    else:\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def checkStatePropSunLine(show_plots):\n\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = sunlineUKF.sunlineUKF()\n    module.ModelTag = \"SunlineUKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n\n    dataLog = module.filtDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    cssConstInMsg = messaging.CSSConfigMsg()\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConstInMsg)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(8000.0))\n    unitTestSim.ExecuteSimulation()\n\n    stateLog = addTimeColumn(dataLog.times(), dataLog.state)\n    postFitLog = addTimeColumn(dataLog.times(), dataLog.postFitRes)\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n    FilterPlots.StateCovarPlot(stateLog, covarLog, 'prop', show_plots)\n    FilterPlots.PostFitResiduals(postFitLog, module.qObsVal, 'prop', show_plots)\n\n    for i in range(6):\n        if(abs(stateLog[-1, i+1] - stateLog[0, i+1]) > 1.0E-10):\n            print(abs(stateLog[-1, i+1] - stateLog[0, i+1]))\n            testFailCount += 1\n            testMessages.append(\"State propagation failure\")\n\n\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag + \" state propagation\")\n    else:\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def addTimeColumn(time, data):\n    return numpy.transpose(numpy.vstack([[time], numpy.transpose(data)]))",
  "def setupFilterData(filterObject, initialized):\n    filterObject.alpha = 0.02\n    filterObject.beta = 2.0\n    filterObject.kappa = 0.0\n\n    if initialized:\n        filterObject.stateInit = [0.0, 0.0, 1.0, 0.0, 0.0, 1.]\n        filterObject.filterInitialized = 1\n    else:\n        filterObject.filterInitialized = 0\n\n    filterObject.covarInit = [1., 0.0, 0.0, 0.0, 0.0, 0.0,\n                          0.0, 1., 0.0, 0.0, 0.0, 0.0,\n                          0.0, 0.0, 1., 0.0, 0.0, 0.0,\n                          0.0, 0.0, 0.0, 0.02, 0.0, 0.0,\n                          0.0, 0.0, 0.0, 0.0, 0.02, 0.0,\n                          0.0, 0.0, 0.0, 0.0, 0.0, 1E-4]\n    qNoiseIn = numpy.identity(6)\n    qNoiseIn[0:3, 0:3] = qNoiseIn[0:3, 0:3]*0.001*0.001\n    qNoiseIn[3:5, 3:5] = qNoiseIn[3:5, 3:5]*0.001*0.001\n    qNoiseIn[5, 5] = qNoiseIn[5, 5]*0.0000002*0.0000002\n    filterObject.qNoise = qNoiseIn.reshape(36).tolist()\n    filterObject.qObsVal = 0.002\n    filterObject.sensorUseThresh = 0.0",
  "def test_all_sunline_kf(show_plots, kellyOn):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = SwitchMethods()\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = StatePropSunLine(show_plots)\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = StateUpdateSunLine(show_plots, kellyOn)\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = FaultScenarios()\n    assert testResults < 1, testMessage",
  "def SwitchMethods():\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    ###################################################################################\n    ## Test the sunlineSEKFComputeDCM_BS method\n    ###################################################################################\n    numStates = 6\n\n    inputStates = [2, 1, 0.75, 0.1, 0.4, 0.]\n    sunheading = inputStates[:3]\n    bvec1 = [0., 1., 0.]\n    b1 = numpy.array(bvec1)\n\n    dcm_BS = [1., 0., 0.,\n             0., 1., 0.,\n             0., 0., 1.]\n\n    # Fill in expected values for test\n\n    DCM_exp = numpy.zeros([3,3])\n    W_exp = numpy.eye(numStates)\n\n    DCM_exp[:, 0] = numpy.array(inputStates[0:3]) / (numpy.linalg.norm(numpy.array(inputStates[0:3])))\n    DCM_exp[:, 1] = numpy.cross(DCM_exp[:, 0], b1) / numpy.linalg.norm(numpy.array(numpy.cross(DCM_exp[:, 0], b1)))\n    DCM_exp[:, 2] = numpy.cross(DCM_exp[:, 0], DCM_exp[:, 1]) / numpy.linalg.norm(\n        numpy.cross(DCM_exp[:, 0], DCM_exp[:, 1]))\n\n    # Fill in the variables for the test\n    dcm = sunlineSuKF.new_doubleArray(3 * 3)\n\n    for j in range(9):\n        sunlineSuKF.doubleArray_setitem(dcm, j, dcm_BS[j])\n\n    sunlineSuKF.sunlineSuKFComputeDCM_BS(sunheading, bvec1, dcm)\n\n    switchBSout = []\n    dcmOut = []\n    for j in range(9):\n        dcmOut.append(sunlineSuKF.doubleArray_getitem(dcm, j))\n\n\n    errorNorm = numpy.zeros(1)\n    errorNorm[0] = numpy.linalg.norm(DCM_exp - numpy.array(dcmOut).reshape([3, 3]))\n\n    for i in range(len(errorNorm)):\n        if (errorNorm[i] > 1.0E-10):\n            testFailCount += 1\n            testMessages.append(\"Frame switch failure \\n\")\n\n    ###################################################################################\n    ## Test the Switching method\n    ###################################################################################\n\n    inputStates = [2,1,0.75,0.1,0.4, 1.]\n    bvec1 = [0.,1.,0.]\n    b1 = numpy.array(bvec1)\n    covar = [1., 0., 0., 1., 0., 0.,\n             0., 1., 0., 0., 1., 0.,\n             0., 0., 1., 0., 0., 1.,\n             1., 0., 0., 1., 0., 0.,\n             0., 1., 0., 0., 1., 0.,\n             0., 0., 1., 0., 0., 1.]\n    noise =0.01\n\n    # Fill in expected values for test\n\n    DCM_BSold = numpy.zeros([3,3])\n    DCM_BSnew = numpy.zeros([3,3])\n    Switch = numpy.eye(numStates)\n    SwitchBSold = numpy.eye(numStates)\n    SwitchBSnew = numpy.eye(numStates)\n\n    DCM_BSold[:,0] = numpy.array(inputStates[0:3])/(numpy.linalg.norm(numpy.array(inputStates[0:3])))\n    DCM_BSold[:,1] = numpy.cross(DCM_BSold[:,0], b1)/numpy.linalg.norm(numpy.array(numpy.cross(DCM_BSold[:,0], b1)))\n    DCM_BSold[:,2] = numpy.cross(DCM_BSold[:,0], DCM_BSold[:,1])/numpy.linalg.norm(numpy.cross(DCM_BSold[:,0], DCM_BSold[:,1]))\n    SwitchBSold[3:5, 3:5] = DCM_BSold[1:3, 1:3]\n\n    b2 = numpy.array([1.,0.,0.])\n    DCM_BSnew[:,0] = numpy.array(inputStates[0:3])/(numpy.linalg.norm(numpy.array(inputStates[0:3])))\n    DCM_BSnew[:,1] = numpy.cross(DCM_BSnew[:,0], b2)/numpy.linalg.norm(numpy.array(numpy.cross(DCM_BSnew[:,0], b2)))\n    DCM_BSnew[:,2] = numpy.cross(DCM_BSnew[:,0], DCM_BSnew[:,1])/numpy.linalg.norm(numpy.cross(DCM_BSnew[:,0], DCM_BSnew[:,1]))\n    SwitchBSnew[3:5, 3:5] = DCM_BSnew[1:3, 1:3]\n\n    DCM_newOld = numpy.dot(DCM_BSnew.T, DCM_BSold)\n    Switch[3:5, 3:5] = DCM_newOld[1:3,1:3]\n\n    # Fill in the variables for the test\n    bvec = sunlineSuKF.new_doubleArray(3)\n    states = sunlineSuKF.new_doubleArray(numStates)\n    covarMat = sunlineSuKF.new_doubleArray(numStates * numStates)\n\n    for i in range(3):\n        sunlineSuKF.doubleArray_setitem(bvec, i, bvec1[i])\n    for i in range(numStates):\n        sunlineSuKF.doubleArray_setitem(states, i, inputStates[i])\n    for j in range(numStates*numStates):\n        sunlineSuKF.doubleArray_setitem(covarMat, j, covar[j])\n        # sunlineSEKF.doubleArray_setitem(switchBS, j, switchInput[j])\n\n    sunlineSuKF.sunlineSuKFSwitch(bvec, states, covarMat)\n\n    switchBSout = []\n    covarOut = []\n    stateOut = []\n    bvecOut = []\n    for i in range(3):\n        bvecOut.append(sunlineSuKF.doubleArray_getitem(bvec, i))\n    for i in range(numStates):\n        stateOut.append(sunlineSuKF.doubleArray_getitem(states, i))\n    for j in range(numStates*numStates):\n        covarOut.append(sunlineSuKF.doubleArray_getitem(covarMat, j))\n\n\n    expectedState = numpy.dot(Switch, numpy.array(inputStates))\n    Pk = numpy.array(covar).reshape([numStates, numStates])\n    expectedP = numpy.dot(Switch, numpy.dot(Pk, Switch.T))\n\n    errorNorm = numpy.zeros(3)\n    errorNorm[0] = numpy.linalg.norm(numpy.array(stateOut) - expectedState)\n    errorNorm[1] = numpy.linalg.norm(expectedP - numpy.array(covarOut).reshape([numStates, numStates]))\n    errorNorm[2] = numpy.linalg.norm(numpy.array(bvecOut) - b2)\n\n    for i in range(len(errorNorm)):\n        if (errorNorm[i] > 1.0E-10):\n            testFailCount += 1\n            testMessages.append(\"Frame switch failure \\n\")\n\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" SuKF switch tests\")\n    else:\n        print(str(testFailCount) + ' tests failed')\n        print(testMessages)\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StateUpdateSunLine(show_plots, kellyOn):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = sunlineSuKF.sunlineSuKF()\n    module.ModelTag = \"sunlineSuKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module, False)\n    cssConstelation = messaging.CSSConfigMsgPayload()\n\n    CSSOrientationList = [\n       [0.70710678118654746, -0.5, 0.5],\n       [0.70710678118654746, -0.5, -0.5],\n       [0.70710678118654746, 0.5, -0.5],\n       [0.70710678118654746, 0.5, 0.5],\n       [-0.70710678118654746, 0, 0.70710678118654757],\n       [-0.70710678118654746, 0.70710678118654757, 0.0],\n       [-0.70710678118654746, 0, -0.70710678118654757],\n       [-0.70710678118654746, -0.70710678118654757, 0.0],\n    ]\n    totalCSSList = []\n    for CSSHat in CSSOrientationList:\n        newCSS = messaging.CSSUnitConfigMsgPayload()\n        newCSS.CBias = 1.0\n        newCSS.nHat_B = CSSHat\n        totalCSSList.append(newCSS)\n    cssConstelation.nCSS = len(CSSOrientationList)\n    cssConstelation.cssVals = totalCSSList\n    cssConstInMsg = messaging.CSSConfigMsg().write(cssConstelation)\n\n    dataLog = module.filtDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Add the kelly curve coefficients\n    if kellyOn:\n        kellList = []\n        for j in range(len(CSSOrientationList)):\n            kellyData = sunlineSuKF.SunlineSuKFCFit()\n            kellyData.cssKellFact = 0.05\n            kellyData.cssKellPow = 2.\n            kellyData.cssRelScale = 1.\n            kellList.append(kellyData)\n        module.kellFits = kellList\n\n    testVector = numpy.array([-0.7, 0.7, 0.0])\n    testVector/=numpy.linalg.norm(testVector)\n    inputData = messaging.CSSArraySensorMsgPayload()\n    dotList = []\n    for element in CSSOrientationList:\n        dotProd = numpy.dot(numpy.array(element), testVector)/(numpy.linalg.norm(element)*numpy.linalg.norm(testVector))\n        dotList.append(dotProd)\n\n    inputData.CosValue = dotList\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n\n    stateTarget = testVector.tolist()\n    stateTarget.extend([0.0, 0.0, 1.])\n    # module.stateInit = [0.7, 0.7, 0.0, 0.01, 0.001, 1.]\n\n    # connect messages\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConstInMsg)\n\n    numStates = len(module.stateInit)\n    unitTestSim.InitializeSimulation()\n    if kellyOn:\n        time = 1000\n    else:\n        time =  500\n    for i in range(time):\n        cssDataInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i+1)*0.5))\n        unitTestSim.ExecuteSimulation()\n\n    stateLog = addTimeColumn(dataLog.times(), dataLog.state)\n    postFitLog = addTimeColumn(dataLog.times(), dataLog.postFitRes)\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n    accuracy = 1.0E-3\n    if kellyOn:\n        accuracy = 1.0E-2 # 1% Error test for the kelly curves given errors\n    for i in range(numStates):\n        if(covarLog[-1, i*numStates+1+i] > covarLog[0, i*numStates+1+i]):\n            testFailCount += 1\n            testMessages.append(\"Covariance update failure first part\")\n    if(numpy.arccos(numpy.dot(stateLog[-1, 1:4], stateTarget[0:3])/(numpy.linalg.norm(stateLog[-1, 1:4])*numpy.linalg.norm(stateTarget[0:3]))) > accuracy):\n        print(numpy.arccos(numpy.dot(stateLog[-1, 1:4], stateTarget[0:3])/(numpy.linalg.norm(stateLog[-1, 1:4])*numpy.linalg.norm(stateTarget[0:3]))))\n        testFailCount += 1\n        testMessages.append(\"Pointing update failure\")\n    if(numpy.linalg.norm(stateLog[-1, 4:7] - stateTarget[3:6]) > accuracy):\n        print(numpy.linalg.norm(stateLog[-1,  4:7] - stateTarget[3:6]))\n        testFailCount += 1\n        testMessages.append(\"Rate update failure\")\n    if(abs(stateLog[-1, 6] - stateTarget[5]) > accuracy):\n        print(abs(stateLog[-1, 6] - stateTarget[5]))\n        testFailCount += 1\n        testMessages.append(\"Sun Intensity update failure\")\n\n    testVector = numpy.array([-0.7, 0.75, 0.0])\n    testVector /= numpy.linalg.norm(testVector)\n    inputData = messaging.CSSArraySensorMsgPayload()\n    dotList = []\n    for element in CSSOrientationList:\n        dotProd = numpy.dot(numpy.array(element), testVector)\n        dotList.append(dotProd)\n    inputData.CosValue = dotList\n\n    for i in range(time):\n        if i > 20:\n            cssDataInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i+time+1)*0.5))\n        unitTestSim.ExecuteSimulation()\n\n    stateLog = addTimeColumn(dataLog.times(), dataLog.state)\n    postFitLog = addTimeColumn(dataLog.times(), dataLog.postFitRes)\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n    stateTarget = testVector.tolist()\n    stateTarget.extend([0.0, 0.0, 1.0])\n\n    for i in range(numStates):\n        if(covarLog[-1, i*numStates+1+i] > covarLog[0, i*numStates+1+i]):\n            print(covarLog[-1, i*numStates+1+i] - covarLog[0, i*numStates+1+i])\n            testFailCount += 1\n            testMessages.append(\"Covariance update failure\")\n    if(numpy.arccos(numpy.dot(stateLog[-1, 1:4], stateTarget[0:3])/(numpy.linalg.norm(stateLog[-1, 1:4])*numpy.linalg.norm(stateTarget[0:3]))) > accuracy):\n        print(numpy.arccos(numpy.dot(stateLog[-1, 1:4], stateTarget[0:3])/(numpy.linalg.norm(stateLog[-1, 1:4])*numpy.linalg.norm(stateTarget[0:3]))))\n        testFailCount += 1\n        testMessages.append(\"Pointing update failure\")\n    if(numpy.linalg.norm(stateLog[-1, 4:7] - stateTarget[3:6]) > accuracy):\n        print(numpy.linalg.norm(stateLog[-1,  4:7] - stateTarget[3:6]))\n        testFailCount += 1\n        testMessages.append(\"Rate update failure\")\n    if(abs(stateLog[-1, 6] - stateTarget[5]) > accuracy):\n        print(abs(stateLog[-1, 6] - stateTarget[5]))\n        testFailCount += 1\n        testMessages.append(\"Sun Intensity update failure\")\n\n    FilterPlots.StateCovarPlot(stateLog, covarLog, show_plots)\n    FilterPlots.PostFitResiduals(postFitLog, module.qObsVal, show_plots)\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag + \" state update\")\n    else:\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StatePropSunLine(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = sunlineSuKF.sunlineSuKF()\n    module.ModelTag = \"sunlineSuKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module, True)\n    numStates = 6\n    dataLog = module.filtDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    cssConstInMsg = messaging.CSSConfigMsg()\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n\n    # connect messages\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConstInMsg)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(8000.0))\n    unitTestSim.ExecuteSimulation()\n\n    stateLog = addTimeColumn(dataLog.times(), dataLog.state)\n    postFitLog = addTimeColumn(dataLog.times(), dataLog.postFitRes)\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n    FilterPlots.StateCovarPlot(stateLog, covarLog, show_plots)\n    FilterPlots.PostFitResiduals(postFitLog, module.qObsVal, show_plots)\n\n    for i in range(numStates):\n        if(abs(stateLog[-1, i+1] - stateLog[0, i+1]) > 1.0E-10):\n            print(abs(stateLog[-1, i+1] - stateLog[0, i+1]))\n            testFailCount += 1\n            testMessages.append(\"State propagation failure\")\n\n\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag + \" state propagation\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def FaultScenarios():\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Clean methods for Measurement and Time Updates\n    moduleClean1 = sunlineSuKF.SunlineSuKFConfig()\n    moduleClean1.numStates = 6\n    moduleClean1.countHalfSPs = moduleClean1.numStates\n    moduleClean1.state = [0., 0., 0., 0., 0., 0.]\n    moduleClean1.statePrev = [0., 0., 0., 0., 0., 0.]\n    moduleClean1.sBar = [0., 0., 0., 0., 0., 0.,\n                               0., 0., 0., 0., 0., 0.,\n                               0., 0., 0., 0., 0., 0.,\n                               0., 0., 0., 0., 0., 0.,\n                               0., 0., 0., 0., 0., 0.,\n                               0., 0., 0., 0., 0., 0.]\n    moduleClean1.sBarPrev = [1., 0., 0., 0., 0., 0.,\n                                   0., 1., 0., 0., 0., 0.,\n                                   0., 0., 1., 0., 0., 0.,\n                                   0., 0., 0., 1., 0., 0.,\n                                   0., 0., 0., 0., 1., 0.,\n                                   0., 0., 0., 0., 0., 1.]\n    moduleClean1.covar = [0., 0., 0., 0., 0., 0.,\n                                0., 0., 0., 0., 0., 0.,\n                                0., 0., 0., 0., 0., 0.,\n                                0., 0., 0., 0., 0., 0.,\n                                0., 0., 0., 0., 0., 0.,\n                                0., 0., 0., 0., 0., 0.]\n    moduleClean1.covarPrev = [2., 0., 0., 0., 0., 0.,\n                                    0., 2., 0., 0., 0., 0.,\n                                    0., 0., 2., 0., 0., 0.,\n                                    0., 0., 0., 2., 0., 0.,\n                                    0., 0., 0., 0., 2., 0.,\n                                    0., 0., 0., 0., 0., 2.]\n\n    sunlineSuKF.sunlineSuKFCleanUpdate(moduleClean1)\n\n    if numpy.linalg.norm(numpy.array(moduleClean1.covarPrev) - numpy.array(moduleClean1.covar)) > 1E10:\n        testFailCount += 1\n        testMessages.append(\"sunlineSuKFClean Covar failed\")\n    if numpy.linalg.norm(numpy.array(moduleClean1.statePrev) - numpy.array(moduleClean1.state)) > 1E10:\n        testFailCount += 1\n        testMessages.append(\"sunlineSuKFClean States failed\")\n    if numpy.linalg.norm(numpy.array(moduleClean1.sBar) - numpy.array(moduleClean1.sBarPrev)) > 1E10:\n        testFailCount += 1\n        testMessages.append(\"sunlineSuKFClean sBar failed\")\n\n    cssConstInMsg = messaging.CSSConfigMsg()\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n\n    # connect messages\n    moduleClean1.cssDataInMsg.subscribeTo(cssDataInMsg)\n    moduleClean1.cssConfigInMsg.subscribeTo(cssConstInMsg)\n\n    moduleClean1.alpha = 0.02\n    moduleClean1.beta = 2.0\n    moduleClean1.kappa = 0.0\n\n    moduleClean1.wC = [-1] * (moduleClean1.numStates * 2 + 1)\n    moduleClean1.wM = [-1] * (moduleClean1.numStates * 2 + 1)\n    retTime = sunlineSuKF.sunlineSuKFTimeUpdate(moduleClean1, 1)\n    retMease = sunlineSuKF.sunlineSuKFMeasUpdate(moduleClean1, 1)\n    if retTime == 0:\n        testFailCount += 1\n        testMessages.append(\"Failed to catch bad Update and clean in Time update\")\n    if retMease == 0:\n        testFailCount += 1\n        testMessages.append(\"Failed to catch bad Update and clean in Meas update\")\n\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: fault detection test\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StateCovarPlot(x, Pflat, show_plots):\n\n    numStates = len(x[0,:])-1\n\n    P = np.zeros([len(Pflat[:,0]),numStates,numStates])\n    t= np.zeros(len(Pflat[:,0]))\n    for i in range(len(Pflat[:,0])):\n        t[i] = x[i, 0]*1E-9\n        P[i,:,:] = Pflat[i,1:(numStates*numStates+1)].reshape([numStates,numStates])\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(t , x[:, 1], \"b\", label='Error Filter')\n    plt.plot(t , x[:, 1]+3 * np.sqrt(P[:, 0, 0]), 'r--',  label='Covar Filter')\n    plt.plot(t , x[:, 1]-3 * np.sqrt(P[:, 0, 0]), 'r--')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n    plt.subplot(322)\n    plt.plot(t , x[:, 4], \"b\")\n    plt.plot(t , x[:, 4]+3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.plot(t , x[:, 4]-3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.title('Second rate component')\n    plt.grid()\n\n    plt.subplot(323)\n    plt.plot(t , x[:, 2], \"b\")\n    plt.plot(t , x[:, 2]+3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.plot(t , x[:, 2]-3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.title('Second LOS component')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(t , x[:, 5], \"b\")\n    plt.plot(t , x[:, 5]+3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.plot(t , x[:, 5]-3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(t , x[:, 3], \"b\")\n    plt.plot(t , x[:, 3]+3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.plot(t , x[:, 3]-3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third LOS component')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(t , x[:, 6], \"b\")\n    plt.plot(t , x[:, 6]+3 * np.sqrt(P[:, 5, 5]), 'r--')\n    plt.plot(t , x[:, 6]-3 * np.sqrt(P[:, 5, 5]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Solar Intensity')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesPlot', 'State error and covariance', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def PostFitResiduals(Res, noise, show_plots):\n\n    MeasNoise = np.zeros(len(Res[:,0]))\n    t= np.zeros(len(Res[:,0]))\n    for i in range(len(Res[:,0])):\n        t[i] = Res[i, 0]*1E-9\n        MeasNoise[i] = 3*noise\n        # Don't plot zero values, since they mean that no measurement is taken\n        for j in range(len(Res[0,:])-1):\n            if -1E-10 < Res[i,j+1] < 1E-10:\n                Res[i, j+1] = np.nan\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(421)\n    plt.plot(t , Res[:, 1], \"b.\", label='Residual')\n    plt.plot(t , MeasNoise, 'r--', label='Covar')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.legend(loc='lower right')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('First CSS')\n    plt.grid()\n\n    plt.subplot(422)\n    plt.plot(t , Res[:, 5], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Fifth CSS')\n    plt.grid()\n\n    plt.subplot(423)\n    plt.plot(t , Res[:, 2], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Second CSS')\n    plt.grid()\n\n    plt.subplot(424)\n    plt.plot(t , Res[:, 6], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Sixth CSS')\n    plt.grid()\n\n    plt.subplot(425)\n    plt.plot(t , Res[:, 3], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Third CSS')\n    plt.grid()\n\n    plt.subplot(426)\n    plt.plot(t , Res[:, 7], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Seventh CSS')\n    plt.grid()\n\n    plt.subplot(427)\n    plt.plot(t , Res[:, 4], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.xlabel('t(s)')\n    plt.title('Fourth CSS')\n    plt.grid()\n\n    plt.subplot(428)\n    plt.plot(t , Res[:, 8], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.xlabel('t(s)')\n    plt.title('Eight CSS')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('PostFit' , 'Post Fit Residuals', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def createCosList(sunPointVec, sensorPointList):\n    outList = []\n    for sensorPoint in sensorPointList:\n        outList.append(numpy.dot(sunPointVec, sensorPoint))\n        if(outList[-1] < 0.0):\n            outList[-1] = 0.0\n    return outList",
  "def checkNumActiveAccuracy(measVec, numActiveUse, numActiveFailCriteria, thresh):\n    numActivePred = 0\n    testFailCount = 0\n    # Iterate through measVec and find all valid signals\n    for i in range(0, 32):\n        obsVal = measVec.CosValue[i]\n        if (obsVal > thresh):\n            numActivePred += 1\n\n    # Iterate through the numActive array and sum up all numActive estimates\n    numActiveTotal = numpy.array([0.])\n    j = 0\n    while j < numActiveUse.shape[0]:\n        numActiveTotal += numActiveUse[j, 1:]\n        j += 1\n    numActiveTotal /= j  # Mean number of numActive\n    # If we violate the test criteria, increment the failure count and alert user\n    if (abs(numActiveTotal[0] - numActivePred) > numActiveFailCriteria):\n        testFailCount += 1\n        errorString = \"Active number failure for count of: \"\n        errorString += str(numActivePred)\n        logging.error(errorString)\n    return testFailCount",
  "def checksHatAccuracy(testVec, sHatEstUse, angleFailCriteria, TotalSim):\n    j = 0\n    testFailCount = 0\n    sHatTotal = numpy.array([0.0, 0.0, 0.0])\n    # Sum up all of the sHat estimates from the execution\n    while j < sHatEstUse.shape[0]:\n        sHatTotal += sHatEstUse[j]\n        j += 1\n    sHatTotal /= j  # mean sHat estimate\n    # This logic is to protect cases where the dot product numerically breaks acos\n    dot_value = numpy.dot(sHatTotal, testVec)\n    if (abs(dot_value > 1.0)):\n        dot_value -= 2.0 * (dot_value - math.copysign(1.0, dot_value))\n\n    # If we violate the failure criteria, increment failure count and alert user\n    if (abs(math.acos(dot_value)) > angleFailCriteria):\n        testFailCount += 1\n        errorString = \"Angle fail criteria violated for test vector:\"\n        errorString += str(testVec).strip('[]') + \"\\n\"\n        errorString += \"Criteria violation of: \"\n        errorString += str(abs(math.acos(numpy.dot(sHatTotal, testVec))))\n        logging.error(errorString)\n    return testFailCount",
  "def checkResidAccuracy(testVec, sResids, sThresh, TotalSim):\n    j = 0\n    testFailCount = 0\n    # Sum up all of the sHat estimates from the execution\n    while j < sResids.shape[0]:\n        sNormObs = numpy.linalg.norm(sResids[j,1:])\n        if(sNormObs > sThresh):\n            testFailCount += 1\n            errorString = \"Residual error computation failure:\"\n            errorString += str(testVec).strip('[]') + \"\\n\"\n            errorString += \"Criteria violation of: \"\n            errorString += str(sNormObs)\n            logging.error(errorString)\n        j += 1\n    return testFailCount",
  "def test_module(show_plots, testSunHeading, testRate):     # update \"module\" in this function name to reflect the module name\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    # pass on the testPlotFixture so that the main test function may set the DataStore attributes\n\n    if testSunHeading:\n        [testResults, testMessage] = cssWlsEstTestFunction(show_plots)\n        assert testResults < 1, testMessage\n\n    if testRate:\n        [testResults, testMessage] = cssRateTestFunction(show_plots)\n        assert testResults < 1, testMessage",
  "def cssWlsEstTestFunction(show_plots):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, int(1E8)))\n\n    # Construct algorithm and associated C++ container\n    CSSWlsEstFSW = cssWlsEst.cssWlsEst()\n    CSSWlsEstFSW.ModelTag = \"CSSWlsEst\"\n\n    # Add module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, CSSWlsEstFSW)\n\n    # Initialize the WLS estimator configuration data\n    CSSWlsEstFSW.useWeights = False\n    CSSWlsEstFSW.sensorUseThresh = 0.15\n\n    CSSOrientationList = [\n        [0.70710678118654746, -0.5, 0.5],\n        [0.70710678118654746, -0.5, -0.5],\n        [0.70710678118654746, 0.5, -0.5],\n        [0.70710678118654746, 0.5, 0.5],\n        [-0.70710678118654746, 0, 0.70710678118654757],\n        [-0.70710678118654746, 0.70710678118654757, 0.0],\n        [-0.70710678118654746, 0, -0.70710678118654757],\n        [-0.70710678118654746, -0.70710678118654757, 0.0],\n    ]\n    numCSS = len(CSSOrientationList)\n\n    # set the CSS unit vectors\n    cssConfigData = messaging.CSSConfigMsgPayload()\n    totalCSSList = []\n    for CSSHat in CSSOrientationList:\n        CSSConfigElement = messaging.CSSUnitConfigMsgPayload()\n        CSSConfigElement.CBias = 1.0\n        CSSConfigElement.nHat_B = CSSHat\n        totalCSSList.append(CSSConfigElement)\n    cssConfigData.nCSS = numCSS\n    cssConfigData.cssVals = totalCSSList\n    cssConfigDataInMsg = messaging.CSSConfigMsg().write(cssConfigData)\n\n    # Initialize CSS input message\n    cssDataMsg = messaging.CSSArraySensorMsgPayload()\n    cssDataInMsg = messaging.CSSArraySensorMsg().write(cssDataMsg)\n\n    angleFailCriteria = 17.5 * math.pi / 180.0  # Get 95% effective charging in this case\n    numActiveFailCriteria = 0.000001  # basically zero\n    residFailCriteria = 1.0E-12  # Essentially numerically \"small\"\n\n    # Log the output message as well as the internal numACtiveCss variables\n    navData = CSSWlsEstFSW.navStateOutMsg.recorder()\n    filterData = CSSWlsEstFSW.cssWLSFiltResOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, navData)\n    unitTestSim.AddModelToTask(unitTaskName, filterData)\n    unitTestSim.AddVariableForLogging(\"CSSWlsEst.numActiveCss\", int(1E8))\n\n    # connect the messages\n    CSSWlsEstFSW.cssDataInMsg.subscribeTo(cssDataInMsg)\n    CSSWlsEstFSW.cssConfigInMsg.subscribeTo(cssConfigDataInMsg)\n\n    # Initial test is all of the principal body axes\n    TestVectors = [[-1.0, 0.0, 0.0],\n                   [0.0, -1.0, 0.0],\n                   [1.0, 0.0, 0.0],\n                   [0.0, 1.0, 0.0],\n                   [0.0, 0.0, -1.0],\n                   [0.0, 0.0, 1.0]]\n\n    # Initialize test and then step through all of the test vectors in a loop\n    unitTestSim.InitializeSimulation()\n    CSSWlsEstFSW.Reset(0)     # this module reset function needs a time input (in NanoSeconds)\n\n    stepCount = 0\n    logLengthPrev = 0\n\n    truthData = []\n    for testVec in TestVectors:\n        if stepCount > 1:  # Doing this to test permutations and get code coverage\n            CSSWlsEstFSW.useWeights = True\n\n        # Get observation data based on sun pointing and CSS orientation data\n        cssDataMsg.CosValue = createCosList(testVec, CSSOrientationList)\n\n        # Write in the observation data to the input message\n        cssDataInMsg.write(cssDataMsg)\n\n        # Increment the stop time to new termination value\n        unitTestSim.ConfigureStopTime(int((stepCount + 1) * 1E9))\n        # Execute simulation to current stop time\n        unitTestSim.ExecuteSimulation()\n        stepCount += 1\n\n        # Pull logged data out into workspace for analysis\n        sHatEst = navData.vehSunPntBdy\n\n        numActive = unitTestSim.GetLogVariableData(\"CSSWlsEst.numActiveCss\")\n        sHatEstUse = sHatEst[logLengthPrev:, :]  # Only data for this subtest\n        numActiveUse = numActive[logLengthPrev + 1:, :]  # Only data for this subtest\n\n        # Check failure criteria and add test failures\n        testFailCount += checksHatAccuracy(testVec, sHatEstUse, angleFailCriteria,\n                                           unitTestSim)\n        testFailCount += checkNumActiveAccuracy(cssDataMsg, numActiveUse,\n                                                numActiveFailCriteria, CSSWlsEstFSW.sensorUseThresh)\n\n        filtRes = filterData.postFitRes\n        testFailCount += checkResidAccuracy(testVec, filtRes, residFailCriteria,\n                                            unitTestSim)\n\n        # Pop truth state onto end of array for plotting purposes\n        currentRow = [sHatEstUse[0, 0]]\n        currentRow.extend(testVec)\n        truthData.append(currentRow)\n        currentRow = [sHatEstUse[-1, 0]]\n        currentRow.extend(testVec)\n        truthData.append(currentRow)\n        logLengthPrev = sHatEst.shape[0]\n\n    # Hand construct case where we get low coverage (2 valid sensors)\n    LonVal = 0.0\n    LatVal = 40.68 * math.pi / 180.0\n    doubleTestVec = [math.sin(LatVal), math.cos(LatVal) * math.sin(LonVal),\n                     math.cos(LatVal) * math.cos(LonVal)]\n    cssDataMsg.CosValue = createCosList(doubleTestVec, CSSOrientationList)\n\n    # Write in double coverage conditions and ensure that we get correct outputs\n    cssDataInMsg.write(cssDataMsg)\n\n    unitTestSim.ConfigureStopTime(int((stepCount + 1) * 1E9))\n    unitTestSim.ExecuteSimulation()\n    stepCount += 1\n    sHatEst = navData.vehSunPntBdy\n    numActive = unitTestSim.GetLogVariableData(\"CSSWlsEst.numActiveCss\")\n    sHatEstUse = sHatEst[logLengthPrev:, :]\n    numActiveUse = numActive[logLengthPrev + 1:, :]\n    logLengthPrev = sHatEst.shape[0]\n    currentRow = [sHatEstUse[0, 0]]\n    currentRow.extend(doubleTestVec)\n    truthData.append(currentRow)\n    currentRow = [sHatEstUse[-1, 0]]\n    currentRow.extend(doubleTestVec)\n    truthData.append(currentRow)\n\n    # Check test criteria again\n    testFailCount += checksHatAccuracy(doubleTestVec, sHatEstUse, angleFailCriteria,\n                                       unitTestSim)\n    testFailCount += checkNumActiveAccuracy(cssDataMsg, numActiveUse,\n                                            numActiveFailCriteria, CSSWlsEstFSW.sensorUseThresh)\n\n    # Same test as above, but zero first element to get to a single coverage case\n    cssDataMsg.CosValue[0] = 0.0\n    cssDataInMsg.write(cssDataMsg)\n\n    unitTestSim.ConfigureStopTime(int((stepCount + 1) * 1E9))\n    unitTestSim.ExecuteSimulation()\n    stepCount += 1\n    numActive = unitTestSim.GetLogVariableData(\"CSSWlsEst.numActiveCss\")\n    numActiveUse = numActive[logLengthPrev + 1:, :]\n    sHatEst = navData.vehSunPntBdy\n    sHatEstUse = sHatEst[logLengthPrev + 1:, :]\n    logLengthPrev = sHatEst.shape[0]\n    testFailCount += checkNumActiveAccuracy(cssDataMsg, numActiveUse,\n                                            numActiveFailCriteria, CSSWlsEstFSW.sensorUseThresh)\n    currentRow = [sHatEstUse[0, 0]]\n    currentRow.extend(doubleTestVec)\n    truthData.append(currentRow)\n    currentRow = [sHatEstUse[-1, 0]]\n    currentRow.extend(doubleTestVec)\n    truthData.append(currentRow)\n\n    # Same test as above, but zero first and fourth elements to get to zero coverage\n    cssDataMsg.CosValue[0] = 0.0\n    cssDataMsg.CosValue[3] = 0.0\n    cssDataInMsg.write(cssDataMsg)\n\n    unitTestSim.ConfigureStopTime(int((stepCount + 1) * 1E9))\n    unitTestSim.ExecuteSimulation()\n    numActive = unitTestSim.GetLogVariableData(\"CSSWlsEst.numActiveCss\")\n    numActiveUse = numActive[logLengthPrev:, :]\n    logLengthPrev = numActive.shape[0]\n    testFailCount += checkNumActiveAccuracy(cssDataMsg, numActiveUse,\n                                            numActiveFailCriteria, CSSWlsEstFSW.sensorUseThresh)\n\n    # Format data for plotting\n    truthData = numpy.array(truthData)\n    sHatEst = navData.vehSunPntBdy\n    numActive = unitTestSim.GetLogVariableData(\"CSSWlsEst.numActiveCss\")\n\n\n    #\n    # test the case where all CSS signals are zero\n    #\n    cssDataMsg.CosValue = numpy.zeros(len(CSSOrientationList))\n    cssDataInMsg.write(cssDataMsg)\n    unitTestSim.ConfigureStopTime(int((stepCount + 2) * 1E9))\n    unitTestSim.ExecuteSimulation()\n    sHatEstZero = navData.vehSunPntBdy\n    sHatEstZeroUse = sHatEstZero[logLengthPrev + 1:, :]\n\n    trueVector = [[0.0, 0.0, 0.0]]*len(sHatEstZeroUse)\n    for i in range(0, len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(sHatEstZeroUse[i], trueVector[i], 3, 1e-12):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + CSSWlsEstFSW.ModelTag + \" Module failed  unit test at t=\" +\n                                str(navData.times()[i] * macros.NANO2SEC) + \"sec\\n\")\n\n\n\n    if show_plots:\n        plt.figure(1)\n        plt.plot(sHatEst[:, 0] * 1.0E-9, sHatEst[:, 0], label='x-Sun')\n        plt.plot(sHatEst[:, 0] * 1.0E-9, sHatEst[:, 1], label='y-Sun')\n        plt.plot(sHatEst[:, 0] * 1.0E-9, sHatEst[:, 2], label='z-Sun')\n        plt.legend(loc='upper left')\n        plt.xlabel('Time (s)')\n        plt.ylabel('Unit Component (--)')\n\n        plt.figure(2)\n        plt.plot(numActive[:, 0] * 1.0E-9, numActive[:, 1])\n        plt.xlabel('Time (s)')\n        plt.ylabel('Number Active CSS (--)')\n\n        plt.figure(3)\n        plt.subplot(3, 1, 1)\n        plt.plot(sHatEst[:, 0] * 1.0E-9, sHatEst[:, 0], label='Est')\n        plt.plot(truthData[:, 0] * 1.0E-9, truthData[:, 0], 'r--', label='Truth')\n        plt.xlabel('Time (s)')\n        plt.ylabel('X Component (--)')\n        plt.legend(loc='lower right')\n        plt.subplot(3, 1, 2)\n        plt.plot(sHatEst[:, 0] * 1.0E-9, sHatEst[:, 1], label='Est')\n        plt.plot(truthData[:, 0] * 1.0E-9, truthData[:, 1], 'r--', label='Truth')\n        plt.xlabel('Time (s)')\n        plt.ylabel('Y Component (--)')\n        plt.subplot(3, 1, 3)\n        plt.plot(sHatEst[:, 0] * 1.0E-9, sHatEst[:, 2], label='Est')\n        plt.plot(truthData[:, 0] * 1.0E-9, truthData[:, 2], 'r--', label='Truth')\n        plt.xlabel('Time (s)')\n        plt.ylabel('Z Component (--)')\n        plt.show()\n        plt.close('all')\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + CSSWlsEstFSW.ModelTag)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def cssRateTestFunction(show_plots):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = cssWlsEst.cssWlsEst()\n    module.ModelTag = \"CSSWlsEst\"\n\n    # Add module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the WLS estimator configuration data\n    module.useWeights = False\n    module.sensorUseThresh = 0.15\n\n    CSSOrientationList = [\n        [0.70710678118654746, -0.5, 0.5],\n        [0.70710678118654746, -0.5, -0.5],\n        [0.70710678118654746, 0.5, -0.5],\n        [0.70710678118654746, 0.5, 0.5],\n        [-0.70710678118654746, 0, 0.70710678118654757],\n        [-0.70710678118654746, 0.70710678118654757, 0.0],\n        [-0.70710678118654746, 0, -0.70710678118654757],\n        [-0.70710678118654746, -0.70710678118654757, 0.0],\n    ]\n    numCSS = len(CSSOrientationList)\n\n    # set the CSS unit vectors\n    cssConfigData = messaging.CSSConfigMsgPayload()\n    totalCSSList = []\n    for CSSHat in CSSOrientationList:\n        CSSConfigElement = messaging.CSSUnitConfigMsgPayload()\n        CSSConfigElement.CBias = 1.0\n        CSSConfigElement.nHat_B = CSSHat\n        totalCSSList.append(CSSConfigElement)\n    cssConfigData.nCSS = numCSS\n    cssConfigData.cssVals = totalCSSList\n    cssConfigDataInMsg = messaging.CSSConfigMsg().write(cssConfigData)\n\n    # Log the output message as well as the internal numACtiveCss variables\n    dataLog = module.navStateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Get observation data based on sun pointing and CSS orientation data\n    cssDataMsg = messaging.CSSArraySensorMsgPayload()\n    cssDataMsg.CosValue = createCosList([1.0, 0.0, 0.0], CSSOrientationList)\n    cssDataInMsg = messaging.CSSArraySensorMsg().write(cssDataMsg)\n\n    # connect messages\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConfigDataInMsg)\n\n    # Initialize test and then step through all of the test vectors in a loop\n    unitTestSim.InitializeSimulation()\n    # Increment the stop time to new termination value\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))\n    # Execute simulation to current stop time\n    unitTestSim.ExecuteSimulation()\n\n    # rotate sun heading by 90 degrees\n    cssDataMsg.CosValue = createCosList([0.0, 1.0, 0.0], CSSOrientationList)\n    cssDataInMsg.write(cssDataMsg)\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))\n    unitTestSim.ExecuteSimulation()\n\n    # test the module reset function\n    module.Reset(1)     # this module reset function needs a time input (in NanoSeconds)\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.5))\n    unitTestSim.ExecuteSimulation()\n    cssDataMsg.CosValue = createCosList([1.0, 0.0, 0.0], CSSOrientationList)\n    cssDataInMsg.write(cssDataMsg)\n    unitTestSim.ConfigureStopTime(macros.sec2nano(3.0))\n    unitTestSim.ExecuteSimulation()\n\n    accuracy = 1e-6\n    trueVector = [\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, -3.14159265],\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, +3.14159265]\n    ]\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, dataLog.omega_BN_B,\n                                                               accuracy, \"CSS Rate Vector\",\n                                                               testFailCount, testMessages)\n\n    #   print out success message if no error were found\n    snippentName = \"passFailRate\"\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def addTimeColumn(time, data):\n    return np.transpose(np.vstack([[time], np.transpose(data)]))",
  "def setupFilterData(filterObject):\n\n    filterObject.sensorUseThresh = 0.\n    filterObject.state = [1.0, 1.0, 1.0, 0.0, 0.0, 0.0]\n    filterObject.x = [1.0, 0.0, 1.0, 0.0, 0.1, 0.0]\n    filterObject.covar = [0.4, 0.0, 0.0, 0.0, 0.0, 0.0,\n                          0.0, 0.4, 0.0, 0.0, 0.0, 0.0,\n                          0.0, 0.0, 0.4, 0.0, 0.0, 0.0,\n                          0.0, 0.0, 0.0, 0.004, 0.0, 0.0,\n                          0.0, 0.0, 0.0, 0.0, 0.004, 0.0,\n                          0.0, 0.0, 0.0, 0.0, 0.0, 0.004]\n\n    filterObject.qProcVal = 0.1**2\n    filterObject.qObsVal = 0.001\n    filterObject.eKFSwitch = 5.",
  "def test_all_functions_ekf(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = sunline_individual_test()\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = StatePropStatic()\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = StatePropVariable(show_plots)\n    assert testResults < 1, testMessage",
  "def test_all_sunline_ekf(show_plots, SimHalfLength, AddMeasNoise, testVector1, testVector2, stateGuess):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = StateUpdateSunLine(show_plots, SimHalfLength, AddMeasNoise, testVector1, testVector2, stateGuess)\n    assert testResults < 1, testMessage",
  "def sunline_individual_test():\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    ###################################################################################\n    ## Testing dynamics matrix computation\n    ###################################################################################\n\n    inputStates = [2,1,0.75,0.1,0.4,0.05]\n    dt =0.5\n\n    expDynMat = np.zeros([6,6])\n    expDynMat[0:3, 0:3] = -(np.outer(inputStates[0:3],inputStates[3:6])/np.linalg.norm(inputStates[0:3])**2. +\n                         np.dot(inputStates[3:6],inputStates[0:3])*(np.linalg.norm(inputStates[0:3])**2.*np.eye(3)- 2*np.outer(inputStates[0:3],inputStates[0:3]))/np.linalg.norm(inputStates[0:3])**4.)\n    expDynMat[0:3, 3:6] = np.eye(3) - np.outer(inputStates[0:3],inputStates[0:3])/np.linalg.norm(inputStates[0:3])**2\n\n    ## Equations when removing the unobservable states from d_dot\n    expDynMat[3:6, 0:3] = -1/dt*(np.outer(inputStates[0:3],inputStates[3:6])/np.linalg.norm(inputStates[0:3])**2. +\n                         np.dot(inputStates[3:6],inputStates[0:3])*(np.linalg.norm(inputStates[0:3])**2.*np.eye(3)- 2*np.outer(inputStates[0:3],inputStates[0:3]))/np.linalg.norm(inputStates[0:3])**4.)\n    expDynMat[3:6, 3:6] =- 1/dt*(np.outer(inputStates[0:3],inputStates[0:3])/np.linalg.norm(inputStates[0:3])**2)\n\n    dynMat = sunlineEKF.new_doubleArray(6*6)\n    for i in range(36):\n        sunlineEKF.doubleArray_setitem(dynMat, i, 0.0)\n    sunlineEKF.sunlineDynMatrix(inputStates, dt, dynMat)\n\n    DynOut = []\n    for i in range(36):\n        DynOut.append(sunlineEKF.doubleArray_getitem(dynMat, i))\n\n    DynOut = np.array(DynOut).reshape(6, 6)\n    errorNorm = np.linalg.norm(expDynMat - DynOut)\n    if(errorNorm > 1.0E-10):\n        print(errorNorm)\n        testFailCount += 1\n        testMessages.append(\"Dynamics Matrix generation Failure \\n\")\n\n    ###################################################################################\n    ## STM and State Test\n    ###################################################################################\n\n    inputStates = [2,1,0.75, 1.5, 0.5, 0.5]\n    dt =0.5\n    stateTransition = sunlineEKF.new_doubleArray(36)\n    states = sunlineEKF.new_doubleArray(6)\n    for i in range(6):\n        sunlineEKF.doubleArray_setitem(states, i, inputStates[i])\n        for j in range(6):\n            if i==j:\n                sunlineEKF.doubleArray_setitem(stateTransition, 6*i+j, 1.0)\n            else:\n                sunlineEKF.doubleArray_setitem(stateTransition, 6*i+j, 0.0)\n\n    sunlineEKF.sunlineStateSTMProp(expDynMat.flatten().tolist(), dt, states, stateTransition)\n\n    PropStateOut = []\n    PropSTMOut = []\n    for i in range(6):\n        PropStateOut.append(sunlineEKF.doubleArray_getitem(states, i))\n    for i in range(36):\n        PropSTMOut.append(sunlineEKF.doubleArray_getitem(stateTransition, i))\n\n    STMout = np.array(PropSTMOut).reshape([6,6])\n    StatesOut = np.array(PropStateOut)\n\n    expectedSTM = dt*np.dot(expDynMat, np.eye(6)) + np.eye(6)\n    expectedStates = np.zeros(6)\n    inputStatesArray = np.array(inputStates)\n    ## Equations when removing the unobservable states from d_dot\n    expectedStates[3:6] = np.array(inputStatesArray[3:6]  - np.dot(inputStatesArray[3:6], inputStatesArray[0:3])*inputStatesArray[0:3]/np.linalg.norm(inputStatesArray[0:3])**2.)\n    expectedStates[0:3] = np.array(inputStatesArray[0:3] + dt*(inputStatesArray[3:6] - np.dot(inputStatesArray[3:6], inputStatesArray[0:3])*inputStatesArray[0:3]/np.linalg.norm(inputStatesArray[0:3])**2.))\n    errorNormSTM = np.linalg.norm(expectedSTM - STMout)\n    errorNormStates = np.linalg.norm(expectedStates - StatesOut)\n\n    if(errorNormSTM > 1.0E-10):\n        testFailCount += 1\n        testMessages.append(\"STM Propagation Failure \\n\")\n\n    if(errorNormStates > 1.0E-10):\n        testFailCount += 1\n        testMessages.append(\"State Propagation Failure \\n\")\n\n    ###################################################################################\n    ## Test the H and yMeas matrix generation as well as the observation count\n    ###################################################################################\n\n    numCSS = 4\n    cssCos = [np.cos(np.deg2rad(10.)), np.cos(np.deg2rad(25.)), np.cos(np.deg2rad(5.)), np.cos(np.deg2rad(90.))]\n    sensorTresh = np.cos(np.deg2rad(50.))\n    cssNormals = [1.,0.,0.,0.,1.,0., 0.,0.,1., 1./np.sqrt(2), 1./np.sqrt(2),0.]\n    cssBias = [1.0 for i in range(numCSS)]\n\n    measMat = sunlineEKF.new_doubleArray(8*6)\n    obs = sunlineEKF.new_doubleArray(8)\n    yMeas = sunlineEKF.new_doubleArray(8)\n    numObs = sunlineEKF.new_intArray(1)\n\n    for i in range(8*6):\n        sunlineEKF.doubleArray_setitem(measMat, i, 0.)\n    for i in range(8):\n        sunlineEKF.doubleArray_setitem(obs, i, 0.0)\n        sunlineEKF.doubleArray_setitem(yMeas, i, 0.0)\n\n    sunlineEKF.sunlineHMatrixYMeas(inputStates, numCSS, cssCos, sensorTresh, cssNormals, cssBias, obs, yMeas, numObs, measMat)\n\n    obsOut = []\n    yMeasOut = []\n    numObsOut = []\n    HOut = []\n    for i in range(8*6):\n        HOut.append(sunlineEKF.doubleArray_getitem(measMat, i))\n    for i in range(8):\n        yMeasOut.append(sunlineEKF.doubleArray_getitem(yMeas, i))\n        obsOut.append(sunlineEKF.doubleArray_getitem(obs, i))\n    numObsOut.append(sunlineEKF.intArray_getitem(numObs, 0))\n\n    #Fill in expected values for test\n    expectedH = np.zeros([8,6])\n    expectedY = np.zeros(8)\n    for j in range(3):\n        expectedH[j,0:3] = np.eye(3)[j,:]\n        expectedY[j] =np.array(cssCos[j]) - np.dot(np.array(inputStates)[0:3], np.array(cssNormals)[j*3:(j+1)*3])\n    expectedObs = np.array([np.cos(np.deg2rad(10.)), np.cos(np.deg2rad(25.)), np.cos(np.deg2rad(5.)),0.,0.,0.,0.,0.])\n    expectedNumObs = 3\n\n    HOut = np.array(HOut).reshape([8, 6])\n    errorNorm = np.zeros(4)\n    errorNorm[0] = np.linalg.norm(HOut - expectedH)\n    errorNorm[1] = np.linalg.norm(yMeasOut - expectedY)\n    errorNorm[2] = np.linalg.norm(obsOut - expectedObs)\n    errorNorm[3] = np.linalg.norm(numObsOut[0] - expectedNumObs)\n\n    for i in range(4):\n        if(errorNorm[i] > 1.0E-10):\n            testFailCount += 1\n            testMessages.append(\"H and yMeas update failure \\n\")\n\n    ###################################################################################\n    ## Test the Kalman Gain\n    ###################################################################################\n\n    numObs = 3\n    h = [1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]\n    covar = [1., 0., 0., 1., 0., 0.,\n        0., 1., 0., 0., 1., 0.,\n        0., 0., 1., 0., 0., 1.,\n        1., 0., 0., 1., 0., 0.,\n        0., 1., 0., 0., 1., 0.,\n        0., 0., 1., 0., 0., 1.]\n    noise= 0.01\n\n    Kalman = sunlineEKF.new_doubleArray(6 * 8)\n\n    for i in range(8 * 6):\n        sunlineEKF.doubleArray_setitem(Kalman, i, 0.)\n\n    sunlineEKF.sunlineKalmanGain(covar, h, noise, numObs, Kalman)\n\n    KalmanOut = []\n    for i in range(8 * 6):\n        KalmanOut.append(sunlineEKF.doubleArray_getitem(Kalman, i))\n\n    # Fill in expected values for test\n    Hmat = np.array(h).reshape([8,6])\n    Pk = np.array(covar).reshape([6,6])\n    R = noise*np.eye(3)\n    expectedK = np.dot(np.dot(Pk, Hmat[0:numObs,:].T), np.linalg.inv(np.dot(np.dot(Hmat[0:numObs,:], Pk), Hmat[0:numObs,:].T) + R[0:numObs,0:numObs]))\n\n    KalmanOut = np.array(KalmanOut)[0:6*numObs].reshape([6, 3])\n    errorNorm = np.linalg.norm(KalmanOut[:,0:numObs] - expectedK)\n\n    if (errorNorm > 1.0E-10):\n        print(errorNorm)\n        testFailCount += 1\n        testMessages.append(\"Kalman Gain update failure \\n\")\n\n    ###################################################################################\n    ## Test the EKF update\n    ###################################################################################\n\n    KGain = [1.,2.,3., 0., 1., 2., 1., 0., 1., 0., 1., 0., 3., 0., 1., 0., 2., 0.]\n    for i in range(6*8-6*3):\n        KGain.append(0.)\n    inputStates = [2,1,0.75,0.1,0.4,0.05]\n    xbar = [0.1, 0.2, 0.01, 0.005, 0.009, 0.001]\n    numObs = 3\n    h = [1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]\n    covar = [1., 0., 0., 1., 0., 0.,\n             0., 1., 0., 0., 1., 0.,\n             0., 0., 1., 0., 0., 1.,\n             1., 0., 0., 1., 0., 0.,\n             0., 1., 0., 0., 1., 0.,\n             0., 0., 1., 0., 0., 1.]\n    noise = 0.01\n    inputY = np.zeros(3)\n    for j in range(3):\n        inputY[j] = np.array(cssCos[j]) - np.dot(np.array(inputStates)[0:3], np.array(cssNormals)[j * 3:(j + 1) * 3])\n    inputY = inputY.tolist()\n\n    stateError = sunlineEKF.new_doubleArray(6)\n    covarMat = sunlineEKF.new_doubleArray(6*6)\n    inputs = sunlineEKF.new_doubleArray(6)\n\n\n    for i in range(6):\n        sunlineEKF.doubleArray_setitem(stateError, i, 0.)\n        sunlineEKF.doubleArray_setitem(inputs, i, inputStates[i])\n        for j in range(6):\n            sunlineEKF.doubleArray_setitem(covarMat,i+j,0.)\n\n    sunlineEKF.sunlineEKFUpdate(KGain, covar, noise, numObs, inputY, h, inputs, stateError, covarMat)\n\n    stateOut = []\n    covarOut = []\n    errorOut = []\n    for i in range(6):\n        stateOut.append(sunlineEKF.doubleArray_getitem(inputs, i))\n        errorOut.append(sunlineEKF.doubleArray_getitem(stateError, i))\n    for j in range(36):\n        covarOut.append(sunlineEKF.doubleArray_getitem(covarMat, j))\n\n    # Fill in expected values for test\n    KK = np.array(KGain)[0:6*3].reshape([6,3])\n    expectedStates = np.array(inputStates) + np.dot(KK, np.array(inputY))\n    H = np.array(h).reshape([8,6])[0:3,:]\n    Pk = np.array(covar).reshape([6, 6])\n    R = noise * np.eye(3)\n    expectedP = np.dot(np.dot(np.eye(6) - np.dot(KK, H), Pk), np.transpose(np.eye(6) - np.dot(KK, H))) + np.dot(KK, np.dot(R,KK.T))\n\n    errorNorm = np.zeros(2)\n    errorNorm[0] = np.linalg.norm(np.array(stateOut) - expectedStates)\n    errorNorm[1] = np.linalg.norm(expectedP - np.array(covarOut).reshape([6,6]))\n\n    for i in range(2):\n        if(errorNorm[i] > 1.0E-10):\n            testFailCount += 1\n            testMessages.append(\"EKF update failure \\n\")\n\n    ###################################################################################\n    ## Test the CKF update\n    ###################################################################################\n\n    KGain = [1., 2., 3., 0., 1., 2., 1., 0., 1., 0., 1., 0., 3., 0., 1., 0., 2., 0.]\n    for i in range(6 * 8 - 6 * 3):\n        KGain.append(0.)\n    inputStates = [2, 1, 0.75, 0.1, 0.4, 0.05]\n    xbar = [0.1, 0.2, 0.01, 0.005, 0.009, 0.001]\n    numObs = 3\n    h = [1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]\n    covar = [1., 0., 0., 1., 0., 0.,\n             0., 1., 0., 0., 1., 0.,\n             0., 0., 1., 0., 0., 1.,\n             1., 0., 0., 1., 0., 0.,\n             0., 1., 0., 0., 1., 0.,\n             0., 0., 1., 0., 0., 1.]\n    noise =0.01\n    inputY = np.zeros(3)\n    for j in range(3):\n        inputY[j] = np.array(cssCos[j]) - np.dot(np.array(inputStates)[0:3],\n                                                 np.array(cssNormals)[j * 3:(j + 1) * 3])\n    inputY = inputY.tolist()\n\n    stateError = sunlineEKF.new_doubleArray(6)\n    covarMat = sunlineEKF.new_doubleArray(6 * 6)\n\n    for i in range(6):\n        sunlineEKF.doubleArray_setitem(stateError, i, xbar[i])\n        for j in range(6):\n            sunlineEKF.doubleArray_setitem(covarMat, i + j, 0.)\n\n    sunlineEKF.sunlineCKFUpdate(xbar, KGain, covar, noise, numObs, inputY, h, stateError, covarMat)\n\n    covarOut = []\n    errorOut = []\n    for i in range(6):\n        errorOut.append(sunlineEKF.doubleArray_getitem(stateError, i))\n    for j in range(36):\n        covarOut.append(sunlineEKF.doubleArray_getitem(covarMat, j))\n\n    # Fill in expected values for test\n    KK = np.array(KGain)[0:6 * 3].reshape([6, 3])\n    H = np.array(h).reshape([8, 6])[0:3, :]\n    expectedStateError = np.array(xbar) + np.dot(KK, (np.array(inputY) - np.dot(H, np.array(xbar))))\n    Pk = np.array(covar).reshape([6, 6])\n    expectedP = np.dot(np.dot(np.eye(6) - np.dot(KK, H), Pk), np.transpose(np.eye(6) - np.dot(KK, H))) + np.dot(KK,\n                                                                                                                np.dot(\n                                                                                                                    R,\n                                                                                                                    KK.T))\n\n    errorNorm = np.zeros(2)\n    errorNorm[0] = np.linalg.norm(np.array(errorOut) - expectedStateError)\n    errorNorm[1] = np.linalg.norm(expectedP - np.array(covarOut).reshape([6, 6]))\n\n    for i in range(2):\n        if (errorNorm[i] > 1.0E-10):\n            testFailCount += 1\n            testMessages.append(\"CKF update failure \\n\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" EKF individual tests\")\n    else:\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StatePropStatic():\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = sunlineEKF.sunlineEKF()\n    module.ModelTag = \"SunlineEKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n    unitTestSim.AddVariableForLogging('SunlineEKF.covar', testProcessRate * 10, 0, 35)\n    unitTestSim.AddVariableForLogging('SunlineEKF.state', testProcessRate * 10, 0, 5)\n\n    # connect messages\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n    cssConfigInMsg = messaging.CSSConfigMsg()\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConfigInMsg)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(8000.0))\n    unitTestSim.ExecuteSimulation()\n\n    stateLog = unitTestSim.GetLogVariableData('SunlineEKF.state')\n\n    for i in range(6):\n        if (abs(stateLog[-1, i + 1] - stateLog[0, i + 1]) > 1.0E-10):\n            testFailCount += 1\n            testMessages.append(\"State propagation failure \\n\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"EKF static state propagation\")\n    else:\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StatePropVariable(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = sunlineEKF.sunlineEKF()\n    module.ModelTag = \"SunlineEKF\"\n\n\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n\n    InitialState = (np.array(module.state)+ +np.array([0.,0.,0.,0.0001,0.002, 0.001])).tolist()\n    Initialx = module.x\n    InitialCovar = module.covar\n\n    module.state = InitialState\n\n    unitTestSim.AddVariableForLogging('SunlineEKF.covar', testProcessRate, 0, 35)\n    unitTestSim.AddVariableForLogging('SunlineEKF.stateTransition', testProcessRate, 0, 35)\n    unitTestSim.AddVariableForLogging('SunlineEKF.state', testProcessRate , 0, 5)\n    unitTestSim.AddVariableForLogging('SunlineEKF.x', testProcessRate , 0, 5)\n\n    # connect messages\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n    cssConfigInMsg = messaging.CSSConfigMsg()\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConfigInMsg)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1000.0))\n    unitTestSim.ExecuteSimulation()\n\n\n    covarLog = unitTestSim.GetLogVariableData('SunlineEKF.covar')\n    stateLog = unitTestSim.GetLogVariableData('SunlineEKF.state')\n    stateErrorLog = unitTestSim.GetLogVariableData('SunlineEKF.x')\n    stmLog = unitTestSim.GetLogVariableData('SunlineEKF.stateTransition')\n\n\n    dt = 0.5\n    expectedStateArray = np.zeros([2001,7])\n    expectedStateArray[0,1:7] = np.array(InitialState)\n\n    for i in range(1,2001):\n        expectedStateArray[i,0] = dt*i*1E9\n        expectedStateArray[i,1:4] = expectedStateArray[i-1,1:4] + dt*(expectedStateArray[i-1,4:7] - (np.dot(expectedStateArray[i-1,4:7],expectedStateArray[i-1,1:4]))*expectedStateArray[i-1,1:4]/np.linalg.norm(expectedStateArray[i-1,1:4])**2.)\n        ## Equations when removing the unobservable states from d_dot\n        expectedStateArray[i, 4:7] = expectedStateArray[i-1,4:7] - (np.dot(expectedStateArray[i-1,4:7],expectedStateArray[i-1,1:4]))*expectedStateArray[i-1,1:4]/np.linalg.norm(expectedStateArray[i-1,1:4])**2.\n\n    expDynMat = np.zeros([2001,6,6])\n    for i in range(0,2001):\n        expDynMat[i, 0:3, 0:3] = -(np.outer(expectedStateArray[i,1:4],expectedStateArray[i,4:7])/np.linalg.norm(expectedStateArray[i,1:4])**2. +\n                             np.dot(expectedStateArray[i,4:7], expectedStateArray[i,1:4])*(np.linalg.norm(expectedStateArray[i,1:4])**2.*np.eye(3)- 2*np.outer(expectedStateArray[i,1:4],expectedStateArray[i,1:4]))/np.linalg.norm(expectedStateArray[i,1:4])**4.)\n        expDynMat[i, 0:3, 3:6] = np.eye(3) - np.outer(expectedStateArray[i,1:4],expectedStateArray[i,1:4])/np.linalg.norm(expectedStateArray[i,1:4])**2\n        ## Equations when removing the unobservable states from d_dot\n        expDynMat[i, 3:6, 0:3] = -1/dt*(np.outer(expectedStateArray[i,1:4],expectedStateArray[i,4:7])/np.linalg.norm(expectedStateArray[i,1:4])**2. +\n                             np.dot(expectedStateArray[i,4:7], expectedStateArray[i,1:4])*(np.linalg.norm(expectedStateArray[i,1:4])**2.*np.eye(3)- 2*np.outer(expectedStateArray[i,1:4],expectedStateArray[i,1:4]))/np.linalg.norm(expectedStateArray[i,1:4])**4.)\n        expDynMat[i, 3:6, 3:6] = -1/dt*(np.outer(expectedStateArray[i,1:4],expectedStateArray[i,1:4])/np.linalg.norm(expectedStateArray[i,1:4])**2)\n\n    expectedSTM = np.zeros([2001,6,6])\n    expectedSTM[0,:,:] = np.eye(6)\n    for i in range(1,2001):\n        expectedSTM[i,:,:] = dt * np.dot(expDynMat[i-1,:,:], np.eye(6)) + np.eye(6)\n\n    expectedXBar = np.zeros([2001,7])\n    expectedXBar[0,1:7] = np.array(Initialx)\n    for i in range(1,2001):\n        expectedXBar[i,0] = dt*i*1E9\n        expectedXBar[i, 1:7] = np.dot(expectedSTM[i, :, :], expectedXBar[i - 1, 1:7])\n\n    expectedCovar = np.zeros([2001,37])\n    expectedCovar[0,1:37] = np.array(InitialCovar)\n    Gamma = np.zeros([6, 3])\n    Gamma[0:3, 0:3] = dt ** 2. / 2. * np.eye(3)\n    Gamma[3:6, 0:3] = dt * np.eye(3)\n    ProcNoiseCovar = np.dot(Gamma, np.dot(module.qProcVal*np.eye(3),Gamma.T))\n    for i in range(1,2001):\n        expectedCovar[i,0] =  dt*i*1E9\n        expectedCovar[i,1:37] = (np.dot(expectedSTM[i,:,:], np.dot(np.reshape(expectedCovar[i-1,1:37],[6,6]), np.transpose(expectedSTM[i,:,:])))+ ProcNoiseCovar).flatten()\n\n    FilterPlots.StatesVsExpected(stateLog, expectedStateArray, show_plots)\n    FilterPlots.StatesPlotCompare(stateErrorLog, expectedXBar, covarLog, expectedCovar, show_plots)\n\n    for j in range(1,2001):\n        for i in range(6):\n            if (abs(stateLog[j, i + 1] - expectedStateArray[j, i + 1]) > 1.0E-4):\n                testFailCount += 1\n                testMessages.append(\"General state propagation failure: State Prop \\n\")\n            if (abs(stateErrorLog[j, i + 1] - expectedXBar[j, i + 1]) > 1.0E-4):\n                testFailCount += 1\n                testMessages.append(\"General state propagation failure: State Error Prop \\n\")\n\n        for i in range(36):\n            if (abs(covarLog[j, i + 1] - expectedCovar[j, i + 1]) > 1.0E-4):\n                abs(covarLog[j, i + 1] - expectedCovar[j, i + 1])\n                testFailCount += 1\n                testMessages.append(\"General state propagation failure: Covariance Prop \\n\")\n            if (abs(stmLog[j, i + 1] - expectedSTM[j,:].flatten()[i]) > 1.0E-4):\n                testFailCount += 1\n                testMessages.append(\"General state propagation failure: STM Prop \\n\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"EKF general state propagation\")\n    else:\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StateUpdateSunLine(show_plots, SimHalfLength, AddMeasNoise, testVector1, testVector2, stateGuess):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = sunlineEKF.sunlineEKF()\n    module.ModelTag = \"SunlineEKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    setupFilterData(module)\n\n    # Set up some test parameters\n\n    cssConstelation = messaging.CSSConfigMsgPayload()\n\n    CSSOrientationList = [\n        [0.70710678118654746, -0.5, 0.5],\n        [0.70710678118654746, -0.5, -0.5],\n        [0.70710678118654746, 0.5, -0.5],\n        [0.70710678118654746, 0.5, 0.5],\n        [-0.70710678118654746, 0, 0.70710678118654757],\n        [-0.70710678118654746, 0.70710678118654757, 0.0],\n        [-0.70710678118654746, 0, -0.70710678118654757],\n        [-0.70710678118654746, -0.70710678118654757, 0.0],\n    ]\n    CSSBias = [1 for i in range(len(CSSOrientationList))]\n\n    totalCSSList = []\n    # Initializing a 2D double array is hard with SWIG.  That's why there is this\n    # layer between the above list and the actual C variables.\n    i = 0\n    for CSSHat in CSSOrientationList:\n        newCSS = messaging.CSSUnitConfigMsgPayload()\n        newCSS.CBias = CSSBias[i]\n        newCSS.nHat_B = CSSHat\n        totalCSSList.append(newCSS)\n        i = i+1\n    cssConstelation.nCSS = len(CSSOrientationList)\n    cssConstelation.cssVals = totalCSSList\n\n    inputData = messaging.CSSArraySensorMsgPayload()\n\n    cssConstInMsg = messaging.CSSConfigMsg().write(cssConstelation)\n    cssDataInMsg = messaging.CSSArraySensorMsg()\n\n    # connect messages\n    module.cssDataInMsg.subscribeTo(cssDataInMsg)\n    module.cssConfigInMsg.subscribeTo(cssConstInMsg)\n\n    stateTarget1 = testVector1\n    stateTarget1 += [0.0, 0.0, 0.0]\n    module.state = stateGuess\n    module.x = (np.array(stateTarget1) - np.array(stateGuess)).tolist()\n    unitTestSim.AddVariableForLogging('SunlineEKF.x', testProcessRate , 0, 5, 'double')\n    dataLog = module.filtDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    unitTestSim.InitializeSimulation()\n\n    for i in range(SimHalfLength):\n        if i > 20:\n            dotList = []\n            for element in CSSOrientationList:\n                if AddMeasNoise:\n                    dotProd = np.dot(np.array(element), np.array(testVector1)[0:3]) + np.random.normal(0., module.qObsVal)\n                else:\n                    dotProd = np.dot(np.array(element), np.array(testVector1)[0:3])\n                dotList.append(dotProd)\n            inputData.CosValue = dotList\n            cssDataInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i + 1) * 0.5))\n        unitTestSim.ExecuteSimulation()\n\n    stateLog = addTimeColumn(dataLog.times(), dataLog.state)\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n    for i in range(6):\n        if (abs(covarLog[-1, i * 6 + 1 + i] - covarLog[0, i * 6 + 1 + i] / 100.) > 1E-2):\n            testFailCount += 1\n            testMessages.append(\"Covariance update failure\")\n        if (abs(stateLog[-1, i + 1] - stateTarget1[i]) > 1.0E-2):\n            testFailCount += 1\n            testMessages.append(\"State update failure\")\n\n\n    stateTarget2 = testVector2\n    stateTarget2 = stateTarget2+[0.,0.,0.]\n\n    inputData = messaging.CSSArraySensorMsgPayload()\n    for i in range(SimHalfLength):\n        if i > 20:\n            dotList = []\n            for element in CSSOrientationList:\n                if AddMeasNoise:\n                    dotProd = np.dot(np.array(element), np.array(testVector2)[0:3])  + np.random.normal(0., module.qObsVal)\n                else:\n                    dotProd = np.dot(np.array(element), np.array(testVector2)[0:3])\n                dotList.append(dotProd)\n            inputData.CosValue = dotList\n            cssDataInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i + SimHalfLength+1) * 0.5))\n        unitTestSim.ExecuteSimulation()\n\n    stateErrorLog = unitTestSim.GetLogVariableData('SunlineEKF.x')\n    stateLog = addTimeColumn(dataLog.times(), dataLog.state)\n    postFitLog = addTimeColumn(dataLog.times(), dataLog.postFitRes)\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n    for i in range(6):\n        if (abs(covarLog[-1, i * 6 + 1 + i] - covarLog[0, i * 6 + 1 + i] / 100.) > 1E-2):\n            testFailCount += 1\n            testMessages.append(\"Covariance update failure\")\n        if (abs(stateLog[-1, i + 1] - stateTarget2[i]) > 1.0E-2):\n            testFailCount += 1\n            testMessages.append(\"State update failure\")\n\n    target1 = np.array(testVector1)\n    target2 = np.array(testVector2+[0.,0.,0.])\n    FilterPlots.StateErrorCovarPlot(stateErrorLog, covarLog, show_plots)\n    FilterPlots.StatesVsTargets(target1, target2, stateLog, show_plots)\n    FilterPlots.PostFitResiduals(postFitLog, module.qObsVal, show_plots)\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \"EKF full test\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StateErrorCovarPlot(x, Pflat, show_plots):\n\n\n    P = np.zeros([len(Pflat[:,0]),6,6])\n    t= np.zeros(len(Pflat[:,0]))\n    for i in range(len(Pflat[:,0])):\n        t[i] = x[i, 0]*1E-9\n        P[i,:,:] = Pflat[i,1:37].reshape([6,6])\n        for j in range(len(P[0,0,:])):\n            P[i,j,j] = np.sqrt(P[i,j,j])\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(t , x[:, 1], \"b\", label='Error Filter')\n    plt.plot(t , 3 * np.sqrt(P[:, 0, 0]), 'r--',  label='Covar Filter')\n    plt.plot(t , -3 * np.sqrt(P[:, 0, 0]), 'r--')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n    plt.subplot(322)\n    plt.plot(t , x[:, 4], \"b\")\n    plt.plot(t , 3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.plot(t , -3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.title('First rate component')\n    plt.grid()\n\n    plt.subplot(323)\n    plt.plot(t , x[:, 2], \"b\")\n    plt.plot(t , 3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.plot(t , -3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.title('Second LOS component')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(t , x[:, 5], \"b\")\n    plt.plot(t , 3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.plot(t , -3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.title('Second rate component')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(t , x[:, 3], \"b\")\n    plt.plot(t , 3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.plot(t , -3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third LOS component')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(t , x[:, 6], \"b\")\n    plt.plot(t , 3 * np.sqrt(P[:, 5, 5]), 'r--')\n    plt.plot(t , -3 * np.sqrt(P[:, 5, 5]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesPlot', 'State error and covariance', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n    plt.close('all')",
  "def StatesPlotCompare(x, x2, Pflat, Pflat2, show_plots):\n\n\n    P = np.zeros([len(Pflat[:,0]),6,6])\n    P2 = np.zeros([len(Pflat[:,0]),6,6])\n    t= np.zeros(len(Pflat[:,0]))\n    for i in range(len(Pflat[:,0])):\n        t[i] = x[i, 0]*1E-9\n        P[i,:,:] = Pflat[i,1:37].reshape([6,6])\n        P2[i, :, :] = Pflat2[i, 1:37].reshape([6, 6])\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(t[0:30] , x[0:30, 1], \"b\", label='Error Filter')\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 0, 0]), 'r--',  label='Covar Filter')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 0, 0]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 1], \"g\", label='Error Expected')\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 0, 0]), 'c--', label='Covar Expected')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 0, 0]), 'c--')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n    plt.subplot(322)\n    plt.plot(t[0:30] , x[0:30, 4], \"b\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 3, 3]), 'r--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 3, 3]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 4], \"g\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 3, 3]), 'c--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 3, 3]), 'c--')\n    plt.title('First rate component')\n    plt.grid()\n\n    plt.subplot(323)\n    plt.plot(t[0:30] , x[0:30, 2], \"b\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 1, 1]), 'r--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 1, 1]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 2], \"g\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 1, 1]), 'c--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 1, 1]), 'c--')\n    plt.title('Second LOS component')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(t[0:30] , x[0:30, 5], \"b\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 4, 4]), 'r--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 4, 4]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 5], \"g\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 4, 4]), 'c--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 4, 4]), 'c--')\n    plt.title('Second rate component')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(t[0:30] , x[0:30, 3], \"b\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 2, 2]), 'r--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 2, 2]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 3], \"g\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 2, 2]), 'c--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 2, 2]), 'c--')\n    plt.xlabel('t(s)')\n    plt.title('Third LOS component')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(t[0:30] , x[0:30, 6], \"b\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P[0:30, 5, 5]), 'r--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P[0:30, 5, 5]), 'r--')\n    plt.plot(t[0:30] , x2[0:30, 6], \"g\")\n    plt.plot(t[0:30] , 3 * np.sqrt(P2[0:30, 5, 5]), 'c--')\n    plt.plot(t[0:30] , -3 * np.sqrt(P2[0:30, 5, 5]), 'c--')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesCompare', 'State error and covariance vs expected Values', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def PostFitResiduals(Res, noise, show_plots):\n\n    MeasNoise = np.zeros(len(Res[:,0]))\n    t= np.zeros(len(Res[:,0]))\n    for i in range(len(Res[:,0])):\n        t[i] = Res[i, 0]*1E-9\n        MeasNoise[i] = 3*noise\n        # Don't plot zero values, since they mean that no measurement is taken\n        for j in range(len(Res[0,:])-1):\n            if -1E-10 < Res[i,j+1] < 1E-10:\n                Res[i, j+1] = np.nan\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(421)\n    plt.plot(t , Res[:, 1], \"b.\", label='Residual')\n    plt.plot(t , MeasNoise, 'r--', label='Covar')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.legend(loc='lower right')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('First CSS')\n    plt.grid()\n\n    plt.subplot(422)\n    plt.plot(t , Res[:, 5], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Fifth CSS')\n    plt.grid()\n\n    plt.subplot(423)\n    plt.plot(t , Res[:, 2], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Second CSS')\n    plt.grid()\n\n    plt.subplot(424)\n    plt.plot(t , Res[:, 6], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Sixth CSS')\n    plt.grid()\n\n    plt.subplot(425)\n    plt.plot(t , Res[:, 3], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Third CSS')\n    plt.grid()\n\n    plt.subplot(426)\n    plt.plot(t , Res[:, 7], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Seventh CSS')\n    plt.grid()\n\n    plt.subplot(427)\n    plt.plot(t , Res[:, 4], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.xlabel('t(s)')\n    plt.title('Fourth CSS')\n    plt.grid()\n\n    plt.subplot(428)\n    plt.plot(t , Res[:, 8], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.xlabel('t(s)')\n    plt.title('Eight CSS')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('PostFit', 'Post Fit Residuals', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def StatesVsExpected(stateLog, expectedStateArray, show_plots):\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(stateLog[:, 0] * 1.0E-9, expectedStateArray[:,  1], 'b--', label='Expected')\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:,  1], 'r', label='Filter')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n    plt.subplot(323)\n    plt.plot(stateLog[:, 0] * 1.0E-9, expectedStateArray[:,  2], 'b--')\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:,  2], 'r')\n    plt.title('Second LOS component')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(stateLog[:, 0] * 1.0E-9, expectedStateArray[:,  4], 'b--')\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:,  4], 'r')\n    plt.title('Second rate component')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(stateLog[:, 0] * 1.0E-9, expectedStateArray[:,  3], 'b--')\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:,  3], 'r')\n    plt.xlabel('t(s)')\n    plt.title('Third LOS component')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(stateLog[:, 0] * 1.0E-9, expectedStateArray[:,  5], 'b--')\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:,  5], 'r')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesExpected', 'States vs true states in static case', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def StatesVsTargets(target1, target2, stateLog, show_plots):\n\n\n    target = np.ones([len(stateLog[:, 0]),6])\n    for i in range((len(stateLog[:, 0])-1)//2):\n        target[i, :] = target1\n        target[i+(len(stateLog[:, 0]) - 1) // 2,:] = target2\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:, 1], 'b', label='Filter')\n    plt.plot(stateLog[:, 0] * 1.0E-9, target[:, 0], 'r--', label='Expected')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n    plt.subplot(322)\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:, 4], 'b')\n    plt.plot(stateLog[:, 0] * 1.0E-9, target[:, 3], 'r--')\n    plt.title('First rate component')\n    plt.grid()\n\n    plt.subplot(323)\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:, 2], 'b')\n    plt.plot(stateLog[:, 0] * 1.0E-9, target[:, 1], 'r--')\n    plt.title('Second LOS component')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:, 5], 'b')\n    plt.plot(stateLog[:, 0] * 1.0E-9, target[:, 4], 'r--')\n    plt.title('Second rate component')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:, 3], 'b')\n    plt.plot(stateLog[:, 0] * 1.0E-9, target[:, 2], 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third LOS component')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(stateLog[:, 0] * 1.0E-9, stateLog[:, 6], 'b')\n    plt.plot(stateLog[:, 0] * 1.0E-9, target[:, 5], 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesTarget', 'States tracking target values', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def StateCovarPlot(time, x, Pflat, string, show_plots):\n\n    numStates = len(x[0, :])\n\n    P = np.zeros([len(Pflat[:, 0]), numStates, numStates])\n    t = np.zeros(len(Pflat[:, 0]))\n    for i in range(len(Pflat[:, 0])):\n        t[i] = time[i]*1E-9\n        P[i, :, :] = Pflat[i, 0:(numStates*numStates+1)].reshape([numStates, numStates])\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(t , x[:, 0], \"b\", label='Error Filter')\n    plt.plot(t , x[:, 0]+3 * np.sqrt(P[:, 0, 0]), 'r--',  label='Covar Filter')\n    plt.plot(t , x[:, 0]-3 * np.sqrt(P[:, 0, 0]), 'r--')\n    plt.legend(loc='lower right')\n    plt.title('First LOS component')\n    plt.grid()\n\n\n    plt.subplot(323)\n    plt.plot(t , x[:, 1], \"b\")\n    plt.plot(t , x[:, 1]+3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.plot(t , x[:, 1]-3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.title('Second LOS component')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(t , x[:, 3], \"b\")\n    plt.plot(t , x[:, 3]+3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.plot(t , x[:, 3]-3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.title('Second rate component')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(t , x[:, 2], \"b\")\n    plt.plot(t , x[:, 2]+3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.plot(t , x[:, 2]-3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third LOS component')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(t , x[:, 4], \"b\")\n    plt.plot(t , x[:, 4]+3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.plot(t , x[:, 4]-3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesPlot' + string, 'State error and covariance', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def PostFitResiduals(time, Res, noise, string, show_plots):\n\n    MeasNoise = np.zeros(len(Res[:,0]))\n    t= np.zeros(len(Res[:,0]))\n    numObs = len(Res[0,:])\n    for i in range(len(Res[:,0])):\n        t[i] = time[i]*1E-9\n        MeasNoise[i] = 3*noise\n        # Don't plot zero values, since they mean that no measurement is taken\n        for j in range(len(Res[0,:])-1):\n            if -1E-10 < Res[i,j+1] < 1E-10:\n                Res[i, j+1] = np.nan\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(311)\n    plt.plot(t , Res[:, 0], \"b.\", label='Residual')\n    plt.plot(t , MeasNoise, 'r--', label='Covar')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.legend(loc='lower right')\n    if noise >1E-5:\n        plt.ylim([-10*noise, 10*noise])\n    plt.title('First Position Component')\n    plt.grid()\n\n    plt.subplot(312)\n    plt.plot(t , Res[:, 1], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    if noise >1E-5:\n        plt.ylim([-10*noise, 10*noise])\n    plt.title('Second Position Component')\n    plt.grid()\n\n    plt.subplot(313)\n    plt.plot(t , Res[:, 2], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    if noise > 1E-5:\n        plt.ylim([-10 * noise, 10 * noise])\n    plt.title('Third Position Component')\n    plt.grid()\n\n\n\n    unitTestSupport.writeFigureLaTeX('PostFit' +string , 'Post Fit Residuals', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def setupFilterData(filterObject):\n\n    filterObject.alpha = 0.02\n    filterObject.beta = 2.0\n    filterObject.kappa = 0.0\n\n    # filterObject.state = [0.0, 0., 0., 0., 0.]\n    filterObject.stateInit = [0.0, 0.0, 1.0, 0.0, 0.0]\n    filterObject.covarInit = [0.1, 0.0, 0.0, 0.0, 0.0,\n                          0.0, 0.1, 0.0, 0.0, 0.0,\n                          0.0, 0.0, 0.1, 0.0, 0.0,\n                          0.0, 0.0, 0.0, 0.01, 0.0,\n                          0.0, 0.0, 0.0, 0.0, 0.01]\n\n    qNoiseIn = np.identity(5)\n    qNoiseIn[0:3, 0:3] = qNoiseIn[0:3, 0:3]*0.01*0.01\n    qNoiseIn[3:5, 3:5] = qNoiseIn[3:5, 3:5]*0.001*0.001\n    filterObject.qNoise = qNoiseIn.reshape(25).tolist()",
  "def test_functions_ukf(show_plots):\n    \"\"\"\n    **Validation Test Description**\n\n    This subtest runs through the general modules file for square root and unscented filters. These methods include\n    LU decompositions, QR decompositions that only provide the R matrix, as well as L, U inverses, and Cholesky\n    decompositions.\n\n    **Description of Variables Being Tested**\n\n    Each method of the general module file for square root and unscented filters are tested to machine precision\n    with errors of 1E-14\n\n    **General Documentation Comments**\n\n    This is a similar test used to other filter modules\n    \"\"\"\n    [testResults, testMessage] = heading_utilities_test(show_plots)\n    assert testResults < 1, testMessage",
  "def test_all_heading_kf(show_plots):\n    \"\"\"\n    **Validation Test Description**\n\n    The StatePropSunLine subtest runs the filter and creates synthetic measurements to trigger the measurement update method.\n    This is tested in two parts. The filter first stabilizes to a value, and then the value is abruptly changed\n    in order for the filter to snap back to the solution.  Measurements are provided every 10 seconds which provides the\n    sparse data that is usually characteristic of OpNav.\n\n    The StateUpdateSunLine subtest runs the filter without measurements to only trigger the time update method. This\n    ensures the filter stays at true values if no measurements are provided.\n\n    **Description of Variables Being Tested**\n\n    For the propagation: The state output by the filter is tested compared to the commanded target,\n    and the covariance is ensured to converge.\n    These are both tested to 1E-1 because of noise introduced in the measurements.\n\n    The measurement updated state output by the filter is tested compared to the expected target.\n    The stability of the state is tested to 1E-10.\n    \"\"\"\n    [testResults, testMessage] = StatePropSunLine(show_plots)\n    assert testResults < 1, testMessage\n    [testResults, testMessage] = StateUpdateSunLine(show_plots)\n    assert testResults < 1, testMessage",
  "def heading_utilities_test(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    # Initialize the test module configuration data\n    AMatrix = [0.488894, 0.888396, 0.325191, 0.319207,\n                1.03469, -1.14707, -0.754928, 0.312859,\n                0.726885, -1.06887, 1.3703, -0.86488,\n               -0.303441, -0.809499, -1.71152, -0.0300513,\n                0.293871, -2.94428, -0.102242, -0.164879,\n               -0.787283, 1.43838, -0.241447, 0.627707]\n\n    RVector = headingSuKF.new_doubleArray(len(AMatrix))\n    AVector = headingSuKF.new_doubleArray(len(AMatrix))\n    for i in range(len(AMatrix)):\n        headingSuKF.doubleArray_setitem(AVector, i, AMatrix[i])\n        headingSuKF.doubleArray_setitem(RVector, i, 0.0)\n\n        headingSuKF.ukfQRDJustR(AVector, 6, 4, RVector)\n    RMatrix = []\n    for i in range(4*4):\n        RMatrix.append(headingSuKF.doubleArray_getitem(RVector, i))\n    RBaseNumpy = np.array(RMatrix).reshape(4,4)\n    AMatNumpy = np.array(AMatrix).reshape(6,4)\n    q,r = np.linalg.qr(AMatNumpy)\n    for i in range(r.shape[0]):\n        if r[i,i] < 0.0:\n            r[i,:] *= -1.0\n    if np.linalg.norm(r - RBaseNumpy) > 1.0E-15:\n        testFailCount += 1\n        testMessages.append(\"QR Decomposition accuracy failure\")\n\n    AMatrix = [1.09327, 1.10927, -0.863653, 1.32288,\n     -1.21412, -1.1135, -0.00684933, -2.43508,\n     -0.769666, 0.371379, -0.225584, -1.76492,\n     -1.08906, 0.0325575, 0.552527, -1.6256,\n     1.54421, 0.0859311, -1.49159, 1.59683]\n\n    RVector = headingSuKF.new_doubleArray(len(AMatrix))\n    AVector = headingSuKF.new_doubleArray(len(AMatrix))\n    for i in range(len(AMatrix)):\n        headingSuKF.doubleArray_setitem(AVector, i, AMatrix[i])\n        headingSuKF.doubleArray_setitem(RVector, i, 0.0)\n\n    headingSuKF.ukfQRDJustR(AVector, 5, 4, RVector)\n    RMatrix = []\n    for i in range(4*4):\n        RMatrix.append(headingSuKF.doubleArray_getitem(RVector, i))\n    RBaseNumpy = np.array(RMatrix).reshape(4,4)\n    AMatNumpy = np.array(AMatrix).reshape(5,4)\n    q,r = np.linalg.qr(AMatNumpy)\n    for i in range(r.shape[0]):\n        if r[i,i] < 0.0:\n            r[i,:] *= -1.0\n    if np.linalg.norm(r - RBaseNumpy) > 1.0E-14:\n        testFailCount += 1\n        testMessages.append(\"QR Decomposition accuracy failure\")\n\n    AMatrix = [ 0.2236,         0,\n               0,    0.2236,\n               -0.2236,         0,\n               0,   -0.2236,\n               0.0170,         0,\n               0,    0.0170]\n\n    RVector = headingSuKF.new_doubleArray(len(AMatrix))\n    AVector = headingSuKF.new_doubleArray(len(AMatrix))\n    for i in range(len(AMatrix)):\n        headingSuKF.doubleArray_setitem(AVector, i, AMatrix[i])\n        headingSuKF.doubleArray_setitem(RVector, i, 0.0)\n\n    headingSuKF.ukfQRDJustR(AVector, 6, 2, RVector)\n    RMatrix = []\n    for i in range(2*2):\n        RMatrix.append(headingSuKF.doubleArray_getitem(RVector, i))\n    RBaseNumpy = np.array(RMatrix).reshape(2,2)\n    AMatNumpy = np.array(AMatrix).reshape(6,2)\n    q,r = np.linalg.qr(AMatNumpy)\n    for i in range(r.shape[0]):\n        if r[i,i] < 0.0:\n            r[i,:] *= -1.0\n\n    if np.linalg.norm(r - RBaseNumpy) > 1.0E-15:\n        testFailCount += 1\n        testMessages.append(\"QR Decomposition accuracy failure\")\n\n\n    LUSourceMat = [8,1,6,3,5,7,4,9,2]\n    LUSVector = headingSuKF.new_doubleArray(len(LUSourceMat))\n    LVector = headingSuKF.new_doubleArray(len(LUSourceMat))\n    UVector = headingSuKF.new_doubleArray(len(LUSourceMat))\n    intSwapVector = headingSuKF.new_intArray(3)\n\n    for i in range(len(LUSourceMat)):\n        headingSuKF.doubleArray_setitem(LUSVector, i, LUSourceMat[i])\n        headingSuKF.doubleArray_setitem(UVector, i, 0.0)\n        headingSuKF.doubleArray_setitem(LVector, i, 0.0)\n\n    exCount = headingSuKF.ukfLUD(LUSVector, 3, 3, LVector, intSwapVector)\n    #headingSuKF.ukfUInv(LUSVector, 3, 3, UVector)\n    LMatrix = []\n    UMatrix = []\n    #UMatrix = []\n    for i in range(3):\n        currRow = headingSuKF.intArray_getitem(intSwapVector, i)\n        for j in range(3):\n            if(j<i):\n                LMatrix.append(headingSuKF.doubleArray_getitem(LVector, i*3+j))\n                UMatrix.append(0.0)\n            elif(j>i):\n                LMatrix.append(0.0)\n                UMatrix.append(headingSuKF.doubleArray_getitem(LVector, i*3+j))\n            else:\n                LMatrix.append(1.0)\n                UMatrix.append(headingSuKF.doubleArray_getitem(LVector, i*3+j))\n    #    UMatrix.append(headingSuKF.doubleArray_getitem(UVector, i))\n\n    LMatrix = np.array(LMatrix).reshape(3,3)\n    UMatrix = np.array(UMatrix).reshape(3,3)\n    outMat = np.dot(LMatrix, UMatrix)\n    outMatSwap = np.zeros((3,3))\n    for i in range(3):\n        currRow = headingSuKF.intArray_getitem(intSwapVector, i)\n        outMatSwap[i,:] = outMat[currRow, :]\n        outMat[currRow,:] = outMat[i, :]\n    LuSourceArray = np.array(LUSourceMat).reshape(3,3)\n\n    if(np.linalg.norm(outMatSwap - LuSourceArray) > 1.0E-14):\n        testFailCount += 1\n        testMessages.append(\"LU Decomposition accuracy failure\")\n\n    EqnSourceMat = [2.0, 1.0, 3.0, 2.0, 6.0, 8.0, 6.0, 8.0, 18.0]\n    BVector = [1.0, 3.0, 5.0]\n    EqnVector = headingSuKF.new_doubleArray(len(EqnSourceMat))\n    EqnBVector = headingSuKF.new_doubleArray(len(LUSourceMat)//3)\n    EqnOutVector = headingSuKF.new_doubleArray(len(LUSourceMat)//3)\n\n    for i in range(len(EqnSourceMat)):\n        headingSuKF.doubleArray_setitem(EqnVector, i, EqnSourceMat[i])\n        headingSuKF.doubleArray_setitem(EqnBVector, i//3, BVector[i//3])\n        headingSuKF.intArray_setitem(intSwapVector, i//3, 0)\n        headingSuKF.doubleArray_setitem(LVector, i, 0.0)\n\n    exCount = headingSuKF.ukfLUD(EqnVector, 3, 3, LVector, intSwapVector)\n\n    headingSuKF.ukfLUBckSlv(LVector, 3, 3, intSwapVector, EqnBVector, EqnOutVector)\n\n    expectedSol = [3.0/10.0, 4.0/10.0, 0.0]\n    errorVal = 0.0\n    for i in range(3):\n        errorVal += abs(headingSuKF.doubleArray_getitem(EqnOutVector, i) -expectedSol[i])\n\n    if(errorVal > 1.0E-14):\n        testFailCount += 1\n        testMessages.append(\"LU Back-Solve accuracy failure\")\n\n\n    InvSourceMat = [8,1,6,3,5,7,4,9,2]\n    SourceVector = headingSuKF.new_doubleArray(len(InvSourceMat))\n    InvVector = headingSuKF.new_doubleArray(len(InvSourceMat))\n    for i in range(len(InvSourceMat)):\n        headingSuKF.doubleArray_setitem(SourceVector, i, InvSourceMat[i])\n        headingSuKF.doubleArray_setitem(InvVector, i, 0.0)\n    nRow = int(math.sqrt(len(InvSourceMat)))\n    headingSuKF.ukfMatInv(SourceVector, nRow, nRow, InvVector)\n\n    InvOut = []\n    for i in range(len(InvSourceMat)):\n        InvOut.append(headingSuKF.doubleArray_getitem(InvVector, i))\n\n    InvOut = np.array(InvOut).reshape(nRow, nRow)\n    expectIdent = np.dot(InvOut, np.array(InvSourceMat).reshape(3,3))\n    errorNorm = np.linalg.norm(expectIdent - np.identity(3))\n    if(errorNorm > 1.0E-14):\n        testFailCount += 1\n        testMessages.append(\"LU Matrix Inverse accuracy failure\")\n\n\n    cholTestMat = [1.0, 0.0, 0.0, 0.0, 10.0, 5.0, 0.0, 5.0, 10.0]\n    SourceVector = headingSuKF.new_doubleArray(len(cholTestMat))\n    CholVector = headingSuKF.new_doubleArray(len(cholTestMat))\n    for i in range(len(cholTestMat)):\n        headingSuKF.doubleArray_setitem(SourceVector, i, cholTestMat[i])\n        headingSuKF.doubleArray_setitem(CholVector, i, 0.0)\n    nRow = int(math.sqrt(len(cholTestMat)))\n    headingSuKF.ukfCholDecomp(SourceVector, nRow, nRow, CholVector)\n    cholOut = []\n    for i in range(len(cholTestMat)):\n        cholOut.append(headingSuKF.doubleArray_getitem(CholVector, i))\n\n    cholOut = np.array(cholOut).reshape(nRow, nRow)\n    cholComp = np.linalg.cholesky(np.array(cholTestMat).reshape(nRow, nRow))\n    errorNorm = np.linalg.norm(cholOut - cholComp)\n    if(errorNorm > 1.0E-14):\n        testFailCount += 1\n        testMessages.append(\"Cholesky Matrix Decomposition accuracy failure\")\n\n\n    InvSourceMat = [2.1950926119414667, 0.0, 0.0, 0.0,\n               1.0974804773131115, 1.9010439702743847, 0.0, 0.0,\n               0.0, 1.2672359635912551, 1.7923572711881284, 0.0,\n               1.0974804773131113, -0.63357997864171967, 1.7920348101787789, 0.033997451205364251]\n\n    SourceVector = headingSuKF.new_doubleArray(len(InvSourceMat))\n    InvVector = headingSuKF.new_doubleArray(len(InvSourceMat))\n    for i in range(len(InvSourceMat)):\n        headingSuKF.doubleArray_setitem(SourceVector, i, InvSourceMat[i])\n        headingSuKF.doubleArray_setitem(InvVector, i, 0.0)\n    nRow = int(math.sqrt(len(InvSourceMat)))\n    headingSuKF.ukfLInv(SourceVector, nRow, nRow, InvVector)\n\n    InvOut = []\n    for i in range(len(InvSourceMat)):\n        InvOut.append(headingSuKF.doubleArray_getitem(InvVector, i))\n\n    InvOut = np.array(InvOut).reshape(nRow, nRow)\n    expectIdent = np.dot(InvOut, np.array(InvSourceMat).reshape(nRow,nRow))\n    errorNorm = np.linalg.norm(expectIdent - np.identity(nRow))\n    if(errorNorm > 1.0E-12):\n        print(errorNorm)\n        testFailCount += 1\n        testMessages.append(\"L Matrix Inverse accuracy failure\")\n\n    InvSourceMat = np.transpose(np.array(InvSourceMat).reshape(nRow, nRow)).reshape(nRow*nRow).tolist()\n    SourceVector = headingSuKF.new_doubleArray(len(InvSourceMat))\n    InvVector = headingSuKF.new_doubleArray(len(InvSourceMat))\n    for i in range(len(InvSourceMat)):\n        headingSuKF.doubleArray_setitem(SourceVector, i, InvSourceMat[i])\n        headingSuKF.doubleArray_setitem(InvVector, i, 0.0)\n    nRow = int(math.sqrt(len(InvSourceMat)))\n    headingSuKF.ukfUInv(SourceVector, nRow, nRow, InvVector)\n\n    InvOut = []\n    for i in range(len(InvSourceMat)):\n        InvOut.append(headingSuKF.doubleArray_getitem(InvVector, i))\n\n    InvOut = np.array(InvOut).reshape(nRow, nRow)\n    expectIdent = np.dot(InvOut, np.array(InvSourceMat).reshape(nRow,nRow))\n    errorNorm = np.linalg.norm(expectIdent - np.identity(nRow))\n    if(errorNorm > 1.0E-12):\n        print(errorNorm)\n        testFailCount += 1\n        testMessages.append(\"U Matrix Inverse accuracy failure\")\n\n\n    # If the argument provided at commandline \"--show_plots\" evaluates as true,\n    # plot all figures\n    if show_plots:\n        plt.show()\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" UKF utilities\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StateUpdateSunLine(show_plots):\n\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = headingSuKF.headingSuKF()\n    module.ModelTag = \"headingSuKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n\n    dataLog = module.filtDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    testVector = np.array([0.9, 0.1, 0.02])\n    testOmega = np.array([0.01, 0.05, 0.001])\n    inputData = messaging.OpNavMsgPayload()\n    opnavDataInMsg = messaging.OpNavMsg()\n\n    stateTarget = testVector.tolist()\n    inputData.r_BN_B = stateTarget\n    stateTarget.extend([0.0, 0.0])\n    module.stateInit = [1., 0.2, 0.1, 0.01, 0.001]\n\n    # setup message connections\n    module.opnavDataInMsg.subscribeTo(opnavDataInMsg)\n\n    unitTestSim.InitializeSimulation()\n    t1 = 1000\n    for i in range(t1):\n        if i > 0 and i%20 == 0:\n            inputData.timeTag = macros.sec2nano(i * 0.5)\n            inputData.valid = 1\n            inputData.r_BN_B += np.random.normal(0, 0.001, 3)\n            inputData.covar_B = [0.0001**2, 0, 0, 0, 0.0001**2, 0, 0, 0, 0.0001**2]\n            opnavDataInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i+1)*0.5))\n        unitTestSim.ExecuteSimulation()\n\n    stateLog = dataLog.state\n    postFitLog = dataLog.postFitRes\n    covarLog = dataLog.covar\n    stateTarget[:3] = (-testVector[:3]/np.linalg.norm(testVector[:3])).tolist()\n\n    for i in range(5):\n        # check covariance immediately after measurement is taken,\n        # ensure order of magnitude less than initial covariance.\n        if(np.abs(covarLog[t1-10, i*5+i] - covarLog[0, i*5+i]/10) > 1E-1):\n            testFailCount += 1\n            testMessages.append(\"Covariance update failure\")\n        if(abs(stateLog[-1, i] - stateTarget[i-1]) > 1.0E-1):\n            print(abs(stateLog[-1, i] - stateTarget[i-1]))\n            testFailCount += 1\n            testMessages.append(\"State update failure\")\n\n    testVector = np.array([0.6, -0.1, 0.2])\n    stateTarget = testVector.tolist()\n    inputData.r_BN_B = stateTarget\n    stateTarget.extend([0.0, 0.0])\n\n    for i in range(t1):\n        if i%20 == 0:\n            inputData.timeTag = macros.sec2nano(i*0.5 +t1 +1)\n            inputData.r_BN_B += np.random.normal(0, 0.001, 3)\n            inputData.valid = 1\n            inputData.covar_B = [0.0001**2,0,0,0,0.0001**2,0,0,0,0.0001**2]\n            opnavDataInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i+t1 +1)*0.5))\n        unitTestSim.ExecuteSimulation()\n\n    stateLog = dataLog.state\n    stateErrorLog = dataLog.stateError\n    postFitLog = dataLog.postFitRes\n    covarLog = dataLog.covar\n    stateTarget[:3] = (-testVector[:3]/np.linalg.norm(testVector[:3])).tolist()\n\n    for i in range(5):\n        if(np.abs(covarLog[2*t1-10, i*5+i] - covarLog[0, i*5+i]/10)>1E-1):\n            testFailCount += 1\n            testMessages.append(\"Covariance update failure\")\n        if(abs(stateLog[-1, i] - stateTarget[i-1]) > 1.0E-1):\n            print(abs(stateLog[-1, i] - stateTarget[i-1]))\n            testFailCount += 1\n            testMessages.append(\"State update failure\")\n\n    FilterPlots.StateCovarPlot(dataLog.times(), stateLog, covarLog, 'Update', show_plots)\n    FilterPlots.StateCovarPlot(dataLog.times(),stateErrorLog, covarLog, 'Update_Error', show_plots)\n    FilterPlots.PostFitResiduals(dataLog.times(), postFitLog, 0.001,  'Update', show_plots)\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag + \" state update\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StatePropSunLine(show_plots):\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = headingSuKF.headingSuKF()\n    module.ModelTag = \"headingSuKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n\n    dataLog = module.filtDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    inData = messaging.OpNavMsgPayload()\n    inDataMsg = messaging.OpNavMsg().write(inData)\n\n    # setup message connections\n    module.opnavDataInMsg.subscribeTo(inDataMsg)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(8000.0))\n    unitTestSim.ExecuteSimulation()\n\n    stateLog = dataLog.state\n    postFitLog = dataLog.postFitRes\n    covarLog = dataLog.covar\n\n    FilterPlots.StateCovarPlot(dataLog.times(), stateLog, covarLog, 'Prop', show_plots)\n    FilterPlots.PostFitResiduals(dataLog.times(), postFitLog, module.qObsVal, 'Prop', show_plots)\n\n    for i in range(5):\n        if(abs(stateLog[-1, i] - stateLog[0, i]) > 1.0E-10):\n            print(abs(stateLog[-1, i] - stateLog[0, i]))\n            testFailCount += 1\n            testMessages.append(\"State propagation failure\")\n\n\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag + \" state propagation\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def test_faultdetection(show_plots, r_c1, r_c2, valid1, valid2, faultMode):\n    \"\"\"\n    **Validation Test Description**\n\n    This module tests the fault detection scenario. The logic behind the fault detection is explained in the doxygen documentation.\n    In order to properly test the proper functioning of the fault detection, all the possible combinations are run (8).\n    The expected results are computed in python and are tested with the output.\n\n    **Test Parameters**\n\n    absolute accuracy value of 1E-10 is used in this test\n\n    - case 1: ([10, 10, 1], [10, 10, 1], 1, 1, 0)\n        No measurement merge, all are valid, no faults\n    - case 2: ([10, 10, 1], [10, 10, 1], 1, 0, 0)\n        No measurement merge, one valid, no faults\n    - case 3: ([10, 10, 1], [10, 10, 1], 1, 0, 2)\n        No measurement merge, one valid, no faults, mode 2\n    - case 4: ([10, 10, 1], [10, 10, 1], 0, 1, 0)\n        No measurement merge, other valid, no faults\n    - case 5: ([10, 10, 1], [10, 10, 1], 0, 1, 0)\n        No measurement merge, other valid, no faults, mode 2\n    - case 6: ([10, 10, 1], [10, 10, 1], 0, 1, 1)\n        Merge on, other valid, no faults\n    - case 7: ([10, 10, 1], [10, 10, 1], 0, 0, 0)\n        No merge, none valid, no faults\n    - case 8: ([10, 10, 1], [100, 10, 1], 1, 1, 0)\n        No merge, all measurements valid, fault\n    - case 9: ([10, 10, 1], [100, 10, 1], 1, 1, 1)\n        Merge, all measurements valid, fault\n    - case 10: ([10, 10, 1], [100, 10, 1], 1, 1, 2)\n        Merge, all measurements valid, fault, mode 2\n    - case 11: ([10, 10, 1], [10, 10, 1], 1, 1, 1)\n        Merge, all measurements valid, no fault\n\n    **Description of Variables Being Tested**\n\n    The time, detection of a fault, measurement, and measurement covariances are tested on the output.\n    These are ``r_BN_N``, ``covar_N``, ``time``, ``faultDetected``\n\n    \"\"\"\n    [testResults, testMessage] = faultdetection(show_plots, r_c1, r_c2, valid1, valid2, faultMode)\n    assert testResults < 1, testMessage",
  "def faultdetection(show_plots, r_c1, r_c2, valid1, valid2, faultMode):\n    \"\"\" Test the faultdetection module. Setup a simulation \"\"\"\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))  # Add a new task to the process\n\n    # Construct the ephemNavConverter module\n    # Set the names for the input messages\n    faults = faultDetection.faultDetection()\n    faults.sigmaFault = 3\n    faults.faultMode = faultMode\n    # ephemNavConfig.outputState = simFswInterfaceMessages.NavTransIntMsg()\n\n    # This calls the algContain to setup the selfInit, update, and reset\n    faults.ModelTag = \"faultDet\"\n\n    # Add the module to the task\n    unitTestSim.AddModelToTask(unitTaskName, faults)\n\n    # Create the input messages.\n    inputPrimary = messaging.OpNavMsgPayload()\n    inputSecondary = messaging.OpNavMsgPayload()\n    inputCamera = messaging.CameraConfigMsgPayload()\n    inputAtt = messaging.NavAttMsgPayload()\n\n    # Set camera\n    inputCamera.fieldOfView = 2.0 * np.arctan(10*1e-3 / 2.0 / (1.*1e-3) )  # 2*arctan(s/2 / f)\n    inputCamera.resolution = [512, 512]\n    inputCamera.sigma_CB = [1.,0.3,0.1]\n    camInMsg = messaging.CameraConfigMsg().write(inputCamera)\n    faults.cameraConfigInMsg.subscribeTo(camInMsg)\n\n    # Set attitude\n    inputAtt.sigma_BN = [0.6, 1., 0.1]\n    attInMsg = messaging.NavAttMsg().write(inputAtt)\n    faults.attInMsg.subscribeTo(attInMsg)\n\n    BN = rbk.MRP2C(inputAtt.sigma_BN)\n    CB = rbk.MRP2C(inputCamera.sigma_CB)\n    NC = np.dot(BN.T, CB.T)\n    # Set primary\n    inputPrimary.r_BN_C = r_c1\n    inputPrimary.r_BN_N = np.dot(NC, np.array(r_c1)).tolist()\n    inputPrimary.valid = valid1\n    inputPrimary.covar_C = [0.5, 0., 0., 0., 0.5, 0., 0., 0., 1.]\n    inputPrimary.covar_N = np.dot(np.dot(NC, np.array([0.5, 0., 0., 0., 0.5, 0., 0., 0., 1.]).reshape([3,3])), NC.T).flatten().tolist()\n    inputPrimary.timeTag = 12345\n    op1InMsg = messaging.OpNavMsg().write(inputPrimary)\n    faults.navMeasPrimaryInMsg.subscribeTo(op1InMsg)\n\n    # Set secondary\n    inputSecondary.r_BN_C = r_c2\n    inputSecondary.r_BN_N = np.dot(NC, np.array(r_c2)).tolist()\n    inputSecondary.valid = valid2\n    inputSecondary.covar_C = [0.5, 0., 0., 0., 0.5, 0., 0., 0., 1.]\n    inputSecondary.covar_N = np.dot(np.dot(NC, np.array([0.5, 0., 0., 0., 0.5, 0., 0., 0., 1.]).reshape([3,3])), NC.T).flatten().tolist()\n    inputSecondary.timeTag = 12345\n    op2InMsg = messaging.OpNavMsg().write(inputSecondary)\n    faults.navMeasSecondaryInMsg.subscribeTo(op2InMsg)\n\n    dataLog = faults.opNavOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n    # The result isn't going to change with more time. The module will continue to produce the same result\n    unitTestSim.ConfigureStopTime(testProcessRate)  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # Truth Vlaues\n    faultDetectedTrue= 0\n    timTagExp = inputPrimary.timeTag\n    if valid1 ==0 and valid2==0:\n        timTagExp = 0\n        r_Cexp = [0,0,0]\n        covar_Cexp = [0,0,0,0,0,0,0,0,0]\n    if valid1 == 0  and valid2 ==1:\n        if faultMode > 0:\n            timTagExp = 0\n            r_Cexp = [0, 0, 0]\n            covar_Cexp = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n        if faultMode == 0:\n            r_Cexp = r_c2\n            covar_Cexp =  [0.5, 0., 0., 0., 0.5, 0., 0., 0., 1.]\n    if valid1 == 1  and valid2 ==0:\n        if faultMode < 2:\n            r_Cexp = r_c1\n            covar_Cexp =  [0.5, 0., 0., 0., 0.5, 0., 0., 0., 1.]\n        if faultMode == 2:\n            timTagExp = 0\n            r_Cexp = [0, 0, 0]\n            covar_Cexp = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n    if valid1 == 1  and valid2 ==1:\n        r1 = np.array(r_c1)\n        r2 = np.array(r_c2)\n        faultNorm = np.linalg.norm(r2 - r1)\n\n        covarz = np.array([0.5, 0., 0., 0., 0.5, 0., 0., 0., 1.]).reshape([3,3])\n        z1 = covarz[:,2]\n        z2 = np.copy(z1)\n        if (faultNorm > faults.sigmaFault*(np.linalg.norm(z1)+np.linalg.norm(z2))):\n            faultDetectedTrue = 1\n            r_Cexp = r_c2\n            covar_Cexp = [0.5, 0., 0., 0., 0.5, 0., 0., 0., 1.]\n        elif faultMode > 0:\n            r_Cexp = r_c1\n            covar_Cexp =  [0.5, 0., 0., 0., 0.5, 0., 0., 0., 1.]\n        elif faultMode == 0:\n            covar_Cexp = np.linalg.inv(np.linalg.inv(covarz) + np.linalg.inv(covarz)).flatten().tolist()\n            r_Cexp = np.dot(np.linalg.inv(np.linalg.inv(covarz) + np.linalg.inv(covarz)), np.dot(np.linalg.inv(covarz), r1) +  np.dot(np.linalg.inv(covarz), r2)).tolist()\n\n\n    posErr = 1e-10\n    print(posErr)\n\n    outputR = dataLog.r_BN_C\n    outputCovar = dataLog.covar_C\n    outputTime = dataLog.timeTag\n    detected = dataLog.faultDetected\n\n    #\n    #\n    for i in range(len(outputR[-1, 1:])):\n        if np.abs(r_Cexp[i] - outputR[-1, i]) > 1E-10 or np.isnan(outputR.any()):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Position Check in pixelLine\")\n\n    for i in range(len(outputCovar[-1, 0:])):\n        if np.abs((covar_Cexp[i] - outputCovar[-1, i])) > 1E-10 or np.isnan(outputTime.any()):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Covar Check in pixelLine\")\n\n    if np.abs((timTagExp - outputTime[-1])) > 1E-10 or np.isnan(outputTime.any()):\n        testFailCount += 1\n        testMessages.append(\"FAILED: Time Check in pixelLine\")\n\n    if np.abs(faultDetectedTrue - detected[-1]) > 1E-10 or np.isnan(outputTime.any()):\n        testFailCount += 1\n        testMessages.append(\"FAILED: Time Check in pixelLine\")\n    #\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + faults.ModelTag)\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + faults.ModelTag)\n\n\n    return [testFailCount, ''.join(testMessages)]",
  "def addTimeColumn(time, data):\n    return np.transpose(np.vstack([[time], np.transpose(data)]))",
  "def rk4(f, t, x0):\n    x = np.zeros([len(t),len(x0)+1])\n    h = (t[len(t)-1] - t[0])/len(t)\n    x[0,0] = t[0]\n    x[0,1:] = x0\n    for i in range(len(t)-1):\n        h = t[i+1] - t[i]\n        x[i,0] = t[i]\n        k1 = h * f(t[i], x[i,1:])\n        k2 = h * f(t[i] + 0.5 * h, x[i,1:] + 0.5 * k1)\n        k3 = h * f(t[i] + 0.5 * h, x[i,1:] + 0.5 * k2)\n        k4 = h * f(t[i] + h, x[i,1:] + k3)\n        x[i+1,1:] = x[i,1:] + (k1 + 2.*k2 + 2.*k3 + k4) / 6.\n        x[i+1,0] = t[i+1]\n    return x",
  "def twoBodyGrav(t, x, mu = 42828.314*1E9):\n    dxdt = np.zeros(np.shape(x))\n    dxdt[0:3] = x[3:6]\n    dxdt[3:6] = -mu/np.linalg.norm(x[0:3])**3.*x[0:3]\n    return dxdt",
  "def setupFilterData(filterObject):\n\n    filterObject.planetIdInit = 2\n    filterObject.alpha = 0.02\n    filterObject.beta = 2.0\n    filterObject.kappa = 0.0\n    filterObject.gamma = 0.9\n\n    mu = 42828.314*1E9 #m^3/s^2\n    elementsInit = orbitalMotion.ClassicElements()\n    elementsInit.a = 8000*1E3 #m\n    elementsInit.e = 0.2\n    elementsInit.i = 10\n    elementsInit.Omega = 0.001\n    elementsInit.omega = 0.01\n    elementsInit.f = 0.1\n    r, v = orbitalMotion.elem2rv(mu, elementsInit)\n    bias = [1,1,-2]\n\n    filterObject.stateInit = r.tolist() + v.tolist() + bias\n    filterObject.covarInit = [1000.*1E6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                              0.0, 1000.*1E6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 1000.*1E6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 5*1E6, 0.0, 0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0, 5*1E6, 0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0, 0.0, 5*1E6, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.0,]\n\n    qNoiseIn = np.identity(9)\n    qNoiseIn[0:3, 0:3] = qNoiseIn[0:3, 0:3]*0.00001*0.00001*1E-6\n    qNoiseIn[3:6, 3:6] = qNoiseIn[3:6, 3:6]*0.0001*0.0001*1E-6\n    qNoiseIn[6:9, 6:9] = qNoiseIn[3:6, 3:6]*0.0001*0.0001\n    filterObject.qNoise = qNoiseIn.reshape(9*9).tolist()",
  "def test_methods_kf(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = relOD_method_test(show_plots)\n    assert testResults < 1, testMessage",
  "def test_propagation_kf(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = StatePropRelOD(show_plots, 10.0)\n    assert testResults < 1, testMessage",
  "def relOD_method_test(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    state = [250, 32000, 1000, 5, 3, 2, 1, 1, 1]\n    covar = 10* np.eye(len(state))\n    dt = 10\n    mu = 42828.314\n    # Measurement Model Test\n    data = pixelLineBiasUKF.PixelLineBiasUKFConfig()\n    msg = messaging.OpNavCirclesMsgPayload()\n    msg.circlesCenters = [100, 200]\n    msg.circlesRadii = [100]\n    msg.planetIds = [2]\n    data.circlesInBuffer = msg\n    data.planetId = 2\n    data.countHalfSPs = len(state)\n    data.numStates = len(state)\n\n    # Dynamics Model Test\n    data.planetId = 2\n\n    stateIn = pixelLineBiasUKF.new_doubleArray(len(state))\n    for i in range(len(state)):\n        pixelLineBiasUKF.doubleArray_setitem(stateIn, i, state[i])\n\n    pixelLineBiasUKF.relODStateProp(data, stateIn, dt)\n\n    propedState = []\n    for i in range(len(state)):\n        propedState.append(pixelLineBiasUKF.doubleArray_getitem(stateIn, i))\n    expected = rk4(twoBodyGrav, [0, dt], np.array(state)*1E3)\n    expected[:,1:]*=1E-3\n    if np.linalg.norm((np.array(propedState) - expected[-1,1:])/(expected[-1,1:])) > 1.0E-15:\n        testFailCount += 1\n        testMessages.append(\"State Prop Failure\")\n\n    # Set up a measurement test\n    data = pixelLineBiasUKF.PixelLineBiasUKFConfig()\n    # Set up a circle input message\n    msg = messaging.OpNavCirclesMsgPayload()\n    msg.circlesCenters = [100, 200]\n    msg.circlesRadii = [100]\n    msg.planetIds = [2]\n    data.circlesInBuffer = msg\n    data.planetId = 2\n    data.countHalfSPs = len(state)\n    data.numStates = len(state)\n\n    # Set up attitud message\n    att = messaging.NavAttMsgPayload()\n    att.sigma_BN = [0, 0.2,-0.1]\n    att.omega_BN_B = [0.,0.,0.]\n    data.attInfo = att\n\n    # Set up a camera message\n    cam = messaging.CameraConfigMsgPayload()\n    cam.sigma_CB = [-0.2, 0., 0.3]\n    cam.fieldOfView = 2.0 * np.arctan(10*1e-3 / 2.0 / (1.*1e-3) )  # 2*arctan(s/2 / f)\n    cam.resolution = [512, 512]\n    data.cameraSpecs = cam\n\n    # Populate sigma points\n    SP = np.zeros([len(state), 2*len(state) +1])\n    for i in range(2*len(state) + 1):\n        if i ==0:\n            SP[:, i] = np.array(state)\n        if i < len(state) + 1 and i>0:\n            SP[:,i] = np.array(state) + covar[:,i-1]\n        if i > len(state):\n            SP[:,i] = np.array(state) - covar[:,i-(len(state)+1)]\n\n    data.SP = np.transpose(SP).flatten().tolist()\n    data.state = state\n    pixelLineBiasUKF.pixelLineBiasUKFMeasModel(data)\n\n    yMeasOut = data.yMeas\n    expectedMeas = np.zeros([6, 2*len(state)+1])\n\n    dcm_CB = rbk.MRP2C(cam.sigma_CB)\n    dcm_BN = rbk.MRP2C(att.sigma_BN)\n    dcm_CN = np.dot(dcm_CB, dcm_BN)\n\n    pX = 2. * np.tan(cam.fieldOfView * cam.resolution[0] / cam.resolution[1] / 2.0)\n    pY = 2. * np.tan(cam.fieldOfView / 2.0)\n    X = pX / cam.resolution[0]\n    Y = pY / cam.resolution[1]\n    planetRad = 3396.19\n    obs = np.array([msg.circlesCenters[0], msg.circlesCenters[1], msg.circlesRadii[0], 0, 0, 0])\n    for i in range(2*len(state)+1):\n        r_C = np.dot(dcm_CN, SP[0:3,i])\n        rNorm = np.linalg.norm(SP[0:3,i])\n        r_C = -1./r_C[2]*r_C\n\n        centerX = r_C[0] / X\n        centerY = r_C[1] / Y\n        centerX += cam.resolution[0]/2 - 0.5\n        centerY += cam.resolution[1] / 2 - 0.5\n\n        rad = 1.0/X*np.tan(np.arcsin(planetRad/rNorm))\n\n        if i == 0:\n            obs[3:5] = np.array(msg.circlesCenters[0:2]) - obs[0:2]\n            obs[5] = rad - obs[2]\n        for j in range(3):\n            obs[3+j] = round(obs[3+j])\n        expectedMeas[0,i] = centerX - SP[6, i]\n        expectedMeas[1,i] = centerY - SP[7, i]\n        expectedMeas[2, i] = rad - SP[8, i]\n        expectedMeas[3:, i] = SP[6:, i]\n\n    yMeasTest = np.zeros([6, 2*len(state)+1])\n    for i in range(2*len(state)+1):\n        yMeasTest[:,i] = yMeasOut[i*6:i*6+6]\n    if np.linalg.norm((yMeasTest - expectedMeas))/np.linalg.norm(expectedMeas[:,0]) > 1.0E-15:\n        testFailCount += 1\n        testMessages.append(\"State Prop Failure\")\n\n    if testFailCount == 0:\n        print(\"PASSED: \")\n    else:\n        print(testMessages)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def StatePropRelOD(show_plots, dt):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    state = [250, 32000, 1000, 5, 3, 2, 1, 1, 1]\n    testProcessRate = macros.sec2nano(dt)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = pixelLineBiasUKF.pixelLineBiasUKF()\n    module.ModelTag = \"relodSuKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    setupFilterData(module)\n\n    # Create the input messages.\n    inputCamera = messaging.CameraConfigMsgPayload()\n    inputAtt = messaging.NavAttMsgPayload()\n\n    # Set camera\n    inputCamera.fieldOfView = 2.0 * np.arctan(10*1e-3 / 2.0 / 0.01)  # 2*arctan(s/2 / f)\n    inputCamera.resolution = [512, 512]\n    inputCamera.sigma_CB = [1., 0.3, 0.1]\n    camInMsg = messaging.CameraConfigMsg().write(inputCamera)\n    module.cameraConfigInMsg.subscribeTo(camInMsg)\n\n    # Set attitude\n    inputAtt.sigma_BN = [0.6, 1., 0.1]\n    attInMsg = messaging.NavAttMsg().write(inputAtt)\n    module.attInMsg.subscribeTo(attInMsg)\n\n    circlesInMsg = messaging.OpNavCirclesMsg()\n    module.circlesInMsg.subscribeTo(circlesInMsg)\n\n    dataLog = module.filtDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    timeSim = 60\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.min2nano(timeSim))\n    unitTestSim.ExecuteSimulation()\n\n    time = np.linspace(0, timeSim*60, (int) (timeSim*60/dt+1))\n    dydt = np.zeros(len(module.stateInit))\n    energy = np.zeros(len(time))\n    expected=np.zeros([len(time), len(module.stateInit)+1])\n    expected[0,1:] = module.stateInit\n    mu = 42828.314*1E9\n    energy[0] = -mu/(2*orbitalMotion.rv2elem(mu, expected[0,1:4], expected[0,4:7]).a)\n    expected = rk4(twoBodyGrav, time, module.stateInit)\n    for i in range(1, len(time)):\n        energy[i] = - mu / (2 * orbitalMotion.rv2elem(mu, expected[i, 1:4], expected[i, 4:7]).a)\n\n    stateLog = addTimeColumn(dataLog.times(), dataLog.state)\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n    diff = np.copy(stateLog)\n    diff[:,1:]-=expected[:,1:]\n    FilterPlots.plot_TwoOrbits(expected[:,0:4], stateLog[:,0:4])\n    FilterPlots.EnergyPlot(time, energy, 'Prop', show_plots)\n    FilterPlots.StateCovarPlot(stateLog, covarLog, 'Prop', show_plots)\n    FilterPlots.StatePlot(diff, 'Prop', show_plots)\n\n    if (np.linalg.norm(diff[-1,1:]/expected[-1,1:]) > 1.0E-10):\n        testFailCount += 1\n        testMessages.append(\"State propagation failure\")\n\n    if (energy[0] - energy[-1])/energy[0] > 1.0E-10:\n        testFailCount += 1\n        testMessages.append(\"State propagation failure\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag + \" state propagation\")\n    else:\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StatePlot(x, testName, show_plots):\n\n    numStates = len(x[0,:])-1\n\n    t= np.zeros(len(x[:,0]))\n    for i in range(len(t)):\n        t[i] = x[i, 0]*1E-9\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(t , x[:, 1], \"b\", label='Error Filter')\n    plt.legend(loc='lower right')\n    plt.title('First pos component (m)')\n    plt.grid()\n\n    plt.subplot(322)\n    plt.plot(t , x[:, 4], \"b\")\n    plt.title('Second rate component (m/s)')\n    plt.grid()\n\n    plt.subplot(323)\n    plt.plot(t , x[:, 2], \"b\")\n    plt.title('Second pos component (m)')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(t , x[:, 5], \"b\")\n    plt.xlabel('t(s)')\n    plt.title('Third rate component (m/s)')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(t , x[:, 3], \"b\")\n    plt.xlabel('t(s)')\n    plt.title('Third pos component (m)')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(t , x[:, 6], \"b\")\n    plt.xlabel('t(s)')\n    plt.title('Third rate component (m/s)')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesPlot' + testName, 'State error', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def EnergyPlot(t, energy, testName, show_plots):\n\n    conserved= np.zeros(len(t))\n    for i in range(len(t)):\n        conserved[i] = (energy[i] - energy[0])/energy[0]\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(t , conserved, \"b\", label='Energy')\n    plt.legend(loc='lower right')\n    plt.title('Energy ' + testName)\n    plt.grid()\n\n\n    unitTestSupport.writeFigureLaTeX('Energy' + testName, 'Orbital Energy', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def StateCovarPlot(x, Pflat, testName, show_plots):\n\n    numStates = len(x[0,:])-1\n\n    P = np.zeros([len(Pflat[:,0]),numStates,numStates])\n    t= np.zeros(len(Pflat[:,0]))\n    for i in range(len(Pflat[:,0])):\n        t[i] = x[i, 0]*1E-9\n        P[i,:,:] = Pflat[i,1:(numStates*numStates+1)].reshape([numStates,numStates])\n\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(t , x[:, 1], \"b\", label='Error Filter')\n    plt.plot(t , x[:, 1]+3 * np.sqrt(P[:, 0, 0]), 'r--',  label='Covar Filter')\n    plt.plot(t , x[:, 1]-3 * np.sqrt(P[:, 0, 0]), 'r--')\n    plt.legend(loc='lower right')\n    plt.title('First pos component (m)')\n    plt.grid()\n\n    plt.subplot(322)\n    plt.plot(t , x[:, 4], \"b\")\n    plt.plot(t , x[:, 4]+3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.plot(t , x[:, 4]-3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.title('Second rate component (m/s)')\n    plt.grid()\n\n    plt.subplot(323)\n    plt.plot(t , x[:, 2], \"b\")\n    plt.plot(t , x[:, 2]+3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.plot(t , x[:, 2]-3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.title('Second pos component (m)')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(t , x[:, 5], \"b\")\n    plt.plot(t , x[:, 5]+3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.plot(t , x[:, 5]-3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component (m/s)')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(t , x[:, 3], \"b\")\n    plt.plot(t , x[:, 3]+3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.plot(t , x[:, 3]-3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third pos component (m)')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(t , x[:, 6], \"b\")\n    plt.plot(t , x[:, 6]+3 * np.sqrt(P[:, 5, 5]), 'r--')\n    plt.plot(t , x[:, 6]-3 * np.sqrt(P[:, 5, 5]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component (m/s)')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesPlot' + testName, 'State error and covariance', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def PostFitResiduals(Res, noise, testName, show_plots):\n\n    MeasNoise = np.zeros(len(Res[:,0]))\n    t= np.zeros(len(Res[:,0]))\n    for i in range(len(Res[:,0])):\n        t[i] = Res[i, 0]*1E-9\n        MeasNoise[i] = 3*noise\n        # Don't plot zero values, since they mean that no measurement is taken\n        for j in range(len(Res[0,:])-1):\n            if -1E-10 < Res[i,j+1] < 1E-10:\n                Res[i, j+1] = np.nan\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(311)\n    plt.plot(t , Res[:, 1], \"b.\", label='Residual')\n    plt.plot(t , MeasNoise, 'r--', label='Covar')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.legend(loc='lower right')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('First Meas Comp (m)')\n    plt.grid()\n\n    plt.subplot(312)\n    plt.plot(t , Res[:, 2], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Second Meas Comp (m)')\n    plt.grid()\n\n    plt.subplot(313)\n    plt.plot(t , Res[:, 3], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Third Meas Comp (m)')\n    plt.grid()\n\n\n    unitTestSupport.writeFigureLaTeX('PostFit' + testName, 'Post Fit Residuals', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def plot_TwoOrbits(r_BN, r_BN2):\n    fig = plt.figure()\n    ax = fig.add_subplot(projection='3d')\n    ax.set_xlabel('$R_x$, km')\n    ax.set_ylabel('$R_y$, km')\n    ax.set_zlabel('$R_z$, km')\n    ax.plot(r_BN[:, 1] * m2km, r_BN[:, 2] * m2km, r_BN[:, 3] * m2km, color_x, label=\"True orbit\")\n    for i in range(len(r_BN2[:,0])):\n        if np.abs(r_BN2[i, 1])>0 or np.abs(r_BN2[i, 2])>0:\n            ax.scatter(r_BN2[i, 1] * m2km, r_BN2[i, 2] * m2km, r_BN2[i, 3] * m2km, color=color_y, label=\"Meas orbit\")\n    ax.scatter(0, 0, color='r')\n    ax.set_title('Spacecraft Orbits')\n    return",
  "def addTimeColumn(time, data):\n    return np.transpose(np.vstack([[time], np.transpose(data)]))",
  "def rk4(f, t, x0):\n    x = np.zeros([len(t),len(x0)+1])\n    h = (t[len(t)-1] - t[0])/len(t)\n    x[0,0] = t[0]\n    x[0,1:] = x0\n    for i in range(len(t)-1):\n        h = t[i+1] - t[i]\n        x[i,0] = t[i]\n        k1 = h * f(t[i], x[i,1:])\n        k2 = h * f(t[i] + 0.5 * h, x[i,1:] + 0.5 * k1)\n        k3 = h * f(t[i] + 0.5 * h, x[i,1:] + 0.5 * k2)\n        k4 = h * f(t[i] + h, x[i,1:] + k3)\n        x[i+1,1:] = x[i,1:] + (k1 + 2.*k2 + 2.*k3 + k4) / 6.\n        x[i+1,0] = t[i+1]\n    return x",
  "def twoBodyGrav(t, x, mu = 42828.314*1E9):\n    dxdt = np.zeros(np.shape(x))\n    dxdt[0:3] = x[3:]\n    dxdt[3:] = -mu/np.linalg.norm(x[0:3])**3.*x[0:3]\n    return dxdt",
  "def setupFilterData(filterObject):\n\n    filterObject.planetIdInit = 2\n    filterObject.alpha = 0.02\n    filterObject.beta = 2.0\n    filterObject.kappa = 0.0\n\n    mu = 42828.314*1E9 #m^3/s^2\n    elementsInit = orbitalMotion.ClassicElements()\n    elementsInit.a = 4000*1E3 #m\n    elementsInit.e = 0.2\n    elementsInit.i = 10\n    elementsInit.Omega = 0.001\n    elementsInit.omega = 0.01\n    elementsInit.f = 0.1\n    r, v = orbitalMotion.elem2rv(mu, elementsInit)\n\n    filterObject.stateInit = r.tolist() + v.tolist()\n    filterObject.covarInit = [1000.*1E6, 0.0, 0.0, 0.0, 0.0, 0.0,\n                              0.0, 1000.*1E6, 0.0, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 1000.*1E6, 0.0, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 5*1E6, 0.0, 0.0,\n                              0.0, 0.0, 0.0, 0.0, 5*1E6, 0.0,\n                              0.0, 0.0, 0.0, 0.0, 0.0, 5*1E6]\n\n    qNoiseIn = np.identity(6)\n    qNoiseIn[0:3, 0:3] = qNoiseIn[0:3, 0:3]*0.00001*0.00001*1E-6\n    qNoiseIn[3:6, 3:6] = qNoiseIn[3:6, 3:6]*0.0001*0.0001*1E-6\n    filterObject.qNoise = qNoiseIn.reshape(36).tolist()\n    filterObject.noiseSF = 1",
  "def test_methods_kf(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = relOD_method_test(show_plots)\n    assert testResults < 1, testMessage",
  "def test_propagation_kf(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = StatePropRelOD(show_plots, 10.0)\n    assert testResults < 1, testMessage",
  "def test_measurements_kf(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = StateUpdateRelOD(show_plots)\n    assert testResults < 1, testMessage",
  "def relOD_method_test(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    state = [250, 32000, 1000, 5, 3, 2]\n    dt = 10\n    mu = 42828.314\n    # Measurement Model Test\n    data = relativeODuKF.RelODuKFConfig()\n    msg = messaging.OpNavMsgPayload()\n    msg.r_BN_N = [300, 200, 100]\n    data.planetId = 2\n    data.opNavInBuffer = msg\n    data.countHalfSPs = 6\n    data.noiseSF = 1\n\n    Covar = np.eye(6)\n    SPexp = np.zeros([6, 2*6+1])\n    SPexp[:,0] = np.array(state)\n    for i in range(1, 6+1):\n        SPexp[:,i] = np.array(state) + Covar[:,i-1]\n        SPexp[:, i+6] = np.array(state) - Covar[:,i-1]\n\n\n    data.SP =  np.transpose(SPexp).flatten().tolist()\n    relativeODuKF.relODuKFMeasModel(data)\n\n    measurements = data.yMeas\n\n    if np.linalg.norm(np.array(measurements) - np.transpose(SPexp[0:3,:]).flatten()) > 1.0E-15:\n        testFailCount += 1\n        testMessages.append(\"Measurement Model Failure\")\n\n    # Dynamics Model Test\n    data.planetId = 2\n\n    stateIn = relativeODuKF.new_doubleArray(6)\n    for i in range(len(state)):\n        relativeODuKF.doubleArray_setitem(stateIn, i, state[i])\n\n    relativeODuKF.relODStateProp(data, stateIn, dt)\n\n    propedState = []\n    for i in range(6):\n        propedState.append(relativeODuKF.doubleArray_getitem(stateIn, i))\n    expected = rk4(twoBodyGrav, [0, dt], np.array(state)*1E3)\n    expected[:,1:]*=1E-3\n    if np.linalg.norm((np.array(propedState) - expected[-1,1:])/(expected[-1,1:])) > 1.0E-15:\n        testFailCount += 1\n        testMessages.append(\"State Prop Failure\")\n\n    if testFailCount:\n        print(testMessages)\n    else:\n        print(\"Passed\")\n    return [testFailCount, ''.join(testMessages)]",
  "def StateUpdateRelOD(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    dt = 1.0\n    t1 = 250\n    multT1 = 8\n\n    testProcessRate = macros.sec2nano(dt)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm\n    module = relativeODuKF.relativeODuKF()\n    module.ModelTag = \"relodSuKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n    module.noiseSF = 1\n\n    dataLog = module.filtDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    time = np.linspace(0, int(multT1*t1), int(multT1*t1//dt)+1)\n    dydt = np.zeros(6)\n    energy = np.zeros(len(time))\n    expected=np.zeros([len(time), 7])\n    expected[0,1:] = module.stateInit\n    mu = 42828.314*1E9\n    energy[0] = -mu/(2*orbitalMotion.rv2elem(mu, expected[0,1:4], expected[0,4:]).a)\n\n    kick = np.array([0., 0., 0., -0.01, 0.01, 0.02]) * 10 *1E3\n\n    expected[0:t1,:] = rk4(twoBodyGrav, time[0:t1], module.stateInit)\n    expected[t1:multT1*t1+1, :] = rk4(twoBodyGrav, time[t1:len(time)], expected[t1-1, 1:] + kick)\n    for i in range(1, len(time)):\n        energy[i] = - mu / (2 * orbitalMotion.rv2elem(mu, expected[i, 1:4], expected[i, 4:]).a)\n\n    inputData = messaging.OpNavMsgPayload()\n    opnavInMsg = messaging.OpNavMsg()\n    module.opNavInMsg.subscribeTo(opnavInMsg)\n\n    inputData.planetID = 2\n    inputData.r_BN_B = expected[0, 1:4]\n\n    opnavInMsg.write(inputData, 0)\n\n    unitTestSim.InitializeSimulation()\n    for i in range(t1):\n        if i > 0 and i % 50 == 0:\n            inputData.timeTag = macros.sec2nano(i * dt)\n            inputData.r_BN_N = expected[i,1:4] + np.random.normal(0, 5*1E-2, 3)\n            inputData.valid = 1\n            inputData.covar_N = [5.*1E-2, 0., 0.,\n                                 0., 5.*1E-2, 0.,\n                                 0., 0., 5.*1E-2]\n            opnavInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i + 1) * dt))\n        unitTestSim.ExecuteSimulation()\n\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n    for i in range(6):\n        if (covarLog[t1, i * 6 + 1 + i] > covarLog[0, i * 6 + 1 + i] / 100):\n            testFailCount += 1\n            testMessages.append(\"Covariance update failure at \" + str(t1))\n\n    for i in range(t1, multT1*t1):\n        if i % 50 == 0:\n            inputData.timeTag = macros.sec2nano(i * dt + 1)\n            inputData.r_BN_N = expected[i,1:4] +  np.random.normal(0, 5*1E-2, 3)\n            inputData.valid = 1\n            inputData.covar_N = [5.*1E-2, 0.,0.,\n                                 0., 5.*1E-2, 0.,\n                                 0., 0., 5.*1E-2]\n            opnavInMsg.write(inputData, unitTestSim.TotalSim.CurrentNanos)\n        unitTestSim.ConfigureStopTime(macros.sec2nano((i + 1)*dt))\n        unitTestSim.ExecuteSimulation()\n\n    stateLog = addTimeColumn(dataLog.times(), dataLog.state)\n    stateErrorLog = addTimeColumn(dataLog.times(), dataLog.stateError)\n    postFitLog = addTimeColumn(dataLog.times(), dataLog.postFitRes)\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n\n    diff = np.copy(stateLog)\n    diff[:,1:]-=expected[:,1:]\n    FilterPlots.EnergyPlot(time, energy, 'Update', show_plots)\n    FilterPlots.StateCovarPlot(stateLog, covarLog, 'Update', show_plots)\n    FilterPlots.StatePlot(diff, 'Update', show_plots)\n    FilterPlots.plot_TwoOrbits(expected[:,0:4], stateLog[:,0:4])\n    FilterPlots.PostFitResiduals(postFitLog, np.sqrt(5*1E-2*1E6), 'Update', show_plots)\n\n    for i in range(6):\n        if (covarLog[t1*multT1, i * 6 + 1 + i] > covarLog[0, i * 6 + 1 + i] / 100):\n            testFailCount += 1\n            testMessages.append(\"Covariance update failure at \" + str(t1*multT1))\n\n    if (np.linalg.norm(diff[-1, 1:]/expected[-1,1:]) > 1.0E-1):\n        testFailCount += 1\n        testMessages.append(\"State propagation failure\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag + \" state update\")\n    else:\n        print(testMessages)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StatePropRelOD(show_plots, dt):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(dt)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = relativeODuKF.relativeODuKF()\n    module.ModelTag = \"relodSuKF\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    setupFilterData(module)\n    module.noiseSF = 1\n\n    dataLog = module.filtDataOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    inputData = messaging.OpNavMsgPayload()\n    opnavInMsg = messaging.OpNavMsg()\n    module.opNavInMsg.subscribeTo(opnavInMsg)\n\n    opnavInMsg.write(inputData, 0)\n\n    timeSim = 60\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.min2nano(timeSim))\n    unitTestSim.ExecuteSimulation()\n\n    time = np.linspace(0, int(timeSim*60), int(timeSim*60//dt)+1)\n    dydt = np.zeros(6)\n    energy = np.zeros(len(time))\n    expected=np.zeros([len(time), 7])\n    expected[0,1:] = module.stateInit\n    mu = 42828.314*1E9\n    energy[0] = -mu/(2*orbitalMotion.rv2elem(mu, expected[0,1:4], expected[0,4:]).a)\n    expected = rk4(twoBodyGrav, time, module.stateInit)\n    for i in range(1, len(time)):\n        energy[i] = - mu / (2 * orbitalMotion.rv2elem(mu, expected[i, 1:4], expected[i, 4:]).a)\n\n    stateLog = addTimeColumn(dataLog.times(), dataLog.state)\n    covarLog = addTimeColumn(dataLog.times(), dataLog.covar)\n\n    diff = np.copy(stateLog)\n    diff[:,1:]-=expected[:,1:]\n    FilterPlots.plot_TwoOrbits(expected[:,0:4], stateLog[:,0:4])\n    FilterPlots.EnergyPlot(time, energy, 'Prop', show_plots)\n    FilterPlots.StateCovarPlot(stateLog, covarLog, 'Prop', show_plots)\n    FilterPlots.StatePlot(diff, 'Prop', show_plots)\n\n    if (np.linalg.norm(diff[-1,1:]/expected[-1,1:]) > 1.0E-10):\n        testFailCount += 1\n        testMessages.append(\"State propagation failure\")\n\n    if (energy[0] - energy[-1])/energy[0] > 1.0E-10:\n        testFailCount += 1\n        testMessages.append(\"State propagation failure\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag + \" state propagation\")\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def StatePlot(x, testName, show_plots):\n\n    numStates = len(x[0,:])-1\n\n    t= np.zeros(len(x[:,0]))\n    for i in range(len(t)):\n        t[i] = x[i, 0]*1E-9\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(t , x[:, 1], \"b\", label='Error Filter')\n    plt.legend(loc='lower right')\n    plt.title('First pos component (m)')\n    plt.grid()\n\n    plt.subplot(322)\n    plt.plot(t , x[:, 4], \"b\")\n    plt.title('Second rate component (m/s)')\n    plt.grid()\n\n    plt.subplot(323)\n    plt.plot(t , x[:, 2], \"b\")\n    plt.title('Second pos component (m)')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(t , x[:, 5], \"b\")\n    plt.xlabel('t(s)')\n    plt.title('Third rate component (m/s)')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(t , x[:, 3], \"b\")\n    plt.xlabel('t(s)')\n    plt.title('Third pos component (m)')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(t , x[:, 6], \"b\")\n    plt.xlabel('t(s)')\n    plt.title('Third rate component (m/s)')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesPlot' + testName, 'State error', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def EnergyPlot(t, energy, testName, show_plots):\n\n    conserved= np.zeros(len(t))\n    for i in range(len(t)):\n        conserved[i] = (energy[i] - energy[0])/energy[0]\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(t , conserved, \"b\", label='Energy')\n    plt.legend(loc='lower right')\n    plt.title('Energy ' + testName)\n    plt.grid()\n\n\n    unitTestSupport.writeFigureLaTeX('Energy' + testName, 'Orbital Energy', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def StateCovarPlot(x, Pflat, testName, show_plots):\n\n    numStates = len(x[0,:])-1\n\n    P = np.zeros([len(Pflat[:,0]),numStates,numStates])\n    t= np.zeros(len(Pflat[:,0]))\n    for i in range(len(Pflat[:,0])):\n        t[i] = x[i, 0]*1E-9\n        P[i,:,:] = Pflat[i,1:(numStates*numStates+1)].reshape([numStates,numStates])\n\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(321)\n    plt.plot(t , x[:, 1], \"b\", label='Error Filter')\n    plt.plot(t , x[:, 1]+3 * np.sqrt(P[:, 0, 0]), 'r--',  label='Covar Filter')\n    plt.plot(t , x[:, 1]-3 * np.sqrt(P[:, 0, 0]), 'r--')\n    plt.legend(loc='lower right')\n    plt.title('First pos component (m)')\n    plt.grid()\n\n    plt.subplot(322)\n    plt.plot(t , x[:, 4], \"b\")\n    plt.plot(t , x[:, 4]+3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.plot(t , x[:, 4]-3 * np.sqrt(P[:, 3, 3]), 'r--')\n    plt.title('Second rate component (m/s)')\n    plt.grid()\n\n    plt.subplot(323)\n    plt.plot(t , x[:, 2], \"b\")\n    plt.plot(t , x[:, 2]+3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.plot(t , x[:, 2]-3 * np.sqrt(P[:, 1, 1]), 'r--')\n    plt.title('Second pos component (m)')\n    plt.grid()\n\n    plt.subplot(324)\n    plt.plot(t , x[:, 5], \"b\")\n    plt.plot(t , x[:, 5]+3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.plot(t , x[:, 5]-3 * np.sqrt(P[:, 4, 4]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component (m/s)')\n    plt.grid()\n\n    plt.subplot(325)\n    plt.plot(t , x[:, 3], \"b\")\n    plt.plot(t , x[:, 3]+3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.plot(t , x[:, 3]-3 * np.sqrt(P[:, 2, 2]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third pos component (m)')\n    plt.grid()\n\n    plt.subplot(326)\n    plt.plot(t , x[:, 6], \"b\")\n    plt.plot(t , x[:, 6]+3 * np.sqrt(P[:, 5, 5]), 'r--')\n    plt.plot(t , x[:, 6]-3 * np.sqrt(P[:, 5, 5]), 'r--')\n    plt.xlabel('t(s)')\n    plt.title('Third rate component (m/s)')\n    plt.grid()\n\n    unitTestSupport.writeFigureLaTeX('StatesPlot' + testName, 'State error and covariance', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def PostFitResiduals(Res, noise, testName, show_plots):\n\n    MeasNoise = np.zeros(len(Res[:,0]))\n    t= np.zeros(len(Res[:,0]))\n    for i in range(len(Res[:,0])):\n        t[i] = Res[i, 0]*1E-9\n        MeasNoise[i] = 3*noise\n        # Don't plot zero values, since they mean that no measurement is taken\n        for j in range(len(Res[0,:])-1):\n            if -1E-10 < Res[i,j+1] < 1E-10:\n                Res[i, j+1] = np.nan\n\n    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    plt.subplot(311)\n    plt.plot(t , Res[:, 1], \"b.\", label='Residual')\n    plt.plot(t , MeasNoise, 'r--', label='Covar')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.legend(loc='lower right')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('First Meas Comp (m)')\n    plt.grid()\n\n    plt.subplot(312)\n    plt.plot(t , Res[:, 2], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Second Meas Comp (m)')\n    plt.grid()\n\n    plt.subplot(313)\n    plt.plot(t , Res[:, 3], \"b.\")\n    plt.plot(t , MeasNoise, 'r--')\n    plt.plot(t , -MeasNoise, 'r--')\n    plt.ylim([-10*noise, 10*noise])\n    plt.title('Third Meas Comp (m)')\n    plt.grid()\n\n\n    unitTestSupport.writeFigureLaTeX('PostFit' + testName, 'Post Fit Residuals', plt, 'height=0.9\\\\textwidth, keepaspectratio', path)\n\n    if show_plots:\n        plt.show()\n    plt.close()",
  "def plot_TwoOrbits(r_BN, r_BN2):\n    fig = plt.figure()\n    ax = fig.add_subplot(projection='3d')\n    ax.set_xlabel('$R_x$, km')\n    ax.set_ylabel('$R_y$, km')\n    ax.set_zlabel('$R_z$, km')\n    ax.plot(r_BN[:, 1] * m2km, r_BN[:, 2] * m2km, r_BN[:, 3] * m2km, color_x, label=\"True orbit\")\n    for i in range(len(r_BN2[:,0])):\n        if np.abs(r_BN2[i, 1])>0 or np.abs(r_BN2[i, 2])>0:\n            ax.scatter(r_BN2[i, 1] * m2km, r_BN2[i, 2] * m2km, r_BN2[i, 3] * m2km, color=color_y, label=\"Meas orbit\")\n    ax.scatter(0, 0, color='r')\n    ax.set_title('Spacecraft Orbits')\n    return",
  "def test_mrp_PD_tracking(show_plots, setExtTorque):\n    r\"\"\"\n    **Validation Test Description**\n\n    The unit test  for this module is kept as there are no branching code segments to account for different cases.\n    The spacecraft inertia tensor message is setup, as well as a guidance message.  The module is then run for a\n    few time steps and the control torque output message compared to a known answer.  The simulation only variable\n    is if the known external torque is specified, or if the zero default vector is used.\n\n    **Test Parameters**\n\n    The unit test verifies that the module output torque message vector matches expected values.  The test\n    method parameters include the following.\n\n    :param show_plots: flag to show the test run plots\n    :param setExtTorque: flag to set the knownTorquePntB_B variable\n    :return: void\n\n    \"\"\"\n    [testResults, testMessage] = mrp_PD_tracking(show_plots, setExtTorque)\n    assert testResults < 1, testMessage",
  "def mrp_PD_tracking(show_plots, setExtTorque):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_PD_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = mrpPD.mrpPD()\n    module.ModelTag = \"mrpPD\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.K = 0.15\n    module.P = 150.0\n    if setExtTorque:\n        module.knownTorquePntB_B = [0.1, 0.2, 0.3]\n\n    #   Create input message and size it because the regular creator of that message\n    #   is not part of the test.\n    #   attGuidOut Message:\n    guidCmdData = messaging.AttGuidMsgPayload()\n    guidCmdData.sigma_BR = [0.3, -0.5, 0.7]\n    guidCmdData.omega_BR_B = [0.010, -0.020, 0.015]\n    guidCmdData.omega_RN_B = [-0.02, -0.01, 0.005]\n    guidCmdData.domega_RN_B = [0.0002, 0.0003, 0.0001]\n    guidInMsg = messaging.AttGuidMsg().write(guidCmdData)\n\n    # vehicleConfig FSW Message:\n    vehicleConfigIn = messaging.VehicleConfigMsgPayload()\n    vehicleConfigIn.ISCPntB_B = [1000., 0., 0.,\n                                  0., 800., 0.,\n                                  0., 0., 800.]\n    vcInMsg = messaging.VehicleConfigMsg().write(vehicleConfigIn)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.cmdTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.vehConfigInMsg.subscribeTo(vcInMsg)\n    module.guidInMsg.subscribeTo(guidInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Step the simulation to 3*process rate so 4 total steps including zero\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    trueVector = [findTrueTorques(module, guidCmdData, vehicleConfigIn)]*3\n    # print trueVector\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    print(\"accuracy = \" + str(accuracy))\n\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, dataLog.torqueRequestBody, accuracy,\n                                                               \"torqueRequestBody\", testFailCount, testMessages)\n\n    snippentName = \"passFail\" + str(setExtTorque)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def findTrueTorques(module, guidCmdData, vehicleConfigOut):\n    sigma_BR = np.array(guidCmdData.sigma_BR)\n    omega_BR_B = np.array(guidCmdData.omega_BR_B)\n    omega_RN_B = np.array(guidCmdData.omega_RN_B)\n    domega_RN_B = np.array(guidCmdData.domega_RN_B)\n\n    I = np.identity(3)\n    I[0][0] = vehicleConfigOut.ISCPntB_B[0]\n    I[1][1] = vehicleConfigOut.ISCPntB_B[4]\n    I[2][2] = vehicleConfigOut.ISCPntB_B[8]\n\n    K = module.K\n    P = module.P\n    L = np.array(module.knownTorquePntB_B)\n\n    # Begin Method\n    omega_BN_B = omega_BR_B + omega_RN_B\n    temp1 = np.dot(I, omega_BN_B)\n    temp2 = domega_RN_B - np.cross(omega_BN_B, omega_RN_B)\n    Lr = K * sigma_BR + P * omega_BR_B - np.cross(omega_RN_B, temp1) - np.dot(I, temp2)\n    Lr += L\n    Lr *= -1.0\n\n    return Lr",
  "def test_mrp_steering_tracking(show_plots,K1, K3, omegaMax):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test is an integrated test of this module with :ref:`rateServoFullNonlinear` as well,\n    comparing the desired torques computed :math:`{\\bf L}_r` with truth values computed in the test.\n\n    **Test Parameters**\n\n    This test checks a set of gains ``K1``, ``K3`` and ``omegaMax`` on a rigid body with no external\n    torques, and with a fixed input reference attitude message. The commanded rate solution\n    is evaluated against python computed values at 0s, 0.5s, 1.0s, 1.5s and 2s to within a\n    tolerance of :math:`10^{-12}`.\n\n    :param show_plots: flag indicating if plots should be shown.\n    :param K1: The control gain :math:`K_1`\n    :param K3: The control gain :math:`K_3`\n    :param omegaMax: The control gain :math:`\\omega_{\\text{max}}`\n    :return: void\n\n    \"\"\"\n    [testResults, testMessage] = mrp_steering_tracking(show_plots,K1, K3, omegaMax)\n    assert testResults < 1, testMessage",
  "def mrp_steering_tracking(show_plots,K1, K3, omegaMax):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = mrpSteering.mrpSteering()\n    module.ModelTag = \"mrpSteering\"\n\n    servo = rateServoFullNonlinear.rateServoFullNonlinear()\n    servo.ModelTag = \"rate_servo\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    unitTestSim.AddModelToTask(unitTaskName, servo)\n\n    module.K1 = K1\n    module.K3 = K3\n    module.omega_max = omegaMax\n    servo.Ki = 0.01\n    servo.P = 150.0\n    servo.integralLimit = 2. / servo.Ki * 0.1\n    servo.knownTorquePntB_B = [0., 0., 0.]\n\n    #   Create input message and size it because the regular creator of that message\n    #   is not part of the test.\n    #   attGuidOut Message:\n    guidCmdData = messaging.AttGuidMsgPayload()  # Create a structure for the input message\n    guidCmdData.sigma_BR = [0.3, -0.5, 0.7]\n    guidCmdData.omega_BR_B = [0.010, -0.020, 0.015]\n    guidCmdData.omega_RN_B = [-0.02, -0.01, 0.005]\n    guidCmdData.domega_RN_B = [0.0002, 0.0003, 0.0001]\n    guidInMsg = messaging.AttGuidMsg().write(guidCmdData)\n\n    # vehicleConfigData Message:\n    vehicleConfigOut = messaging.VehicleConfigMsgPayload()\n    I = [1000., 0., 0.,\n         0., 800., 0.,\n         0., 0., 800.]\n    vehicleConfigOut.ISCPntB_B = I\n    vcInMsg = messaging.VehicleConfigMsg().write(vehicleConfigOut)\n\n    # wheelSpeeds Message\n    rwSpeedMessage = messaging.RWSpeedMsgPayload()\n    Omega = [10.0, 25.0, 50.0, 100.0]\n    rwSpeedMessage.wheelSpeeds = Omega\n    rwInMsg = messaging.RWSpeedMsg().write(rwSpeedMessage)\n\n    # wheelConfigData message\n    def writeMsgInWheelConfiguration():\n        rwConfigParams = messaging.RWArrayConfigMsgPayload()\n        rwConfigParams.GsMatrix_B = [\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0,\n            0.5773502691896258, 0.5773502691896258, 0.5773502691896258\n        ]\n        rwConfigParams.JsList = [0.1, 0.1, 0.1, 0.1]\n        rwConfigParams.numRW = 4\n        msg = messaging.RWArrayConfigMsg().write(rwConfigParams)\n        jsList = rwConfigParams.JsList\n        GsMatrix_B = rwConfigParams.GsMatrix_B\n        return jsList, GsMatrix_B, msg\n\n    jsList, GsMatrix_B, rwParamInMsg = writeMsgInWheelConfiguration()\n\n    # wheelAvailability message\n    rwAvailList = []\n    rwAvailabilityMessage = messaging.RWAvailabilityMsgPayload()\n    rwAvail = [messaging.AVAILABLE, messaging.AVAILABLE, messaging.AVAILABLE, messaging.AVAILABLE]\n    rwAvailabilityMessage.wheelAvailability = rwAvail\n    rwAvailInMsg = messaging.RWAvailabilityMsg().write(rwAvailabilityMessage)\n    rwAvailList.append(rwAvail)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = servo.cmdTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.guidInMsg.subscribeTo(guidInMsg)\n    servo.guidInMsg.subscribeTo(guidInMsg)\n    servo.vehConfigInMsg.subscribeTo(vcInMsg)\n    servo.rwParamsInMsg.subscribeTo(rwParamInMsg)\n    servo.vehConfigInMsg.subscribeTo(vcInMsg)\n    servo.rwSpeedsInMsg.subscribeTo(rwInMsg)\n    servo.rateSteeringInMsg.subscribeTo(module.rateCmdOutMsg)\n    servo.rwAvailInMsg.subscribeTo(rwAvailInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Step the simulation to 3*process rate so 4 total steps including zero\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    servo.Reset(1)  # this module reset function needs a time input (in NanoSeconds)\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # Compute true values\n    trueVals = findTrueTorques(module, servo, guidCmdData, rwSpeedMessage, vehicleConfigOut, rwAvailList)\n\n    # set the filtered output truth states\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0, len(trueVals)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.torqueRequestBody[i], trueVals[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed torqueRequestBody unit test at t=\"\n                                + str(dataLog.times[i] * macros.NANO2SEC) + \"sec \\n\")\n\n\n    # If the argument provided at commandline \"--show_plots\" evaluates as true,\n    # plot all figures\n    if show_plots:\n        plt.show()\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def findTrueValues(guidCmdData, module):\n\n    omegaMax = module.omega_max\n    sigma = np.asarray(guidCmdData.sigma_BR)\n    K1 = np.asarray(module.K1)\n    K3 = np.asarray(module.K3)\n    Bmat = RigidBodyKinematics.BmatMRP(sigma)\n    omegaAst = []#np.asarray([0, 0, 0])\n    omegaAst_P = []\n\n    for i in range(len(sigma)):\n        steerRate = -1*(2*omegaMax/np.pi)*np.arctan((K1*sigma[i]+K3*sigma[i]*sigma[i]*sigma[i])*np.pi/(2*omegaMax))\n        omegaAst.append(steerRate)\n    #print omegaAst\n\n\n    if 1:#module.ignoreOuterLoopFeedforward: #should be \"if not\"\n        sigmaP = 0.25*Bmat.dot(omegaAst)\n        for i in range(len(sigma)):\n            omegaAstRate = (K1+3*K3*sigma[i]**2)/(1+((K1*sigma[i]+K3*sigma[i]**3)**2)*(np.pi/(2*omegaMax))**2)*sigmaP[i]\n            omegaAst_P.append(-omegaAstRate)\n    else:\n        omegaAst_P = np.asarray([0, 0, 0])\n\n    return omegaAst, omegaAst_P",
  "def findTrueTorques(module,servo, guidCmdData,rwSpeedMessage,vehicleConfigOut, rwAvailMsg):\n    Lr = []\n\n    #Read in variables\n    numRW = servo.rwConfigParams.numRW\n    L = np.asarray(servo.knownTorquePntB_B)\n    steps = [0, 0, .5, 0, .5]\n    omega_BR_B = np.asarray(guidCmdData.omega_BR_B)\n    omega_RN_B = np.asarray(guidCmdData.omega_RN_B)\n    omega_BN_B = omega_BR_B + omega_RN_B #find body rate\n    domega_RN_B = np.asarray(guidCmdData.domega_RN_B)\n\n\n    omega_BastR_B, omegap_BastR_B = findTrueValues(guidCmdData, module)\n\n    omega_BastN_B = omega_BastR_B+omega_RN_B\n    omega_BBast_B = omega_BN_B - omega_BastN_B\n\n    Isc = np.asarray(vehicleConfigOut.ISCPntB_B)\n    Isc = np.reshape(Isc, (3, 3))\n    Ki = servo.Ki\n    P = servo.P\n    jsVec = servo.rwConfigParams.JsList[0:numRW]\n    #GsMatrix_B_array = np.asarray(GsMatrix)\n    GsMatrix = (servo.rwConfigParams.GsMatrix_B)\n    GsMatrix_B_array = np.reshape(GsMatrix[0:numRW * 3], (numRW, 3))\n\n    #Compute toruqes\n    for i in range(len(steps)):\n        dt = steps[i]\n        if dt == 0:\n            zVec = np.asarray([0, 0, 0])\n\n        #evaluate integral term\n        if Ki > 0 and abs(servo.integralLimit) > 0: #if integral feedback is on\n            zVec = dt * omega_BBast_B + zVec  # z = integral(del_omega)\n            # Make sure each component is less than the integral limit\n            for i in range(3):\n                if zVec[i] > servo.integralLimit:\n                        zVec[i] = zVec[i]/abs(zVec[i])*servo.integralLimit\n\n        else: #integral gain turned off/negative setting\n            zVec = np.asarray([0, 0, 0])\n\n        #compute torque Lr\n        Lr0 = Ki * zVec  # +K*sigmaBR\n        Lr1 = Lr0 + P * omega_BBast_B  # +P*deltaOmega\n\n        GsHs = np.array([0,0,0])\n\n        if numRW > 0:\n            for i in range(numRW):\n                if rwAvailMsg[0][i] == 0:  # Make RW availability check\n                    GsHs = GsHs + np.dot(GsMatrix_B_array[i, :], jsVec[i]*(np.dot(omega_BN_B, GsMatrix_B_array[i, :]) + rwSpeedMessage.wheelSpeeds[i]))\n                    # J_s*(dot(omegaBN_B,Gs_vec)+Omega_wheel)\n\n        Lr2 = Lr1 - np.cross(omega_BastN_B, (Isc.dot(omega_BN_B)+GsHs))  #  - omega_BastN x ([I]omega + [Gs]h_s)\n\n        Lr3 = Lr2 - Isc.dot(omegap_BastR_B + domega_RN_B - np.cross(omega_BN_B, omega_RN_B))\n        # - [I](d(omega_B^ast/R)/dt + d(omega_r)/dt - omega x omega_r)\n        Lr4 = Lr3 + L\n        Lr4 = -Lr4\n        Lr.append(np.ndarray.tolist(Lr4))\n    return Lr",
  "def writeMsgInWheelConfiguration():\n        rwConfigParams = messaging.RWArrayConfigMsgPayload()\n        rwConfigParams.GsMatrix_B = [\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0,\n            0.5773502691896258, 0.5773502691896258, 0.5773502691896258\n        ]\n        rwConfigParams.JsList = [0.1, 0.1, 0.1, 0.1]\n        rwConfigParams.numRW = 4\n        msg = messaging.RWArrayConfigMsg().write(rwConfigParams)\n        jsList = rwConfigParams.JsList\n        GsMatrix_B = rwConfigParams.GsMatrix_B\n        return jsList, GsMatrix_B, msg",
  "def test_mrp_steering_tracking(show_plots, K1, K3, omegaMax):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test  compares the computed :math:`\\pmb\\omega_{\\mathcal{B}^{\\ast}/\\mathcal{R}}` and\n    :math:`\\pmb\\omega_{\\mathcal{B}^{\\ast}/\\mathcal{R}}'` to truth values computed in the python unit test.\n\n    **Test Parameters**\n\n    This test checks a set of gains ``K1``, ``K3`` and ``omegaMax`` on a rigid body with no external\n    torques, and with a fixed input reference attitude message. The commanded rate solution\n    is evaluated against python computed values at 0s, 0.5s and 1s to within a tolerance of :math:`10^{-12}`.\n\n    :param show_plots: flag indicating if plots should be shown.\n    :param K1: The control gain :math:`K_1`\n    :param K3: The control gain :math:`K_3`\n    :param omegaMax: The control gain :math:`\\omega_{\\text{max}}`\n    :return: void\n\n    \"\"\"\n    [testResults, testMessage] = mrp_steering_tracking(show_plots, K1, K3, omegaMax)\n    assert testResults < 1, testMessage",
  "def mrp_steering_tracking(show_plots, K1, K3, omegaMax):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = mrpSteering.mrpSteering()\n    module.ModelTag = \"mrpSteering\"\n\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.K1 = K1\n    module.K3 = K3\n    module.omega_max = omegaMax\n\n    #   Create input message and size it because the regular creator of that message\n    #   is not part of the test.\n    guidCmdData = messaging.AttGuidMsgPayload()  # Create a structure for the input message\n    sigma_BR = np.array([0.3, -0.5, 0.7])\n    guidCmdData.sigma_BR = sigma_BR\n    omega_BR_B = np.array([0.010, -0.020, 0.015])\n    guidCmdData.omega_BR_B = omega_BR_B\n    omega_RN_B = np.array([-0.02, -0.01, 0.005])\n    guidCmdData.omega_RN_B = omega_RN_B\n    domega_RN_B = np.array([0.0002, 0.0003, 0.0001])\n    guidCmdData.domega_RN_B = domega_RN_B\n    guidInMsg = messaging.AttGuidMsg().write(guidCmdData)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.rateCmdOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.guidInMsg.subscribeTo(guidInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Step the simulation to 3*process rate so 4 total steps including zero\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # Compute truth states\n    omegaAstTrue, omegaAstPTrue = findTrueValues(guidCmdData, module)\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0, len(omegaAstTrue)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.omega_BastR_B[i], omegaAstTrue[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omega_BastR_B unit test at t=\"\n                                + str(dataLog.times()[i] * macros.NANO2SEC) + \"sec \\n\")\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0, len(omegaAstPTrue)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.omegap_BastR_B[i], omegaAstPTrue[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed omegap_BastR_B unit test at t=\"\n                                + str(dataLog.times()[i] * macros.NANO2SEC) + \"sec \\n\")\n\n    # If the argument provided at commandline \"--show_plots\" evaluates as true,\n    # plot all figures\n    if show_plots:\n        plt.show()\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def findTrueValues(guidCmdData, module):\n\n    omegaMax = module.omega_max\n    sigma = np.asarray(guidCmdData.sigma_BR)\n    K1 = np.asarray(module.K1)\n    K3 = np.asarray(module.K3)\n    Bmat = RigidBodyKinematics.BmatMRP(sigma)\n    omegaAst = []   #np.asarray([0, 0, 0])\n    omegaAst_P = []\n\n    for i in range(len(sigma)):\n        steerRate = -1*(2*omegaMax/np.pi)*np.arctan((K1*sigma[i]+K3*sigma[i]*sigma[i]*sigma[i])*np.pi/(2*omegaMax))\n        omegaAst.append(steerRate)\n\n\n    if 1:   #module.ignoreOuterLoopFeedforward: #should be \"if not\"\n        sigmaP = 0.25*Bmat.dot(omegaAst)\n        for i in range(len(sigma)):\n            omegaAstRate = (K1+3*K3*sigma[i]**2)/(1+((K1*sigma[i]+K3*sigma[i]**3)**2)*(np.pi/(2*omegaMax))**2)*sigmaP[i]\n            omegaAst_P.append(-omegaAstRate)\n    else:\n        omegaAst_P = np.asarray([0, 0, 0])\n\n    omegaAst = [omegaAst, omegaAst, omegaAst]\n    omegaAst_P = [omegaAst_P, omegaAst_P, omegaAst_P]\n\n    return omegaAst, omegaAst_P",
  "def test_thrMomentumManagement(show_plots, hsMinCheck):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = thrMomentumManagementTestFunction(show_plots, hsMinCheck)\n    assert testResults < 1, testMessage",
  "def thrMomentumManagementTestFunction(show_plots, hsMinCheck):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    # Construct algorithm and associated C++ container\n    module = thrMomentumManagement.thrMomentumManagement()\n    module.ModelTag = \"thrMomentumManagement\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    if hsMinCheck:\n        module.hs_min = 1000./6000.*100.               # Nms\n    else:\n        module.hs_min = 100./6000.*100.               # Nms\n\n\n    # wheelSpeeds Message\n    rwSpeedMessage = messaging.RWSpeedMsgPayload()\n    rwSpeedMessage.wheelSpeeds = [10.0, -25.0, 50.0, 100.]\n    rwSpeedInMsg = messaging.RWSpeedMsg().write(rwSpeedMessage)\n\n\n    # wheelConfigData Message\n    fswSetupRW.clearSetup()\n    Js = 0.1\n    fswSetupRW.create([1.0, 0.0, 0.0], Js)\n    fswSetupRW.create([0.0, 1.0, 0.0], Js)\n    fswSetupRW.create([0.0, 0.0, 1.0], Js)\n    fswSetupRW.create([0.5773502691896258, 0.5773502691896258, 0.5773502691896258], Js)\n    rwConfigInMsg = fswSetupRW.writeConfigMessage()\n\n\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.deltaHOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # setup message connections\n    module.rwSpeedsInMsg.subscribeTo(rwSpeedInMsg)\n    module.rwConfigDataInMsg.subscribeTo(rwConfigInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.5))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # set the filtered output truth states\n    if hsMinCheck == 1:\n        trueVector = [\n                   [0.0, 0.0, 0.0]\n                   ]*2\n    else:\n        trueVector = [\n                   [-5.914369484146579, -2.858300248464629, -9.407020039211664]\n                   ]*2\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, dataLog.torqueRequestBody, accuracy,\n                                                               \"torqueRequestBody\", testFailCount, testMessages)\n\n    snippetName = \"passFail\" + str(hsMinCheck)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippetName, passedText, path)\n\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_lowPassFilterControlTorque(show_plots):     # update \"subModule\" in this function name to reflect the module name\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = subModuleTestFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def subModuleTestFunction(show_plots):\n    #   zero all unit test result gather variables\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n                                                        # this create a fresh and consistent simulation environment for each test run\n\n    #   Create test thread\n    testProcessRate = macros.sec2nano(0.5)         # process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    #   Construct algorithm and associated C++ container\n    module = lowPassFilterTorqueCommand.lowPassFilterTorqueCommand()\n    module.ModelTag = \"lowPassFilterTorqueCommand\"      # python name of test module.\n\n    #   Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    #   Initialize the test module configuration data\n    module.wc = 0.1*math.pi*2                 #   [rad/s] continous time critical filter frequency\n    module.h = 0.5                            #   [s]     filter time step\n    module.reset = 1                          #           flag to initialize module states on first run\n\n\n    #   Create input message and size it because the regular creator of that message\n    #   is not part of the test.\n    inputMessageData = messaging.CmdTorqueBodyMsgPayload()\n    inputMessageData.torqueRequestBody = [1.0, -0.5, 0.7]\n    inMsg = messaging.CmdTorqueBodyMsg().write(inputMessageData)\n\n    # setup msg connection\n    module.cmdTorqueInMsg.subscribeTo(inMsg)\n\n    #   Setup logging on the test module output message so that we get all the writes to it\n    outLog = module.cmdTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, outLog)\n\n    #   Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    #   Step the simulation to 3*process rate so 4 total steps including zero\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))    # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    module.Reset(1)     # this module reset function needs a time input (in NanoSeconds)\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    LrF = outLog.torqueRequestBody\n\n    #   set the filtered output truth states\n    LrFtrue = [\n               [0.2734574719946391,-0.1367287359973196,0.1914202303962474],\n               [0.4721359549995794,-0.2360679774997897,0.3304951684997055],\n               [0.6164843223022588,-0.3082421611511294,0.4315390256115811],\n               [0.2734574719946391,-0.1367287359973196,0.1914202303962474],\n               [0.4721359549995794,-0.2360679774997897,0.3304951684997055],\n               ]\n\n    #   compare the module and truth results\n    for i in range(0,len(LrFtrue)):\n        if not unitTestSupport.isArrayEqual(LrF[i], LrFtrue[i], 3, 1e-12):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed LrFtrue unit test at t=\" + str(LrF[i,0]*unitTestSupport.NANO2SEC) + \"sec\\n\")\n\n\n\n    # If the argument provided at commandline \"--show_plots\" evaluates as true,\n    # plot all figures\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_mtbMomentumManagement():     # update \"module\" in this function name to reflect the module name\n    r\"\"\"\n    **Validation Test Description**\n\n    This script tests that the module returns expected non-zero and zero \n    outputs.\n\n    **Description of Variables Being Tested**\n\n    The variables being checked are:\n    variables\n\n    - ``mtbDipoleCmds[MAX_EFF_CNT]``\n    - ``motorTorque[MAX_EFF_CNT]``\n    \"\"\"\n    # each test method requires a single assert method to be called\n    # pass on the testPlotFixture so that the main test function may set the DataStore attributes\n    [testResults, testMessage] = mtbMomentumManagementModuleTestFunction()\n    assert testResults < 1, testMessage",
  "def mtbMomentumManagementModuleTestFunction():\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.01)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = mtbMomentumManagement.mtbMomentumManagement()\n    module.cGain = 0.005\n    module.wheelSpeedBiases = [0., 0., 0, 0.]\n    module.ModelTag = \"mtbMomentumManagement\"           # update python name of test module\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # wheelConfigData message (array is ordered c11, c22, c33, c44, ...)\n    rwConfigParams = messaging.RWArrayConfigMsgPayload()\n    beta = 45. * np.pi / 180.\n    rwConfigParams.GsMatrix_B = [0., np.cos(beta), np.sin(beta), 0., np.sin(beta), -np.cos(beta), np.cos(beta), -np.sin(beta), 0., -np.cos(beta), -np.sin(beta), 0.]\n    rwConfigParams.JsList = [0.002, 0.002, 0.002, 0.002]\n    rwConfigParams.numRW = 4\n    rwParamsInMsg = messaging.RWArrayConfigMsg().write(rwConfigParams)\n    \n    # mtbConfigData message (array is ordered c11, c22, c33, c44, ...)\n    mtbConfigParams = messaging.MTBArrayConfigMsgPayload()\n    mtbConfigParams.numMTB = 3\n    # row major toque bar alignments\n    mtbConfigParams.GtMatrix_B = [\n        1., 0., 0.,\n        0., 1., 0.,\n        0., 0., 1.\n    ]\n    mtbConfigParams.maxMtbDipoles = [10.]*mtbConfigParams.numMTB\n    mtbParamsInMsg = messaging.MTBArrayConfigMsg().write(mtbConfigParams)\n    \n    # TAMSensorBodyMsg message (leads to non-invertible matrix)\n    tamSensorBodyInMsgContainer = messaging.TAMSensorBodyMsgPayload()\n    tamSensorBodyInMsgContainer.tam_B = [ 5E3 * 0.03782347,  5E3 * 0.49170516, 5E3 * -0.8699399]\n    tamSensorBodyInMsg = messaging.TAMSensorBodyMsg().write(tamSensorBodyInMsgContainer)\n    \n    # rwSpeeds message\n    rwSpeedsInMsgContainer = messaging.RWSpeedMsgPayload()\n    rwSpeedsInMsgContainer.wheelSpeeds = [100., 200., 300., 400.]\n    rwSpeedsInMsg = messaging.RWSpeedMsg().write(rwSpeedsInMsgContainer)\n\n    # attControl message\n    rwMotorTorqueInMsgContainer = messaging.ArrayMotorTorqueMsgPayload()\n    rwMotorTorqueInMsgContainer.motorTorque = [0., 0., 0., 0.]\n    rwMotorTorqueInMsg = messaging.ArrayMotorTorqueMsg().write(rwMotorTorqueInMsgContainer)\n    \n    # Setup logging on the test module output message so that we get all the writes to it\n    resultMtbCmdOutMsg = module.mtbCmdOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, resultMtbCmdOutMsg)\n    resultRwMotorTorqueOutMsg = module.rwMotorTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, resultRwMotorTorqueOutMsg)\n\n    # connect the message interfaces\n    module.rwParamsInMsg.subscribeTo(rwParamsInMsg)\n    module.mtbParamsInMsg.subscribeTo(mtbParamsInMsg)\n    module.tamSensorBodyInMsg.subscribeTo(tamSensorBodyInMsg)\n    module.rwSpeedsInMsg.subscribeTo(rwSpeedsInMsg)\n    module.rwMotorTorqueInMsg.subscribeTo(rwMotorTorqueInMsg)\n    \n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.0))        # seconds to stop simulation\n    accuracy = 1E-8\n    \n    \n    '''\n        TEST 0: \n            Check that mtbDipoleCmds and are non-zero.\n    '''\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ExecuteSimulation()\n    \n    testFailCount, testMessages = unitTestSupport.compareVector([0., 0., 0.],\n                                                                resultMtbCmdOutMsg.mtbDipoleCmds[0][0:3],\n                                                                accuracy,\n                                                                \"tauMtbRequestOutMsg\",\n                                                                testFailCount, testMessages, ExpectedResult=0)\n    \n    testFailCount, testMessages = unitTestSupport.compareVector([0., 0., 0., 0.],\n                                                                resultRwMotorTorqueOutMsg.motorTorque[0][0:4],\n                                                                accuracy,\n                                                                \"rwMotorTorqueOutMsg\",\n                                                                testFailCount, testMessages, ExpectedResult=0)  \n    '''\n\n        TEST 1: \n            Check that the mtbDipoleCmds are zero and that the resulting\n            torque on the body is zero when the b field is zero.\n    '''\n    tamSensorBodyInMsgContainer.tam_B = [0., 0., 0.]\n    tamSensorBodyInMsg = messaging.TAMSensorBodyMsg().write(tamSensorBodyInMsgContainer)\n    module.tamSensorBodyInMsg.subscribeTo(tamSensorBodyInMsg)\n    \n    unitTestSim.InitializeSimulation()\n    unitTestSim.ExecuteSimulation()\n\n    testFailCount, testMessages = unitTestSupport.compareVector([0., 0., 0.],\n                                                                resultMtbCmdOutMsg.mtbDipoleCmds[0][0:3],\n                                                                accuracy,\n                                                                \"tauMtbRequestOutMsg\",\n                                                                testFailCount, testMessages, ExpectedResult=1)\n    \n    Gs = np.array(rwConfigParams.GsMatrix_B[0:12]).reshape(4, 3).T\n    tauBody = Gs @ np.array(resultRwMotorTorqueOutMsg.motorTorque[0][0:4])\n    testFailCount, testMessages = unitTestSupport.compareVector([0., 0., 0.],\n                                                                tauBody,\n                                                                accuracy,\n                                                                \"rwMotorTorqueOutMsg\",\n                                                                testFailCount, testMessages, ExpectedResult=1)  \n\n\n    # reset the module to test this functionality\n    module.Reset(0)     # this module reset function needs a time input (in NanoSeconds)\n\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    print(\"fail count\", testFailCount)\n    return [testFailCount, ''.join(testMessages)]",
  "def test_mtbFeedforward_module():     # update \"module\" in this function name to reflect the module name\n    r\"\"\"\n    **Validation Test Description**\n\n    This script tests that the torqueRequestBody vector is computed as \n    expected and that the algorithm doesn't fail when given inputs with a \n    value of zero.\n\n    **Description of Variables Being Tested**\n\n    In this file we are checking the values of the output message variable:\n\n    - ``torqueRequestBody``\n    \"\"\"\n    # each test method requires a single assert method to be called\n    # pass on the testPlotFixture so that the main test function may set the DataStore attributes\n    [testResults, testMessage] = mtbFeedforwardModuleTestFunction()\n    assert testResults < 1, testMessage",
  "def mtbFeedforwardModuleTestFunction():\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.01)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Initialize module under test's config message and add module to runtime call list\n    module = mtbFeedforward.mtbFeedforward()\n    module.ModelTag = \"mrpFeedback\"           # update python name of test module\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    \n    # Initialize CmdTorqueBodyMsg\n    vehControlInMsgContainer = messaging.CmdTorqueBodyMsgPayload()\n    vehControlInMsgContainer.torqueRequestBody = [0., 0., 0.]\n    vehControlInMsg = messaging.CmdTorqueBodyMsg().write(vehControlInMsgContainer)\n    \n    # Initialize DipoleRequestBodyMsg\n    dipoleRequestMtbInMsgContainer = messaging.MTBCmdMsgPayload()\n    dipoleRequestMtbInMsgContainer.mtbDipoleCmds = [1., 2., 3.]\n    dipoleRequestMtbInMsg = messaging.MTBCmdMsg().write(dipoleRequestMtbInMsgContainer) \n    \n    # Initialize TAMSensorBodyMsg\n    tamSensorBodyInMsgContainer = messaging.TAMSensorBodyMsgPayload()\n    tamSensorBodyInMsgContainer.tam_B = [ 1E-5, -3E-5, 5E-5]\n    tamSensorBodyInMsg = messaging.TAMSensorBodyMsg().write(tamSensorBodyInMsgContainer)\n\n    # Initialize MTBArrayConfigMsg\n    mtbArrayConfigParamsInMsgContainer = messaging.MTBArrayConfigMsgPayload()\n    mtbArrayConfigParamsInMsgContainer.numMTB = 3\n    mtbArrayConfigParamsInMsgContainer.maxMtbDipoles = [1E3, 1E3, 1E3]\n    mtbArrayConfigParamsInMsgContainer.GtMatrix_B = [1., 0., 0., 0., 1., 0., 0., 0., 1.]  \n    mtbArrayConfigParamsInMsg = messaging.MTBArrayConfigMsg().write(mtbArrayConfigParamsInMsgContainer)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    resultVehControlOutMsg = module.vehControlOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, resultVehControlOutMsg)\n    \n    # connect the message interfaces\n    module.vehControlInMsg.subscribeTo(vehControlInMsg)\n    module.dipoleRequestMtbInMsg.subscribeTo(dipoleRequestMtbInMsg)\n    module.tamSensorBodyInMsg.subscribeTo(tamSensorBodyInMsg)\n    module.mtbArrayConfigParamsInMsg.subscribeTo(mtbArrayConfigParamsInMsg)\n    \n    # Set the simulation time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.0))        # seconds to stop simulation\n    unitTestSim.InitializeSimulation()\n\n    '''\n        TEST 1: \n            Check that dipoles are non-zero expected value.\n    '''\n    unitTestSim.ExecuteSimulation()\n    m = np.array(dipoleRequestMtbInMsgContainer.mtbDipoleCmds[0:3])\n    b = np.array(tamSensorBodyInMsgContainer.tam_B)\n    expectedTorque = -np.cross(m, b)    \n    testFailCount, testMessages = unitTestSupport.compareVector(expectedTorque,\n                                                                resultVehControlOutMsg.torqueRequestBody[0],\n                                                                accuracy,\n                                                                \"torqueRequestBody\",\n                                                                testFailCount, testMessages)                        \n    \n    '''\n        TEST 2: \n            Check that torqueRequestBody is zero when b field is zero.\n    '''\n    tamSensorBodyInMsgContainer.tam_B = [0., 0., 0.]\n    tamSensorBodyInMsg = messaging.TAMSensorBodyMsg().write(tamSensorBodyInMsgContainer)\n    module.tamSensorBodyInMsg.subscribeTo(tamSensorBodyInMsg)\n    \n    unitTestSim.InitializeSimulation()\n    unitTestSim.ExecuteSimulation()\n    expectedTorque = [0., 0., 0.]   \n    testFailCount, testMessages = unitTestSupport.compareVector(expectedTorque,\n                                                                resultVehControlOutMsg.torqueRequestBody[0],\n                                                                accuracy,\n                                                                \"torqueRequestBody\",\n                                                                testFailCount, testMessages)\n    \n    '''\n        TEST 3: \n            Check that torqueRequestBody is zero when dipoles are zero.\n    '''\n    tamSensorBodyInMsgContainer.tam_B = [1E-5, -3E-5, 5E-5]\n    tamSensorBodyInMsg = messaging.TAMSensorBodyMsg().write(tamSensorBodyInMsgContainer)\n    module.tamSensorBodyInMsg.subscribeTo(tamSensorBodyInMsg)\n    \n    dipoleRequestMtbInMsgContainer.mtbDipoleCmds = [0., 0., 0.]\n    dipoleRequestMtbInMsg = messaging.MTBCmdMsg().write(dipoleRequestMtbInMsgContainer) \n    module.dipoleRequestMtbInMsg.subscribeTo(dipoleRequestMtbInMsg)\n    \n    unitTestSim.InitializeSimulation()\n    unitTestSim.ExecuteSimulation()\n    expectedTorque = [0., 0., 0.]   \n    testFailCount, testMessages = unitTestSupport.compareVector(expectedTorque,\n                                                                resultVehControlOutMsg.torqueRequestBody[0],\n                                                                accuracy,\n                                                                \"torqueRequestBody\",\n                                                                testFailCount, testMessages)\n    \n    '''\n        TEST 4: \n            Check that torqueRequestBody is non-zero expected value with \n            non-trivial Gt matrix.\n    '''\n    dipoleRequestMtbInMsgContainer.mtbDipoleCmds = [7., -3.]\n    dipoleRequestMtbInMsg = messaging.MTBCmdMsg().write(dipoleRequestMtbInMsgContainer) \n    module.dipoleRequestMtbInMsg.subscribeTo(dipoleRequestMtbInMsg)\n    \n    beta = 45. * np.pi / 180.\n    Gt = np.array([[np.cos(beta), -np.sin(beta)],[np.sin(beta),  np.cos(beta)], [0., 0.]])\n    mtbArrayConfigParamsInMsgContainer.numMTB = 2\n    mtbArrayConfigParamsInMsgContainer.GtMatrix_B = [Gt[0, 0], Gt[0, 1], \n                                                     Gt[1, 0], Gt[1, 1],\n                                                     Gt[2, 0], Gt[2, 1]]  \n    mtbArrayConfigParamsInMsg = messaging.MTBArrayConfigMsg().write(mtbArrayConfigParamsInMsgContainer)\n    module.mtbArrayConfigParamsInMsg.subscribeTo(mtbArrayConfigParamsInMsg)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ExecuteSimulation()\n    m = Gt @ np.array(dipoleRequestMtbInMsgContainer.mtbDipoleCmds[0:2])\n    b = np.array(tamSensorBodyInMsgContainer.tam_B)\n    expectedTorque = -np.cross(m, b) \n    testFailCount, testMessages = unitTestSupport.compareVector(expectedTorque,\n                                                                resultVehControlOutMsg.torqueRequestBody[0],\n                                                                accuracy,\n                                                                \"torqueRequestBody\",\n                                                                testFailCount, testMessages)\n    \n    print(\"Accuracy used: \" + str(accuracy))\n    if testFailCount == 0:\n        print(\"PASSED: mtbFeedforward unit test\")\n    else:\n        print(\"Failed: mtbFeedforward unit test\")\n    return [testFailCount, ''.join(testMessages)]",
  "def test_prvSteering(show_plots, simCase):     # update \"subModule\" in this function name to reflect the module name\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = subModuleTestFunction(show_plots, simCase)\n    assert testResults < 1, testMessage",
  "def subModuleTestFunction(show_plots, simCase):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    #   Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    #   Construct algorithm and associated C++ container\n    module = prvSteering.prvSteering()\n    module.ModelTag = \"prvSteering\"\n\n    servo = rateServoFullNonlinear.rateServoFullNonlinear()\n    servo.ModelTag = \"rate_servo\"\n\n    #   Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n    unitTestSim.AddModelToTask(unitTaskName, servo)\n\n    # configure BSK modules\n    module.K1 = 0.15\n    module.K3 = 1.0\n    module.omega_max = 1.5*macros.D2R\n    servo.Ki = 0.01\n    servo.P = 150.0\n    servo.integralLimit = 2./servo.Ki * 0.1\n    servo.knownTorquePntB_B = [0., 0., 0.]\n\n\n    #   Create input message and size it because the regular creator of that message\n    #   is not part of the test.\n\n    #   attGuidOut Message:\n    guidCmdData = messaging.AttGuidMsgPayload()  # Create a structure for the input message\n\n    sigma_BR = []\n    if simCase == 0:\n        sigma_BR = np.array([0.3, -0.5, 0.7])\n    if simCase == 1:\n        sigma_BR = np.array([0, 0, 0])\n    guidCmdData.sigma_BR = sigma_BR\n\n    omega_BR_B = np.array([0.010, -0.020, 0.015])\n    guidCmdData.omega_BR_B = omega_BR_B\n    omega_RN_B = np.array([-0.02, -0.01, 0.005])\n    guidCmdData.omega_RN_B = omega_RN_B\n    domega_RN_B = np.array([0.0002, 0.0003, 0.0001])\n    guidCmdData.domega_RN_B = domega_RN_B\n    guidInMsg = messaging.AttGuidMsg().write(guidCmdData)\n\n    # vehicleConfigData Message:\n    vehicleConfigOut = messaging.VehicleConfigMsgPayload()\n    I = [1000., 0., 0.,\n         0., 800., 0.,\n         0., 0., 800.]\n    vehicleConfigOut.ISCPntB_B = I\n    vcInMsg = messaging.VehicleConfigMsg().write(vehicleConfigOut)\n\n    # wheelSpeeds Message\n    rwSpeedMessage = messaging.RWSpeedMsgPayload()\n    Omega = [10.0, 25.0, 50.0, 100.0]\n    rwSpeedMessage.wheelSpeeds = Omega\n    rwSpeedInMsg = messaging.RWSpeedMsg().write(rwSpeedMessage)\n\n    # wheelConfigData message\n    def writeMsgInWheelConfiguration():\n        rwConfigParams = messaging.RWArrayConfigMsgPayload()\n        rwConfigParams.GsMatrix_B = [\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0\n        ]\n        rwConfigParams.JsList = [0.1, 0.1, 0.1, 0.1]\n        rwConfigParams.numRW = 4\n        rwParamInMsg = messaging.RWArrayConfigMsg().write(rwConfigParams)\n        return rwParamInMsg\n\n    rwParamInMsg = writeMsgInWheelConfiguration()\n\n    # wheelAvailability message\n    def writeMsgInWheelAvailability():\n        rwAvailabilityMessage = messaging.RWAvailabilityMsgPayload()\n        avail = [messaging.AVAILABLE, messaging.AVAILABLE, messaging.AVAILABLE, messaging.AVAILABLE]\n        rwAvailabilityMessage.wheelAvailability = avail\n        rwAvailInMsg = messaging.RWAvailabilityMsg().write(rwAvailabilityMessage)\n        return rwAvailInMsg\n\n    rwAvailInMsg = writeMsgInWheelAvailability()\n\n\n    #   Setup logging on the test module output message so that we get all the writes to it\n    dataLog = servo.cmdTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    #   connect input and output messages\n    module.guidInMsg.subscribeTo(guidInMsg)\n    servo.vehConfigInMsg.subscribeTo(vcInMsg)\n    servo.guidInMsg.subscribeTo(guidInMsg)\n    servo.rwParamsInMsg.subscribeTo(rwParamInMsg)\n    servo.rwAvailInMsg.subscribeTo(rwAvailInMsg)\n    servo.rwSpeedsInMsg.subscribeTo(rwSpeedInMsg)\n    servo.rateSteeringInMsg.subscribeTo(module.rateCmdOutMsg)\n\n    #   Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    #   Step the simulation to 3*process rate so 4 total steps including zero\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    servo.Reset(1)     # this module reset function needs a time input (in NanoSeconds)\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # set the filtered output truth states\n    trueVector = []\n    if simCase == 0:\n        trueVector = [\n                   [-2.9352922876097969, +6.2831737715827778, -4.0554726129822907]\n                  ,[-2.9352922876097969, +6.2831737715827778, -4.0554726129822907]\n                  ,[-2.9353853745179044, +6.2833455830962901, -4.0556481491012084]\n                  ,[-2.9352922876097969, +6.2831737715827778, -4.0554726129822907]\n                  ,[-2.9353853745179044, +6.2833455830962901, -4.0556481491012084]\n                   ]\n    if simCase == 1:\n        trueVector = [\n                     [-1.39,      3.79,     -1.39]\n                    ,[-1.39,      3.79,     -1.39]\n                    ,[-1.39005,   3.7901,   -1.390075]\n                    ,[-1.39,      3.79,     -1.39]\n                    ,[-1.39005,   3.7901,   -1.390075]\n                     ]\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    for i in range(0,len(trueVector)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.torqueRequestBody[i], trueVector[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed torqueRequestBody unit test at t=\"\n                                + str(dataLog.times()[i]*macros.NANO2SEC) + \"sec\\n\")\n\n\n\n\n\n\n\n    # If the argument provided at commandline \"--show_plots\" evaluates as true,\n    # plot all figures\n    if show_plots:\n          plt.show()\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def writeMsgInWheelConfiguration():\n        rwConfigParams = messaging.RWArrayConfigMsgPayload()\n        rwConfigParams.GsMatrix_B = [\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0,\n            0.0, 0.0, 0.0\n        ]\n        rwConfigParams.JsList = [0.1, 0.1, 0.1, 0.1]\n        rwConfigParams.numRW = 4\n        rwParamInMsg = messaging.RWArrayConfigMsg().write(rwConfigParams)\n        return rwParamInMsg",
  "def writeMsgInWheelAvailability():\n        rwAvailabilityMessage = messaging.RWAvailabilityMsgPayload()\n        avail = [messaging.AVAILABLE, messaging.AVAILABLE, messaging.AVAILABLE, messaging.AVAILABLE]\n        rwAvailabilityMessage.wheelAvailability = avail\n        rwAvailInMsg = messaging.RWAvailabilityMsg().write(rwAvailabilityMessage)\n        return rwAvailInMsg",
  "def test_mtbMomentumManagementSimple():     # update \"module\" in this function name to reflect the module name\n    r\"\"\"\n    **Validation Test Description**\n\n    This script tests that the module returns expected non-zero and zero \n    outputs.\n\n    **Description of Variables Being Tested**\n\n    The output torque message is being recorded and the following variable is being checked.\n\n    - ``torqueRequestBody``\n    \"\"\"\n    # each test method requires a single assert method to be called\n    # pass on the testPlotFixture so that the main test function may set the DataStore attributes\n    [testResults, testMessage] = mtbMomentumManagementSimpleTestFunction()\n    assert testResults < 1, testMessage",
  "def mtbMomentumManagementSimpleTestFunction():\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.01)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = mtbMomentumManagementSimple.mtbMomentumManagementSimple()\n    module.Kp = 0.003\n    module.ModelTag = \"mtbMomentumManagementSimple\"           # update python name of test module\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # wheelConfigData message (column major format)\n    rwConfigParams = messaging.RWArrayConfigMsgPayload()\n    beta = 45. * np.pi / 180.\n    rwConfigParams.GsMatrix_B = [0., np.cos(beta), np.sin(beta), 0., np.sin(beta), -np.cos(beta), np.cos(beta), -np.sin(beta), 0., -np.cos(beta), -np.sin(beta), 0.]\n    rwConfigParams.JsList = [0.002, 0.002, 0.002, 0.002]\n    rwConfigParams.numRW = 4\n    rwParamsInMsg = messaging.RWArrayConfigMsg().write(rwConfigParams)\n    \n    # rwSpeeds message\n    rwSpeedsInMsgContainer = messaging.RWSpeedMsgPayload()\n    rwSpeedsInMsgContainer.wheelSpeeds = [100., 200., 300., 400.]\n    rwSpeedsInMsg = messaging.RWSpeedMsg().write(rwSpeedsInMsgContainer)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    resultTauMtbRequestOutMsg = module.tauMtbRequestOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, resultTauMtbRequestOutMsg)\n\n    # connect the message interfaces\n    module.rwParamsInMsg.subscribeTo(rwParamsInMsg)\n    module.rwSpeedsInMsg.subscribeTo(rwSpeedsInMsg)\n    \n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(0.0))        # seconds to stop simulation\n    accuracy = 1E-8\n\n    '''\n        TEST 1: \n            Check that tauMtbRequestOutMsg is non-zero when the wheel speeds\n            are non-zero.\n    '''\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ExecuteSimulation()\n    Gs = np.array([\n            [0.,            0.,             np.cos(beta), -np.cos(beta)],\n            [np.cos(beta),  np.sin(beta),  -np.sin(beta), -np.sin(beta)],\n            [np.sin(beta), -np.cos(beta),   0.,             0.]])\n    wheelSpeeds = np.array(rwSpeedsInMsgContainer.wheelSpeeds[0:4])\n    hWheels_W = wheelSpeeds * rwConfigParams.JsList[0]\n    hWheels_B  = Gs @ hWheels_W\n    tauExpected = - module.Kp * hWheels_B\n    \n    testFailCount, testMessages = unitTestSupport.compareVector(tauExpected,\n                                                            resultTauMtbRequestOutMsg.torqueRequestBody[0][0:3],\n                                                            accuracy,\n                                                            \"tauMtbRequestOutMsg\",\n                                                            testFailCount, testMessages, ExpectedResult=1)\n\n    '''\n        TEST 2: \n            Check that tauMtbRequestOutMsg is the zero vector when the wheels\n            speeds are zero.\n    '''\n    rwSpeedsInMsgContainer.wheelSpeeds = [0., 0., 0., 0.]\n    rwSpeedsInMsg = messaging.RWSpeedMsg().write(rwSpeedsInMsgContainer)\n    module.rwSpeedsInMsg.subscribeTo(rwSpeedsInMsg)\n    \n    unitTestSim.InitializeSimulation()\n    unitTestSim.ExecuteSimulation()\n    \n    testFailCount, testMessages = unitTestSupport.compareVector([0., 0., 0.],\n                                                            resultTauMtbRequestOutMsg.torqueRequestBody[0][0:3],\n                                                            accuracy,\n                                                            \"tauMtbRequestOutMsg\",\n                                                            testFailCount, testMessages, ExpectedResult=1)\n    \n    '''\n        TEST 3: \n            Check that tauMtbRequestOutMsg is the zero vector when the wheels\n            speeds are non-zero and the feedback gain is zero.\n    '''\n    rwSpeedsInMsgContainer.wheelSpeeds = [100., 200., 300., 400.]\n    rwSpeedsInMsg = messaging.RWSpeedMsg().write(rwSpeedsInMsgContainer)\n    module.rwSpeedsInMsg.subscribeTo(rwSpeedsInMsg)\n    \n    module.Kp = 0.\n    \n    unitTestSim.InitializeSimulation()\n    unitTestSim.ExecuteSimulation()\n    \n    testFailCount, testMessages = unitTestSupport.compareVector([0., 0., 0.],\n                                                            resultTauMtbRequestOutMsg.torqueRequestBody[0][0:3],\n                                                            accuracy,\n                                                            \"tauMtbRequestOutMsg\",\n                                                            testFailCount, testMessages, ExpectedResult=1)\n    \n    \n    # reset the module to test this functionality\n    module.Reset(0)     # this module reset function needs a time input (in NanoSeconds)\n\n\n\n    print(\"Accuracy used: \" + str(accuracy))\n    if testFailCount == 0:\n        print(\"PASSED: mtbMomentumManagementSimple unit test\")\n    else:\n        print(\"Failed: mtbMomentumManagementSimple unit test\")\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_MRP_Feedback(show_plots, intGain, rwNum, integralLimit, ctrlLaw, useRwAvailability):\n    r\"\"\"\n        **Validation Test Description**\n\n        The unit test for this module tests a set of gains :math:`K`, :math:`K_i`, :math:`P` on a rigid body\n        with no external torques, and with a fixed input reference attitude message. The torque requested\n        by the controller is evaluated against python computed torques at 0s, 0.5s, 1s, 1.5s and 2s to\n        within a tolerance of :math:`10^{-8}`. After 1s the simulation is stopped and the ``Reset()``\n        function is called to check that integral feedback related variables are properly reset.\n        The following permutations are run:\n\n        - The test is run for a case with error integration feedback (:math:`k_i`=0.01) and one case\n          where :math:`k_i` is set to a negative value, resulting in a case with no integrator.\n        - The RW array number is configured either to 4 or 0\n        - The integral limit term is set to either 0 or 20\n        - The RW availability message is tested in 3 manners.  Either the availability  message is not\n          written where all wheels should default to being available.  If the availability message is\n          written, then the RWs are either zero to available or not available.\n        - The control parameter :math:`\\delta\\omega_{0}` is set to either a zero or non-zero vector\n\n        All permutations of these test cases are expected to pass.\n\n\n        **Test Parameters**\n\n        Args:\n            intGain (float): value of the integral gain :math:`K_i`\n            rwNum (int): number of RW devices to simulate\n            integralLimit (float): value of the integral limit\n            ctrlLaw (int): type of control law used\n            useRwAvailability (string): Flag to not use RW availabillity (``NO``), use the availability\n               message and turn on the RW devices (``ON``) and use the message and turn off the devices (``OFF``)\n    \"\"\"\n\n    # each test method requires a single assert method to be called\n\n    [testResults, testMessage] = run(show_plots,intGain, rwNum, integralLimit, ctrlLaw, useRwAvailability)\n\n    assert testResults < 1, testMessage",
  "def run(show_plots, intGain, rwNum, integralLimit, ctrlLaw, useRwAvailability):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n                                                        # this creates a fresh and consistent simulation environment for each test run\n\n    #   Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n\n    #   Construct algorithm and associated C++ container\n    module = mrpFeedback.mrpFeedback()\n    module.ModelTag = \"mrpFeedback\"\n\n    #   Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    #   Initialize the test module configuration data\n    module.K = 0.15\n    module.Ki = intGain\n    module.P = 150.0\n    module.integralLimit = integralLimit\n    module.controlLawType = ctrlLaw\n    module.knownTorquePntB_B = [1., 1., 1.]\n\n    # create input messages\n    #   AttGuidFswMsg Message:\n    guidCmdData = messaging.AttGuidMsgPayload()\n    sigma_BR = [0.3, -0.5, 0.7]\n    guidCmdData.sigma_BR = sigma_BR\n    omega_BR_B = [0.010, -0.020, 0.015]\n    guidCmdData.omega_BR_B = omega_BR_B\n    omega_RN_B = [-0.02, -0.01, 0.005]\n    guidCmdData.omega_RN_B = omega_RN_B\n    domega_RN_B = [0.0002, 0.0003, 0.0001]\n    guidCmdData.domega_RN_B = domega_RN_B\n    guidInMsg = messaging.AttGuidMsg().write(guidCmdData)\n\n    # vehicleConfigData Message:\n    vehicleConfig = messaging.VehicleConfigMsgPayload()\n    I = [1000., 0., 0.,\n         0., 800., 0.,\n         0., 0., 800.]\n    vehicleConfig.ISCPntB_B = I\n    vcInMsg = messaging.VehicleConfigMsg().write(vehicleConfig)\n\n    # wheelSpeeds Message\n    rwSpeedMessage = messaging.RWSpeedMsgPayload()\n    Omega = [10.0, 25.0, 50.0, 100.0]  # rad/sec\n    rwSpeedMessage.wheelSpeeds = Omega\n    rwSpeedInMsg = messaging.RWSpeedMsg().write(rwSpeedMessage)\n\n    # wheelConfigData message\n    jsList = []\n    GsMatrix_B = []\n    def writeMsgInWheelConfiguration():\n        rwConfigParams = messaging.RWArrayConfigMsgPayload()\n\n        rwConfigParams.GsMatrix_B = [\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0,\n            0.577350269190, 0.577350269190, 0.577350269190\n        ]\n        rwConfigParams.JsList = [0.1, 0.1, 0.1, 0.1]\n        rwConfigParams.numRW = rwNum\n        msg = messaging.RWArrayConfigMsg().write(rwConfigParams)\n        return rwConfigParams.JsList, rwConfigParams.GsMatrix_B, msg\n\n    if rwNum > 0:\n        jsList, GsMatrix_B, rwParamInMsg = writeMsgInWheelConfiguration()\n\n    # wheelAvailability message\n    rwAvailabilityMessage = messaging.RWAvailabilityMsgPayload()\n    if useRwAvailability != \"NO\":\n        if useRwAvailability == \"ON\":\n            rwAvailabilityMessage.wheelAvailability = [messaging.AVAILABLE, messaging.AVAILABLE,\n                                                       messaging.AVAILABLE, messaging.AVAILABLE]\n        elif useRwAvailability == \"OFF\":\n            rwAvailabilityMessage.wheelAvailability = [messaging.UNAVAILABLE, messaging.UNAVAILABLE,\n                                                       messaging.UNAVAILABLE, messaging.UNAVAILABLE]\n        else:\n            print(\"WARNING: unknown rw availability status\")\n        rwAvailInMsg = messaging.RWAvailabilityMsg().write(rwAvailabilityMessage)\n    else:\n        # set default availability\n        rwAvailabilityMessage.wheelAvailability = [messaging.AVAILABLE, messaging.AVAILABLE,\n                                                   messaging.AVAILABLE, messaging.AVAILABLE]\n\n    LrTrue = findTrueTorques(module, guidCmdData, rwSpeedMessage, vehicleConfig, jsList,\n                             rwNum, GsMatrix_B, rwAvailabilityMessage, ctrlLaw)\n\n    #   Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.cmdTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.guidInMsg.subscribeTo(guidInMsg)\n    module.vehConfigInMsg.subscribeTo(vcInMsg)\n    if rwNum > 0:\n        module.rwParamsInMsg.subscribeTo(rwParamInMsg)\n        module.rwSpeedsInMsg.subscribeTo(rwSpeedInMsg)\n    if useRwAvailability != \"NO\":\n        module.rwAvailInMsg.subscribeTo(rwAvailInMsg)\n\n    #   Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    #   Step the simulation to 3*process rate so 4 total steps including zero\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    module.Reset(1)     # this module reset function needs a time input (in NanoSeconds)\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # compare the module results to the truth values\n    accuracy = 1e-8\n    for i in range(0, len(LrTrue)):\n        # check vector values\n        if not unitTestSupport.isArrayEqual(dataLog.torqueRequestBody[i], LrTrue[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed mrpFeedback unit test at t=\"\n                                + str(dataLog.times()[i]*macros.NANO2SEC) + \"sec\\n\")\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(\"Failed: \" + module.ModelTag)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def findTrueTorques(module,guidCmdData,rwSpeedMessage,vehicleConfigOut,jsList,numRW,GsMatrix_B,rwAvailMsg,ctrlLaw):\n    Lr = []\n\n    #Read in variables\n    L = np.asarray(module.knownTorquePntB_B)\n    steps = [0, 0, .5, 0, .5]\n    omega_BR_B = np.asarray(guidCmdData.omega_BR_B)\n    omega_RN_B = np.asarray(guidCmdData.omega_RN_B)\n    omega_BN_B = omega_BR_B + omega_RN_B #find body rate\n    domega_RN_B = np.asarray(guidCmdData.domega_RN_B)\n    sigma_BR = np.asarray(guidCmdData.sigma_BR)\n    Isc = np.asarray(vehicleConfigOut.ISCPntB_B)\n    Isc = np.reshape(Isc, (3, 3))\n    Ki = module.Ki\n    K = module.K\n    P = module.P\n    jsVec = jsList\n    GsMatrix_B_array = np.asarray(GsMatrix_B)\n    GsMatrix_B_array = np.reshape(GsMatrix_B_array[0:numRW * 3], (numRW, 3))\n    sigmaInt = np.asarray([0, 0, 0])\n\n    #Compute toruqes\n    for i in range(len(steps)):\n        dt = steps[i]\n        if dt == 0:\n            sigmaInt = np.asarray([0, 0, 0])\n\n        #evaluate integral term\n        if Ki > 0: #if integral feedback is on\n            sigmaInt = K * dt * sigma_BR + sigmaInt\n            for n in range(3):\n                if abs(sigmaInt[n]) > module.integralLimit:\n                    sigmaInt[n] *= module.integralLimit/sigmaInt[n] #check elementwise if integral term is greater than limit; preserve direction (+/-)\n\n            zVec = sigmaInt + Isc.dot(omega_BR_B)\n        else: #integral gain turned off/negative setting\n            zVec = np.asarray([0, 0, 0])\n\n        #compute torque Lr\n        Lr0 = K * sigma_BR  # +K*sigmaBR\n        Lr1 = Lr0 + P * omega_BR_B  # +P*deltaOmega\n        Lr2 = Lr1 + P * Ki * zVec  # +P*Ki*z\n        GsHs = np.array([0,0,0])\n\n        if numRW>0:\n            for i in range(numRW):\n                if rwAvailMsg.wheelAvailability[i] == 0:  #Make RW availability check\n                    GsHs = GsHs + np.dot(GsMatrix_B_array[i, :], jsVec[i]*(np.dot(omega_BN_B, GsMatrix_B_array[i, :])+rwSpeedMessage.wheelSpeeds[i]))\n                    #J_s*(dot(omegaBN_B,Gs_vec)+Omega_wheel)\n\n        if ctrlLaw == 0:\n            Lr3 = Lr2 - np.cross((omega_RN_B+Ki*zVec), (Isc.dot(omega_BN_B)+GsHs)) # -[v3Tilde(omega_r+Ki*z)]([I]omega + [Gs]h_s)\n        else:\n            Lr3 = Lr2 - np.cross(omega_BN_B, (Isc.dot(omega_BN_B)+GsHs)) # -[v3Tilde(omega)]([I]omega + [Gs]h_s)\n\n        Lr4 = Lr3 + Isc.dot(-domega_RN_B + np.cross(omega_BN_B, omega_RN_B)) #+[I](-d(omega_r)/dt + omega x omega_r)\n        Lr5 = Lr4 + L\n        Lr5 = -Lr5\n        Lr.append(np.ndarray.tolist(Lr5))\n    return Lr",
  "def writeMsgInWheelConfiguration():\n        rwConfigParams = messaging.RWArrayConfigMsgPayload()\n\n        rwConfigParams.GsMatrix_B = [\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0,\n            0.577350269190, 0.577350269190, 0.577350269190\n        ]\n        rwConfigParams.JsList = [0.1, 0.1, 0.1, 0.1]\n        rwConfigParams.numRW = rwNum\n        msg = messaging.RWArrayConfigMsg().write(rwConfigParams)\n        return rwConfigParams.JsList, rwConfigParams.GsMatrix_B, msg",
  "def test_rate_servo_full_nonlinear(show_plots, rwNum, intGain, omegap_BastR_B, omega_BastR_B, integralLimit,\n                                   useRwAvailability):\n    \"\"\"Module Unit Test\"\"\"\n\n    [testResults, testMessage] = rate_servo_full_nonlinear(show_plots, rwNum, intGain, omegap_BastR_B, omega_BastR_B,\n                                                           integralLimit, useRwAvailability)\n\n    assert testResults < 1, testMessage",
  "def rate_servo_full_nonlinear(show_plots,rwNum, intGain, omegap_BastR_B, omega_BastR_B, integralLimit,\n                              useRwAvailability):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    #__tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    #   Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = rateServoFullNonlinear.rateServoFullNonlinear()\n    module.ModelTag = \"rate_servo\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # configure module parameters\n    module.Ki = intGain\n    module.P = 150.0\n    module.integralLimit = integralLimit\n    module.knownTorquePntB_B = (1,1,1)\n\n    #   Create input message and size it because the regular creator of that message\n    #   is not part of the test.\n    #   attGuidOut Message:\n    guidCmdData = messaging.AttGuidMsgPayload()  # Create a structure for the input message\n    sigma_BR = np.array([0.3, -0.5, 0.7])\n    guidCmdData.sigma_BR = sigma_BR\n    omega_BR_B = np.array([0.010, -0.020, 0.015])\n    guidCmdData.omega_BR_B = omega_BR_B\n    omega_RN_B = np.array([-0.02, -0.01, 0.005])\n    guidCmdData.omega_RN_B = omega_RN_B\n    domega_RN_B = np.array([0.0002, 0.0003, 0.0001])\n    guidCmdData.domega_RN_B = domega_RN_B\n    guidInMsg = messaging.AttGuidMsg().write(guidCmdData)\n\n    # vehicleConfigData Message:\n    vehicleConfigOut = messaging.VehicleConfigMsgPayload()\n    I = [1000., 0., 0.,\n         0., 800., 0.,\n         0., 0., 800.]\n    vehicleConfigOut.ISCPntB_B = I\n    vcInMsg = messaging.VehicleConfigMsg().write(vehicleConfigOut)\n\n    # wheelSpeeds Message\n    rwSpeedMessage = messaging.RWSpeedMsgPayload()\n    Omega = [10.0, 25.0, 50.0, 100.0]\n    rwSpeedMessage.wheelSpeeds = Omega\n    rwSpeedInMsg = messaging.RWSpeedMsg().write(rwSpeedMessage)\n\n    # wheelConfigData message\n    jsList = []\n    GsMatrix_B = []\n    def writeMsgInWheelConfiguration():\n        rwConfigParams = messaging.RWArrayConfigMsgPayload()\n        rwConfigParams.GsMatrix_B = [\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0,\n            0.5773502691896258, 0.5773502691896258, 0.5773502691896258\n        ]\n        rwConfigParams.JsList = [0.1, 0.1, 0.1, 0.1]\n        rwConfigParams.numRW = rwNum\n        rwParamInMsg = messaging.RWArrayConfigMsg().write((rwConfigParams))\n        return rwConfigParams.JsList, rwConfigParams.GsMatrix_B, rwParamInMsg\n\n    jsList, GsMatrix_B, rwParamInMsg = writeMsgInWheelConfiguration()\n\n    # wheelAvailability message\n    rwAvailabilityMessage = messaging.RWAvailabilityMsgPayload()\n    if useRwAvailability != \"NO\":\n        if useRwAvailability == \"ON\":\n            rwAvailabilityMessage.wheelAvailability  = [messaging.AVAILABLE, messaging.AVAILABLE,\n                                                        messaging.AVAILABLE, messaging.AVAILABLE]\n        elif useRwAvailability == \"OFF\":\n            rwAvailabilityMessage.wheelAvailability  = [messaging.UNAVAILABLE, messaging.UNAVAILABLE,\n                                                        messaging.UNAVAILABLE, messaging.UNAVAILABLE]\n        else:\n            print(\"WARNING: unknown rw availability status\")\n        rwAvailInMsg = messaging.RWAvailabilityMsg().write(rwAvailabilityMessage)\n    else:\n        # set default availability\n        rwAvailabilityMessage.wheelAvailability = [messaging.AVAILABLE, messaging.AVAILABLE,\n                                                   messaging.AVAILABLE, messaging.AVAILABLE]\n\n\n    # rateSteering message\n    rateSteeringMsg = messaging.RateCmdMsgPayload()\n    rateSteeringMsg.omega_BastR_B = omega_BastR_B\n    rateSteeringMsg.omegap_BastR_B = omegap_BastR_B\n    rateCmdInMsg = messaging.RateCmdMsg().write(rateSteeringMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.cmdTorqueOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Initialize the test module configuration data\n    module.guidInMsg.subscribeTo(guidInMsg)\n    module.vehConfigInMsg.subscribeTo(vcInMsg)\n    module.rwParamsInMsg.subscribeTo(rwParamInMsg)\n    module.vehConfigInMsg.subscribeTo(vcInMsg)\n    module.rwSpeedsInMsg.subscribeTo(rwSpeedInMsg)\n    module.rateSteeringInMsg.subscribeTo(rateCmdInMsg)\n    if useRwAvailability != \"NO\":\n        module.rwAvailInMsg.subscribeTo(rwAvailInMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Step the simulation to 3*process rate so 4 total steps including zero\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    module.Reset(1)  # this module reset function needs a time input (in NanoSeconds)\n\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # set the filtered output truth states\n    LrTrue = findTrueTorques(module, guidCmdData, rwSpeedMessage, vehicleConfigOut, jsList,\n                             rwNum, GsMatrix_B, rwAvailabilityMessage,rateSteeringMsg)\n\n\n    # compare the module results to the truth values\n    accuracy = 1e-8\n    for i in range(0, len(LrTrue)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(dataLog.torqueRequestBody[i], LrTrue[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed torqueRequestBody unit test at t=\"\n                                + str(dataLog.times()[i] * macros.NANO2SEC) + \"sec \\n\")\n\n    # If the argument provided at commandline \"--show_plots\" evaluates as true,\n    # plot all figures\n    if show_plots:\n        plt.show()\n\n    # print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def findTrueTorques(module,guidCmdData,rwSpeedMessage,vehicleConfigOut,jsList,numRW,GsMatrix_B,rwAvailMsg,rateSteeringMsg ):\n    Lr = []\n\n    #Read in variables\n    L = np.asarray(module.knownTorquePntB_B)\n    steps = [0, 0, .5, 0, .5]\n    omega_BR_B = np.asarray(guidCmdData.omega_BR_B)\n    omega_RN_B = np.asarray(guidCmdData.omega_RN_B)\n    omega_BN_B = omega_BR_B + omega_RN_B #find body rate\n    domega_RN_B = np.asarray(guidCmdData.domega_RN_B)\n    omega_BastR_B = np.asarray(rateSteeringMsg.omega_BastR_B)\n    omegap_BastR_B = np.asarray(rateSteeringMsg.omegap_BastR_B) #body-frame derivative of omega_BastR_B\n    omega_BastN_B = omega_BastR_B+omega_RN_B\n    omega_BBast_B = omega_BN_B - omega_BastN_B\n\n    Isc = np.asarray(vehicleConfigOut.ISCPntB_B)\n    Isc = np.reshape(Isc, (3, 3))\n    Ki = module.Ki\n    P = module.P\n    jsVec = jsList\n    GsMatrix_B_array = np.asarray(GsMatrix_B)\n    GsMatrix_B_array = np.reshape(GsMatrix_B_array[0:numRW * 3], (numRW, 3))\n\n    #Compute toruqes\n    for i in range(len(steps)):\n        dt = steps[i]\n        if dt == 0:\n            zVec = np.asarray([0, 0, 0])\n\n        #evaluate integral term\n        if Ki > 0 and abs(module.integralLimit) > 0: #if integral feedback is on\n            zVec = dt * omega_BBast_B + zVec  # z = integral(del_omega)\n            # Make sure each component is less than the integral limit\n            for i in range(3):\n                if zVec[i] > module.integralLimit:\n                        zVec[i] = zVec[i]/abs(zVec[i])*module.integralLimit\n\n        else: #integral gain turned off/negative setting\n            zVec = np.asarray([0, 0, 0])\n\n        #compute torque Lr\n        Lr0 = Ki * zVec  # +K*sigmaBR\n        Lr1 = Lr0 + P * omega_BBast_B  # +P*deltaOmega\n\n        GsHs = np.array([0,0,0])\n\n        if numRW > 0:\n            for i in range(numRW):\n                if rwAvailMsg.wheelAvailability[i] == 0:  # Make RW availability check\n                    GsHs = GsHs + np.dot(GsMatrix_B_array[i, :], jsVec[i]*(np.dot(omega_BN_B, GsMatrix_B_array[i, :]) + rwSpeedMessage.wheelSpeeds[i]))\n                    # J_s*(dot(omegaBN_B,Gs_vec)+Omega_wheel)\n\n        Lr2 = Lr1 - np.cross(omega_BastN_B, (Isc.dot(omega_BN_B)+GsHs))  #  - omega_BastN x ([I]omega + [Gs]h_s)\n\n        Lr3 = Lr2 - Isc.dot(omegap_BastR_B + domega_RN_B - np.cross(omega_BN_B, omega_RN_B))\n        # - [I](d(omega_B^ast/R)/dt + d(omega_r)/dt - omega x omega_r)\n        Lr4 = Lr3 + L\n        Lr4 = -Lr4\n        Lr.append(np.ndarray.tolist(Lr4))\n    return Lr",
  "def writeMsgInWheelConfiguration():\n        rwConfigParams = messaging.RWArrayConfigMsgPayload()\n        rwConfigParams.GsMatrix_B = [\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0,\n            0.5773502691896258, 0.5773502691896258, 0.5773502691896258\n        ]\n        rwConfigParams.JsList = [0.1, 0.1, 0.1, 0.1]\n        rwConfigParams.numRW = rwNum\n        rwParamInMsg = messaging.RWArrayConfigMsg().write((rwConfigParams))\n        return rwConfigParams.JsList, rwConfigParams.GsMatrix_B, rwParamInMsg",
  "def test_chebyPosFitAllTest(show_plots, validChebyCurveTime, anomFlag):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = chebyPosFitAllTest(show_plots, validChebyCurveTime, anomFlag)\n    assert testResults < 1, testMessage",
  "def chebyPosFitAllTest(show_plots, validChebyCurveTime, anomFlag):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    #__tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    numCurvePoints = 4*8640+1\n    curveDurationSeconds = 4*86400\n    logPeriod = curveDurationSeconds // (numCurvePoints - 1)\n    degChebCoeff = 14\n    integFrame = \"j2000\"\n    zeroBase = \"Earth\"\n    centralBodyMu = 3.98574405096E14\n\n    dateSpice = \"2015 April 10, 00:00:00.0 TDB\"\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/naif0012.tls')\n    et = pyswice.new_doubleArray(1)\n    pyswice.str2et_c(dateSpice, et)\n    etStart = pyswice.doubleArray_getitem(et, 0)\n    etEnd = etStart + curveDurationSeconds\n\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/de430.bsp')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/naif0012.tls')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/de-403-masses.tpc')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/pck00010.tpc')\n    pyswice.furnsh_c(path + '/TDRSS.bsp')\n\n    tdrssPosList = []\n    tdrssVelList = []\n    timeHistory = numpy.linspace(etStart, etEnd, numCurvePoints)\n    position = numpy.array(3)\n    velocity = numpy.array(3)\n    rpArray = []\n    eccArray = []\n    incArray = []\n    OmegaArray = []\n    omegaArray = []\n    anomArray = []\n    anomPrev = 0.0\n    anomCount = 0\n\n    for timeVal in timeHistory:\n        stringCurrent = pyswice.et2utc_c(timeVal, 'C', 4, 1024, \"Yo\")\n        stateOut = spkRead('-221', stringCurrent, integFrame, zeroBase)\n        position = stateOut[0:3]*1000.0\n        velocity = stateOut[3:6]*1000.0\n        orbEl = orbitalMotion.rv2elem(centralBodyMu, position, velocity)\n        tdrssPosList.append(position)\n        tdrssVelList.append(velocity)\n        rpArray.append(orbEl.rPeriap)\n        eccArray.append(orbEl.e)\n        incArray.append(orbEl.i)\n        OmegaArray.append(orbEl.Omega)\n        omegaArray.append(orbEl.omega)\n        if anomFlag == 1:\n            currentAnom = orbitalMotion.E2M(orbitalMotion.f2E(orbEl.f, orbEl.e), orbEl.e)\n        else:\n            currentAnom = orbEl.f\n        if currentAnom < anomPrev:\n            anomCount += 1\n        anomArray.append(2*math.pi*anomCount + currentAnom)\n        anomPrev = currentAnom\n\n    tdrssPosList = numpy.array(tdrssPosList)\n    tdrssVelList = numpy.array(tdrssVelList)\n\n    fitTimes = numpy.linspace(-1, 1, numCurvePoints)\n    chebRpCoeff = numpy.polynomial.chebyshev.chebfit(fitTimes, rpArray, degChebCoeff)\n    chebEccCoeff = numpy.polynomial.chebyshev.chebfit(fitTimes, eccArray, degChebCoeff)\n    chebIncCoeff = numpy.polynomial.chebyshev.chebfit(fitTimes, incArray, degChebCoeff)\n    chebOmegaCoeff = numpy.polynomial.chebyshev.chebfit(fitTimes, OmegaArray, degChebCoeff)\n    chebomegaCoeff = numpy.polynomial.chebyshev.chebfit(fitTimes, omegaArray, degChebCoeff)\n    chebAnomCoeff = numpy.polynomial.chebyshev.chebfit(fitTimes, anomArray, degChebCoeff)\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    sim = SimulationBaseClass.SimBaseClass()\n\n    FSWUnitTestProc = sim.CreateNewProcess(unitProcessName)\n    # create the dynamics task and specify the integration update time\n    FSWUnitTestProc.addTask(sim.CreateNewTask(unitTaskName, macros.sec2nano(logPeriod)))\n\n    oeStateModel = oeStateEphem.oeStateEphem()\n    oeStateModel.ModelTag = \"oeStateModel\"\n    sim.AddModelToTask(unitTaskName, oeStateModel)\n\n    oeStateModel.muCentral = centralBodyMu\n\n    oeStateModel.ephArray[0].rPeriapCoeff = chebRpCoeff.tolist()\n    oeStateModel.ephArray[0].eccCoeff = chebEccCoeff.tolist()\n    oeStateModel.ephArray[0].incCoeff = chebIncCoeff.tolist()\n    oeStateModel.ephArray[0].argPerCoeff = chebomegaCoeff.tolist()\n    oeStateModel.ephArray[0].anomCoeff = chebAnomCoeff.tolist()\n    oeStateModel.ephArray[0].RAANCoeff = chebOmegaCoeff.tolist()\n    oeStateModel.ephArray[0].nChebCoeff = degChebCoeff + 1\n    oeStateModel.ephArray[0].ephemTimeMid = etStart + curveDurationSeconds/2.0\n    oeStateModel.ephArray[0].ephemTimeRad = curveDurationSeconds/2.0\n\n    if not (anomFlag == -1):\n        oeStateModel.ephArray[0].anomalyFlag = anomFlag\n\n    clockCorrData = messaging.TDBVehicleClockCorrelationMsgPayload()\n    clockCorrData.vehicleClockTime = 0.0\n    clockCorrData.ephemerisTime = oeStateModel.ephArray[0].ephemTimeMid - oeStateModel.ephArray[0].ephemTimeRad\n\n    clockInMsg = messaging.TDBVehicleClockCorrelationMsg().write(clockCorrData)\n    oeStateModel.clockCorrInMsg.subscribeTo(clockInMsg)\n\n    dataLog = oeStateModel.stateFitOutMsg.recorder()\n    sim.AddModelToTask(unitTaskName, dataLog)\n\n    if not validChebyCurveTime:\n        sim.InitializeSimulation()\n        # increase the run time by one logging period so that the sim time is outside the\n        # valid chebychev curve duration\n        sim.ConfigureStopTime(int((curveDurationSeconds + logPeriod) * 1.0E9))\n        sim.ExecuteSimulation()\n    else:\n        sim.InitializeSimulation()\n        sim.ConfigureStopTime(int(curveDurationSeconds*1.0E9))\n        sim.ExecuteSimulation()\n\n    posChebData = dataLog.r_BdyZero_N\n    velChebData = dataLog.v_BdyZero_N\n\n    if not validChebyCurveTime:\n        lastLogidx = (curveDurationSeconds + logPeriod) // logPeriod - 1\n        secondLastPos = posChebData[lastLogidx + 1, 0:] - tdrssPosList[lastLogidx, :]\n        lastPos = posChebData[lastLogidx, 0:] - tdrssPosList[lastLogidx, :]\n        if not numpy.array_equal(secondLastPos, lastPos):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Expected Chebychev position to rail high or low \"\n                                + str(secondLastPos)\n                                + \" != \"\n                                + str(lastPos))\n\n        secondLastVel = velChebData[lastLogidx + 1, 0:] - tdrssVelList[lastLogidx, :]\n        lastVel = velChebData[lastLogidx, 0:] - tdrssVelList[lastLogidx, :]\n        if not numpy.array_equal(secondLastVel, lastVel):\n            testFailCount += 1\n            testMessages.append(\"FAILED: Expected Chebychev velocity to rail high or low \"\n                                + str(secondLastVel)\n                                + \" != \"\n                                + str(lastVel))\n    else:\n        maxErrVec = [abs(max(posChebData[:, 0] - tdrssPosList[:, 0])),\n                     abs(max(posChebData[:, 1] - tdrssPosList[:, 1])),\n                     abs(max(posChebData[:,2] - tdrssPosList[:, 2]))]\n        maxVelErrVec = [abs(max(velChebData[:, 0] - tdrssVelList[:, 0])),\n                        abs(max(velChebData[:, 1] - tdrssVelList[:, 1])),\n                        abs(max(velChebData[:, 2] - tdrssVelList[:, 2]))]\n\n        if max(maxErrVec) >= orbitPosAccuracy:\n            testFailCount += 1\n            testMessages.append(\"FAILED: maxErrVec >= orbitPosAccuracy, TDRSS Orbit Accuracy: \"\n                                + str(max(maxErrVec)))\n        if max(maxVelErrVec) >= orbitVelAccuracy:\n            testFailCount += 1\n            testMessages.append(\"FAILED: maxVelErrVec >= orbitVelAccuracy, TDRSS Velocity Accuracy: \"\n                                + str(max(maxVelErrVec)))\n\n        plt.close(\"all\")\n        # plot the fitted and actual position coordinates\n        plt.figure(1)\n        fig = plt.gcf()\n        ax = fig.gca()\n        ax.ticklabel_format(useOffset=False, style='plain')\n        for idx in range(0, 3):\n            plt.plot(dataLog.times()*macros.NANO2HOUR,\n                     posChebData[:, idx]/1000,\n                     color=unitTestSupport.getLineColor(idx, 3),\n                     linewidth=0.5,\n                     label='$r_{fit,' + str(idx) + '}$')\n            plt.plot(dataLog.times()*macros.NANO2HOUR,\n                     tdrssPosList[:, idx]/1000,\n                     color=unitTestSupport.getLineColor(idx, 3),\n                     linestyle='dashed', linewidth=2,\n                     label='$r_{true,' + str(idx) + '}$')\n        plt.legend(loc='lower right')\n        plt.xlabel('Time [h]')\n        plt.ylabel('Inertial Position [km]')\n\n        # plot the fitted and actual velocity coordinates\n        plt.figure(2)\n        for idx in range(0, 3):\n            plt.plot(dataLog.times()*macros.NANO2HOUR,\n                     velChebData[:, idx]/1000,\n                     color=unitTestSupport.getLineColor(idx, 3),\n                     linewidth=0.5,\n                     label='$v_{fit,' + str(idx) + '}$')\n            plt.plot(dataLog.times()*macros.NANO2HOUR,\n                     tdrssVelList[:, idx]/1000,\n                     color=unitTestSupport.getLineColor(idx, 3),\n                     linestyle='dashed', linewidth=2,\n                     label='$v_{true,' + str(idx) + '}$')\n        plt.legend(loc='lower right')\n        plt.xlabel('Time [h]')\n        plt.ylabel('Velocity [km/s]')\n\n        # plot the difference in position coordinates\n        plt.figure(3)\n        arrayLength = posChebData[:, 0].size\n        for idx in range(0,3):\n            plt.plot(dataLog.times() * macros.NANO2HOUR,\n                     posChebData[:, idx] - tdrssPosList[:, idx],\n                     color=unitTestSupport.getLineColor(idx, 3),\n                     linewidth=0.5,\n                     label=r'$\\Delta r_{' + str(idx) + '}$')\n        plt.plot(dataLog.times() * macros.NANO2HOUR,\n                 orbitPosAccuracy*numpy.ones(arrayLength),\n                 color='r',\n                 linewidth=1)\n        plt.plot(dataLog.times() * macros.NANO2HOUR,\n                 -orbitPosAccuracy * numpy.ones(arrayLength),\n                 color='r',\n                 linewidth=1)\n        plt.legend(loc='lower right')\n        plt.xlabel('Time [h]')\n        plt.ylabel('Position Difference [m]')\n\n        # plot the difference in velocity coordinates\n        plt.figure(4)\n        arrayLength = velChebData[:, 0].size\n        for idx in range(0,3):\n            plt.plot(dataLog.times() * macros.NANO2HOUR,\n                     velChebData[:, idx] - tdrssVelList[:, idx],\n                     color=unitTestSupport.getLineColor(idx, 3),\n                     linewidth=0.5,\n                     label=r'$\\Delta v_{' + str(idx) + '}$')\n        plt.plot(dataLog.times() * macros.NANO2HOUR,\n                 orbitVelAccuracy*numpy.ones(arrayLength),\n                 color='r',\n                 linewidth=1)\n        plt.plot(dataLog.times() * macros.NANO2HOUR,\n                 -orbitVelAccuracy * numpy.ones(arrayLength),\n                 color='r',\n                 linewidth=1)\n        plt.legend(loc='lower right')\n        plt.xlabel('Time [h]')\n        plt.ylabel('Velocity Difference [m/s]')\n\n    if show_plots:\n        plt.show()\n        plt.close('all')\n\n    snippentName = \"passFail\" + str(validChebyCurveTime)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + oeStateModel.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + oeStateModel.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def generateAccData():\n    \"\"\" Returns a list of random AccPktDataFswMsg.\"\"\"\n    accPktList = list()\n    for _ in range(120):\n        accPacketData = messaging.AccPktDataMsgPayload()\n        accPacketData.measTime = abs(int(random.normal(5e7, 1e7)))\n        accPacketData.accel_B = random.normal(0.1, 0.2, 3)  # Acceleration in platform frame [m/s2]\n        accPktList.append(accPacketData)\n\n    return accPktList",
  "def test_dv_accumulation():\n    \"\"\" Test dvAccumulation. \"\"\"\n    [testResults, testMessage] = dvAccumulationTestFunction()\n    assert testResults < 1, testMessage",
  "def dvAccumulationTestFunction():\n    \"\"\" Test the dvAccumulation module. Setup a simulation, \"\"\"\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Test quicksort routine\n    # Generate (1) random packet measurement times and (2) completely inverted measurement times\n    randMeasTimes = []\n    invMeasTimes = []\n    randData = messaging.AccDataMsgPayload()\n    invData = messaging.AccDataMsgPayload()\n    for i in range(0, messaging.MAX_ACC_BUF_PKT):\n        randMeasTimes.append(random.randint(0, 1000000))\n        randData.accPkts[i].measTime = randMeasTimes[i]\n\n        invMeasTimes.append(messaging.MAX_ACC_BUF_PKT - i)\n        invData.accPkts[i].measTime = invMeasTimes[i]\n\n    # Run module quicksort function\n    dvAccumulation.dvAccumulation_QuickSort(randData.accPkts[0], 0, messaging.MAX_ACC_BUF_PKT - 1)\n    dvAccumulation.dvAccumulation_QuickSort(invData.accPkts[0], 0, messaging.MAX_ACC_BUF_PKT - 1)\n\n    # Check that sorted packets properly\n    randMeasTimes.sort()\n    invMeasTimes.sort()\n    for i in range(0, messaging.MAX_ACC_BUF_PKT):\n        if randData.accPkts[i].measTime != randMeasTimes[i]:\n            testFailCount += 1\n        if invData.accPkts[i].measTime != invMeasTimes[i]:\n            testFailCount += 1\n\n    # Test Module\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # This is needed if multiple unit test scripts are run\n    # This create a fresh and consistent simulation environment for each test run\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))  # Add a new task to the process\n\n    # Construct the dvAccumulation module\n    # Set the names for the input messages\n    module = dvAccumulation.dvAccumulation()\n\n    # This calls the algContain to setup the selfInit, update, and reset\n    module.ModelTag = \"dvAccumulation\"\n\n    # Add the module to the task\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    dataLog = module.dvAcumOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Create the input message.\n    inputAccData = messaging.AccDataMsgPayload()\n\n    # Set this as the packet data in the acceleration data\n    random.seed(12345)\n    inputAccData.accPkts = generateAccData()\n    inMsg = messaging.AccDataMsg()\n    module.accPktInMsg.subscribeTo(inMsg)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n    inMsg.write(inputAccData)\n\n    #   Step the simulation to 3*process rate so 4 total steps including zero\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # Create the input message again to simulate multiple acceleration inputs.\n    inputAccData = messaging.AccDataMsgPayload()\n\n    # Set this as the packet data in the acceleration data. Test the module with different inputs.\n    inputAccData.accPkts = generateAccData()\n\n    # Write this message\n    inMsg.write(inputAccData)\n\n    #   Step the simulation to 3*process rate so 4 total steps including zero\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    outputNavMsgData = dataLog.vehAccumDV\n    timeMsgData = dataLog.timeTag\n\n    # print(outputNavMsgData)\n    # print(timeMsgData)\n\n    trueDVVector = [[4.82820079e-03,   7.81971465e-03,   2.29605663e-03],\n                 [ 4.82820079e-03,   7.81971465e-03,   2.29605663e-03],\n                 [ 4.82820079e-03,   7.81971465e-03,   2.29605663e-03],\n                 [ 6.44596343e-03,   9.00203561e-03,   2.60580728e-03],\n                 [ 6.44596343e-03,   9.00203561e-03,   2.60580728e-03]]\n    trueTime = np.array([7.2123026e+07, 7.2123026e+07, 7.2123026e+07, 7.6667436e+07, 7.6667436e+07]) * macros.NANO2SEC\n\n    accuracy = 1e-6\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    # At each timestep, make sure the vehicleConfig values haven't changed from the initial values\n    testFailCount, testMessages = unitTestSupport.compareArrayND(trueDVVector, outputNavMsgData,\n                                                                 accuracy,\n                                                                 \"dvAccumulation output\",\n                                                                 2, testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArrayND([trueTime], [timeMsgData],\n                                                                 accuracy, \"timeTag\", 5,\n                                                                 testFailCount, testMessages)\n\n    snippentName = \"passFail\"\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_chebyPosFitAllTest(show_plots, function):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = eval(function + '(show_plots)')\n    assert testResults < 1, testMessage",
  "def sineCosine(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    __tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    orbitRadius = 70000.0\n    numCurvePoints = 365*3+1\n    curveDurationDays = 365.0*3\n    degChebCoeff =21\n\n    angleSpace = numpy.linspace(-3*math.pi, 3*math.pi, numCurvePoints)\n\n    cosineValues = numpy.cos(angleSpace)*orbitRadius\n    sineValues = numpy.sin(angleSpace)*orbitRadius\n    oopValues = numpy.sin(angleSpace) + orbitRadius\n\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/naif0012.tls')\n    et = pyswice.new_doubleArray(1)\n\n    timeStringMid = '2019 APR 1 12:12:12.0 (UTC)'\n    pyswice.str2et_c(timeStringMid, et)\n\n    fitTimes = numpy.linspace(-1, 1, numCurvePoints)\n\n    chebCosCoeff = numpy.polynomial.chebyshev.chebfit(fitTimes, cosineValues, degChebCoeff)\n    chebSinCoeff = numpy.polynomial.chebyshev.chebfit(fitTimes, sineValues, degChebCoeff)\n    cheboopCoeff = numpy.polynomial.chebyshev.chebfit(fitTimes, oopValues, degChebCoeff)\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    TotalSim = SimulationBaseClass.SimBaseClass()\n\n    FSWUnitTestProc = TotalSim.CreateNewProcess(unitProcessName)\n    # create the dynamics task and specify the integration update time\n    FSWUnitTestProc.addTask(TotalSim.CreateNewTask(unitTaskName, macros.sec2nano(8640.0)))\n\n    chebyFitModel = chebyPosEphem.chebyPosEphem()\n    chebyFitModel.ModelTag = \"chebyFitModel\"\n    TotalSim.AddModelToTask(unitTaskName, chebyFitModel)\n\n    totalList = numpy.array(chebCosCoeff).tolist()\n    totalList.extend(numpy.array(chebSinCoeff).tolist())\n    totalList.extend(numpy.array(cheboopCoeff).tolist())\n\n    chebyFitModel.ephArray[0].posChebyCoeff = totalList\n    chebyFitModel.ephArray[0].nChebCoeff = degChebCoeff+1\n    chebyFitModel.ephArray[0].ephemTimeMid = pyswice.doubleArray_getitem(et, 0)\n    chebyFitModel.ephArray[0].ephemTimeRad = curveDurationDays/2.0*86400.0\n\n    clockCorrData = messaging.TDBVehicleClockCorrelationMsgPayload()\n    clockCorrData.vehicleClockTime = 0.0\n    clockCorrData.ephemerisTime = chebyFitModel.ephArray[0].ephemTimeMid  - \\\n        chebyFitModel.ephArray[0].ephemTimeRad\n    clockInMsg = messaging.TDBVehicleClockCorrelationMsg().write(clockCorrData)\n    chebyFitModel.clockCorrInMsg.subscribeTo(clockInMsg)\n\n    xFitData = numpy.polynomial.chebyshev.chebval(fitTimes, chebCosCoeff)\n\n    dataLog = chebyFitModel.posFitOutMsg.recorder()\n    TotalSim.AddModelToTask(unitTaskName, dataLog)\n\n    TotalSim.InitializeSimulation()\n    TotalSim.ConfigureStopTime(int(curveDurationDays*86400.0*1.0E9))\n    TotalSim.ExecuteSimulation()\n\n    posChebData = dataLog.r_BdyZero_N\n\n    angleSpaceFine = numpy.linspace(-3*math.pi, 3*math.pi, numCurvePoints*10-9)\n\n    cosineValuesFine = numpy.cos(angleSpaceFine)*orbitRadius\n    sineValuesFine = numpy.sin(angleSpaceFine)*orbitRadius\n    oopValuesFine = numpy.sin(angleSpaceFine) + orbitRadius\n\n    maxErrVec = [max(abs(posChebData[:,0] - cosineValuesFine)),\n        max(abs(posChebData[:,1] - sineValuesFine)),\n        max(abs(posChebData[:,2] - oopValuesFine))]\n\n    print(\"Sine Wave error: \" +  str(max(maxErrVec)))\n    assert max(maxErrVec) < orbitPosAccuracy\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Sine and Cosine curve fit\")\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def earthOrbitFit(show_plots):\n    # The __tracebackhide__ setting influences pytest showing of tracebacks:\n    # the mrp_steering_tracking() function will not be shown unless the\n    # --fulltrace command line option is specified.\n    #__tracebackhide__ = True\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty list to store test log messages\n\n    numCurvePoints = 365*3+1\n    curveDurationSeconds = 3*5950.0\n    degChebCoeff =23\n    integFrame = \"j2000\"\n    zeroBase = \"Earth\"\n\n    dateSpice = \"2015 February 10, 00:00:00.0 TDB\"\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/naif0012.tls')\n    et = pyswice.new_doubleArray(1)\n    pyswice.str2et_c(dateSpice, et)\n    etStart = pyswice.doubleArray_getitem(et, 0)\n    etEnd = etStart + curveDurationSeconds\n\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/de430.bsp')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/naif0012.tls')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/de-403-masses.tpc')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/pck00010.tpc')\n    pyswice.furnsh_c(path + '/hst_edited.bsp')\n\n    hubblePosList = []\n    hubbleVelList = []\n    timeHistory = numpy.linspace(etStart, etEnd, numCurvePoints)\n\n    for timeVal in timeHistory:\n        stringCurrent = pyswice.et2utc_c(timeVal, 'C', 4, 1024, \"Yo\")\n        stateOut = spkRead('HUBBLE SPACE TELESCOPE', stringCurrent, integFrame, zeroBase)\n        hubblePosList.append(stateOut[0:3].tolist())\n        hubbleVelList.append(stateOut[3:6].tolist())\n\n    hubblePosList = numpy.array(hubblePosList)\n    hubbleVelList = numpy.array(hubbleVelList)\n\n    fitTimes = numpy.linspace(-1, 1, numCurvePoints)\n    chebCoeff = numpy.polynomial.chebyshev.chebfit(fitTimes, hubblePosList, degChebCoeff)\n\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    TotalSim = SimulationBaseClass.SimBaseClass()\n\n    FSWUnitTestProc = TotalSim.CreateNewProcess(unitProcessName)\n    # create the dynamics task and specify the integration update time\n    FSWUnitTestProc.addTask(TotalSim.CreateNewTask(unitTaskName, macros.sec2nano(curveDurationSeconds/(numCurvePoints-1))))\n\n    chebyFitModel = chebyPosEphem.chebyPosEphem()\n    chebyFitModel.ModelTag = \"chebyFitModel\"\n    TotalSim.AddModelToTask(unitTaskName, chebyFitModel)\n\n    totalList = chebCoeff[:,0].tolist()\n    totalList.extend(chebCoeff[:,1].tolist())\n    totalList.extend(chebCoeff[:,2].tolist())\n\n    chebyFitModel.ephArray[0].posChebyCoeff = totalList\n    chebyFitModel.ephArray[0].nChebCoeff = degChebCoeff+1\n    chebyFitModel.ephArray[0].ephemTimeMid = etStart + curveDurationSeconds/2.0\n    chebyFitModel.ephArray[0].ephemTimeRad = curveDurationSeconds/2.0\n\n    clockCorrData = messaging.TDBVehicleClockCorrelationMsgPayload()\n    clockCorrData.vehicleClockTime = 0.0\n    clockCorrData.ephemerisTime = chebyFitModel.ephArray[0].ephemTimeMid  - \\\n        chebyFitModel.ephArray[0].ephemTimeRad\n    clockInMsg = messaging.TDBVehicleClockCorrelationMsg().write(clockCorrData)\n    chebyFitModel.clockCorrInMsg.subscribeTo(clockInMsg)\n\n    dataLog = chebyFitModel.posFitOutMsg.recorder()\n    TotalSim.AddModelToTask(unitTaskName, dataLog)\n\n    TotalSim.InitializeSimulation()\n    TotalSim.ConfigureStopTime(int(curveDurationSeconds*1.0E9))\n    TotalSim.ExecuteSimulation()\n\n    posChebData = dataLog.r_BdyZero_N\n    velChebData = dataLog.v_BdyZero_N\n\n    maxErrVec = [abs(max(posChebData[:,0] - hubblePosList[:,0])),\n        abs(max(posChebData[:,1] - hubblePosList[:,1])),\n        abs(max(posChebData[:,2] - hubblePosList[:,2]))]\n    maxVelErrVec = [abs(max(velChebData[:,0] - hubbleVelList[:,0])),\n             abs(max(velChebData[:,1] - hubbleVelList[:,1])),\n             abs(max(velChebData[:,2] - hubbleVelList[:,2]))]\n    print(\"Hubble Orbit Accuracy: \" + str(max(maxErrVec)))\n    print(\"Hubble Velocity Accuracy: \" + str(max(maxVelErrVec)))\n    assert (max(maxErrVec)) < orbitPosAccuracy\n    assert (max(maxVelErrVec)) < orbitVelAccuracy\n    plt.figure()\n    plt.plot(dataLog.times()*1.0E-9, velChebData[:,0], dataLog.times()*1.0E-9, hubbleVelList[:,0])\n\n    if(show_plots):\n        plt.show()\n        plt.close('all')\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + \" Orbit curve fit\")\n    # return fail count and join into a single string all messages in the list\n    # testMessage\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots, numAttNav, numTransNav):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = navAggregateTestFunction(show_plots, numAttNav, numTransNav)\n    assert testResults < 1, testMessage",
  "def navAggregateTestFunction(show_plots, numAttNav, numTransNav):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct an instance of the module being tested\n    module = navAggregate.navAggregate()\n    module.ModelTag = \"navAggregate\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Create input messages\n    navAtt1Msg = messaging.NavAttMsgPayload()\n    navAtt1Msg.timeTag = 11.11\n    navAtt1Msg.sigma_BN = [0.1, 0.01, -0.1]\n    navAtt1Msg.omega_BN_B = [1., 1., -1.]\n    navAtt1Msg.vehSunPntBdy = [-0.1, 0.1, 0.1]\n    navAtt1InMsg = messaging.NavAttMsg().write(navAtt1Msg)\n    navAtt2Msg = messaging.NavAttMsgPayload()\n    navAtt2Msg.timeTag = 22.22\n    navAtt2Msg.sigma_BN = [0.2, 0.02, -0.2]\n    navAtt2Msg.omega_BN_B = [2., 2., -2.]\n    navAtt2Msg.vehSunPntBdy = [-0.2, 0.2, 0.2]\n    navAtt2InMsg = messaging.NavAttMsg().write(navAtt2Msg)\n\n    navTrans1Msg = messaging.NavTransMsgPayload()\n    navTrans1Msg.timeTag = 11.1\n    navTrans1Msg.r_BN_N = [1000.0, 100.0, -1000.0]\n    navTrans1Msg.v_BN_N = [1., 1., -1.]\n    navTrans1Msg.vehAccumDV = [-10.1, 10.1, 10.1]\n    navTrans1InMsg = messaging.NavTransMsg().write(navTrans1Msg)\n    navTrans2Msg = messaging.NavTransMsgPayload()\n    navTrans2Msg.timeTag = 22.2\n    navTrans2Msg.r_BN_N = [2000.0, 200.0, -2000.0]\n    navTrans2Msg.v_BN_N = [2., 2., -2.]\n    navTrans2Msg.vehAccumDV = [-20.2, 20.2, 20.2]\n    navTrans2InMsg = messaging.NavTransMsg().write(navTrans2Msg)\n\n    # create input navigation message containers\n    navAtt1 = navAggregate.AggregateAttInput()\n    navAtt2 = navAggregate.AggregateAttInput()\n    navTrans1 = navAggregate.AggregateTransInput()\n    navTrans2 = navAggregate.AggregateTransInput()\n\n    module.attMsgCount = numAttNav\n    if numAttNav == 3:       # here the index asks to read from an empty (zero) message\n        module.attMsgCount = 2\n\n    module.transMsgCount = numTransNav\n    if numTransNav == 3:     # here the index asks to read from an empty (zero) message\n        module.transMsgCount = 2\n\n    if numAttNav <= navAggregate.MAX_AGG_NAV_MSG:\n        module.attMsgs = [navAtt1, navAtt2]\n        module.attMsgs[0].navAttInMsg.subscribeTo(navAtt1InMsg)\n        module.attMsgs[1].navAttInMsg.subscribeTo(navAtt2InMsg)\n    else:\n        module.attMsgs = [navAtt1] * navAggregate.MAX_AGG_NAV_MSG\n        for i in range(navAggregate.MAX_AGG_NAV_MSG):\n            module.attMsgs[i].navAttInMsg.subscribeTo(navAtt1InMsg)\n    if numTransNav <= navAggregate.MAX_AGG_NAV_MSG:\n        module.transMsgs = [navTrans1, navTrans2]\n        module.transMsgs[0].navTransInMsg.subscribeTo(navTrans1InMsg)\n        module.transMsgs[1].navTransInMsg.subscribeTo(navTrans2InMsg)\n    else:\n        module.transMsgs = [navTrans1] * navAggregate.MAX_AGG_NAV_MSG\n        for i in range(navAggregate.MAX_AGG_NAV_MSG):\n            module.transMsgs[i].navTransInMsg.subscribeTo(navTrans1InMsg)\n\n    if numAttNav > 1:       # always read from the last message counter\n        module.attTimeIdx = numAttNav - 1\n        module.attIdx = numAttNav - 1\n        module.rateIdx = numAttNav - 1\n        module.sunIdx = numAttNav - 1\n    if numTransNav > 1:     # always read from the last message counter\n        module.transTimeIdx = numTransNav-1\n        module.posIdx = numTransNav-1\n        module.velIdx = numTransNav-1\n        module.dvIdx = numTransNav-1\n\n    # write TeX snippets for the message values\n    unitTestSupport.writeTeXSnippet(\"navAtt1Msg.timeTag\", str(navAtt1Msg.timeTag), path)\n    unitTestSupport.writeTeXSnippet(\"navAtt1Msg.sigma_BN\", str(navAtt1Msg.sigma_BN), path)\n    unitTestSupport.writeTeXSnippet(\"navAtt1Msg.omega_BN_B\", str(navAtt1Msg.omega_BN_B), path)\n    unitTestSupport.writeTeXSnippet(\"navAtt1Msg.vehSunPntBdy\", str(navAtt1Msg.vehSunPntBdy), path)\n    unitTestSupport.writeTeXSnippet(\"navAtt2Msg.timeTag\", str(navAtt2Msg.timeTag), path)\n    unitTestSupport.writeTeXSnippet(\"navAtt2Msg.sigma_BN\", str(navAtt2Msg.sigma_BN), path)\n    unitTestSupport.writeTeXSnippet(\"navAtt2Msg.omega_BN_B\", str(navAtt2Msg.omega_BN_B), path)\n    unitTestSupport.writeTeXSnippet(\"navAtt2Msg.vehSunPntBdy\", str(navAtt2Msg.vehSunPntBdy), path)\n    unitTestSupport.writeTeXSnippet(\"navTrans1Msg.timeTag\", str(navTrans1Msg.timeTag), path)\n    unitTestSupport.writeTeXSnippet(\"navTrans1Msg.r_BN_N\", str(navTrans1Msg.r_BN_N), path)\n    unitTestSupport.writeTeXSnippet(\"navTrans1Msg.v_BN_N\", str(navTrans1Msg.v_BN_N), path)\n    unitTestSupport.writeTeXSnippet(\"navTrans1Msg.vehAccumDV\", str(navTrans1Msg.vehAccumDV), path)\n    unitTestSupport.writeTeXSnippet(\"navTrans2Msg.timeTag\", str(navTrans2Msg.timeTag), path)\n    unitTestSupport.writeTeXSnippet(\"navTrans2Msg.r_BN_N\", str(navTrans2Msg.r_BN_N), path)\n    unitTestSupport.writeTeXSnippet(\"navTrans2Msg.v_BN_N\", str(navTrans2Msg.v_BN_N), path)\n    unitTestSupport.writeTeXSnippet(\"navTrans2Msg.vehAccumDV\", str(navTrans2Msg.vehAccumDV), path)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataAttLog = module.navAttOutMsg.recorder()\n    dataTransLog = module.navTransOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataAttLog)\n    unitTestSim.AddModelToTask(unitTaskName, dataTransLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # This pulls the actual data log from the simulation run.\n    attTimeTag = np.transpose([dataAttLog.timeTag])\n    attSigma = dataAttLog.sigma_BN\n    attOmega = dataAttLog.omega_BN_B\n    attSunVector = dataAttLog.vehSunPntBdy\n\n    transTimeTag = np.transpose([dataTransLog.timeTag])\n    transPos = dataTransLog.r_BN_N\n    transVel = dataTransLog.v_BN_N\n    transAccum = dataTransLog.vehAccumDV\n\n    # set the filtered output truth states\n    if numAttNav == 0 or numAttNav == 3:\n        trueAttTimeTag = [[0.0]]*3\n        trueAttSigma = [[0., 0., 0.]]*3\n        trueAttOmega = [[0., 0., 0.]]*3\n        trueAttSunVector = [[0., 0., 0.]]*3\n\n    if numTransNav == 0 or numTransNav == 3:\n        trueTransTimeTag = [[0.0]]*3\n        trueTransPos = [[0.0, 0.0, 0.0]]*3\n        trueTransVel = [[0.0, 0.0, 0.0]]*3\n        trueTransAccum = [[0.0, 0.0, 0.0]]*3\n\n    if numAttNav == 1 or numAttNav == 11:\n        trueAttTimeTag = [[navAtt1Msg.timeTag]]*3\n        trueAttSigma = [navAtt1Msg.sigma_BN]*3\n        trueAttOmega = [navAtt1Msg.omega_BN_B]*3\n        trueAttSunVector = [navAtt1Msg.vehSunPntBdy]*3\n\n    if numTransNav == 1 or numTransNav == 11:\n        trueTransTimeTag = [[navTrans1Msg.timeTag]]*3\n        trueTransPos = [navTrans1Msg.r_BN_N]*3\n        trueTransVel = [navTrans1Msg.v_BN_N]*3\n        trueTransAccum = [navTrans1Msg.vehAccumDV]*3\n\n    if numAttNav == 2:\n        trueAttTimeTag = [[navAtt2Msg.timeTag]] * 3\n        trueAttSigma = [navAtt2Msg.sigma_BN] * 3\n        trueAttOmega = [navAtt2Msg.omega_BN_B] * 3\n        trueAttSunVector = [navAtt2Msg.vehSunPntBdy] * 3\n\n    if numTransNav == 2:\n        trueTransTimeTag = [[navTrans2Msg.timeTag]]*3\n        trueTransPos = [navTrans2Msg.r_BN_N]*3\n        trueTransVel = [navTrans2Msg.v_BN_N]*3\n        trueTransAccum = [navTrans2Msg.vehAccumDV]*3\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    # check if the module output matches the truth data\n    testFailCount, testMessages = unitTestSupport.compareArrayND(trueAttTimeTag, attTimeTag,\n                                                               accuracy, \"attTimeTag\", 1,\n                                                               testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArray(trueAttSigma, attSigma,\n                                                                 accuracy, \"sigma_BN\",\n                                                                 testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArray(trueAttOmega, attOmega,\n                                                               accuracy, \"omega_BN_B\",\n                                                               testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArray(trueAttSunVector, attSunVector,\n                                                               accuracy, \"vehSunPntBdy\",\n                                                               testFailCount, testMessages)\n\n    testFailCount, testMessages = unitTestSupport.compareArrayND(trueTransTimeTag, transTimeTag,\n                                                                 accuracy, \"transTimeTag\", 1,\n                                                                 testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArray(trueTransPos, transPos,\n                                                               accuracy, \"sigma_BN\",\n                                                               testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArray(trueTransVel, transVel,\n                                                               accuracy, \"omega_BN_B\",\n                                                               testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArray(trueTransAccum, transAccum,\n                                                               accuracy, \"vehSunPntBdy\",\n                                                               testFailCount, testMessages)\n\n    if numAttNav == 11:\n        if module.attMsgCount != navAggregate.MAX_AGG_NAV_MSG:\n            testFailCount += 1\n            testMessages.append(\"FAILED numAttNav too large test\")\n        if module.attTimeIdx != navAggregate.MAX_AGG_NAV_MSG-1:\n            testFailCount += 1\n            testMessages.append(\"FAILED attTimeIdx too large test\")\n        if module.attIdx != navAggregate.MAX_AGG_NAV_MSG-1:\n            testFailCount += 1\n            testMessages.append(\"FAILED attIdx too large test\")\n        if module.rateIdx != navAggregate.MAX_AGG_NAV_MSG-1:\n            testFailCount += 1\n            testMessages.append(\"FAILED rateIdx too large test\")\n        if module.sunIdx != navAggregate.MAX_AGG_NAV_MSG-1:\n            testFailCount += 1\n            testMessages.append(\"FAILED sunIdx too large test\")\n\n    if numTransNav == 11:\n        if module.transMsgCount != navAggregate.MAX_AGG_NAV_MSG:\n            testFailCount += 1\n            testMessages.append(\"FAILED numTransNav too large test\")\n        if module.posIdx != navAggregate.MAX_AGG_NAV_MSG-1:\n            testFailCount += 1\n            testMessages.append(\"FAILED posIdx too large test\")\n        if module.velIdx != navAggregate.MAX_AGG_NAV_MSG-1:\n            testFailCount += 1\n            testMessages.append(\"FAILED velIdx too large test\")\n        if module.dvIdx != navAggregate.MAX_AGG_NAV_MSG-1:\n            testFailCount += 1\n            testMessages.append(\"FAILED dvIdx too large test\")\n\n    #   print out success message if no error were found\n    snippentName = \"passFail\" + str(numAttNav) + str(numTransNav)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_ephemDifference(ephBdyCount):\n    \"\"\" Test ephemDifference. \"\"\"\n    [testResults, testMessage] = ephemDifferenceTestFunction(ephBdyCount)\n    assert testResults < 1, testMessage",
  "def ephemDifferenceTestFunction(ephBdyCount):\n    \"\"\" Test the ephemDifference module. Setup a simulation, \"\"\"\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))  # Add a new task to the process\n\n    ephemDiff = ephemDifference.ephemDifference()\n\n    # This calls the algContain to setup the selfInit, update, and reset\n    ephemDiff.ModelTag = \"ephemDifference\"\n\n    # Add the module to the task\n    unitTestSim.AddModelToTask(unitTaskName, ephemDiff)\n\n    # Create the input message.\n    inputEphemBase = messaging.EphemerisMsgPayload() # The clock correlation message ?\n    # Get the Earth's position and velocity\n    position, velocity = astroFunctions.Earth_RV(astroFunctions.JulianDate([2018, 10, 16]))\n    inputEphemBase.r_BdyZero_N = position\n    inputEphemBase.v_BdyZero_N = velocity\n    inputEphemBase.timeTag = 1234.0\n    ephBaseInMsg = messaging.EphemerisMsg().write(inputEphemBase)\n    ephemDiff.ephBaseInMsg.subscribeTo(ephBaseInMsg)\n    functions = [astroFunctions.Mars_RV, astroFunctions.Jupiter_RV, astroFunctions.Saturn_RV]\n\n    changeBodyList = list()\n    ephInMsgList = list()\n    if ephBdyCount == 3:\n        for i in range(ephBdyCount):\n            # Create the change body message\n            changeBodyMsg = ephemDifference.EphemChangeConfig()\n\n            changeBodyList.append(changeBodyMsg)\n\n            # Create the input message to the change body config\n            inputMsg = messaging.EphemerisMsgPayload()\n            position, velocity = functions[i](astroFunctions.JulianDate([2018, 10, 16]))\n            inputMsg.r_BdyZero_N = position\n            inputMsg.v_BdyZero_N = velocity\n            inputMsg.timeTag = 321.0\n\n            # Set this message\n            ephInMsgList.append(messaging.EphemerisMsg().write(inputMsg))\n            changeBodyMsg.ephInMsg.subscribeTo(ephInMsgList[-1])\n\n    ephemDiff.changeBodies = changeBodyList\n\n    # the logging setup must occur on the actual ephemDiff.changeBodies[i].ephOutMsg as we are providing\n    # pointers to the message payload.  Logging changeBodyList.ephOutMsg won't work as this message has a\n    # different location.\n    dataLogList = list()\n    for i in range(ephBdyCount):\n        dataLogList.append(ephemDiff.changeBodies[i].ephOutMsg.recorder())\n        unitTestSim.AddModelToTask(unitTaskName, dataLogList[i])\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n\n    # The result isn't going to change with more time. The module will continue to produce the same result\n    unitTestSim.ConfigureStopTime(0)  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    if ephBdyCount == 3:\n        trueRVector = [[69313607.6209608,  -75620898.04028425,   -5443274.17030424],\n                       [-5.33462105e+08,  -7.56888610e+08,   1.17556184e+07],\n                       [9.94135029e+07,  -1.54721593e+09,   1.65081472e+07]]\n\n        trueVVector = [[15.04232523,  -1.13359121,   0.47668898],\n                       [23.2531093,  -33.17628299,  -0.22550391],\n                       [21.02793499, -25.86425597,  -0.38273815]]\n\n\n        posAcc = 1e1\n        velAcc = 1e-4\n        unitTestSupport.writeTeXSnippet(\"toleranceValuePos\", str(posAcc), path)\n        unitTestSupport.writeTeXSnippet(\"toleranceValueVel\", str(velAcc), path)\n\n        for i in range(ephBdyCount):\n\n            outputData_R = dataLogList[i].r_BdyZero_N\n            outputData_V = dataLogList[i].v_BdyZero_N\n            timeTag = dataLogList[i].timeTag\n            # print(timeTag)\n            # print(outputData_R)\n\n            # At each timestep, make sure the vehicleConfig values haven't changed from the initial values\n            testFailCount, testMessages = unitTestSupport.compareArrayND([trueRVector[i]], outputData_R,\n                                                                         posAcc,\n                                                                         \"ephemDifference position output body \" + str(i),\n                                                                         2, testFailCount, testMessages)\n            testFailCount, testMessages = unitTestSupport.compareArrayND([trueVVector[i]], outputData_V,\n                                                                         velAcc,\n                                                                         \"ephemDifference velocity output body \" + str(i),\n                                                                         2, testFailCount, testMessages)\n            if timeTag[0] != 321.0:\n                testFailCount += 1\n                testMessages.append(\"ephemDifference timeTag output body \" + str(i))\n\n    if ephemDiff.ephBdyCount is not ephBdyCount:\n        testFailCount += 1\n        testMessages.append(\"input/output message count is wrong.\")\n\n    snippentName = \"passFail\" + str(ephBdyCount)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + ephemDiff.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + ephemDiff.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_ephemNavConverter():\n    \"\"\" Test ephemNavConverter. \"\"\"\n    [testResults, testMessage] = ephemNavConverterTestFunction()\n    assert testResults < 1, testMessage",
  "def ephemNavConverterTestFunction():\n    \"\"\" Test the ephemNavConverter module. Setup a simulation \"\"\"\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))  # Add a new task to the process\n\n    # Construct the ephemNavConverter module\n    # Set the names for the input messages\n    ephemNav = ephemNavConverter.ephemNavConverter()\n\n    # This calls the algContain to setup the selfInit, update, and reset\n    ephemNav.ModelTag = \"ephemNavConverter\"\n\n    # Add the module to the task\n    unitTestSim.AddModelToTask(unitTaskName, ephemNav)\n\n    # Create the input message.\n    inputEphem = messaging.EphemerisMsgPayload()\n\n    # Get the Earth's position and velocity\n    position, velocity = astroFunctions.Earth_RV(astroFunctions.JulianDate([2018, 10, 16]))\n    inputEphem.r_BdyZero_N = position\n    inputEphem.v_BdyZero_N = velocity\n    inputEphem.timeTag = 1.0  # sec\n    inMsg = messaging.EphemerisMsg().write(inputEphem)\n    ephemNav.ephInMsg.subscribeTo(inMsg)\n\n    dataLog = ephemNav.stateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n\n    # The result isn't going to change with more time. The module will continue to produce the same result\n    unitTestSim.ConfigureStopTime(testProcessRate)  # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    posAcc = 1e1\n    velAcc = 1e-4\n\n    outputR = dataLog.r_BN_N\n    outputV = dataLog.v_BN_N\n    outputTime = dataLog.timeTag\n\n    trueR = [position, position]\n    trueV = [velocity, velocity]\n    trueTime = [inputEphem.timeTag, inputEphem.timeTag]\n\n    # At each timestep, make sure the vehicleConfig values haven't changed from the initial values\n    testFailCount, testMessages = unitTestSupport.compareArrayND(trueR, outputR,\n                                                                 posAcc,\n                                                                 \"ephemNavConverter output Position\",\n                                                                 2, testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareArrayND(trueV, outputV,\n                                                                 velAcc,\n                                                                 \"ephemNavConverter output Velocity\",\n                                                                 2, testFailCount, testMessages)\n    testFailCount, testMessages = unitTestSupport.compareDoubleArray(trueTime, outputTime,\n                                                                 velAcc,\n                                                                 \"ephemNavConverter output Time\",\n                                                                 testFailCount, testMessages)\n\n    #   print out success message if no error were found\n    snippentName = \"passFail\"\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + ephemNav.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + ephemNav.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_cssComm(numSensors, sensorData):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = cssCommTestFunction(numSensors, sensorData)\n    assert testResults < 1, testMessage",
  "def cssCommTestFunction(numSensors, sensorData):\n    \"\"\" Test the cssComm module \"\"\"\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # This is needed if multiple unit test scripts are run\n    # This create a fresh and consistent simulation environment for each test run\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate)) # Add a new task to the process\n\n    # Construct the cssComm module\n    module = cssComm.cssComm()\n    # Populate the config\n    module.numSensors = numSensors\n    module.maxSensorValue = 500e-6\n\n    ChebyList =  [-1.734963346951471e+06, 3.294117146099591e+06,\n                     -2.816333294617512e+06, 2.163709942144332e+06,\n                     -1.488025993860025e+06, 9.107359382775769e+05,\n                     -4.919712500291216e+05, 2.318436583511218e+05,\n                     -9.376105045529010e+04, 3.177536873430168e+04,\n                     -8.704033370738143e+03, 1.816188108176300e+03,\n                     -2.581556805090373e+02, 1.888418924282780e+01]\n    module.chebyCount = len(ChebyList)\n    module.kellyCheby = ChebyList\n\n    module.ModelTag = \"cssComm\"\n\n    # Add the module to the task\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # The cssComm module reads in from the sensor list, so create that message here\n    cssArrayMsg = messaging.CSSArraySensorMsgPayload()\n\n    # NOTE: This is nonsense. These are more or less random numbers\n    cssArrayMsg.CosValue = sensorData\n    cssInMsg = messaging.CSSArraySensorMsg().write(cssArrayMsg)\n    module.sensorListInMsg.subscribeTo(cssInMsg)\n\n    # Log the output message\n    dataLog = module.cssArrayOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n\n    unitTestSim.ConfigureStopTime(testProcessRate)\n    unitTestSim.ExecuteSimulation()\n\n    # Get the output from this simulation\n    MAX_NUM_CSS_SENSORS = messaging.MAX_NUM_CSS_SENSORS\n    outputData = dataLog.CosValue\n\n    trueCssList= [0]*MAX_NUM_CSS_SENSORS\n    if numSensors==4:\n        trueCssList[0:4] = [0.0, 0.45791653042, 1.0, 0.615444781018]\n    if numSensors==MAX_NUM_CSS_SENSORS+1:\n        trueCssList = [0.45791653042]*32\n\n    # Create the true array\n    trueCss = [\n        trueCssList,\n        trueCssList\n    ]\n\n    accuracy = 1e-6\n\n    testFailCount, testMessages = unitTestSupport.compareArrayND(trueCss, outputData, accuracy, \"cosValues\",\n                                                                 MAX_NUM_CSS_SENSORS, testFailCount, testMessages)\n\n    #   print out success message if no error were found\n    unitTestSupport.writeTeXSnippet('toleranceValue', str(accuracy), path)\n\n    snippentName = \"passFail_\"+str(numSensors)\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots):\n    \"\"\"Module Unit Test\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = rateMsgConvertFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def rateMsgConvertFunction(show_plots):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = rateMsgConverter.rateMsgConverter()\n    module.ModelTag = \"rateMsgConverter\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    inputMessageData = messaging.IMUSensorBodyMsgPayload()\n    inputMessageData.AngVelBody = [-0.1, 0.2, -0.3]\n    inMsg = messaging.IMUSensorBodyMsg().write(inputMessageData)\n    module.imuRateInMsg.subscribeTo(inMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.navRateOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n    print(\"accuracy = \" + str(accuracy))\n\n    # This pulls the actual data log from the simulation run.\n    moduleOutput = dataLog.omega_BN_B\n    # set the filtered output truth states\n    trueVector = [\n        [-0.1, 0.2, -0.3],\n        [-0.1, 0.2, -0.3],\n        [-0.1, 0.2, -0.3]\n    ]\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput,\n                                                               accuracy, \"Output Vector\",\n                                                               testFailCount, testMessages)\n\n    moduleOutput = dataLog.sigma_BN\n\n    # set the filtered output truth states\n    trueVector = [\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0]\n    ]\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput,\n                                                               accuracy, \"Output MRP Vector\",\n                                                               testFailCount, testMessages)\n\n    moduleOutput = dataLog.vehSunPntBdy\n\n    # set the filtered output truth states\n    trueVector = [\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0]\n    ]\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput,\n                                                               accuracy, \"Output sun heading Vector\",\n                                                               testFailCount, testMessages)\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(\"Failed: \" + module.ModelTag)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_module(show_plots):\n    \"\"\"\n    **Validation Test Description**\n\n    This section describes the specific unit tests conducted on this module. \\\n    The test contains 1 test and is located at ``test_tamComm.py``. \\\n    The success criteria is to match the outputs with the generated truth.\n\n    **Description of Variables Being Tested**\n\n    In this file, we are checking the values of the variable:\n\n        tam_B\n\n    which is pulled from the log data from TAMSensorBodyFswMsg to see if they match with the expected truth values.\n    \"\"\"\n\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = tamCommTestFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def tamCommTestFunction(show_plots):\n    \"\"\" Test the tamComm module \"\"\"\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"               # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"         # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)     # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = tamComm.tamComm()\n    module.ModelTag = \"tamComm\"\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    dcm3, _ = np.linalg.qr(np.random.normal(0, 1, (3, 3)))\n    module.dcm_BS = dcm3.reshape(9, 1)\n\n    # Create input message and size it because the regular creator of that message\n    # is not part of the test.\n    inputMessageData = messaging.TAMSensorMsgPayload()\n    inputMessageData.tam_S = [-1e-5, 2e-6, -3e-5]  # Tesla\n    inMsg = messaging.TAMSensorMsg().write(inputMessageData)\n    module.tamInMsg.subscribeTo(inMsg)\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.tamOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # compare the module results to the truth values\n    accuracy = 1e-12\n\n    # This pulls the actual data log from the simulation run.\n    moduleOutput = dataLog.tam_B\n    # set the filtered output truth states\n    trueVector = [\n        [-1e-5, 2e-6, -3e-5],\n        [-1e-5, 2e-6, -3e-5],\n        [-1e-5, 2e-6, -3e-5]\n    ]\n    for i in range(len(trueVector)):\n        trueVector[i] = np.dot(dcm3, trueVector[i])\n\n    testFailCount, testMessages = unitTestSupport.compareArray(trueVector, moduleOutput,\n                                                               accuracy, \"TAM Output Vector\",\n                                                               testFailCount, testMessages)\n\n    #   print out success message if no error were found\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n        print(\"This test uses an accuracy value of \" + str(accuracy))\n    else:\n        print(\"Failed: \" + module.ModelTag)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_simple_instrument_controller(show_plots, use_rate_limit, rate_limit, omega_mag, deviceStatus, controlStatus, expected_result):\n    r\"\"\"\n    **Validation Test Description**\n\n    Unit test for simpleInstrumentController. The unit test specifically covers:\n\n    1. If the controller correctly sends an image command if access and attitude error are within bounds\n\n    2. If the controller does not image until the imaged variable is reset to 0\n\n    3. If the controller sends an image command again after the imaged variable has been reset to 0\n\n    4. If the rate tolerance limit only effects operation when enabled, and effects operation in the expected manner.\n\n    5. If the controller sends an image command when deviceStatusInMsg is set to 1 and the instrumentStatus is set to 0\n\n    6. If the controller does not send an image command when deviceStatusInMsg is set to 0 and the instrumentStatus is set to 1\n\n    7. If the controller does send an image command when deviceStatusInMsg is not written and the instrumentStatus is set to 1\n    \"\"\"\n    # each test method requires a single assert method to be called\n    # pass on the testPlotFixture so that the main test function may set the DataStore attributes\n    [testResults, testMessage] = simpleInstrumentControllerTestFunction(show_plots, use_rate_limit, rate_limit, omega_mag, deviceStatus, controlStatus, expected_result)\n    \n    assert testResults < 1, testMessage",
  "def simpleInstrumentControllerTestFunction(show_plots, use_rate_limit=1, rate_limit=0.01, omega_mag=0.001, deviceStatus=None, controlStatus=None, expected_result=None):\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(1.0)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # Construct algorithm and associated C++ container\n    module = simpleInstrumentController.simpleInstrumentController()\n    module.ModelTag = \"simpleInstrumentController\"           # update python name of test module\n\n    # Add test module to runtime call list\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Initialize the test module configuration data\n    module.attErrTolerance = 0.1                           # set the attitude error tolerance\n    module.rateErrTolerance = rate_limit                   # set the attitude rate error tolerance\n    module.useRateTolerance = use_rate_limit               # enable attitude rate error tolerance\n\n    # Create and write the ground location access message\n    inputAccessMsgData = messaging.AccessMsgPayload()\n    inputAccessMsgData.hasAccess = 1\n    inputAccessMsg = messaging.AccessMsg().write(inputAccessMsgData)\n\n    # Create and write the attitude guidance message\n    inputAttGuidMsgData = messaging.AttGuidMsgPayload()\n    inputAttGuidMsgData.sigma_BR = [0.01, 0.01, 0.01]\n    inputAttGuidMsgData.omega_BR_B = [omega_mag, 0.0, 0.0]\n    inputAttGuidMsg = messaging.AttGuidMsg().write(inputAttGuidMsgData)\n\n    # Create and write the device status message\n    if deviceStatus is not None:\n        inputDeviceStatusMsgData = messaging.DeviceStatusMsgPayload()\n        inputDeviceStatusMsgData.deviceStatus = deviceStatus\n        inputDeviceStatusMsg = messaging.DeviceStatusMsg().write(inputDeviceStatusMsgData)\n        module.deviceStatusInMsg.subscribeTo(inputDeviceStatusMsg)\n    \n    # Set the controllerStatus variable\n    if controlStatus is not None:\n        module.controllerStatus = controlStatus\n\n    # Setup logging on the test module output message so that we get all the writes to it\n    dataLog = module.deviceCmdOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect the message interfaces\n    module.locationAccessInMsg.subscribeTo(inputAccessMsg)\n    module.attGuidInMsg.subscribeTo(inputAttGuidMsg)\n\n    # Need to call the self-init and cross-init methods\n    unitTestSim.InitializeSimulation()\n\n    # Set the simulation time.\n    # NOTE: the total simulation time may be longer than this value. The\n    # simulation is stopped at the next logging event on or after the\n    # simulation end time.\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))        # seconds to stop simulation\n\n    # Begin the simulation time run set above\n    unitTestSim.ExecuteSimulation()\n\n    # run the module again for an additional second\n    unitTestSim.ConfigureStopTime(macros.sec2nano(2.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # Now change the imaged variable back to 0 and run again for another image\n    module.imaged = 0\n    unitTestSim.ConfigureStopTime(macros.sec2nano(4.0))        # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    if not unitTestSupport.isArrayEqual(dataLog.deviceCmd, expected_result, len(expected_result), 1e-12):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + module.ModelTag + \" Module failed dataVector\" + \" unit test at t=\" + str(dataLog.times()[0]*macros.NANO2SEC) + \"sec\\n\")\n\n    # Plots\n    plt.close(\"all\")  # close all prior figures so we start with a clean slate\n    plt.figure(1)\n    plt.plot(dataLog.times() * macros.NANO2SEC, dataLog.deviceCmd)\n    plt.xlabel('Time [s]')\n    plt.ylabel('Device Status')\n    plt.suptitle('Device Status Over Time')\n\n    if show_plots:\n        plt.show()\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def test_smallBodyNavEKF(show_plots):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test checks that the filter converges to a constant state estimate under the presence of static measurements.\n    No thrusters are used, but a message for each is created and connected to avoid warnings.\n\n    **Test Parameters**\n\n    Args:\n        :param show_plots: flag if plots should be shown.\n    \"\"\"\n    [testResults, testMessage] = smallBodyNavEKFTestFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def smallBodyNavEKFTestFunction(show_plots):\n    \"\"\"Test method\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(0.5)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    module = smallBodyNavEKF.SmallBodyNavEKF()\n    module.ModelTag = \"smallBodyNavEKFTag\"\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Set the filter parameters (sc area, mass, gravitational constants, etc.)\n    module.A_sc = 1.  # Surface area of the spacecraft, m^2\n    module.M_sc = 100.  # Mass of the spacecraft, kg\n    module.mu_ast = 5.2  # Gravitational constant of the asteroid\n    module.Q = (0.1*np.identity(12)).tolist()  # Process Noise\n    module.R = (0.1*np.identity(12)).tolist()  # Measurement Noise\n\n    bennu_radius = 1.355887692*orbitalMotion.AU*1000.0  # meters\n    bennu_velocity = np.sqrt(orbitalMotion.MU_SUN*(1000.**3)/bennu_radius) # m/s, assumes circular orbit\n\n    x_0 = [2010., 1510., 1010., 0., 2., 0., 0.14, 0., 0., 0., 0., 0.]\n    module.x_hat_k = x_0\n    module.P_k = (0.1*np.identity(12)).tolist()\n\n    # Configure blank module input messages\n    navTransInMsgData = messaging.NavTransMsgPayload()\n    navTransInMsgData.r_BN_N = [bennu_radius + 1000., 1000., 1000.]\n    navTransInMsgData.v_BN_N = [0., bennu_velocity + 1., 0.]\n    navTransInMsg = messaging.NavTransMsg().write(navTransInMsgData)\n\n    navAttInMsgData = messaging.NavAttMsgPayload()\n    navAttInMsgData.sigma_BN = [0.1, 0.0, 0.0]\n    navAttInMsgData.omega_BN_B = [0.0, 0.0, 0.0]\n    navAttInMsg = messaging.NavAttMsg().write(navAttInMsgData)\n\n    asteroidEphemerisInMsgData = messaging.EphemerisMsgPayload()\n    asteroidEphemerisInMsgData.r_BdyZero_N = [bennu_radius, 0., 0.]\n    asteroidEphemerisInMsgData.v_BdyZero_N = [0., bennu_velocity, 0.]\n    asteroidEphemerisInMsgData.sigma_BN = [0.1, 0.0, 0.0]\n    asteroidEphemerisInMsgData.omega_BN_B = [0.0, 0.0, 0.0]\n    asteroidEphemerisInMsg = messaging.EphemerisMsg().write(asteroidEphemerisInMsgData)\n\n    sunEphemerisInMsgData = messaging.EphemerisMsgPayload()\n    sunEphemerisInMsg = messaging.EphemerisMsg().write(sunEphemerisInMsgData)\n\n    THROutputInMsgData = messaging.THROutputMsgPayload()\n    THROutputInMsg = messaging.THROutputMsg().write(THROutputInMsgData)\n\n    cmdForceInMsgData = messaging.CmdForceBodyMsgPayload()\n    cmdForceInMsg = messaging.CmdForceBodyMsg().write(cmdForceInMsgData)\n\n    # subscribe input messages to module\n    module.navTransInMsg.subscribeTo(navTransInMsg)\n    module.navAttInMsg.subscribeTo(navAttInMsg)\n    module.asteroidEphemerisInMsg.subscribeTo(asteroidEphemerisInMsg)\n    module.sunEphemerisInMsg.subscribeTo(sunEphemerisInMsg)\n    module.addThrusterToFilter(THROutputInMsg)\n    module.cmdForceBodyInMsg.subscribeTo(cmdForceInMsg)\n\n    # setup output message recorder objects\n    navTransOutMsgRec = module.navTransOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, navTransOutMsgRec)\n    smallBodyNavOutMsgRec = module.smallBodyNavOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, smallBodyNavOutMsgRec)\n    smallBodyNavOutMsgRecC = module.smallBodyNavOutMsgC.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, smallBodyNavOutMsgRecC)\n    asteroidEphemerisOutMsgRec = module.asteroidEphemerisOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, asteroidEphemerisOutMsgRec)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(10.))\n    unitTestSim.ExecuteSimulation()\n\n    x_hat = smallBodyNavOutMsgRec.state\n    x_hat_c_wrapped = smallBodyNavOutMsgRecC.state\n    true_x_hat = np.array([[1.33666664e+03,  1.18333330e+03,  1.00333330e+03, -4.77594532e-06,\n                            1.33332617,     -6.10976335e-06,  1.13333333e-01,  0.00000000,\n                            0.00000000,      0.00000000,      0.00000000,      0.00000000]])\n\n    testFailCount, testMessages = unitTestSupport.compareArray(\n        true_x_hat, np.array([x_hat[-1,:]]), 0.1, \"x_hat\",\n        testFailCount, testMessages)\n\n    testFailCount, testMessages = unitTestSupport.compareArray(\n        true_x_hat, np.array([x_hat_c_wrapped[-1,:]]), 0.1, \"x_hat_c_wrapped\",\n        testFailCount, testMessages)\n\n    plt.figure(1)\n    plt.clf()\n    plt.figure(1, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.ticklabel_format(useOffset=False)\n    plt.plot(navTransOutMsgRec.times() * 1.0E-9, x_hat[:,0], label='x-pos')\n    plt.plot(navTransOutMsgRec.times() * 1.0E-9, x_hat[:,1], label='y-pos')\n    plt.plot(navTransOutMsgRec.times() * 1.0E-9, x_hat[:,2], label='z-pos')\n    plt.legend(loc='upper left')\n    plt.xlabel('Time (s)')\n    plt.ylabel('r_BO_O (m)')\n    plt.title('Estimated Relative Spacecraft Position')\n\n    plt.figure(2)\n    plt.clf()\n    plt.figure(2, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(navTransOutMsgRec.times() * 1.0E-9, x_hat[:,3], label='x-vel')\n    plt.plot(navTransOutMsgRec.times() * 1.0E-9, x_hat[:,4], label='y-vel')\n    plt.plot(navTransOutMsgRec.times() * 1.0E-9, x_hat[:,5], label='z-vel')\n    plt.legend(loc='upper left')\n    plt.xlabel('Time (s)')\n    plt.ylabel('v_BO_O (m/s)')\n    plt.title('Estimated Spacecraft Velocity')\n\n    plt.figure(5)\n    plt.clf()\n    plt.figure(5, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(navTransOutMsgRec.times() * 1.0E-9, x_hat[:,6], label='s1')\n    plt.plot(navTransOutMsgRec.times() * 1.0E-9, x_hat[:,7], label='s2')\n    plt.plot(navTransOutMsgRec.times() * 1.0E-9, x_hat[:,8], label='s3')\n    plt.legend(loc='upper left')\n    plt.xlabel('Time (s)')\n    plt.ylabel('sigma_AN (rad)')\n    plt.title('Estimated Asteroid Attitude')\n\n    plt.figure(6)\n    plt.clf()\n    plt.figure(6, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(navTransOutMsgRec.times() * 1.0E-9, x_hat[:,9], label='omega1')\n    plt.plot(navTransOutMsgRec.times() * 1.0E-9, x_hat[:,10], label='omega2')\n    plt.plot(navTransOutMsgRec.times() * 1.0E-9, x_hat[:,11], label='omega3')\n    plt.legend(loc='upper left')\n    plt.xlabel('Time (s)')\n    plt.ylabel('omega_AN_A (rad/s)')\n    plt.title('Estimated Asteroid Rate')\n\n    if show_plots:\n        plt.show()\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, \"\".join(testMessages)]",
  "def test_smallBodyNavUKF(show_plots):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test checks that the filter converges to a constant position and null velocity estimates under the presence of static measurements.\n    Then, the non-Keplerian gravity estimation should match the Keplerian gravity with opposite sign.\n\n    **Test Parameters**\n\n    Args:\n        :param show_plots: flag if plots should be shown.\n    \"\"\"\n    [testResults, testMessage] = smallBodyNavUKFTestFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def smallBodyNavUKFTestFunction(show_plots):\n    \"\"\"Test method\"\"\"\n    testFailCount = 0\n    testMessages = []\n    unitTaskName = \"unitTask\"\n    unitProcessName = \"TestProcess\"\n\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n    testProcessRate = macros.sec2nano(15)\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\n\n    # setup module to be tested\n    module = smallBodyNavUKF.SmallBodyNavUKF()\n    module.ModelTag = \"smallBodyNavUKFTag\"\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # Set the filter parameters (hyperparameters, small body gravitational constant, noise matrices)\n    module.alpha = 0  # Filter hyperparameter\n    module.beta = 2  # Filter hyperparameter\n    module.kappa = 1e-3  # Filter hyperparameter\n    module.mu_ast = 17.2882449693*1e9  # Gravitational constant of the asteroid m^3/s^2\n    module.P_proc = (0.1*np.identity(9)).tolist()  # Process Noise\n    module.R_meas = (0.1*np.identity(3)).tolist()  # Measurement Noise\n\n    vesta_radius = 2.3612 * orbitalMotion.AU * 1000  # meters\n    vesta_velocity = np.sqrt(orbitalMotion.MU_SUN*(1000.**3)/vesta_radius) # m/s, assumes circular orbit\n\n    x_0 = [2010., 1510., 1010., 0., 2., 0., 0.14, 0., 0.]\n    module.x_hat_k = x_0\n    module.P_k = [[1000., 0., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 1000., 0., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 1000., 0., 0., 0., 0., 0., 0.],\n               [0., 0., 0., 1, 0., 0., 0., 0., 0.],\n               [0., 0., 0., 0., 1, 0., 0., 0., 0.],\n               [0., 0., 0., 0., 0., 1, 0., 0., 0.],\n               [0., 0., 0., 0., 0., 0., 1e-3, 0., 0.],\n               [0., 0., 0., 0., 0., 0., 0., 1e-3, 0.],\n               [0., 0., 0., 0., 0., 0., 0., 0., 1e-3]]\n    #module.P_k = P_k.tolist()\n\n    # Configure blank module input messages\n    navTransInMsgData = messaging.NavTransMsgPayload()\n    navTransInMsgData.r_BN_N = [vesta_radius + 600. * 1000., -400. * 1000, 200. * 1000]\n    navTransInMsgData.v_BN_N = [0., vesta_velocity, 0.]\n    navTransInMsg = messaging.NavTransMsg().write(navTransInMsgData)\n\n    asteroidEphemerisInMsgData = messaging.EphemerisMsgPayload()\n    asteroidEphemerisInMsgData.r_BdyZero_N = [vesta_radius, 0., 0.]\n    asteroidEphemerisInMsgData.v_BdyZero_N = [0., vesta_velocity, 0.]\n    asteroidEphemerisInMsgData.sigma_BN = [0.0, 0.0, 0.0]\n    asteroidEphemerisInMsgData.omega_BN_B = [0.0, 0.0, 0.0]\n    asteroidEphemerisInMsg = messaging.EphemerisMsg().write(asteroidEphemerisInMsgData)\n\n    # subscribe input messages to module\n    module.navTransInMsg.subscribeTo(navTransInMsg)\n    module.asteroidEphemerisInMsg.subscribeTo(asteroidEphemerisInMsg)\n\n    # setup output message recorder objects\n    smallBodyNavUKFOutMsgRec = module.smallBodyNavUKFOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, smallBodyNavUKFOutMsgRec)\n    smallBodyNavUKFOutMsgRecC = module.smallBodyNavUKFOutMsgC.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, smallBodyNavUKFOutMsgRecC)\n\n    unitTestSim.InitializeSimulation()\n    unitTestSim.ConfigureStopTime(macros.sec2nano(600))\n    unitTestSim.ExecuteSimulation()\n\n    x_hat = smallBodyNavUKFOutMsgRec.state\n    x_hat_c_wrapped = smallBodyNavUKFOutMsgRecC.state\n    covar = smallBodyNavUKFOutMsgRec.covar\n\n    # Since the small body does not rotate, no inhomogeneous gravity has\n    # been considered and the spacecraft velocity in the small body\n    # fixed frame is null, then the measured acceleration should correspond\n    # to the Keplerian gravity with opposite sign\n    true_r = np.array([[600. * 1000, -400. * 1000, 200. * 1000]])\n    true_v = np.array([[0., 0., 0.]])\n    true_a = module.mu_ast * true_r / (np.linalg.norm(true_r))**3\n    true_x_hat = np.zeros(9)\n    true_x_hat[0:3] = true_r\n    true_x_hat[3:6] = true_v\n    true_x_hat[6:9] = true_a\n\n    testFailCount, testMessages = unitTestSupport.compareArrayRelative(\n        [true_x_hat], np.array([x_hat[-1,:]]), 0.01, \"x_hat\",\n        testFailCount, testMessages)\n\n    testFailCount, testMessages = unitTestSupport.compareArrayRelative(\n        [true_x_hat], np.array([x_hat_c_wrapped[-1,:]]), 0.01, \"x_hat_c_wrapped\",\n        testFailCount, testMessages)\n\n    plt.figure(1)\n    plt.clf()\n    plt.figure(1, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.ticklabel_format(useOffset=False)\n    plt.plot(smallBodyNavUKFOutMsgRec.times() * 1.0E-9 / 60, x_hat[:,0] / 1000, label='x-pos')\n    plt.plot(smallBodyNavUKFOutMsgRec.times() * 1.0E-9 / 60, x_hat[:,1] / 1000, label='y-pos')\n    plt.plot(smallBodyNavUKFOutMsgRec.times() * 1.0E-9 / 60, x_hat[:,2] / 1000, label='z-pos')\n    plt.legend(loc='lower left')\n    plt.xlabel('Time (min)')\n    plt.ylabel('${}^{A}r_{BA}$ (km)')\n    plt.title('Estimated Relative Spacecraft Position')\n\n    plt.figure(2)\n    plt.clf()\n    plt.figure(2, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(smallBodyNavUKFOutMsgRec.times() * 1.0E-9 / 60, x_hat[:,3], label='x-vel')\n    plt.plot(smallBodyNavUKFOutMsgRec.times() * 1.0E-9 / 60, x_hat[:,4], label='y-vel')\n    plt.plot(smallBodyNavUKFOutMsgRec.times() * 1.0E-9 / 60, x_hat[:,5], label='z-vel')\n    plt.legend(loc='upper right')\n    plt.xlabel('Time (min)')\n    plt.ylabel('${}^{A}v_{BA}$ (m/s)')\n    plt.title('Estimated Spacecraft Velocity')\n\n    plt.figure(3)\n    plt.clf()\n    plt.figure(3, figsize=(7, 5), dpi=80, facecolor='w', edgecolor='k')\n    plt.plot(smallBodyNavUKFOutMsgRec.times() * 1.0E-9 / 60, x_hat[:,6], label='x-acc')\n    plt.plot(smallBodyNavUKFOutMsgRec.times() * 1.0E-9 / 60, x_hat[:,7], label='y-acc')\n    plt.plot(smallBodyNavUKFOutMsgRec.times() * 1.0E-9 / 60, x_hat[:,8], label='z-acc')\n    plt.legend(loc='lower right')\n    plt.xlabel('Time (min)')\n    plt.ylabel('${}^{A}a_{BA}$ (m/s^2)')\n    plt.title('Estimated Non-Keplerian Acceleration')\n\n    if show_plots:\n        plt.show()\n\n    if testFailCount == 0:\n        print(\"PASSED: \" + module.ModelTag)\n    else:\n        print(testMessages)\n\n    return [testFailCount, \"\".join(testMessages)]",
  "def test_dv_guidance(show_plots):\n    \"\"\" Test dvGuidance. \"\"\"\n    [testResults, testMessage] = dvGuidanceTestFunction(show_plots)\n    assert testResults < 1, testMessage",
  "def dvGuidanceTestFunction(show_plots):\n    \"\"\" Test the dvGuidance module. Setup a simulation, write a DvBurnCmdFswMsg, and confirm that dvGuidance outputs the\n        correct values. \"\"\"\n\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n    unitTaskName = \"unitTask\"  # arbitrary name (don't change)\n    unitProcessName = \"TestProcess\"  # arbitrary name (don't change)\n\n    # Create a sim module as an empty container\n    unitTestSim = SimulationBaseClass.SimBaseClass()\n\n    # This is needed if multiple unit test scripts are run\n    # This create a fresh and consistent simulation environment for each test run\n\n    # Create test thread\n    testProcessRate = macros.sec2nano(0.5)  # update process rate update time\n    testProc = unitTestSim.CreateNewProcess(unitProcessName)\n    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))  # Add a new task to the process\n\n    # Construct the dvGuidance module\n    module = dvGuidance.dvGuidance()\n\n    # This calls the algContain to setup the selfInit, and update\n    module.ModelTag = \"dvGuidance\"\n\n    # Add the module to the task\n    unitTestSim.AddModelToTask(unitTaskName, module)\n\n    # The dvGuidance module reads in from the dvBurnCmd, so create that message here\n    dvBurnCmdMsg = messaging.DvBurnCmdMsgPayload()\n    # NOTE: This is nonsense. These are random numbers\n    dvBurnCmdMsg.dvInrtlCmd = [5, 5, 5]\n    dvBurnCmdMsg.dvRotVecUnit = [1, 0, 0]\n    dvBurnCmdMsg.dvRotVecMag = .5\n    dvBurnCmdMsg.burnStartTime = macros.sec2nano(0.5)\n    # Write this message\n    dvBurnInMsg = messaging.DvBurnCmdMsg().write(dvBurnCmdMsg)\n\n    # Log the output message\n    # unitTestSim.TotalSim.logThisMessage(module.outputDataName, testProcessRate)\n    dataLog = module.attRefOutMsg.recorder()\n    unitTestSim.AddModelToTask(unitTaskName, dataLog)\n\n    # connect messages\n    module.burnDataInMsg.subscribeTo(dvBurnInMsg)\n\n\n    # Initialize the simulation\n    unitTestSim.InitializeSimulation()\n\n    #   Step the simulation to 3*process rate so 4 total steps including zero\n    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0)) # seconds to stop simulation\n    unitTestSim.ExecuteSimulation()\n\n    # Get the output from this simulation\n    moduleOutputName = 'dvAttGuidance'\n    outSigma = dataLog.sigma_RN\n    outOmega = dataLog.omega_RN_N\n    outDOmega = dataLog.domega_RN_N\n\n    # NOTE: these values are just from a previous run. These should be validated\n    trueSigma = [[5.69822629e-01, 1.99143700e-01, 2.72649472e-01],\n                 [6.12361487e-01, 1.31298090e-01, 3.16981631e-01],\n                 [6.50967464e-01, 5.62624705e-02, 3.61117890e-01]]\n    trueOmega = [[4.08248290e-01, -2.04124145e-01, -2.04124145e-01],\n                 [4.08248290e-01, -2.04124145e-01, -2.04124145e-01],\n                 [4.08248290e-01, -2.04124145e-01, -2.04124145e-01]]\n    trueDOmega =[[0.00000000e+00, 0.00000000e+00, 0.00000000e+00],\n                 [0.00000000e+00, 0.00000000e+00, 0.00000000e+00],\n                 [0.00000000e+00, 0.00000000e+00, 0.00000000e+00]]\n\n    accuracy = 1e-9\n    unitTestSupport.writeTeXSnippet(\"toleranceValue\", str(accuracy), path)\n\n    for i in range(len(trueSigma)):\n        # check a vector values\n        if not unitTestSupport.isArrayEqual(outSigma[i], trueSigma[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\n                \"FAILED: \" + module.ModelTag + \" Module failed sigma_RN unit test at t=\" + str(\n                    dataLog.times()[i] * macros.NANO2SEC) + \"sec\\n\")\n        if not unitTestSupport.isArrayEqual(outOmega[i], trueOmega[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\n                \"FAILED: \" + module.ModelTag + \" Module failed omega_RN_N unit test at t=\" + str(\n                    dataLog.times()[i] * macros.NANO2SEC) + \"sec\\n\")\n        if not unitTestSupport.isArrayEqual(outDOmega[i], trueDOmega[i], 3, accuracy):\n            testFailCount += 1\n            testMessages.append(\n                \"FAILED: \" + module.ModelTag + \" Module failed domega_RN_N unit test at t=\" + str(\n                    dataLog.times()[i] * macros.NANO2SEC) + \"sec\\n\")\n\n    # print(outSigma)\n    # print(outOmega)\n    # print(outDOmega)\n\n    plt.figure()\n    plt.plot(dataLog.times() * macros.NANO2SEC, outSigma[:, 0], label=\"Sigma 1\")\n    plt.plot(dataLog.times() * macros.NANO2SEC, outSigma[:, 1], label=\"Sigma 2\")\n    plt.plot(dataLog.times() * macros.NANO2SEC, outSigma[:, 2], label=\"Sigma 3\")\n    plt.legend(loc='upper left')\n    plt.xlabel('Time [s]')\n    plt.ylabel('Sigma')\n\n    plt.figure()\n    plt.plot(dataLog.times() * macros.NANO2SEC, outOmega[:, 0], label=\"Omega 1\")\n    plt.plot(dataLog.times() * macros.NANO2SEC, outOmega[:, 1], label=\"Omega 2\")\n    plt.plot(dataLog.times() * macros.NANO2SEC, outOmega[:, 2], label=\"Omega 3\")\n    plt.legend(loc='upper left')\n    plt.xlabel('Time [s]')\n    plt.ylabel('Omega [rad/s]')\n\n    plt.figure()\n    plt.plot(dataLog.times() * macros.NANO2SEC, outDOmega[:, 0], label=\"DOmega 1\")\n    plt.plot(dataLog.times() * macros.NANO2SEC, outDOmega[:, 1], label=\"DOmega 2\")\n    plt.plot(dataLog.times() * macros.NANO2SEC, outDOmega[:, 2], label=\"DOmega 3\")\n    plt.legend(loc='upper left')\n    plt.xlabel('Time [s]')\n    plt.ylabel('DOmega')\n\n    if show_plots:\n        plt.show()\n\n    snippentName = \"passFail\"\n    if testFailCount == 0:\n        colorText = 'ForestGreen'\n        print(\"PASSED: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"PASSED\" + '}'\n    else:\n        colorText = 'Red'\n        print(\"Failed: \" + module.ModelTag)\n        passedText = r'\\textcolor{' + colorText + '}{' + \"Failed\" + '}'\n    unitTestSupport.writeTeXSnippet(snippentName, passedText, path)\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_PySysModel():\n    testResults, testMessage = 0, []\n\n    #  Create a sim module as an empty container\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    #  create the simulation process\n    dynProcess = scSim.CreateNewProcess(\"dynamicsProcess\")\n\n    # create the dynamics task and specify the integration update time\n    dynProcess.addTask(scSim.CreateNewTask(\"dynamicsTask\", macros.sec2nano(5.)))\n\n    # create copies of the Basilisk modules\n    mod1 = cModuleTemplate.cModuleTemplate()\n    mod1.ModelTag = \"cModule1\"\n\n    mod2 = cppModuleTemplate.CppModuleTemplate()\n    mod2.ModelTag = \"cppModule2\"\n\n    mod3 = cModuleTemplate.cModuleTemplate()\n    mod3.ModelTag = \"cModule3\"\n\n    mod4 = PythonModule()\n    mod4.ModelTag = \"pythonModule4\"\n\n    mod2.dataInMsg.subscribeTo(mod4.dataOutMsg)\n\n    scSim.AddModelToTask(\"dynamicsTask\", mod1, 0)\n    scSim.AddModelToTask(\"dynamicsTask\", mod2, 5)\n    scSim.AddModelToTask(\"dynamicsTask\", mod3, 15)\n    scSim.AddModelToTask(\"dynamicsTask\", mod4, 10)\n\n    # Set up recording\n    mod2MsgRecorder = mod2.dataOutMsg.recorder()\n    scSim.AddModelToTask(\"dynamicsTask\", mod2MsgRecorder)\n\n    # initialize Simulation:\n    scSim.InitializeSimulation()\n\n    # configure a simulation stop time and execute the simulation run\n    scSim.ConfigureStopTime(macros.sec2nano(5.0))\n    scSim.ExecuteSimulation()\n\n    if mod4.CallCounts != 2:\n        testResults += 1\n        testMessage.append(\"TestPythonModule::UpdateState was not called\")\n\n    if mod2MsgRecorder.dataVector[1,1] == 0:\n        testResults += 1\n        testMessage.append(\"Message from TestPythonModule was not connected to message in mod2\")\n    elif mod2MsgRecorder.dataVector[1,1] == 1:\n        testResults += 1\n        testMessage.append(\"TestPythonModule does not run before mod2 despite having greater priority\")\n\n    assert testResults < 1, testMessage",
  "class PythonModule(sysModel.SysModel):\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        self.dataOutMsg = messaging.CModuleTemplateMsg()\n\n    def Reset(self, CurrentSimNanos):\n        payload = self.dataOutMsg.zeroMsgPayload\n        payload.dataVector = np.array([0,0,0])\n        self.dataOutMsg.write(payload, CurrentSimNanos, self.moduleID)\n        self.bskLogger.bskLog(bskLogging.BSK_INFORMATION, \"Reset in TestPythonModule\")\n\n    def UpdateState(self, CurrentSimNanos):\n        payload = self.dataOutMsg.zeroMsgPayload\n        payload.dataVector = self.dataOutMsg.read().dataVector + np.array([0,1,0])\n        self.dataOutMsg.write(payload, CurrentSimNanos, self.moduleID)\n        self.bskLogger.bskLog(bskLogging.BSK_INFORMATION, f\"Python Module ID {self.moduleID} ran Update at {CurrentSimNanos*1e-9}s\")",
  "def __init__(self, *args):\n        super().__init__(*args)\n        self.dataOutMsg = messaging.CModuleTemplateMsg()",
  "def Reset(self, CurrentSimNanos):\n        payload = self.dataOutMsg.zeroMsgPayload\n        payload.dataVector = np.array([0,0,0])\n        self.dataOutMsg.write(payload, CurrentSimNanos, self.moduleID)\n        self.bskLogger.bskLog(bskLogging.BSK_INFORMATION, \"Reset in TestPythonModule\")",
  "def UpdateState(self, CurrentSimNanos):\n        payload = self.dataOutMsg.zeroMsgPayload\n        payload.dataVector = self.dataOutMsg.read().dataVector + np.array([0,1,0])\n        self.dataOutMsg.write(payload, CurrentSimNanos, self.moduleID)\n        self.bskLogger.bskLog(bskLogging.BSK_INFORMATION, f\"Python Module ID {self.moduleID} ran Update at {CurrentSimNanos*1e-9}s\")",
  "def test_RecordingInputMessages():\n    \"\"\"\n    testing recording a C-wrapped input message with the recorder module\n    \"\"\"\n\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    #  Create a sim module as an empty container\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    #  create the simulation process\n    dynProcess = scSim.CreateNewProcess(\"dynamicsProcess\")\n\n    # create the dynamics task and specify the integration update time\n    dynProcess.addTask(scSim.CreateNewTask(\"dynamicsTask\", macros.sec2nano(1.)))\n\n    # create modules\n    mod1 = cModuleTemplate.cModuleTemplate()\n    mod1.ModelTag = \"cModule1\"\n    scSim.AddModelToTask(\"dynamicsTask\", mod1)\n\n    # Write input data\n    inputData = messaging.CModuleTemplateMsgPayload()\n    inputData.dataVector = [1, 2, 3]\n    inputDataMsg = messaging.CModuleTemplateMsg().write(inputData)\n\n    # Subscribe input message to stand alone message\n    mod1.dataInMsg.subscribeTo(inputDataMsg)\n\n    # Create recorders tied to IO messages\n    dataInRec = mod1.dataInMsg.recorder()\n    scSim.AddModelToTask(\"dynamicsTask\", dataInRec)\n    dataOutRec = mod1.dataOutMsg.recorder()\n    scSim.AddModelToTask(\"dynamicsTask\", dataOutRec)\n\n    attGuidMsg = messaging.CModuleTemplateMsg_C()\n    attGuidMsgPayload = messaging.CModuleTemplateMsgPayload()\n    attGuidMsg.write(attGuidMsgPayload)\n    messaging.CModuleTemplateMsg_C_addAuthor(mod1.dataOutMsg, attGuidMsg)\n    dataOut2Rec = attGuidMsg.recorder()\n    scSim.AddModelToTask(\"dynamicsTask\", dataOut2Rec)\n\n    #  initialize Simulation:\n    scSim.InitializeSimulation()\n\n    #   configure a simulation stop time and execute the simulation run\n    scSim.ConfigureStopTime(macros.sec2nano(1.0))\n    scSim.ExecuteSimulation()\n\n    # reading the module output message show not change the earlier redirection\n    # further, we are testing that the read() command copies the payload from\n    # the stand alone msg to the module output module\n    tempSet = mod1.dataOutMsg.read().dataVector\n    scSim.ConfigureStopTime(macros.sec2nano(2.0))\n    scSim.ExecuteSimulation()\n\n    # print(dataInRec.dataVector)\n    # print(dataOutRec.dataVector)\n    # print(dataOut2Rec.dataVector)\n\n    testFailCount, testMessages = uts.compareArray([inputData.dataVector]*3\n                                                   , dataInRec.dataVector\n                                                   , 0.01\n                                                   , \"recorded input message was not correct.\"\n                                                   , testFailCount\n                                                   , testMessages)\n\n    testFailCount, testMessages = uts.compareArray([[0, 0, 0], [0, 0, 0], [3, 2, 3]]\n                                                   , dataOutRec.dataVector\n                                                   , 0.01\n                                                   , \"recorded module output message was not correct.\"\n                                                   , testFailCount\n                                                   , testMessages)\n\n    testFailCount, testMessages = uts.compareArray([[2, 2, 3], [3, 2, 3], [4, 2, 3]]\n                                                   , dataOut2Rec.dataVector\n                                                   , 0.01\n                                                   , \"recorded redirected module output message was not correct.\"\n                                                   , testFailCount\n                                                   , testMessages)\n\n    testFailCount, testMessages = uts.compareArray([[4., 2., 3.]]\n                                                   , [mod1.dataOutMsg.read().dataVector]\n                                                   , 0.01\n                                                   , \"read of module output message was not correct.\"\n                                                   , testFailCount\n                                                   , testMessages)\n\n    testFailCount, testMessages = uts.compareArray([[4, 2, 3]]\n                                                   , [attGuidMsg.read().dataVector]\n                                                   , 0.01\n                                                   , \"read of module redirected output message was not correct.\"\n                                                   , testFailCount\n                                                   , testMessages)\n\n    if testFailCount:\n        print(testMessages)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    assert testFailCount < 1, testMessages",
  "def test_CMsgTimeWritten():\n    \"\"\"\n    testing recording timeWritten in C-wrapped message\n    \"\"\"\n\n    bskLogging.setDefaultLogLevel(bskLogging.BSK_WARNING)\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    #  Create a sim module as an empty container\n    scSim = SimulationBaseClass.SimBaseClass()\n\n    #  create the simulation process\n    dynProcess = scSim.CreateNewProcess(\"dynamicsProcess\")\n\n    # create the dynamics task and specify the integration update time\n    dynProcess.addTask(scSim.CreateNewTask(\"dynamicsTask\", macros.sec2nano(1.)))\n\n    # create modules\n    mod1 = cModuleTemplate.cModuleTemplate()\n    mod1.ModelTag = \"cModule1\"\n    scSim.AddModelToTask(\"dynamicsTask\", mod1)\n    mod1.dataInMsg.subscribeTo(mod1.dataOutMsg)\n\n    # setup message recording\n    msgRec = mod1.dataOutMsg.recorder()\n    scSim.AddModelToTask(\"dynamicsTask\", msgRec)\n\n    #  initialize Simulation:\n    scSim.InitializeSimulation()\n\n    #   configure a simulation stop time time and execute the simulation run\n    scSim.ConfigureStopTime(macros.sec2nano(1.0))\n    scSim.ExecuteSimulation()\n\n    testFailCount, testMessages = uts.compareVector(msgRec.timesWritten()\n                                                    , msgRec.times()\n                                                    , 0.01\n                                                    , \"recorded msg timesWritten was not correct.\"\n                                                    , testFailCount\n                                                    , testMessages)\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    assert testFailCount < 1, testMessages",
  "class GenerateMessages:\n\n    \"\"\"\n    A class to generate C and C++ messages using a defined template before the build.\n\n    Attributes:\n        pathToExternalModules: string\n                path to add messages for external module (default empty string)\n\n    \"\"\"\n    def __init__(self, pathToExternalModules):\n        self.messageTemplate = \"\"\n        self.headerTemplate = \"\"\n        self.autoSourceDestDir = '../../../../dist3/autoSource/'\n        self.destinationDir = os.path.join(self.autoSourceDestDir, 'cMsgCInterface/')\n        self.pathToExternalModules = pathToExternalModules\n        with open('./cMsgCInterfacePy.i.in', 'r') as f:\n            self.swig_template_block = f.read()\n        self.swigTemplate = \"\"\n        self.messagingAutoData = list()\n\n\n    def __createMessageAndHeaderTemplate(self):\n        \"\"\"\n        A method which reads the license and README add create messageTemplate and headerTemplate\n        \"\"\"\n        licenseREADME = list()\n        with open(\"../../../../LICENSE\", 'r') as f:\n            licenseREADME.extend([\"/*\", f.read(),\"*/\\n\\n\"])\n        with open('./README.in', 'r') as r:\n            licenseREADME.append(r.read())\n        self.messageTemplate = ''.join(licenseREADME)\n        self.headerTemplate = ''.join(licenseREADME)\n        with open('./msg_C.cpp.in', 'r') as f:\n            self.messageTemplate += f.read()\n        with open('./msg_C.h.in', 'r') as f:\n            self.headerTemplate += f.read()\n\n    def __recreateDestinationDirectory(self):\n        \"\"\"\n        Method to delete the existing destination directory and recreate it.\n        \"\"\"\n        if os.path.exists(self.autoSourceDestDir):\n            shutil.rmtree(self.autoSourceDestDir, ignore_errors=True)\n        try:\n            os.makedirs(os.path.dirname(self.autoSourceDestDir))\n        except OSError as exc:  # Guard against race condition\n            if exc.errno != errno.EEXIST:\n                raise\n        print(self.destinationDir)\n        os.makedirs(os.path.dirname(self.destinationDir))\n\n    def __generateMessagingHeaderInterface(self):\n        \"\"\"\n        Method to generate message header interface. It is empty for windows.\n        \"\"\"\n        messaging_header_i_template = \"\"\n        if platform == \"linux\" or platform == \"linux2\":\n            messaging_header_i_template = \"#define SWIGWORDSIZE64\\n\"\n        with open(self.autoSourceDestDir + 'messaging.header.auto.i', 'w') as w:\n            w.write(messaging_header_i_template)\n\n    def __createMessageC(self,parentPath, external=False):\n        \"\"\"\n        Method to add C messages to messaging.auto.i file which will be used to create swig interface for messaging\n        \"\"\"\n        if external:\n            messaging_i_template = \"\"\n            relativePath = os.path.relpath(self.pathToExternalModules, \"../../../architecture\").replace(\"\\\\\",\n                                                                                                        \"/\")\n        else:\n            messaging_i_template = \"//C messages:\"\n        for file in os.listdir(f\"{parentPath}/msgPayloadDefC\"):\n            if file.endswith(\".h\"):\n                msgName = (os.path.splitext(file)[0])[:-7]\n                if external:\n                    messaging_i_template += f\"\\nINSTANTIATE_TEMPLATES({msgName}, {msgName}Payload, {relativePath}/msgPayloadDefC)\"\n                else:\n                    messaging_i_template += f\"\\nINSTANTIATE_TEMPLATES({msgName}, {msgName}Payload, msgPayloadDefC)\"\n        with open(self.autoSourceDestDir + 'messaging.auto.i', 'a') as w:\n            w.write(messaging_i_template)\n\n    def __createMessageCpp(self,parentPath, external=False):\n        \"\"\"\n        Method to add Cpp messages to messaging.auto.i file which will be used to create swig interface for messaging\n        \"\"\"\n        if external:\n            messaging_i_template = \"\"\n        else:\n            messaging_i_template = \"\\n\\n//C++ messages:\"\n        for file in os.listdir(f\"{parentPath}/msgPayloadDefCpp\"):\n            if file.endswith(\".h\"):\n                msgName = (os.path.splitext(file)[0])[:-7]\n                if external:\n                    relativePath = os.path.relpath(self.pathToExternalModules, \"../../../architecture\").replace(\"\\\\\",\n                                                                                                               \"/\")\n                    messaging_i_template += f\"\\nINSTANTIATE_TEMPLATES({msgName}, {msgName}Payload, {relativePath}/msgPayloadDefCpp)\"\n                else:\n                    messaging_i_template += f\"\\nINSTANTIATE_TEMPLATES({msgName}, {msgName}Payload, msgPayloadDefCpp)\"\n        with open(self.autoSourceDestDir + 'messaging.auto.i', 'a') as w:\n            w.write(messaging_i_template)\n\n    def __generateMessages(self):\n        \"\"\"\n        Method which call create messages methods for c and Cpp messages for basilisk as well as external messages\n        \"\"\"\n        # append all C msg definitions to the dist3/autoSource/messaging.auto.i file that is imported into messaging.auto.i\n        self.__createMessageC(\"../..\")\n        if self.pathToExternalModules and os.path.exists(os.path.join(self.pathToExternalModules,\"msgPayloadDefC\")):\n            self.__createMessageC(self.pathToExternalModules,True)\n\n        with open(self.autoSourceDestDir + 'messaging.auto.i', 'r') as fb:\n            self.messagingAutoData = fb.readlines()\n        # The following cpp message definitions must be included after the `self.messagingAutoData` variable is set above.\n        # We only need to create Python interfaces to C++ messages, not C wrappers.\n        self.__createMessageCpp(\"../..\")\n        if self.pathToExternalModules and os.path.exists(\n                os.path.join(self.pathToExternalModules, \"msgPayloadDefCpp\")):\n\n            self.__createMessageCpp(self.pathToExternalModules, True)\n\n    def __toMessage(self, structData):\n        \"\"\"\n        Method to generate Cpp wrapper for C messages.\n        \"\"\"\n        if structData:\n            structData = structData.replace(' ', '').split(',')\n            structName = structData[0]\n            sourceHeaderFile = f\"{structData[2]}/{structName}Payload.h\"\n            definitions = self.messageTemplate.format(type=structName)\n            header = self.headerTemplate.format(type=structName, structHeader=sourceHeaderFile)\n            self.swigTemplate.write(self.swig_template_block.format(type=structName))\n            file_name = os.path.join(self.destinationDir, structName + '_C')\n            definitionsFile = file_name + '.cpp'\n            header_file = file_name + '.h'\n            with open(definitionsFile, 'w') as w:\n                w.write(definitions)\n            with open(header_file, 'w') as w:\n                w.write(header)\n\n    def initialize(self):\n        \"\"\"\n        Method to initialize class members.\n        \"\"\"\n        self.__createMessageAndHeaderTemplate()\n        self.__recreateDestinationDirectory()\n        self.__generateMessagingHeaderInterface()\n\n    def run(self):\n        \"\"\"\n        Method to run the generation workflow\n        \"\"\"\n        self.__generateMessages()\n        # create swig file for C-msg C interface methods\n        self.swigTemplate = open(self.autoSourceDestDir + 'cMsgCInterfacePy.auto.i', 'w')\n        templateCall = 'INSTANTIATE_TEMPLATES({:dat})'\n        for line in self.messagingAutoData:\n            parse.parse(templateCall, line.strip(), dict(dat=self.__toMessage))\n        self.swigTemplate.close()",
  "def __init__(self, pathToExternalModules):\n        self.messageTemplate = \"\"\n        self.headerTemplate = \"\"\n        self.autoSourceDestDir = '../../../../dist3/autoSource/'\n        self.destinationDir = os.path.join(self.autoSourceDestDir, 'cMsgCInterface/')\n        self.pathToExternalModules = pathToExternalModules\n        with open('./cMsgCInterfacePy.i.in', 'r') as f:\n            self.swig_template_block = f.read()\n        self.swigTemplate = \"\"\n        self.messagingAutoData = list()",
  "def __createMessageAndHeaderTemplate(self):\n        \"\"\"\n        A method which reads the license and README add create messageTemplate and headerTemplate\n        \"\"\"\n        licenseREADME = list()\n        with open(\"../../../../LICENSE\", 'r') as f:\n            licenseREADME.extend([\"/*\", f.read(),\"*/\\n\\n\"])\n        with open('./README.in', 'r') as r:\n            licenseREADME.append(r.read())\n        self.messageTemplate = ''.join(licenseREADME)\n        self.headerTemplate = ''.join(licenseREADME)\n        with open('./msg_C.cpp.in', 'r') as f:\n            self.messageTemplate += f.read()\n        with open('./msg_C.h.in', 'r') as f:\n            self.headerTemplate += f.read()",
  "def __recreateDestinationDirectory(self):\n        \"\"\"\n        Method to delete the existing destination directory and recreate it.\n        \"\"\"\n        if os.path.exists(self.autoSourceDestDir):\n            shutil.rmtree(self.autoSourceDestDir, ignore_errors=True)\n        try:\n            os.makedirs(os.path.dirname(self.autoSourceDestDir))\n        except OSError as exc:  # Guard against race condition\n            if exc.errno != errno.EEXIST:\n                raise\n        print(self.destinationDir)\n        os.makedirs(os.path.dirname(self.destinationDir))",
  "def __generateMessagingHeaderInterface(self):\n        \"\"\"\n        Method to generate message header interface. It is empty for windows.\n        \"\"\"\n        messaging_header_i_template = \"\"\n        if platform == \"linux\" or platform == \"linux2\":\n            messaging_header_i_template = \"#define SWIGWORDSIZE64\\n\"\n        with open(self.autoSourceDestDir + 'messaging.header.auto.i', 'w') as w:\n            w.write(messaging_header_i_template)",
  "def __createMessageC(self,parentPath, external=False):\n        \"\"\"\n        Method to add C messages to messaging.auto.i file which will be used to create swig interface for messaging\n        \"\"\"\n        if external:\n            messaging_i_template = \"\"\n            relativePath = os.path.relpath(self.pathToExternalModules, \"../../../architecture\").replace(\"\\\\\",\n                                                                                                        \"/\")\n        else:\n            messaging_i_template = \"//C messages:\"\n        for file in os.listdir(f\"{parentPath}/msgPayloadDefC\"):\n            if file.endswith(\".h\"):\n                msgName = (os.path.splitext(file)[0])[:-7]\n                if external:\n                    messaging_i_template += f\"\\nINSTANTIATE_TEMPLATES({msgName}, {msgName}Payload, {relativePath}/msgPayloadDefC)\"\n                else:\n                    messaging_i_template += f\"\\nINSTANTIATE_TEMPLATES({msgName}, {msgName}Payload, msgPayloadDefC)\"\n        with open(self.autoSourceDestDir + 'messaging.auto.i', 'a') as w:\n            w.write(messaging_i_template)",
  "def __createMessageCpp(self,parentPath, external=False):\n        \"\"\"\n        Method to add Cpp messages to messaging.auto.i file which will be used to create swig interface for messaging\n        \"\"\"\n        if external:\n            messaging_i_template = \"\"\n        else:\n            messaging_i_template = \"\\n\\n//C++ messages:\"\n        for file in os.listdir(f\"{parentPath}/msgPayloadDefCpp\"):\n            if file.endswith(\".h\"):\n                msgName = (os.path.splitext(file)[0])[:-7]\n                if external:\n                    relativePath = os.path.relpath(self.pathToExternalModules, \"../../../architecture\").replace(\"\\\\\",\n                                                                                                               \"/\")\n                    messaging_i_template += f\"\\nINSTANTIATE_TEMPLATES({msgName}, {msgName}Payload, {relativePath}/msgPayloadDefCpp)\"\n                else:\n                    messaging_i_template += f\"\\nINSTANTIATE_TEMPLATES({msgName}, {msgName}Payload, msgPayloadDefCpp)\"\n        with open(self.autoSourceDestDir + 'messaging.auto.i', 'a') as w:\n            w.write(messaging_i_template)",
  "def __generateMessages(self):\n        \"\"\"\n        Method which call create messages methods for c and Cpp messages for basilisk as well as external messages\n        \"\"\"\n        # append all C msg definitions to the dist3/autoSource/messaging.auto.i file that is imported into messaging.auto.i\n        self.__createMessageC(\"../..\")\n        if self.pathToExternalModules and os.path.exists(os.path.join(self.pathToExternalModules,\"msgPayloadDefC\")):\n            self.__createMessageC(self.pathToExternalModules,True)\n\n        with open(self.autoSourceDestDir + 'messaging.auto.i', 'r') as fb:\n            self.messagingAutoData = fb.readlines()\n        # The following cpp message definitions must be included after the `self.messagingAutoData` variable is set above.\n        # We only need to create Python interfaces to C++ messages, not C wrappers.\n        self.__createMessageCpp(\"../..\")\n        if self.pathToExternalModules and os.path.exists(\n                os.path.join(self.pathToExternalModules, \"msgPayloadDefCpp\")):\n\n            self.__createMessageCpp(self.pathToExternalModules, True)",
  "def __toMessage(self, structData):\n        \"\"\"\n        Method to generate Cpp wrapper for C messages.\n        \"\"\"\n        if structData:\n            structData = structData.replace(' ', '').split(',')\n            structName = structData[0]\n            sourceHeaderFile = f\"{structData[2]}/{structName}Payload.h\"\n            definitions = self.messageTemplate.format(type=structName)\n            header = self.headerTemplate.format(type=structName, structHeader=sourceHeaderFile)\n            self.swigTemplate.write(self.swig_template_block.format(type=structName))\n            file_name = os.path.join(self.destinationDir, structName + '_C')\n            definitionsFile = file_name + '.cpp'\n            header_file = file_name + '.h'\n            with open(definitionsFile, 'w') as w:\n                w.write(definitions)\n            with open(header_file, 'w') as w:\n                w.write(header)",
  "def initialize(self):\n        \"\"\"\n        Method to initialize class members.\n        \"\"\"\n        self.__createMessageAndHeaderTemplate()\n        self.__recreateDestinationDirectory()\n        self.__generateMessagingHeaderInterface()",
  "def run(self):\n        \"\"\"\n        Method to run the generation workflow\n        \"\"\"\n        self.__generateMessages()\n        # create swig file for C-msg C interface methods\n        self.swigTemplate = open(self.autoSourceDestDir + 'cMsgCInterfacePy.auto.i', 'w')\n        templateCall = 'INSTANTIATE_TEMPLATES({:dat})'\n        for line in self.messagingAutoData:\n            parse.parse(templateCall, line.strip(), dict(dat=self.__toMessage))\n        self.swigTemplate.close()",
  "def test_BSpline(show_plots, P, XDot_flag, XDDot_flag, accuracy):\n    r\"\"\"\n    **Validation Test Description**\n\n    This unit test script tests the capability of the BSpline function to correctly interpolate \n    a series of points in 3 dimensions.\n    The coordinates of these 7 points are stored in 3 numpy arrays:\n\n    X1 = np.array([0, 1, 2, 3, 4, 5, 6])\n\n    X2 = np.array([5, 4, 3, 2, 1, 0, 1])\n\n    X3 = np.array([3, 2, 1, 2, 3, 4, 5]).\n\n    The input arrays are initialized through ``Input = BSpline.InputDataSet(X1, X2, X3)``. \n    The time tags at which each waypoint is to be hit are provided through ``Input.setT([0, 2, 3, 5, 7, 8, 10])``. \n    Alternatively, it is possible to specify the average velocity norm through ``Input.setAvgXDot()``.\n    The endpoint derivatives are specified through the methods:\n\n    - ``Input.setXDot_0()`` for starting point first-order derivative;\n    - ``Input.setXDot_N()`` for last point first-order derivative;\n    - ``Input.setXDDot_0()`` for starting point second-order derivative;\n    - ``Input.setXDDot_N()`` for last point second-order derivative.\n\n    Each method to specify the derivatives takes in a 3-dimensional numpy array.\n    The output data structure is created with ``Output = BSpline.OutputDataSet()``.\n    The interpolation happens calling the method ``BSpline.interpolate(Input, N, P, Output)`` where:\n\n    - N is the desired number of equally spaced data points in the interpolated function;\n    \n    - P is the polynomial order of the B-Spline function. The order should be at least 3 when first-order derivatives are specified, \n      and 5 when second-order derivatives are specified. The maximum oder is P = n + k - 1, with n being the number of waypoints and k\n      being the number of endpoint derivatives that are being specified.\n\n    **Test Parameters**\n\n    As this is a parameterized unit test, note that the test case parameters values are shown automatically in the\n    pytest HTML report.  This sample script has the parameters param1 and param 2.  Provide a description of what\n    each parameter controls.  This is a convenient location to include the accuracy variable used in the\n    validation test.\n\n    Args:\n        P (int): polynomial order of the B-Spline curve;\n        XDot_flag (bool) : whether the first-order end point derivatives should be specified;\n        XDDot_flag (bool) : whether the second-order end point derivatives should be specified;\n        accuracy (float): absolute accuracy value used in the validation tests.\n\n    **Description of Variables Being Tested**\n\n    This unit test checks the correctness of the interpolated function: \n    - a check is performed on whether or not each waypoint is hit at the specified time;\n    - when the derivatives are specified, it checks whether the starting point derivative actually matches the input derivative.\n    \"\"\"\n    \n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = BSplineTestFunction(P, XDot_flag, XDDot_flag, accuracy)\n    assert testResults < 1, testMessage",
  "def BSplineTestFunction(P, XDot_flag, XDDot_flag, accuracy):\n\n    testFailCount = 0                       # zero unit test result counter\n    testMessages = []                       # create empty array to store test log messages\n\n    X1 = np.array([0, 1, 2, 3, 4, 5, 6])\n    X2 = np.array([5, 4, 3, 2, 1, 0, 1])\n    X3 = np.array([3, 2, 1, 2, 3, 4, 5])\n\n    Input = BSpline.InputDataSet(X1, X2, X3)\n    Input.setT([0, 2, 3, 5, 7, 8, 10])\n    if XDot_flag:\n        Input.setXDot_0([0, 0, 0])\n        Input.setXDot_N([0, 0, 0])\n    if XDDot_flag:\n        Input.setXDDot_0([0, 0, 0])\n        Input.setXDDot_N([0.2, 0, 0])\n\n    Output = BSpline.OutputDataSet()\n    BSpline.interpolate(Input, 101, P, Output)\n\n    for i in range(len(Output.T)):\n        for j in range(len(Input.T)):\n            if abs(Output.T[i][0] - Input.T[j][0]) < accuracy:\n                if not abs(Output.X1[i][0] - X1[j]) < accuracy:\n                    testFailCount += 1\n                    testMessages.append(\"FAILED: BSpline.\" + \" Function of order {} failed coordinate #1 check at time t = {}\".format(P,Input.T[j][0]))\n                if not abs(Output.X2[i][0] - X2[j]) < accuracy:\n                    testFailCount += 1\n                    testMessages.append(\"FAILED: BSpline.\" + \" Function of order {} failed coordinate #2 check at time t = {}\".format(P,Input.T[j][0]))\n                if not abs(Output.X3[i][0] - X3[j]) < accuracy:\n                    testFailCount += 1\n                    testMessages.append(\"FAILED: BSpline.\" + \" Function of order {} failed coordinate #3 check at time t = {}\".format(P,Input.T[j][0]))\n    if XDot_flag:\n        if not ((abs(Output.XD1[0][0]-Input.XDot_0[0][0]) < accuracy) and \n                (abs(Output.XD2[0][0]-Input.XDot_0[1][0]) < accuracy) and \n                (abs(Output.XD3[0][0]-Input.XDot_0[2][0]) < accuracy)):\n            testFailCount += 1\n            testMessages.append(\"FAILED: BSpline.\" + \" Function of order {} failed first derivative at starting point\".format(P))\n    if XDDot_flag:\n        if not ((abs(Output.XDD1[0][0]-Input.XDDot_0[0][0]) < accuracy) and \n                (abs(Output.XDD2[0][0]-Input.XDDot_0[1][0]) < accuracy) and \n                (abs(Output.XDD3[0][0]-Input.XDDot_0[2][0]) < accuracy)):\n            testFailCount += 1\n            testMessages.append(\"FAILED: BSpline.\" + \" Function of order {} failed second derivative at starting point\".format(P))\n\n\n    return [testFailCount, ''.join(testMessages)]",
  "def test_unitDynamicsModes(testName):\n    \"\"\"AVS Library Self Check\"\"\"\n    # each test method requires a single assert method to be called\n    [testResults, testMessage] = unitAVSLibrarySelfCheck(testName)\n    assert testResults < 1, testMessage",
  "def unitAVSLibrarySelfCheck(testName):\n    testFailCount = 0  # zero unit test result counter\n    testMessages = []  # create empty array to store test log messages\n\n    if testName == \"testRigidBodyKinematics\":\n        errorCount = avsLibrarySelfCheck.testRigidBodyKinematics(1e-10)\n        if errorCount:\n            testFailCount += errorCount\n            testMessages.append(\"ERROR: Rigid Body Kinematics Library Failed Self Test.\\n\")\n    if testName == \"testOrbitalAnomalies\":\n        errorCount = avsLibrarySelfCheck.testOrbitalAnomalies(1e-10)\n        if errorCount:\n            testFailCount += errorCount\n            testMessages.append(\"ERROR: Orbital Anomalies Library Failed Self Test.\\n\")\n    if testName == \"testOrbitalHill\":\n        errorCount = avsLibrarySelfCheck.testOrbitalHill(1e-4)\n        if errorCount:\n            testFailCount += errorCount\n            testMessages.append(\"ERROR: Orbital Hill Library Failed Self Test.\\n\")\n    if testName == \"testLinearAlgebra\":\n        errorCount = avsLibrarySelfCheck.testLinearAlgebra(1e-10)\n        if errorCount:\n            testFailCount += errorCount\n            testMessages.append(\"ERROR: Linear Algebra Library Failed Self Test.\\n\")\n\n    if testFailCount == 0:\n        print(\"PASSED \")\n        passFailText = \"PASSED\"\n        colorText = 'ForestGreen'  # color to write auto-documented \"PASSED\" message in in LATEX\n        snippetContent = \"\"\n    else:\n        print(testFailCount)\n        print(testMessages)\n        passFailText = 'FAILED'\n        colorText = 'Red'  # color to write auto-documented \"FAILED\" message in in LATEX\n        snippetContent = \"\"\n        for message in testMessages:\n            snippetContent += message\n\n    fileName = os.path.basename(os.path.splitext(__file__)[0])\n    path = os.path.dirname(os.path.abspath(__file__))\n\n    snippetMsgName = fileName + 'Msg-' + testName\n    unitTestSupport.writeTeXSnippet(snippetMsgName, snippetContent, path + \"/../_Documentation/\")\n\n    snippetPassFailName = fileName + 'TestMsg-' + testName\n    snippetContent = r'\\textcolor{' + colorText + '}{' + passFailText + '}'\n    unitTestSupport.writeTeXSnippet(snippetPassFailName, snippetContent, path + \"/../_Documentation/\")\n\n    # each test method requires a single assert method to be called\n    # this check below just makes sure no sub-test failures were found\n    return [testFailCount, ''.join(testMessages)]",
  "def get_class_without_warning():\n    with deprecated.catch_warnings():\n        deprecated.filterwarnings(\n            \"ignore\", \"SwigDeprecatedTestClass.SwigDeprecatedTestClass\"\n        )\n        return swigDeprecatedCheck.SwigDeprecatedTestClass()",
  "def test_test1():\n    \"\"\"Checks that stand-alone functions generates appropriate warnings\"\"\"\n    with pytest.warns(deprecated.BSKUrgentDeprecationWarning, match=\"(.*)test1 Msg\"):\n        swigDeprecatedCheck.test1(0, 0)",
  "def test_class():\n    \"\"\"Checks that instantiating classes generates appropriate warnings\"\"\"\n    with pytest.warns(deprecated.BSKDeprecationWarning, match=\"(.*)class Msg\"):\n        swigDeprecatedCheck.SwigDeprecatedTestClass()",
  "def test_test2():\n    \"\"\"Checks that calling class methods generates appropriate warnings\"\"\"\n    testClass = get_class_without_warning()\n    with pytest.warns(deprecated.BSKUrgentDeprecationWarning, match=\"(.*)test2 Msg\"):\n        testClass.test2()",
  "def test_test3():\n    \"\"\"Checks that calling class methods generates appropriate warnings\"\"\"\n    testClass = get_class_without_warning()\n    with pytest.warns(deprecated.BSKDeprecationWarning, match=\"(.*)test3 Msg\"):\n        testClass.test3()",
  "def test_test4_set():\n    \"\"\"Checks that setting deprecated variables generates appropriate warnings\"\"\"\n    testClass = get_class_without_warning()\n    with pytest.warns(deprecated.BSKDeprecationWarning, match=\"(.*)test4 Msg\"):\n        testClass.test4 = 1\n\n        assert testClass.test4 == 1",
  "def test_test4_get():\n    \"\"\"Checks that calling deprecated variables generates appropriate warnings\"\"\"\n    testClass = get_class_without_warning()\n    with pytest.warns(deprecated.BSKDeprecationWarning, match=\"(.*)test4 Msg\"):\n        _ = testClass.test4",
  "def test_unitKeplerianOrbit(show_plots=False):\n    \"\"\"Module Unit Test\"\"\"\n    [testResults, testMessage] = unitKeplerianOrbit(show_plots)\n    assert testResults < 1, testMessage",
  "def unitKeplerianOrbit(show_plots=False):\n    \"\"\"\n    Unit Test Keplerian Orbit object\n\n    This test covers:\n    1) elem to rv conversion\n    2) orbit energy calculation\n    3) orbital period calculation\n    4) mean motion calculation\n    5) changing individual orbital elements\n    6) copy constructor\n    7) constructor with arguments\n    8) constructor without arguments\n\n    Parameters\n    ----------\n    show_plots : bool\n        unused. required for Basilisk test suite\n\n    Returns\n    -------\n    testFailCount : int\n        number of tests that failed\n    testMessages : str\n        a string of all of the failure messages\n    \"\"\"\n    testFailCount = 0\n    testMessages = []\n\n    # constructor without arguments\n    orb = keplerianOrbit.KeplerianOrbit()\n    assert orb.a() == 100000.\n    if not orb.a() == 100000.:\n        testFailCount += 1\n        testMessages.append('default constructor failure')\n\n    # constructor with arguments\n    oe = orb.oe()\n    orb2 = keplerianOrbit.KeplerianOrbit(oe, orbitalMotion.MU_EARTH)\n    assert orb2.r_BP_P() == orb.r_BP_P()\n    if not orb2.r_BP_P() == orb.r_BP_P():\n        testFailCount += 1\n        testMessages.append('Argumented constructor failure')\n\n    # copy constructor\n    orb3 = keplerianOrbit.KeplerianOrbit(orb2)\n    assert orb2.v_BP_P() == orb3.v_BP_P()\n    if not orb2.v_BP_P() == orb3.v_BP_P():\n        testFailCount += 1\n        testMessages.append('Copy Constructor Failure')\n    try:\n        orb4 = copy(orb3)\n    except:\n        assert False\n        testFailCount += 1\n        testMessages.append('python copy not working')\n\n    # changing orbital elements\n    orb3.set_f(0.0)\n    init_r = orb3.r()\n    orb3.set_f(1.)\n    assert init_r != orb3.r()\n    if init_r == orb3.r():\n        testFailCount += 1\n        testMessages.append('Failure to change element')\n    orb3.set_f(0.0)\n    assert init_r == orb3.r()\n    if init_r != orb3.r():\n        testFailCount += 1\n        testMessages.append('Failure to change element')\n\n    # mean motion calc\n    expected_n = np.sqrt(orbitalMotion.MU_EARTH / orb3.a()**3)\n    assert orb3.n() == expected_n\n    if not orb3.n() == expected_n:\n        testFailCount += 1\n        testMessages.append('Bad mean motion calc')\n\n    # orbital period calc\n    assert orb3.P() == 2 * np.pi / expected_n\n    if not orb3.P() == 2 * np.pi / expected_n:\n        testFailCount += 1\n        testMessages.append('Bad period calc')\n\n    # orbital energy calc\n    expected_E = -orbitalMotion.MU_EARTH / 2.0 / orb3.a()\n    assert orb3.Energy() == expected_E\n    if not orb3.Energy() == expected_E:\n        testFailCount += 1\n        testMessages.append('Bad energy calc')\n\n    # rv calc\n    expected_r, expected_v = orbitalMotion.elem2rv(orbitalMotion.MU_EARTH, orb3.oe())\n    dist = np.linalg.norm(np.array(orb3.r_BP_P()).flatten() - expected_r)\n    assert dist == 0.0\n    if not dist == 0.0:\n        testFailCount += 1\n        testMessages.append('RV conversion failure')\n\n    return [testFailCount, ''.join(testMessages)]",
  "def getData(type: str):\n    if type.lower() == \"mrpd\":\n        return [0, 0.5, 0], [[0], [0.5], [0]]\n    if type.lower() == \"quaterniond\":\n        return [0, 0, 1, 0], [[0], [0], [1], [0]]\n\n    scalar = type[-1]\n    isMatrix = \"matrix\" in type.lower()\n    dimensions = type[:-1].lower().replace(\"matrix\", \"\").replace(\"vector\", \"\")\n\n    if len(dimensions) == 1:\n        if isMatrix:\n            dimensions += dimensions\n        else:\n            dimensions += \"1\"\n\n    size = [7 if dim == \"x\" else int(dim) for dim in dimensions]\n\n    i = 0.5\n    inputData = []\n    outputData = []\n\n    def lambda_gen(i):\n        return int(i) if scalar == \"i\" else i\n\n    for _ in range(size[0]):\n        if size[1] == 1:\n            val = lambda_gen(i)\n            inputData.append(val)\n            outputData.append([val])\n            i += 1\n        else:\n            val = lambda_gen(i)\n            inputData.append([])\n            outputData.append([])\n            for _ in range(size[1]):\n                inputData[-1].append(val)\n                outputData[-1].append(val)\n                i += 1\n\n    return inputData, outputData",
  "def getRotationData(input: str, output: str):\n    if input == \"mrpd\":\n        input_data = [0, 0.5, 0]\n        if output == \"mrpd\":\n            output_data = np.array([[0], [0.5], [0]])\n        elif output == \"quaterniond\":\n            output_data = rbk.MRP2EP([0, 0.5, 0]).reshape(4, 1)\n        else:\n            raise ValueError(f\"Unknown output type {output}\")\n\n    elif input == \"quaterniond\":\n        input_data = np.array([[0], [0.5], [0], [0.2]])\n        input_data /= np.linalg.norm(input_data)\n        if output == \"mrpd\":\n            output_data = rbk.EP2MRP(input_data).reshape(3, 1)\n        elif output == \"quaterniond\":\n            output_data = input_data\n        else:\n            raise ValueError(f\"Unknown output type {output}\")\n\n    elif input == \"rotationMatrix\":\n        input_data = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]])\n        if output == \"mrpd\":\n            output_data = rbk.C2MRP(input_data).reshape(3, 1)\n        elif output == \"quaterniond\":\n            output_data = rbk.C2EP(input_data).reshape(4, 1)\n        else:\n            raise ValueError(f\"Unknown output type {output}\")\n\n    else:\n        raise ValueError(f\"Unknown input type {input}\")\n\n    return input_data, output_data",
  "def test_simpleInputOutput(attr: str, useNumpy: bool):\n    testClass = SwigEigenTestClass()\n\n    inputData, outputData = getData(attr)\n\n    setattr(testClass, attr, np.array(inputData) if useNumpy else inputData)\n    retrieved = getattr(testClass, attr)\n\n    assert outputData == retrieved, f\"{attr} {retrieved}\"",
  "def test_illegal(keyword: str, attr: str, data):\n    testClass = SwigEigenTestClass()\n\n    with pytest.raises(ValueError, match=rf\".*{keyword}.*\"):\n        setattr(testClass, attr, data)",
  "def test_rotation(input: str, output: str):\n    testClass = SwigEigenTestClass()\n\n    inpData, outData = getRotationData(input, output)\n\n    setattr(testClass, output, inpData)\n    retrieved = getattr(testClass, output)\n\n    np.testing.assert_almost_equal(outData, np.array(retrieved), 8)",
  "def test_precedence(functionName: str):\n    testClass = SwigEigenTestClass()\n    testData = [1, 2, 3]\n\n    assert getattr(testClass, functionName)(testData)",
  "def test_antiPrecedence(functionName: str, testData):\n    testClass = SwigEigenTestClass()\n\n    assert not getattr(testClass, functionName)(testData)",
  "def test_nullPointerReturn():\n    testClass = SwigEigenTestClass()\n    data = [[1.0], [2.0], [3.0]]\n    testClass.vector3d = data\n\n    # returnVector3dPointer will return a nullptr if True is passed\n    # otherwise, it returns vector3d\n\n    assert testClass.returnVector3dPointer(True) is None\n    assert testClass.returnVector3dPointer(False) == data",
  "def test_qualifiers(qualifier: str, attr: str):\n    testClass = SwigEigenTestClass()\n\n    functionName = f\"qualifierTest{attr}{qualifier}\"\n\n    inputData, outputData = getData(attr)\n\n    try:\n        getattr(testClass, functionName)(inputData)\n    except TypeError:\n        assert False, \"Cannot call method with qualifiers from\" + functionName\n\n    retrieved = getattr(testClass, attr)\n    assert outputData == retrieved",
  "def lambda_gen(i):\n        return int(i) if scalar == \"i\" else i",
  "def _pipe_segment_with_colons(align, colwidth):\n    \"\"\"Return a segment of a horizontal line with optional colons which\n    indicate column's alignment (as in `pipe` output format).\"\"\"\n    w = colwidth\n    if align in [\"right\", \"decimal\"]:\n        return ('-' * (w - 1)) + \":\"\n    elif align == \"center\":\n        return \":\" + ('-' * (w - 2)) + \":\"\n    elif align == \"left\":\n        return \":\" + ('-' * (w - 1))\n    else:\n        return '-' * w",
  "def _pipe_line_with_colons(colwidths, colaligns):\n    \"\"\"Return a horizontal line with optional colons to indicate column's\n    alignment (as in `pipe` output format).\"\"\"\n    segments = [_pipe_segment_with_colons(a, w) for a, w in zip(colaligns, colwidths)]\n    return \"|\" + \"|\".join(segments) + \"|\"",
  "def _mediawiki_row_with_attrs(separator, cell_values, colwidths, colaligns):\n    alignment = { \"left\":    '',\n                  \"right\":   'align=\"right\"| ',\n                  \"center\":  'align=\"center\"| ',\n                  \"decimal\": 'align=\"right\"| ' }\n    # hard-coded padding _around_ align attribute and value together\n    # rather than padding parameter which affects only the value\n    values_with_attrs = [' ' + alignment.get(a, '') + c + ' '\n                         for c, a in zip(cell_values, colaligns)]\n    colsep = separator*2\n    return (separator + colsep.join(values_with_attrs)).rstrip()",
  "def _html_row_with_attrs(celltag, cell_values, colwidths, colaligns):\n    alignment = { \"left\":    '',\n                  \"right\":   ' style=\"text-align: right;\"',\n                  \"center\":  ' style=\"text-align: center;\"',\n                  \"decimal\": ' style=\"text-align: right;\"' }\n    values_with_attrs = [\"<{0}{1}>{2}</{0}>\".format(celltag, alignment.get(a, ''), c)\n                         for c, a in zip(cell_values, colaligns)]\n    return \"<tr>\" + \"\".join(values_with_attrs).rstrip() + \"</tr>\"",
  "def _latex_line_begin_tabular(colwidths, colaligns, booktabs=False):\n    alignment = { \"left\": \"l\", \"right\": \"r\", \"center\": \"c\", \"decimal\": \"r\" }\n    tabular_columns_fmt = \"\".join([alignment.get(a, \"l\") for a in colaligns])\n    return \"\\n\".join([r\"\\begin{tabular}{\" + tabular_columns_fmt + \"}\",\n                      r\"\\toprule\" if booktabs else r\"\\hline\"])",
  "def _latex_row(cell_values, colwidths, colaligns):\n    def escape_char(c):\n        return LATEX_ESCAPE_RULES.get(c, c)\n    escaped_values = [\"\".join(map(escape_char, cell)) for cell in cell_values]\n    rowfmt = DataRow(\"\", \"&\", r\"\\\\\")\n    return _build_simple_row(escaped_values, rowfmt)",
  "def simple_separated_format(separator):\n    \"\"\"Construct a simple TableFormat with columns separated by a separator.\n\n    >>> tsv = simple_separated_format(\"\\\\t\") ; \\\n        tabulate([[\"foo\", 1], [\"spam\", 23]], tablefmt=tsv) == 'foo \\\\t 1\\\\nspam\\\\t23'\n    True\n\n    \"\"\"\n    return TableFormat(None, None, None, None,\n                       headerrow=DataRow('', separator, ''),\n                       datarow=DataRow('', separator, ''),\n                       padding=0, with_header_hide=None)",
  "def _isconvertible(conv, string):\n    try:\n        n = conv(string)\n        return True\n    except (ValueError, TypeError):\n        return False",
  "def _isnumber(string):\n    \"\"\"\n    >>> _isnumber(\"123.45\")\n    True\n    >>> _isnumber(\"123\")\n    True\n    >>> _isnumber(\"spam\")\n    False\n    \"\"\"\n    return _isconvertible(float, string)",
  "def _isint(string, inttype=int):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is inttype or\\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type))\\\n            and\\\n            _isconvertible(inttype, string)",
  "def _type(string, has_invisible=True):\n    \"\"\"The least generic type (type(None), int, float, str, unicode).\n\n    >>> _type(None) is type(None)\n    True\n    >>> _type(\"foo\") is type(\"\")\n    True\n    >>> _type(\"1\") is type(1)\n    True\n    >>> _type('\\x1b[31m42\\x1b[0m') is type(42)\n    True\n    >>> _type('\\x1b[31m42\\x1b[0m') is type(42)\n    True\n\n    \"\"\"\n\n    if has_invisible and \\\n       (isinstance(string, _text_type) or isinstance(string, _binary_type)):\n        string = _strip_invisible(string)\n\n    if string is None:\n        return _none_type\n    elif hasattr(string, \"isoformat\"):  # datetime.datetime, date, and time\n        return _text_type\n    elif _isint(string):\n        return int\n    elif _isint(string, _long_type):\n        return _long_type\n    elif _isnumber(string):\n        return float\n    elif isinstance(string, _binary_type):\n        return _binary_type\n    else:\n        return _text_type",
  "def _afterpoint(string):\n    \"\"\"Symbols after a decimal point, -1 if the string lacks the decimal point.\n\n    >>> _afterpoint(\"123.45\")\n    2\n    >>> _afterpoint(\"1001\")\n    -1\n    >>> _afterpoint(\"eggs\")\n    -1\n    >>> _afterpoint(\"123e45\")\n    2\n\n    \"\"\"\n    if _isnumber(string):\n        if _isint(string):\n            return -1\n        else:\n            pos = string.rfind(\".\")\n            pos = string.lower().rfind(\"e\") if pos < 0 else pos\n            if pos >= 0:\n                return len(string) - pos - 1\n            else:\n                return -1  # no point\n    else:\n        return -1",
  "def _padleft(width, s, has_invisible=True):\n    \"\"\"Flush right.\n\n    >>> _padleft(6, '\\u044f\\u0439\\u0446\\u0430') == '  \\u044f\\u0439\\u0446\\u0430'\n    True\n\n    \"\"\"\n    iwidth = width + len(s) - len(_strip_invisible(s)) if has_invisible else width\n    fmt = \"{0:>%ds}\" % iwidth\n    return fmt.format(s)",
  "def _padright(width, s, has_invisible=True):\n    \"\"\"Flush left.\n\n    >>> _padright(6, '\\u044f\\u0439\\u0446\\u0430') == '\\u044f\\u0439\\u0446\\u0430  '\n    True\n\n    \"\"\"\n    iwidth = width + len(s) - len(_strip_invisible(s)) if has_invisible else width\n    fmt = \"{0:<%ds}\" % iwidth\n    return fmt.format(s)",
  "def _padboth(width, s, has_invisible=True):\n    \"\"\"Center string.\n\n    >>> _padboth(6, '\\u044f\\u0439\\u0446\\u0430') == ' \\u044f\\u0439\\u0446\\u0430 '\n    True\n\n    \"\"\"\n    iwidth = width + len(s) - len(_strip_invisible(s)) if has_invisible else width\n    fmt = \"{0:^%ds}\" % iwidth\n    return fmt.format(s)",
  "def _strip_invisible(s):\n    \"Remove invisible ANSI color codes.\"\n    if isinstance(s, _text_type):\n        return re.sub(_invisible_codes, \"\", s)\n    else:  # a bytestring\n        return re.sub(_invisible_codes_bytes, \"\", s)",
  "def _visible_width(s):\n    \"\"\"Visible width of a printed string. ANSI color codes are removed.\n\n    >>> _visible_width('\\x1b[31mhello\\x1b[0m'), _visible_width(\"world\")\n    (5, 5)\n\n    \"\"\"\n    if isinstance(s, _text_type) or isinstance(s, _binary_type):\n        return len(_strip_invisible(s))\n    else:\n        return len(_text_type(s))",
  "def _align_column(strings, alignment, minwidth=0, has_invisible=True):\n    \"\"\"[string] -> [padded_string]\n\n    >>> list(map(str,_align_column([\"12.345\", \"-1234.5\", \"1.23\", \"1234.5\", \"1e+234\", \"1.0e234\"], \"decimal\")))\n    ['   12.345  ', '-1234.5    ', '    1.23   ', ' 1234.5    ', '    1e+234 ', '    1.0e234']\n\n    >>> list(map(str,_align_column(['123.4', '56.7890'], None)))\n    ['123.4', '56.7890']\n\n    \"\"\"\n    if alignment == \"right\":\n        strings = [s.strip() for s in strings]\n        padfn = _padleft\n    elif alignment == \"center\":\n        strings = [s.strip() for s in strings]\n        padfn = _padboth\n    elif alignment == \"decimal\":\n        if has_invisible:\n            decimals = [_afterpoint(_strip_invisible(s)) for s in strings]\n        else:\n            decimals = [_afterpoint(s) for s in strings]\n        maxdecimals = max(decimals)\n        strings = [s + (maxdecimals - decs) * \" \"\n                   for s, decs in zip(strings, decimals)]\n        padfn = _padleft\n    elif not alignment:\n        return strings\n    else:\n        strings = [s.strip() for s in strings]\n        padfn = _padright\n\n    if has_invisible:\n        width_fn = _visible_width\n    else:\n        width_fn = len\n\n    maxwidth = max(max(list(map(width_fn, strings))), minwidth)\n    padded_strings = [padfn(maxwidth, s, has_invisible) for s in strings]\n    return padded_strings",
  "def _more_generic(type1, type2):\n    types = { _none_type: 0, int: 1, float: 2, _binary_type: 3, _text_type: 4 }\n    invtypes = { 4: _text_type, 3: _binary_type, 2: float, 1: int, 0: _none_type }\n    moregeneric = max(types.get(type1, 4), types.get(type2, 4))\n    return invtypes[moregeneric]",
  "def _column_type(strings, has_invisible=True):\n    \"\"\"The least generic type all column values are convertible to.\n\n    >>> _column_type([\"1\", \"2\"]) is _int_type\n    True\n    >>> _column_type([\"1\", \"2.3\"]) is _float_type\n    True\n    >>> _column_type([\"1\", \"2.3\", \"four\"]) is _text_type\n    True\n    >>> _column_type([\"four\", '\\u043f\\u044f\\u0442\\u044c']) is _text_type\n    True\n    >>> _column_type([None, \"brux\"]) is _text_type\n    True\n    >>> _column_type([1, 2, None]) is _int_type\n    True\n    >>> import datetime as dt\n    >>> _column_type([dt.datetime(1991,2,19), dt.time(17,35)]) is _text_type\n    True\n\n    \"\"\"\n    types = [_type(s, has_invisible) for s in strings ]\n    return reduce(_more_generic, types, int)",
  "def _format(val, valtype, floatfmt, missingval=\"\", has_invisible=True):\n    \"\"\"Format a value accoding to its type.\n\n    Unicode is supported:\n\n    >>> hrow = ['\\u0431\\u0443\\u043a\\u0432\\u0430', '\\u0446\\u0438\\u0444\\u0440\\u0430'] ; \\\n        tbl = [['\\u0430\\u0437', 2], ['\\u0431\\u0443\\u043a\\u0438', 4]] ; \\\n        good_result = '\\\\u0431\\\\u0443\\\\u043a\\\\u0432\\\\u0430      \\\\u0446\\\\u0438\\\\u0444\\\\u0440\\\\u0430\\\\n-------  -------\\\\n\\\\u0430\\\\u0437             2\\\\n\\\\u0431\\\\u0443\\\\u043a\\\\u0438           4' ; \\\n        tabulate(tbl, headers=hrow) == good_result\n    True\n\n    \"\"\"\n    if val is None:\n        return missingval\n\n    if valtype in [int, _long_type, _text_type]:\n        return \"{0}\".format(val)\n    elif valtype is _binary_type:\n        try:\n            return _text_type(val, \"ascii\")\n        except TypeError:\n            return _text_type(val)\n    elif valtype is float:\n        is_a_colored_number = has_invisible and isinstance(val, (_text_type, _binary_type))\n        if is_a_colored_number:\n            raw_val = _strip_invisible(val)\n            formatted_val = format(float(raw_val), floatfmt)\n            return val.replace(raw_val, formatted_val)\n        else:\n            return format(float(val), floatfmt)\n    else:\n        return \"{0}\".format(val)",
  "def _align_header(header, alignment, width):\n    if alignment == \"left\":\n        return _padright(width, header)\n    elif alignment == \"center\":\n        return _padboth(width, header)\n    elif not alignment:\n        return \"{0}\".format(header)\n    else:\n        return _padleft(width, header)",
  "def _normalize_tabular_data(tabular_data, headers):\n    \"\"\"Transform a supported data type to a list of lists, and a list of headers.\n\n    Supported tabular data types:\n\n    * list-of-lists or another iterable of iterables\n\n    * list of named tuples (usually used with headers=\"keys\")\n\n    * list of dicts (usually used with headers=\"keys\")\n\n    * list of OrderedDicts (usually used with headers=\"keys\")\n\n    * 2D NumPy arrays\n\n    * NumPy record arrays (usually used with headers=\"keys\")\n\n    * dict of iterables (usually used with headers=\"keys\")\n\n    * pandas.DataFrame (usually used with headers=\"keys\")\n\n    The first row can be used as headers if headers=\"firstrow\",\n    column indices can be used as headers if headers=\"keys\".\n\n    \"\"\"\n\n    if hasattr(tabular_data, \"keys\") and hasattr(tabular_data, \"values\"):\n        # dict-like and pandas.DataFrame?\n        if hasattr(tabular_data.values, \"__call__\"):\n            # likely a conventional dict\n            keys = list(tabular_data.keys())\n            rows = list(zip_longest(*list(tabular_data.values())))  # columns have to be transposed\n        elif hasattr(tabular_data, \"index\"):\n            # values is a property, has .index => it's likely a pandas.DataFrame (pandas 0.11.0)\n            keys = list(tabular_data.keys())\n            vals = tabular_data.values  # values matrix doesn't need to be transposed\n            names = tabular_data.index\n            rows = [[v]+list(row) for v,row in zip(names, vals)]\n        else:\n            raise ValueError(\"tabular data doesn't appear to be a dict or a DataFrame\")\n\n        if headers == \"keys\":\n            headers = list(map(_text_type,keys))  # headers should be strings\n\n    else:  # it's a usual an iterable of iterables, or a NumPy array\n        rows = list(tabular_data)\n\n        if (headers == \"keys\" and\n            hasattr(tabular_data, \"dtype\") and\n            getattr(tabular_data.dtype, \"names\")):\n            # numpy record array\n            headers = tabular_data.dtype.names\n        elif (headers == \"keys\"\n              and len(rows) > 0\n              and isinstance(rows[0], tuple)\n              and hasattr(rows[0], \"_fields\")):\n            # namedtuple\n            headers = list(map(_text_type, rows[0]._fields))\n        elif (len(rows) > 0\n              and isinstance(rows[0], dict)):\n            # dict or OrderedDict\n            uniq_keys = set() # implements hashed lookup\n            keys = [] # storage for set\n            if headers == \"firstrow\":\n                firstdict = rows[0] if len(rows) > 0 else {}\n                keys.extend(list(firstdict.keys()))\n                uniq_keys.update(keys)\n                rows = rows[1:]\n            for row in rows:\n                for k in list(row.keys()):\n                    #Save unique items in input order\n                    if k not in uniq_keys:\n                        keys.append(k)\n                        uniq_keys.add(k)\n            if headers == 'keys':\n                headers = keys\n            elif isinstance(headers, dict):\n                # a dict of headers for a list of dicts\n                headers = [headers.get(k, k) for k in keys]\n                headers = list(map(_text_type, headers))\n            elif headers == \"firstrow\":\n                if len(rows) > 0:\n                    headers = [firstdict.get(k, k) for k in keys]\n                    headers = list(map(_text_type, headers))\n                else:\n                    headers = []\n            elif headers:\n                raise ValueError('headers for a list of dicts is not a dict or a keyword')\n            rows = [[row.get(k) for k in keys] for row in rows]\n        elif headers == \"keys\" and len(rows) > 0:\n            # keys are column indices\n            headers = list(map(_text_type, list(range(len(rows[0])))))\n\n    # take headers from the first row if necessary\n    if headers == \"firstrow\" and len(rows) > 0:\n        headers = list(map(_text_type, rows[0])) # headers should be strings\n        rows = rows[1:]\n\n    headers = list(map(_text_type,headers))\n    rows = list(map(list,rows))\n\n    # pad with empty headers for initial columns if necessary\n    if headers and len(rows) > 0:\n       nhs = len(headers)\n       ncols = len(rows[0])\n       if nhs < ncols:\n           headers = [\"\"]*(ncols - nhs) + headers\n\n    return rows, headers",
  "def tabulate(tabular_data, headers=(), tablefmt=\"simple\",\n             floatfmt=\"g\", numalign=\"decimal\", stralign=\"left\",\n             missingval=\"\"):\n    \"\"\"Format a fixed width table for pretty printing.\n\n    >>> print(tabulate([[1, 2.34], [-56, \"8.999\"], [\"2\", \"10001\"]]))\n    ---  ---------\n      1      2.34\n    -56      8.999\n      2  10001\n    ---  ---------\n\n    The first required argument (`tabular_data`) can be a\n    list-of-lists (or another iterable of iterables), a list of named\n    tuples, a dictionary of iterables, an iterable of dictionaries,\n    a two-dimensional NumPy array, NumPy record array, or a Pandas'\n    dataframe.\n\n\n    **Table headers**\n\n    To print nice column headers, supply the second argument (`headers`):\n\n      - `headers` can be an explicit list of column headers\n      - if `headers=\"firstrow\"`, then the first row of data is used\n      - if `headers=\"keys\"`, then dictionary keys or column indices are used\n\n    Otherwise a headerless table is produced.\n\n    If the number of headers is less than the number of columns, they\n    are supposed to be names of the last columns. This is consistent\n    with the plain-text format of R and Pandas' dataframes.\n\n    >>> print(tabulate([[\"sex\",\"age\"],[\"Alice\",\"F\",24],[\"Bob\",\"M\",19]],\n    ...       headers=\"firstrow\"))\n           sex      age\n    -----  -----  -----\n    Alice  F         24\n    Bob    M         19\n\n\n    **Column alignment**\n\n    `tabulate` tries to detect column types automatically, and aligns\n    the values properly. By default it aligns decimal points of the\n    numbers (or flushes integer numbers to the right), and flushes\n    everything else to the left. Possible column alignments\n    (`numalign`, `stralign`) are: \"right\", \"center\", \"left\", \"decimal\"\n    (only for `numalign`), and None (to disable alignment).\n\n\n    **Table formats**\n\n    `floatfmt` is a format specification used for columns which\n    contain numeric data with a decimal point.\n\n    `None` values are replaced with a `missingval` string:\n\n    >>> print(tabulate([[\"spam\", 1, None],\n    ...                 [\"eggs\", 42, 3.14],\n    ...                 [\"other\", None, 2.7]], missingval=\"?\"))\n    -----  --  ----\n    spam    1  ?\n    eggs   42  3.14\n    other   ?  2.7\n    -----  --  ----\n\n    Various plain-text table formats (`tablefmt`) are supported:\n    'plain', 'simple', 'grid', 'pipe', 'orgtbl', 'rst', 'mediawiki',\n    'latex', and 'latex_booktabs'. Variable `tabulate_formats` contains the list of\n    currently supported formats.\n\n    \"plain\" format doesn't use any pseudographics to draw tables,\n    it separates columns with a double space:\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]],\n    ...                 [\"strings\", \"numbers\"], \"plain\"))\n    strings      numbers\n    spam         41.9999\n    eggs        451\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]], tablefmt=\"plain\"))\n    spam   41.9999\n    eggs  451\n\n    \"simple\" format is like Pandoc simple_tables:\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]],\n    ...                 [\"strings\", \"numbers\"], \"simple\"))\n    strings      numbers\n    ---------  ---------\n    spam         41.9999\n    eggs        451\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]], tablefmt=\"simple\"))\n    ----  --------\n    spam   41.9999\n    eggs  451\n    ----  --------\n\n    \"grid\" is similar to tables produced by Emacs table.el package or\n    Pandoc grid_tables:\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]],\n    ...                [\"strings\", \"numbers\"], \"grid\"))\n    +-----------+-----------+\n    | strings   |   numbers |\n    +===========+===========+\n    | spam      |   41.9999 |\n    +-----------+-----------+\n    | eggs      |  451      |\n    +-----------+-----------+\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]], tablefmt=\"grid\"))\n    +------+----------+\n    | spam |  41.9999 |\n    +------+----------+\n    | eggs | 451      |\n    +------+----------+\n\n    \"fancy_grid\" draws a grid using box-drawing characters:\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]],\n    ...                [\"strings\", \"numbers\"], \"fancy_grid\"))\n    \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\n    \u2502 strings   \u2502   numbers \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 spam      \u2502   41.9999 \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502 eggs      \u2502  451      \u2502\n    \u2558\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255b\n\n    \"pipe\" is like tables in PHP Markdown Extra extension or Pandoc\n    pipe_tables:\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]],\n    ...                [\"strings\", \"numbers\"], \"pipe\"))\n    | strings   |   numbers |\n    |:----------|----------:|\n    | spam      |   41.9999 |\n    | eggs      |  451      |\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]], tablefmt=\"pipe\"))\n    |:-----|---------:|\n    | spam |  41.9999 |\n    | eggs | 451      |\n\n    \"orgtbl\" is like tables in Emacs org-mode and orgtbl-mode. They\n    are slightly different from \"pipe\" format by not using colons to\n    define column alignment, and using a \"+\" sign to indicate line\n    intersections:\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]],\n    ...                [\"strings\", \"numbers\"], \"orgtbl\"))\n    | strings   |   numbers |\n    |-----------+-----------|\n    | spam      |   41.9999 |\n    | eggs      |  451      |\n\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]], tablefmt=\"orgtbl\"))\n    | spam |  41.9999 |\n    | eggs | 451      |\n\n    \"rst\" is like a simple table format from reStructuredText; please\n    note that reStructuredText accepts also \"grid\" tables:\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]],\n    ...                [\"strings\", \"numbers\"], \"rst\"))\n    =========  =========\n    strings      numbers\n    =========  =========\n    spam         41.9999\n    eggs        451\n    =========  =========\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]], tablefmt=\"rst\"))\n    ====  ========\n    spam   41.9999\n    eggs  451\n    ====  ========\n\n    \"mediawiki\" produces a table markup used in Wikipedia and on other\n    MediaWiki-based sites:\n\n    >>> print(tabulate([[\"strings\", \"numbers\"], [\"spam\", 41.9999], [\"eggs\", \"451.0\"]],\n    ...                headers=\"firstrow\", tablefmt=\"mediawiki\"))\n    {| class=\"wikitable\" style=\"text-align: left;\"\n    |+ <!-- caption -->\n    |-\n    ! strings   !! align=\"right\"|   numbers\n    |-\n    | spam      || align=\"right\"|   41.9999\n    |-\n    | eggs      || align=\"right\"|  451\n    |}\n\n    \"html\" produces HTML markup:\n\n    >>> print(tabulate([[\"strings\", \"numbers\"], [\"spam\", 41.9999], [\"eggs\", \"451.0\"]],\n    ...                headers=\"firstrow\", tablefmt=\"html\"))\n    <table>\n    <tr><th>strings  </th><th style=\"text-align: right;\">  numbers</th></tr>\n    <tr><td>spam     </td><td style=\"text-align: right;\">  41.9999</td></tr>\n    <tr><td>eggs     </td><td style=\"text-align: right;\"> 451     </td></tr>\n    </table>\n\n    \"latex\" produces a tabular environment of LaTeX document markup:\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]], tablefmt=\"latex\"))\n    \\\\begin{tabular}{lr}\n    \\\\hline\n     spam &  41.9999 \\\\\\\\\n     eggs & 451      \\\\\\\\\n    \\\\hline\n    \\\\end{tabular}\n\n    \"latex_booktabs\" produces a tabular environment of LaTeX document markup\n    using the booktabs.sty package:\n\n    >>> print(tabulate([[\"spam\", 41.9999], [\"eggs\", \"451.0\"]], tablefmt=\"latex_booktabs\"))\n    \\\\begin{tabular}{lr}\n    \\\\toprule\n     spam &  41.9999 \\\\\\\\\n     eggs & 451      \\\\\\\\\n    \\\\bottomrule\n    \\\\end{tabular}\n    \"\"\"\n    if tabular_data is None:\n        tabular_data = []\n    list_of_lists, headers = _normalize_tabular_data(tabular_data, headers)\n\n    # optimization: look for ANSI control codes once,\n    # enable smart width functions only if a control code is found\n    plain_text = '\\n'.join(['\\t'.join(map(_text_type, headers))] + \\\n                            ['\\t'.join(map(_text_type, row)) for row in list_of_lists])\n    has_invisible = re.search(_invisible_codes, plain_text)\n    if has_invisible:\n        width_fn = _visible_width\n    else:\n        width_fn = len\n\n    # format rows and columns, convert numeric values to strings\n    cols = list(zip(*list_of_lists))\n    coltypes = list(map(_column_type, cols))\n    cols = [[_format(v, ct, floatfmt, missingval, has_invisible) for v in c]\n             for c,ct in zip(cols, coltypes)]\n\n    # align columns\n    aligns = [numalign if ct in [int,float] else stralign for ct in coltypes]\n    minwidths = [width_fn(h) + MIN_PADDING for h in headers] if headers else [0]*len(cols)\n    cols = [_align_column(c, a, minw, has_invisible)\n            for c, a, minw in zip(cols, aligns, minwidths)]\n\n    if headers:\n        # align headers and add headers\n        t_cols = cols or [['']] * len(headers)\n        t_aligns = aligns or [stralign] * len(headers)\n        minwidths = [max(minw, width_fn(c[0])) for minw, c in zip(minwidths, t_cols)]\n        headers = [_align_header(h, a, minw)\n                   for h, a, minw in zip(headers, t_aligns, minwidths)]\n        rows = list(zip(*cols))\n    else:\n        minwidths = [width_fn(c[0]) for c in cols]\n        rows = list(zip(*cols))\n\n    if not isinstance(tablefmt, TableFormat):\n        tablefmt = _table_formats.get(tablefmt, _table_formats[\"simple\"])\n\n    return _format_table(tablefmt, headers, rows, minwidths, aligns)",
  "def _build_simple_row(padded_cells, rowfmt):\n    \"Format row according to DataRow format without padding.\"\n    begin, sep, end = rowfmt\n    return (begin + sep.join(padded_cells) + end).rstrip()",
  "def _build_row(padded_cells, colwidths, colaligns, rowfmt):\n    \"Return a string which represents a row of data cells.\"\n    if not rowfmt:\n        return None\n    if hasattr(rowfmt, \"__call__\"):\n        return rowfmt(padded_cells, colwidths, colaligns)\n    else:\n        return _build_simple_row(padded_cells, rowfmt)",
  "def _build_line(colwidths, colaligns, linefmt):\n    \"Return a string which represents a horizontal line.\"\n    if not linefmt:\n        return None\n    if hasattr(linefmt, \"__call__\"):\n        return linefmt(colwidths, colaligns)\n    else:\n        begin, fill, sep,  end = linefmt\n        cells = [fill*w for w in colwidths]\n        return _build_simple_row(cells, (begin, sep, end))",
  "def _pad_row(cells, padding):\n    if cells:\n        pad = \" \"*padding\n        padded_cells = [pad + cell + pad for cell in cells]\n        return padded_cells\n    else:\n        return cells",
  "def _format_table(fmt, headers, rows, colwidths, colaligns):\n    \"\"\"Produce a plain-text representation of the table.\"\"\"\n    lines = []\n    hidden = fmt.with_header_hide if (headers and fmt.with_header_hide) else []\n    pad = fmt.padding\n    headerrow = fmt.headerrow\n\n    padded_widths = [(w + 2*pad) for w in colwidths]\n    padded_headers = _pad_row(headers, pad)\n    padded_rows = [_pad_row(row, pad) for row in rows]\n\n    if fmt.lineabove and \"lineabove\" not in hidden:\n        lines.append(_build_line(padded_widths, colaligns, fmt.lineabove))\n\n    if padded_headers:\n        lines.append(_build_row(padded_headers, padded_widths, colaligns, headerrow))\n        if fmt.linebelowheader and \"linebelowheader\" not in hidden:\n            lines.append(_build_line(padded_widths, colaligns, fmt.linebelowheader))\n\n    if padded_rows and fmt.linebetweenrows and \"linebetweenrows\" not in hidden:\n        # initial rows with a line below\n        for row in padded_rows[:-1]:\n            lines.append(_build_row(row, padded_widths, colaligns, fmt.datarow))\n            lines.append(_build_line(padded_widths, colaligns, fmt.linebetweenrows))\n        # the last row without a line below\n        lines.append(_build_row(padded_rows[-1], padded_widths, colaligns, fmt.datarow))\n    else:\n        for row in padded_rows:\n            lines.append(_build_row(row, padded_widths, colaligns, fmt.datarow))\n\n    if fmt.linebelow and \"linebelow\" not in hidden:\n        lines.append(_build_line(padded_widths, colaligns, fmt.linebelow))\n\n    return \"\\n\".join(lines)",
  "def _main():\n    \"\"\"\\\n    Usage: tabulate [options] [FILE ...]\n\n    Pretty-print tabular data.\n    See also https://bitbucket.org/astanin/python-tabulate\n\n    FILE                      a filename of the file with tabular data;\n                              if \"-\" or missing, read data from stdin.\n\n    Options:\n\n    -h, --help                show this message\n    -1, --header              use the first row of data as a table header\n    -o FILE, --output FILE    print table to FILE (default: stdout)\n    -s REGEXP, --sep REGEXP   use a custom column separator (default: whitespace)\n    -F FPFMT, --float FPFMT   floating point number format (default: g)\n    -f FMT, --format FMT      set output table format; supported formats:\n                              plain, simple, grid, fancy_grid, pipe, orgtbl,\n                              rst, mediawiki, html, latex, latex_booktabs, tsv\n                              (default: simple)\n    \"\"\"\n    import getopt\n    import sys\n    import textwrap\n    usage = textwrap.dedent(_main.__doc__)\n    try:\n        opts, args = getopt.getopt(sys.argv[1:],\n                     \"h1o:s:F:f:\",\n                     [\"help\", \"header\", \"output\", \"sep=\", \"float=\", \"format=\"])\n    except getopt.GetoptError as e:\n        print(e)\n        print(usage)\n        sys.exit(2)\n    headers = []\n    floatfmt = \"g\"\n    tablefmt = \"simple\"\n    sep = r\"\\s+\"\n    outfile = \"-\"\n    for opt, value in opts:\n        if opt in [\"-1\", \"--header\"]:\n            headers = \"firstrow\"\n        elif opt in [\"-o\", \"--output\"]:\n            outfile = value\n        elif opt in [\"-F\", \"--float\"]:\n            floatfmt = value\n        elif opt in [\"-f\", \"--format\"]:\n            if value not in tabulate_formats:\n                print(\"%s is not a supported table format\" % value)\n                print(usage)\n                sys.exit(3)\n            tablefmt = value\n        elif opt in [\"-s\", \"--sep\"]:\n            sep = value\n        elif opt in [\"-h\", \"--help\"]:\n            print(usage)\n            sys.exit(0)\n    files = [sys.stdin] if not args else args\n    with (sys.stdout if outfile == \"-\" else open(outfile, \"w\")) as out:\n        for f in files:\n            if f == \"-\":\n                f = sys.stdin\n            if _is_file(f):\n                _pprint_file(f, headers=headers, tablefmt=tablefmt,\n                             sep=sep, floatfmt=floatfmt, file=out)\n            else:\n                with open(f) as fobj:\n                    _pprint_file(fobj, headers=headers, tablefmt=tablefmt,\n                                 sep=sep, floatfmt=floatfmt, file=out)",
  "def _pprint_file(fobject, headers, tablefmt, sep, floatfmt, file):\n    rows = fobject.readlines()\n    table = [re.split(sep, r.rstrip()) for r in rows]\n    print(tabulate(table, headers, tablefmt, floatfmt=floatfmt, file=file))",
  "def _is_file(f):\n        return isinstance(f, file)",
  "def _is_file(f):\n        return isinstance(f, io.IOBase)",
  "def escape_char(c):\n        return LATEX_ESCAPE_RULES.get(c, c)",
  "def sec2nano(time):\n    \"\"\"convert seconds to nano-seconds\"\"\"\n    return int(time*1E9+0.5)",
  "def min2nano(time):\n    \"convert minutes to nano-seconds\"\n    return int((time*1E9+0.5)*60)",
  "def hour2nano(time):\n    \"\"\"convert hours to nano-seconds\"\"\"\n    return int((time*1E9+0.5)*60*60)",
  "def day2nano(time):\n    \"\"\"convert days to nano-seconds\"\"\"\n    return int((time*1E9+0.5)*60*60*24)",
  "def exponentialAtmosphere(atmosModule, name):\n    \"\"\"\n    Sets the exponential atmosphere model parameters for a particular planet.\n\n    :param atmosModule: atmospheric environment module\n    :param name: planet name string\n\n    \"\"\"\n    if name == \"earth\":\n        atmosModule.planetRadius = 6378136.6   # meters\n        atmosModule.baseDensity = 1.217  # kg/m^3\n        atmosModule.scaleHeight = 8500.0 # meters\n        atmosModule.localTemp = 293.0\n\n    else:\n        print(\"ERROR: \" + name + \" not setup for exponential atmosphere model\\n\")\n\n    return",
  "def centeredDipoleMagField(magFieldModule, name):\n    \"\"\"\n    Sets the centered dipole magnetic field model parameters for a particular planet\n\n    :param magFieldModule: magnetic field environment module\n    :param name: planet name string\n\n    \"\"\"\n    if name == \"earth\":\n        # The following parameters are from the 2020 IGRF model\n        # (https://www.ngdc.noaa.gov/IAGA/vmod/igrf.html)\n        magFieldModule.g10 = -30926.00/1e9     # Tesla\n        magFieldModule.g11 =  -2318.00/1e9     # Tesla\n        magFieldModule.h11 =   5817.00/1e9     # Tesla\n        magFieldModule.planetRadius = 6371.2*1000   # meters\n\n    elif name == \"mercury\":\n        # The following parameters are from NASA planetary fact sheet\n        # (https://nssdc.gsfc.nasa.gov/planetary/planetfact.html)\n        magFieldModule.planetRadius = 2440.0*1000   # meters\n        convertToIgrfDipoleCoefficients(0.002/10000,        # [T]   dipole strength\n                                        0.0*macros.D2R,     # [rad] Dipole tilt to rotational axis\n                                        0.0*macros.D2R,     # [rad] Longitude of tilt\n                                        magFieldModule)\n\n    elif name == \"jupiter\":\n        # The following parameters are from NASA planetary fact sheet\n        # (https://nssdc.gsfc.nasa.gov/planetary/planetfact.html)\n        magFieldModule.planetRadius = 71398.0*1000   # meters\n        convertToIgrfDipoleCoefficients(4.30/10000,         # [T]   dipole strength\n                                        9.4*macros.D2R,     # [rad] Dipole tilt to rotational axis\n                                        200.1*macros.D2R,   # [rad] Longitude of tilt\n                                        magFieldModule)\n\n    elif name == \"saturn\":\n        # The following parameters are from NASA planetary fact sheet\n        # (https://nssdc.gsfc.nasa.gov/planetary/planetfact.html)\n        magFieldModule.planetRadius = 60330.0*1000   # meters\n        convertToIgrfDipoleCoefficients(0.215/10000,        # [T]   dipole strength\n                                        0.0*macros.D2R,     # [rad] Dipole tilt to rotational axis\n                                        0.0*macros.D2R,     # [rad] Longitude of tilt\n                                        magFieldModule)\n\n    elif name == \"uranus\":\n        # The following parameters are from NASA planetary fact sheet\n        # (https://nssdc.gsfc.nasa.gov/planetary/planetfact.html)\n        magFieldModule.planetRadius = 25600.0*1000   # meters\n        convertToIgrfDipoleCoefficients(0.228/10000,        # [T]   dipole strength\n                                        58.6*macros.D2R,    # [rad] Dipole tilt to rotational axis\n                                        53.6*macros.D2R,    # [rad] Longitude of tilt\n                                        magFieldModule)\n\n    elif name == \"neptune\":\n        # The following parameters are from NASA planetary fact sheet\n        # (https://nssdc.gsfc.nasa.gov/planetary/planetfact.html)\n        magFieldModule.planetRadius = 24765.0*1000   # meters\n        convertToIgrfDipoleCoefficients(0.142/10000,        # [T]   dipole strength\n                                        46.9*macros.D2R,    # [rad] Dipole tilt to rotational axis\n                                        288.*macros.D2R,    # [rad] Longitude of tilt\n                                        magFieldModule)\n\n    else:\n        print(\"ERROR: \" + name + \" not setup for centered dipole magnetic field model. Options include mercury, earth, jupiter, saturn, uranus and neptune. \\n\")\n\n    return",
  "def convertToIgrfDipoleCoefficients(nominalField, tilt, longitudeOfTilt, magFieldModule):\n    \"\"\"\n    Converts the NASA Magnetosphere parameters from https://nssdc.gsfc.nasa.gov/planetary/planetfact.html\n    to IGRF compatible dipole coefficients.\n\n    :param nominalField: nominal magnetic field parameter given in Tesla\n    :param tilt: Dipole tilt to rotational axis in radians\n    :param longitudeOfTilt: Longitude of tilt in radians\n    :param magFieldModule: magnetic field environment module\n    \"\"\"\n\n    # the following conversion is taken from Appendix D of doi:10.1007/978-1-4939-0802-8\n    theta_m = np.pi - tilt\n    alpha_m = np.pi - longitudeOfTilt\n    magFieldModule.g11 = nominalField*np.sin(theta_m)*np.cos(alpha_m)\n    magFieldModule.h11 = nominalField*np.sin(theta_m)*np.sin(alpha_m)\n    magFieldModule.g10 = nominalField*np.cos(theta_m)\n\n    return",
  "class moduleGenerator:\n    \"\"\"\n    class to generate draft Basilisk modules\n    \"\"\"\n    def __init__(self):\n        # the following variables must be set for this module generator to function\n        self.modulePathRelSrc = None  # path to the new module folder relative to basilisk/src\n        self.moduleName = None  # lower camel case name of the module\n        self.briefDescription = None  # brief module description\n        self.copyrightHolder = None  # holder of open source copyright\n        self.inMsgList = []  # list of input message dictionary list\n        self.outMsgList = []  # list of input message dictionary list\n\n        # module behavior flags\n        self.cleanBuild = False  # flag if any prior directories should be deleted automatically\n        self.verbose = True  # flag if the status messages should be printed\n\n        # private class variables\n        self._absPath = None  # absolute path to the folder which will contain the module folder\n        self._newModuleLocation = None  # absolute path to the auto-generated Basilisk module folder\n        self._licenseText = None  # BSK open-source license statement\n\n    def log(self, statement, **kwargs):\n        if self.verbose:\n            if 'end' in kwargs:\n                endString = kwargs['end']\n                print(statement, end=endString)\n            else:\n                print(statement)\n\n    def checkPathToNewFolderLocation(self):\n        \"\"\"\n        Make sure the supplied module destination path is correct\n        \"\"\"\n        self.log(statusColor + \"Checking Module location:\" + endColor, end=\" \")\n        if os.path.isdir(self._absPath):\n            os.chdir(self._absPath)\n        else:\n            self.log(failColor + \"\\nERROR: \" + endColor + \"Incorrect path to the new folder:\")\n            self.log(self._absPath)\n            exit()\n        self.log(\"Done\")\n        self.log(self._absPath)\n\n    def createNewModuleFolder(self):\n        \"\"\"\n        Create the new module folder\n        \"\"\"\n        self.log(statusColor + \"Creating Module Folder:\" + endColor, end=\" \")\n        if os.path.isdir(self._newModuleLocation):\n            self.log(\"\\n\" + warningColor + \"WARNING: \" + endColor + \"The new module destination already exists.\")\n            if not self.cleanBuild:\n                ans = input(\"Do you want to delete this folder and recreate? (y or n): \")\n                if ans != \"y\":\n                    self.log(failColor + \"Aborting module creation.\" + endColor)\n                    exit()\n            self.log(\"Cleared the old folder.\")\n            shutil.rmtree(self._newModuleLocation)\n        else:\n            self.log(\"Done\")\n        os.mkdir(self._newModuleLocation)\n        os.chdir(self._newModuleLocation)\n\n    def readLicense(self):\n        \"\"\"Read the Basilisk license file\"\"\"\n        self.log(statusColor + \"Importing License:\" + endColor, end=\" \")\n        with open(pathToSrc + \"/../LICENSE\", 'r') as f:\n            self._licenseText = f.read()\n            self._licenseText = self._licenseText.replace(\"2016\", str(datetime.now().year))\n            self._licenseText = self._licenseText.replace(\n                \"Autonomous Vehicle Systems Lab, University of Colorado at Boulder\",\n                self.copyrightHolder)\n        self.log(\"Done\")\n\n    def createRstFile(self):\n        \"\"\"Create the Module RST documentation draft.\"\"\"\n        rstFileName = self.moduleName + \".rst\"\n        self.log(statusColor + \"Creating RST Documentation File \" + rstFileName + \":\" + endColor, end=\" \")\n        rstFile = 'Executive Summary\\n'\n        rstFile += '-----------------\\n'\n        rstFile += self.briefDescription + '\\n'\n        rstFile += '\\n'\n        rstFile += 'Message Connection Descriptions\\n'\n        rstFile += '-------------------------------\\n'\n        rstFile += 'The following table lists all the module input and output messages.  \\n'\n        rstFile += 'The module msg connection is set by the user from python.  \\n'\n        rstFile += 'The msg type contains a link to the message structure definition, while the description \\n'\n        rstFile += 'provides information on what this message is used for.\\n'\n        rstFile += '\\n'\n        rstFile += '.. list-table:: Module I/O Messages\\n'\n        rstFile += '    :widths: 25 25 50\\n'\n        rstFile += '    :header-rows: 1\\n'\n        rstFile += '\\n'\n        rstFile += '    * - Msg Variable Name\\n'\n        rstFile += '      - Msg Type\\n'\n        rstFile += '      - Description\\n'\n        for msg in self.inMsgList + self.outMsgList:\n            rstFile += '    * - ' + msg['var'] + '\\n'\n            rstFile += '      - :ref:`' + msg['type'] + 'Payload`\\n'\n            rstFile += '      - ' + msg['desc'] + '\\n'\n        rstFile += '\\n'\n\n        with open(rstFileName, 'w') as w:\n            w.write(rstFile)\n        self.log(\"Done\")\n\n    def createTestFile(self, type):\n        \"\"\"\n            Create a functioning python unit test file that loads the new module, creates and connect blank\n            input messages, and sets up recorder modules for each output message.\n        \"\"\"\n        os.mkdir('_UnitTest')\n        os.chdir('_UnitTest')\n        testFileName = \"test_\" + self.moduleName + \".py\"\n        self.log(statusColor + \"Creating Python Init Test File \" + testFileName + \":\" + endColor, end=\" \")\n        testFile = \"\"\n        for line in self._licenseText.split('\\n'):\n            testFile += '# ' + line + '\\n'\n        testFile += '\\n'\n        testFile += 'import pytest\\n'\n        testFile += '\\n'\n        testFile += 'from Basilisk.utilities import SimulationBaseClass\\n'\n        testFile += 'from Basilisk.utilities import unitTestSupport\\n'\n        testFile += 'from Basilisk.architecture import messaging\\n'\n        testFile += 'from Basilisk.utilities import macros\\n'\n        testFile += 'from Basilisk.' + os.path.split(self.modulePathRelSrc)[0] + ' import ' + self.moduleName + '\\n'\n        testFile += '\\n'\n        testFile += '@pytest.mark.parametrize(\"accuracy\", [1e-12])\\n'\n        testFile += '@pytest.mark.parametrize(\"param1, param2\", [\\n'\n        testFile += '     (1, 1)\\n'\n        testFile += '    ,(1, 3)\\n'\n        testFile += '])\\n'\n        testFile += '\\n'\n        testFile += 'def test_' + self.moduleName + '(show_plots, param1, param2, accuracy):\\n'\n        testFile += '    r\"\"\"\\n'\n        testFile += '    **Validation Test Description**\\n'\n        testFile += '\\n'\n        testFile += '    Compose a general description of what is being tested in this unit test script.\\n'\n        testFile += '\\n'\n        testFile += '    **Test Parameters**\\n'\n        testFile += '\\n'\n        testFile += '    Discuss the test parameters used.\\n'\n        testFile += '\\n'\n        testFile += '    Args:\\n'\n        testFile += '        param1 (int): Dummy test parameter for this parameterized unit test\\n'\n        testFile += '        param2 (int): Dummy test parameter for this parameterized unit test\\n'\n        testFile += '        accuracy (float): absolute accuracy value used in the validation tests\\n'\n        testFile += '\\n'\n        testFile += '    **Description of Variables Being Tested**\\n'\n        testFile += '\\n'\n        testFile += '    Here discuss what variables and states are being checked. \\n'\n        testFile += '    \"\"\"\\n'\n        testFile += '    [testResults, testMessage] = ' + self.moduleName + 'TestFunction(show_plots, param1, param2, accuracy)\\n'\n        testFile += '    assert testResults < 1, testMessage\\n'\n        testFile += '\\n'\n        testFile += '\\n'\n        testFile += 'def ' + self.moduleName + 'TestFunction(show_plots, param1, param2, accuracy):\\n'\n        testFile += '    \"\"\"Test method\"\"\"\\n'\n        testFile += '    testFailCount = 0\\n'\n        testFile += '    testMessages = []\\n'\n        testFile += '    unitTaskName = \"unitTask\"\\n'\n        testFile += '    unitProcessName = \"TestProcess\"\\n'\n        testFile += '\\n'\n        testFile += '    unitTestSim = SimulationBaseClass.SimBaseClass()\\n'\n        testFile += '    testProcessRate = macros.sec2nano(0.5)\\n'\n        testFile += '    testProc = unitTestSim.CreateNewProcess(unitProcessName)\\n'\n        testFile += '    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\\n'\n        testFile += '\\n'\n        testFile += '    # setup module to be tested\\n'\n        if type == \"C++\":\n            testFile += '    module = ' + self.moduleName + '.' + self._className + '()\\n'\n        elif type == \"C\":\n            testFile += '    module = ' + self.moduleName + '.' + self.moduleName + '()\\n'\n        else:\n            self.log(failColor + \"ERROR: \" + endColor + \"Wrong module type provided to test file method.\")\n            exit(0)\n        testFile += '    module.ModelTag = \"' + self.moduleName + 'Tag\"\\n'\n        testFile += '    unitTestSim.AddModelToTask(unitTaskName, module)\\n'\n        testFile += '\\n'\n        testFile += '    # Configure blank module input messages\\n'\n        for msg in self.inMsgList:\n            testFile += '    ' + msg['var'] + 'Data = messaging.' + msg['type'] + 'Payload()\\n'\n            testFile += '    ' + msg['var'] + ' = messaging.' + msg['type'] + '().write(' + msg['var'] + 'Data)' + '\\n'\n            testFile += '\\n'\n        testFile += '    # subscribe input messages to module\\n'\n        for msg in self.inMsgList:\n            testFile += '    module.' + msg['var'] + '.subscribeTo(' + msg['var'] + ')\\n'\n        testFile += '\\n'\n        testFile += '    # setup output message recorder objects\\n'\n        for msg in self.outMsgList:\n            testFile += '    ' + msg['var'] + 'Rec = module.' + msg['var'] + '.recorder()\\n'\n            testFile += '    unitTestSim.AddModelToTask(unitTaskName, ' + msg['var'] + 'Rec)\\n'\n        testFile += '\\n'\n        testFile += '    unitTestSim.InitializeSimulation()\\n'\n        testFile += '    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))\\n'\n        testFile += '    unitTestSim.ExecuteSimulation()\\n'\n        testFile += '\\n'\n        testFile += '    # pull module data and make sure it is correct\\n'\n        testFile += '\\n'\n        testFile += '    if testFailCount == 0:\\n'\n        testFile += '        print(\"PASSED: \" + module.ModelTag)\\n'\n        testFile += '    else:\\n'\n        testFile += '        print(testMessages)\\n'\n        testFile += '\\n'\n        testFile += '    return [testFailCount, \"\".join(testMessages)]\\n'\n        testFile += '\\n'\n        testFile += '\\n'\n        testFile += 'if __name__ == \"__main__\":\\n'\n        testFile += '    test_' + self.moduleName + '(False, 1, 1, 1e-12)\\n'\n        testFile += '\\n'\n        testFile += '\\n'\n\n        with open(testFileName, 'w') as w:\n            w.write(testFile)\n        self.log(\"Done\")\n\n    def createCppModule(self):\n        \"\"\"\n        Create a C++ Basilisk module\n        \"\"\"\n        modulePath = self.modulePathRelSrc\n        name = self.moduleName\n        briefDescription = self.briefDescription\n        inMsgList = self.inMsgList\n        outMsgList = self.outMsgList\n\n        self.log(statusColor + '\\nCreating C++ Module: ' + endColor + name)\n        self._className = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), name, 1)\n\n        # read in the license information\n        self.readLicense()\n        licenseC = \"/*\" + self._licenseText + \"*/\\n\\n\"\n\n        # make sure the path, specified relative to basilisk/src, to the new module location is correct\n        self._absPath = os.path.join(pathToSrc, modulePath)\n        self.checkPathToNewFolderLocation()\n\n        # create new Module folder\n        self._newModuleLocation = os.path.join(self._absPath, name)\n        self.createNewModuleFolder()\n\n        #\n        # make module header file\n        #\n        headerFileName = name + \".h\"\n        self.log(statusColor + \"Creating Header File \" + headerFileName + \":\" + endColor, end=\" \")\n        headerFile = licenseC\n        headerFile += '\\n'\n        headerFile += '#ifndef ' + name.upper() + '_H\\n'\n        headerFile += '#define ' + name.upper() + '_H\\n'\n        headerFile += '\\n'\n        headerFile += '#include \"architecture/_GeneralModuleFiles/sys_model.h\"\\n'\n        # loop over message definition includes\n        includedMsgs = []\n        for msg in inMsgList + outMsgList:\n            # ensure we don't include message definition files multiple times\n            if msg['type'] not in includedMsgs:\n                if msg['wrap'] == 'C':\n                    headerFile += '#include \"architecture/msgPayloadDefC/' + msg['type'] + 'Payload.h\"\\n'\n                if msg['wrap'] == 'C++':\n                    headerFile += '#include \"architecture/msgPayloadDefCpp/' + msg['type'] + 'Payload.h\"\\n'\n                includedMsgs.append(msg['type'])\n        headerFile += '#include \"architecture/utilities/bskLogging.h\"\\n'\n        headerFile += '#include \"architecture/messaging/messaging.h\"\\n'\n        headerFile += '\\n'\n        headerFile += '/*! @brief ' + briefDescription + '\\n */\\n'\n        headerFile += 'class ' + self._className + ': public SysModel {\\n'\n        headerFile += 'public:\\n'\n        headerFile += '    ' + self._className + '();\\n'\n        headerFile += '    ~' + self._className + '();\\n'\n        headerFile += '\\n'\n        headerFile += '    void Reset(uint64_t CurrentSimNanos);\\n'\n        headerFile += '    void UpdateState(uint64_t CurrentSimNanos);\\n'\n        headerFile += '\\n'\n        headerFile += 'public:\\n'\n        for msg in inMsgList:\n            headerFile += '    ReadFunctor<' + msg['type'] + 'Payload> ' + msg['var'] \\\n                          + ';  //!< ' + msg['desc'] + '\\n'\n        headerFile += '\\n'\n        for msg in outMsgList:\n            headerFile += '    Message<' + msg['type'] + 'Payload> ' + msg['var'] \\\n                          + ';  //!< ' + msg['desc'] + '\\n'\n        headerFile += '\\n'\n        headerFile += '    BSKLogger bskLogger;              //!< -- BSK Logging\\n'\n        headerFile += '\\n'\n        headerFile += '};\\n'\n        headerFile += '\\n'\n        headerFile += \"\\n#endif\\n\"\n\n        with open(headerFileName, 'w') as w:\n            w.write(headerFile)\n        self.log(\"Done\")\n\n        #\n        # make module definition file\n        #\n        defFileName = name + \".cpp\"\n        self.log(statusColor + \"Creating Definition File \" + defFileName + \":\" + endColor, end=\" \")\n        defFile = licenseC\n        defFile += '\\n'\n        defFile += '#include \"' + modulePath + '/' + name + '/' + name + '.h\"\\n'\n        defFile += '#include <iostream>\\n'\n        defFile += '#include <cstring>\\n'\n        defFile += '\\n'\n        defFile += '/*! This is the constructor for the module class.  It sets default variable\\n'\n        defFile += '    values and initializes the various parts of the model */\\n'\n        defFile += self._className + '::' + self._className + '()\\n'\n        defFile += '{\\n'\n        defFile += '}\\n'\n        defFile += '\\n'\n        defFile += '/*! Module Destructor */\\n'\n        defFile += self._className + '::~' + self._className + '()\\n'\n        defFile += '{\\n'\n        defFile += '}\\n'\n        defFile += '\\n'\n        defFile += '/*! This method is used to reset the module and checks that required input messages are connect.\\n'\n        defFile += '    @return void\\n'\n        defFile += '*/\\n'\n        defFile += 'void ' + self._className + '::Reset(uint64_t CurrentSimNanos)\\n'\n        defFile += '{\\n'\n        defFile += '    // check that required input messages are connected\\n'\n        for msg in inMsgList:\n            defFile += '    if (!this->' + msg['var'] + '.isLinked()) {\\n'\n            defFile += '        bskLogger.bskLog(BSK_ERROR, \"' + self._className + '.' + msg['var'] + ' was not linked.\");\\n'\n            defFile += '    }\\n'\n        defFile += '\\n'\n        defFile += '}\\n'\n        defFile += '\\n'\n        defFile += '\\n'\n        defFile += '/*! This is the main method that gets called every time the module is updated.  ' \\\n                   'Provide an appropriate description.\\n'\n        defFile += '    @return void\\n'\n        defFile += '*/\\n'\n        defFile += 'void ' + self._className + '::UpdateState(uint64_t CurrentSimNanos)\\n'\n        defFile += '{\\n'\n        for msg in inMsgList + outMsgList:\n            defFile += '    ' + msg['type'] + 'Payload ' + msg['var'] + 'Buffer;  //!< local copy of message buffer\\n'\n        defFile += '\\n'\n        defFile += '    // always zero the output message buffers before assigning values\\n'\n        for msg in outMsgList:\n            defFile += '    ' + msg['var'] + 'Buffer = this->' + msg['var'] + '.zeroMsgPayload;\\n'\n        defFile += '\\n'\n        defFile += '    // read in the input messages\\n'\n        for msg in inMsgList:\n            defFile += '    ' + msg['var'] + 'Buffer = this->' + msg['var'] + '();\\n'\n        defFile += '\\n'\n        defFile += '    // do some math and stuff to populate the output messages\\n'\n        defFile += '\\n'\n        defFile += '    // write to the output messages\\n'\n        for msg in outMsgList:\n            defFile += '    this->' + msg['var'] + '.write(&' + msg['var'] + 'Buffer, this->moduleID, CurrentSimNanos);\\n'\n        defFile += '}\\n'\n        defFile += '\\n'\n\n        with open(defFileName, 'w') as w:\n            w.write(defFile)\n        self.log(\"Done\")\n\n        #\n        # make module swig interface file\n        #\n        swigFileName = name + \".i\"\n        self.log(statusColor + \"Creating Swig Interface File \" + swigFileName + \":\" + endColor, end=\" \")\n        swigFile = licenseC\n        swigFile += '%module ' + name + '\\n'\n        swigFile += '%{\\n'\n        swigFile += '    #include \"' + name + '.h\"\\n'\n        swigFile += '%}\\n'\n        swigFile += '\\n'\n        swigFile += '%pythoncode %{\\n'\n        swigFile += '    from Basilisk.architecture.swig_common_model import *\\n'\n        swigFile += '%}\\n'\n        swigFile += '%include \"std_string.i\"\\n'\n        swigFile += '%include \"swig_conly_data.i\"\\n'\n        swigFile += '\\n'\n        swigFile += '%include \"sys_model.h\"\\n'\n        swigFile += '%include \"' + name + '.h\"\\n'\n        swigFile += '\\n'\n        includedMsgs = []\n        for msg in inMsgList + outMsgList:\n            # ensure we don't include message definition files multiple times\n            if msg['type'] not in includedMsgs:\n                if msg['wrap'] == 'C':\n                    swigFile += '%include \"architecture/msgPayloadDefC/' + msg['type'] + 'Payload.h\"\\n'\n                    swigFile += 'struct ' + msg['type'] + '_C;\\n'\n                if msg['wrap'] == 'C++':\n                    swigFile += '%include \"architecture/msgPayloadDefCpp/' + msg['type'] + 'Payload.h\"\\n'\n                includedMsgs.append(msg['type'])\n        swigFile += '\\n'\n        swigFile += '%pythoncode %{\\n'\n        swigFile += 'import sys\\n'\n        swigFile += 'protectAllClasses(sys.modules[__name__])\\n'\n        swigFile += '%}\\n'\n        swigFile += '\\n'\n\n        with open(swigFileName, 'w') as w:\n            w.write(swigFile)\n        self.log(\"Done\")\n\n        # make module definition file\n        self.createRstFile()\n\n        # make module unit test file\n        self.createTestFile(\"C++\")\n\n        # restore current working directory\n        os.chdir(initialCwd)\n\n    def createCModule(self):\n        \"\"\"\n        Create a C Basilisk module\n        \"\"\"\n        modulePath = self.modulePathRelSrc\n        name = self.moduleName\n        briefDescription = self.briefDescription\n        inMsgList = self.inMsgList\n        outMsgList = self.outMsgList\n\n        self.log(statusColor + \"\\nCreating C Module: \" + endColor + name)\n        self._className = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), name, 1)\n\n        # read in the license information\n        self.readLicense()\n        licenseC = \"/*\" + self._licenseText + \"*/\\n\\n\"\n\n        # make sure the path, specified relative to basilisk/src, to the new module location is correct\n        self._absPath = os.path.join(pathToSrc, modulePath)\n        self.checkPathToNewFolderLocation()\n\n        # create new Module folder\n        self._newModuleLocation = os.path.join(self._absPath, name)\n        self.createNewModuleFolder()\n\n        #\n        # make module header file\n        #\n        headerFileName = name + \".h\"\n        self.log(statusColor + \"Creating Header File \" + headerFileName + \":\" + endColor, end=\" \")\n        headerFile = licenseC\n        headerFile += '\\n'\n        headerFile += '#ifndef ' + name.upper() + '_H\\n'\n        headerFile += '#define ' + name.upper() + '_H\\n'\n        headerFile += '\\n'\n        headerFile += '#include <stdint.h>\\n'\n        # loop over message definition includes\n        includedMsgs = []\n        for msg in inMsgList + outMsgList:\n            # ensure we don't include message definition files multiple times\n            if msg['type'] not in includedMsgs:\n                if msg['wrap'] == 'C':\n                    headerFile += '#include \"cMsgCInterface/' + msg['type'] + '_C.h\"\\n'\n                if msg['wrap'] == 'C++':\n                    self.log(failColor + \"Error: \" + endColor + \"You can't include C++ messages in a C module.\")\n                    exit()\n                includedMsgs.append(msg['type'])\n        headerFile += '#include \"architecture/utilities/bskLogging.h\"\\n'\n        headerFile += '\\n'\n        headerFile += '/*! @brief ' + briefDescription + '\\n */\\n'\n        headerFile += 'typedef struct {\\n'\n        headerFile += '\\n'\n        headerFile += '    /* declare module IO interfaces */\\n'\n        for msg in inMsgList:\n            headerFile += '    ' + msg['type'] + '_C ' + msg['var'] \\\n                          + ';  //!< ' + msg['desc'] + '\\n'\n        for msg in outMsgList:\n            headerFile += '    ' + msg['type'] + '_C ' + msg['var'] \\\n                          + ';  //!< ' + msg['desc'] + '\\n'\n        headerFile += '\\n'\n        headerFile += '    BSKLogger *bskLogger;  //!< BSK Logging\\n'\n        headerFile += '}' + name + 'Config;\\n'\n        headerFile += '\\n'\n        headerFile += '#ifdef __cplusplus\\n'\n        headerFile += 'extern \"C\" {\\n'\n        headerFile += '#endif\\n'\n        headerFile += '    void SelfInit_' + name + '(' + name + 'Config *configData, int64_t moduleID);\\n'\n        headerFile += '    void Update_' + name + '(' + name + 'Config *configData, uint64_t callTime, int64_t moduleID);\\n'\n        headerFile += '    void Reset_' + name + '(' + name + 'Config *configData, uint64_t callTime, int64_t moduleID);\\n'\n        headerFile += '\\n'\n        headerFile += '#ifdef __cplusplus\\n'\n        headerFile += '}\\n'\n        headerFile += '#endif\\n'\n        headerFile += '\\n'\n        headerFile += '#endif\\n'\n\n        with open(headerFileName, 'w') as w:\n            w.write(headerFile)\n        self.log(\"Done\")\n\n        #\n        # make module definition file\n        #\n        defFileName = name + \".c\"\n        self.log(statusColor + \"Creating Definition File \" + defFileName + \":\" + endColor, end=\" \")\n        defFile = licenseC\n        defFile += '\\n'\n        defFile += '#include \"' + modulePath + '/' + name + '/' + name + '.h\"\\n'\n        defFile += '#include \"string.h\"\\n'\n        defFile += '\\n'\n        defFile += '/*!\\n'\n        defFile += '    This method initializes the output messages for this module.\\n'\n        defFile += ' @return void\\n'\n        defFile += ' @param configData The configuration data associated with this module\\n'\n        defFile += ' @param moduleID The module identifier\\n'\n        defFile += ' */\\n'\n        defFile += 'void SelfInit_' + name + '(' + name + 'Config  *configData, int64_t moduleID)\\n'\n        defFile += '{\\n'\n        for msg in outMsgList:\n            defFile += '    ' + msg['type'] + '_C_init(&configData->' + msg['var'] + ');\\n'\n        defFile += '}\\n'\n        defFile += '\\n'\n        defFile += '\\n'\n        defFile += '/*! This method performs a complete reset of the module.  Local module variables that retain\\n'\n        defFile += '    time varying states between function calls are reset to their default values.\\n'\n        defFile += '    Check if required input messages are connected.\\n'\n        defFile += ' @return void\\n'\n        defFile += ' @param configData The configuration data associated with the module\\n'\n        defFile += ' @param callTime [ns] time the method is called\\n'\n        defFile += ' @param moduleID The module identifier\\n'\n        defFile += '*/\\n'\n        defFile += 'void Reset_' + name + '(' + name + 'Config *configData, uint64_t callTime, int64_t moduleID)\\n'\n        defFile += '{\\n'\n        defFile += '    // check if the required message has not been connected\\n'\n        for msg in inMsgList:\n            defFile += '    if (!' + msg['type'] + '_C_isLinked(&configData->' + msg['var'] + ')) {\\n'\n            defFile += '        _bskLog(configData->bskLogger, BSK_ERROR, \"Error: ' + name + '.' + msg['var'] \\\n                       + ' was not connected.\");\\n'\n            defFile += '    }\\n'\n\n        defFile += '}\\n'\n        defFile += '\\n'\n        defFile += '\\n'\n        defFile += '/*! Add a description of what this main Update() routine does for this module\\n'\n        defFile += ' @return void\\n'\n        defFile += ' @param configData The configuration data associated with the module\\n'\n        defFile += ' @param callTime The clock time at which the function was called (nanoseconds)\\n'\n        defFile += ' @param moduleID The module identifier\\n'\n        defFile += '*/\\n'\n        defFile += 'void Update_' + name + '(' + name + 'Config *configData, uint64_t callTime, int64_t moduleID)\\n'\n        defFile += '{\\n'\n        for msg in inMsgList + outMsgList:\n            defFile += '    ' + msg['type'] + 'Payload ' + msg['var'] + 'Buffer;  //!< local copy of message buffer\\n'\n        defFile += '\\n'\n        defFile += '    // always zero the output message buffers before assigning values\\n'\n        for msg in outMsgList:\n            defFile += '    ' + msg['var'] + 'Buffer = ' + msg['type'] + '_C_zeroMsgPayload();\\n'\n        defFile += '\\n'\n        defFile += '    // read in the input messages\\n'\n        for msg in inMsgList:\n            defFile += '    ' + msg['var'] + 'Buffer = ' + msg['type'] + '_C_read(&configData->' + msg['var'] + ');\\n'\n        defFile += '\\n'\n        defFile += '    // do some math and stuff to populate the output messages\\n'\n        defFile += '\\n'\n        defFile += '    // write to the output messages\\n'\n        for msg in outMsgList:\n            defFile += '    ' + msg['type'] + '_C_write(&' + msg['var'] + 'Buffer, &configData->' + msg[\n                'var'] + ', moduleID, callTime);\\n'\n        defFile += '}\\n'\n        defFile += '\\n'\n\n\n        with open(defFileName, 'w') as w:\n            w.write(defFile)\n        self.log(\"Done\")\n\n        #\n        # make module swig interface file\n        #\n        swigFileName = name + \".i\"\n        self.log(statusColor + \"Creating Swig Interface File \" + swigFileName + \":\" + endColor, end=\" \")\n        swigFile = licenseC\n        swigFile += '%module ' + name + '\\n'\n        swigFile += '%{\\n'\n        swigFile += '    #include \"' + name + '.h\"\\n'\n        swigFile += '%}\\n'\n        swigFile += '\\n'\n        swigFile += '%pythoncode %{\\n'\n        swigFile += '    from Basilisk.architecture.swig_common_model import *\\n'\n        swigFile += '%}\\n'\n        swigFile += '%include \"swig_c_wrap.i\"\\n'\n        swigFile += f'%c_wrap({name});\\n'\n        swigFile += '\\n'\n        swigFile += '%include \"' + name + '.h\"\\n'\n        swigFile += '\\n'\n        includedMsgs = []\n        for msg in inMsgList + outMsgList:\n            # ensure we don't include message definition files multiple times\n            if msg['type'] not in includedMsgs:\n                if msg['wrap'] == 'C':\n                    swigFile += '%include \"architecture/msgPayloadDefC/' + msg['type'] + 'Payload.h\"\\n'\n                    swigFile += 'struct ' + msg['type'] + '_C;\\n'\n                if msg['wrap'] == 'C++':\n                    self.log(failColor + \"ERROR: \" + endColor + 'you cannot swig a C++ message in a C module.')\n                includedMsgs.append(msg['type'])\n        swigFile += '\\n'\n        swigFile += '%pythoncode %{\\n'\n        swigFile += 'import sys\\n'\n        swigFile += 'protectAllClasses(sys.modules[__name__])\\n'\n        swigFile += '%}\\n'\n        swigFile += '\\n'\n\n        with open(swigFileName, 'w') as w:\n            w.write(swigFile)\n        self.log(\"Done\")\n\n        # make module definition file\n        self.createRstFile()\n\n        # make module unit test file\n        self.createTestFile(\"C\")\n\n        os.chdir(initialCwd)",
  "def fillCppInfo(module):\n    \"\"\"Fill in the C++ module information.  This should be edited before running to meet the new module needs.\"\"\"\n    # define the path where the Basilisk module folder will be\n    module.modulePathRelSrc = os.path.join(\"moduleTemplates\", \"\")\n\n    # define module name and brief description\n    module.moduleName = \"autoCppModule\"        # should be lower camel case\n    module.briefDescription = \"This is an auto-created sample C++ module.  The description is included with \" \\\n        \"the module class definition\"\n    module.copyrightHolder = \"Autonomous Vehicle Systems Lab, University of Colorado Boulder\"\n\n    # provide list of input messages\n    # leave list empty if there are no input messages\n    inMsgList = list()\n    inMsgList.append({'type': 'AttRefMsg', 'var': 'someInMsg', 'desc': 'input msg description', 'wrap': 'C'})\n    inMsgList.append({'type': 'AttRefMsg', 'var': 'some2InMsg', 'desc': 'input msg description', 'wrap': 'C'})\n    inMsgList.append({'type': 'CSSConfigMsg', 'var': 'anotherInMsg', 'desc': 'input msg description', 'wrap': 'C'})\n    inMsgList.append({'type': 'CSSConfigLogMsg', 'var': 'anotherCppInMsg', 'desc': 'input msg description', 'wrap': 'C++'})\n    module.inMsgList = inMsgList\n\n    # provide list of output messages\n    # leave list empty if there are no input messages\n    outMsgList = list()\n    outMsgList.append({'type': 'AttRefMsg', 'var': 'some2OutMsg', 'desc': 'output msg description', 'wrap': 'C'})\n    outMsgList.append({'type': 'SCStatesMsg', 'var': 'someOutMsg', 'desc': 'output msg description', 'wrap': 'C'})\n    outMsgList.append({'type': 'RWConfigMsg', 'var': 'anotherCppOutMsg', 'desc': 'output msg description', 'wrap': 'C++'})\n    module.outMsgList = outMsgList",
  "def fillCInfo(module):\n    \"\"\"Fill in the C module information.  This should be edited before running to meet the new module needs.\"\"\"\n    # define the path where the Basilisk module folder will be\n    module.modulePathRelSrc = os.path.join(\"moduleTemplates\", \"\")\n\n    # define module name and brief description\n    module.moduleName = \"autoCModule\"        # should be lower camel case\n    module.briefDescription = \"This is an auto-created sample C module.  The description is included with \" \\\n        \"the module class definition\"\n    module.copyrightHolder = \"Autonomous Vehicle Systems Lab, University of Colorado Boulder\"\n\n    # provide list of input messages\n    # leave list empty if there are no input messages\n    inMsgList = list()\n    inMsgList.append({'type': 'AttRefMsg', 'var': 'someInMsg', 'desc': 'input msg description', 'wrap': 'C'})\n    inMsgList.append({'type': 'AttRefMsg', 'var': 'some2InMsg', 'desc': 'input msg description', 'wrap': 'C'})\n    inMsgList.append({'type': 'CSSConfigMsg', 'var': 'anotherInMsg', 'desc': 'input msg description', 'wrap': 'C'})\n    module.inMsgList = inMsgList\n\n    # provide list of output messages\n    # leave list empty if there are no input messages\n    outMsgList = list()\n    outMsgList.append({'type': 'AttRefMsg', 'var': 'some2OutMsg', 'desc': 'output msg description', 'wrap': 'C'})\n    outMsgList.append({'type': 'SCStatesMsg', 'var': 'someOutMsg', 'desc': 'output msg description', 'wrap': 'C'})\n    module.outMsgList = outMsgList",
  "def __init__(self):\n        # the following variables must be set for this module generator to function\n        self.modulePathRelSrc = None  # path to the new module folder relative to basilisk/src\n        self.moduleName = None  # lower camel case name of the module\n        self.briefDescription = None  # brief module description\n        self.copyrightHolder = None  # holder of open source copyright\n        self.inMsgList = []  # list of input message dictionary list\n        self.outMsgList = []  # list of input message dictionary list\n\n        # module behavior flags\n        self.cleanBuild = False  # flag if any prior directories should be deleted automatically\n        self.verbose = True  # flag if the status messages should be printed\n\n        # private class variables\n        self._absPath = None  # absolute path to the folder which will contain the module folder\n        self._newModuleLocation = None  # absolute path to the auto-generated Basilisk module folder\n        self._licenseText = None",
  "def log(self, statement, **kwargs):\n        if self.verbose:\n            if 'end' in kwargs:\n                endString = kwargs['end']\n                print(statement, end=endString)\n            else:\n                print(statement)",
  "def checkPathToNewFolderLocation(self):\n        \"\"\"\n        Make sure the supplied module destination path is correct\n        \"\"\"\n        self.log(statusColor + \"Checking Module location:\" + endColor, end=\" \")\n        if os.path.isdir(self._absPath):\n            os.chdir(self._absPath)\n        else:\n            self.log(failColor + \"\\nERROR: \" + endColor + \"Incorrect path to the new folder:\")\n            self.log(self._absPath)\n            exit()\n        self.log(\"Done\")\n        self.log(self._absPath)",
  "def createNewModuleFolder(self):\n        \"\"\"\n        Create the new module folder\n        \"\"\"\n        self.log(statusColor + \"Creating Module Folder:\" + endColor, end=\" \")\n        if os.path.isdir(self._newModuleLocation):\n            self.log(\"\\n\" + warningColor + \"WARNING: \" + endColor + \"The new module destination already exists.\")\n            if not self.cleanBuild:\n                ans = input(\"Do you want to delete this folder and recreate? (y or n): \")\n                if ans != \"y\":\n                    self.log(failColor + \"Aborting module creation.\" + endColor)\n                    exit()\n            self.log(\"Cleared the old folder.\")\n            shutil.rmtree(self._newModuleLocation)\n        else:\n            self.log(\"Done\")\n        os.mkdir(self._newModuleLocation)\n        os.chdir(self._newModuleLocation)",
  "def readLicense(self):\n        \"\"\"Read the Basilisk license file\"\"\"\n        self.log(statusColor + \"Importing License:\" + endColor, end=\" \")\n        with open(pathToSrc + \"/../LICENSE\", 'r') as f:\n            self._licenseText = f.read()\n            self._licenseText = self._licenseText.replace(\"2016\", str(datetime.now().year))\n            self._licenseText = self._licenseText.replace(\n                \"Autonomous Vehicle Systems Lab, University of Colorado at Boulder\",\n                self.copyrightHolder)\n        self.log(\"Done\")",
  "def createRstFile(self):\n        \"\"\"Create the Module RST documentation draft.\"\"\"\n        rstFileName = self.moduleName + \".rst\"\n        self.log(statusColor + \"Creating RST Documentation File \" + rstFileName + \":\" + endColor, end=\" \")\n        rstFile = 'Executive Summary\\n'\n        rstFile += '-----------------\\n'\n        rstFile += self.briefDescription + '\\n'\n        rstFile += '\\n'\n        rstFile += 'Message Connection Descriptions\\n'\n        rstFile += '-------------------------------\\n'\n        rstFile += 'The following table lists all the module input and output messages.  \\n'\n        rstFile += 'The module msg connection is set by the user from python.  \\n'\n        rstFile += 'The msg type contains a link to the message structure definition, while the description \\n'\n        rstFile += 'provides information on what this message is used for.\\n'\n        rstFile += '\\n'\n        rstFile += '.. list-table:: Module I/O Messages\\n'\n        rstFile += '    :widths: 25 25 50\\n'\n        rstFile += '    :header-rows: 1\\n'\n        rstFile += '\\n'\n        rstFile += '    * - Msg Variable Name\\n'\n        rstFile += '      - Msg Type\\n'\n        rstFile += '      - Description\\n'\n        for msg in self.inMsgList + self.outMsgList:\n            rstFile += '    * - ' + msg['var'] + '\\n'\n            rstFile += '      - :ref:`' + msg['type'] + 'Payload`\\n'\n            rstFile += '      - ' + msg['desc'] + '\\n'\n        rstFile += '\\n'\n\n        with open(rstFileName, 'w') as w:\n            w.write(rstFile)\n        self.log(\"Done\")",
  "def createTestFile(self, type):\n        \"\"\"\n            Create a functioning python unit test file that loads the new module, creates and connect blank\n            input messages, and sets up recorder modules for each output message.\n        \"\"\"\n        os.mkdir('_UnitTest')\n        os.chdir('_UnitTest')\n        testFileName = \"test_\" + self.moduleName + \".py\"\n        self.log(statusColor + \"Creating Python Init Test File \" + testFileName + \":\" + endColor, end=\" \")\n        testFile = \"\"\n        for line in self._licenseText.split('\\n'):\n            testFile += '# ' + line + '\\n'\n        testFile += '\\n'\n        testFile += 'import pytest\\n'\n        testFile += '\\n'\n        testFile += 'from Basilisk.utilities import SimulationBaseClass\\n'\n        testFile += 'from Basilisk.utilities import unitTestSupport\\n'\n        testFile += 'from Basilisk.architecture import messaging\\n'\n        testFile += 'from Basilisk.utilities import macros\\n'\n        testFile += 'from Basilisk.' + os.path.split(self.modulePathRelSrc)[0] + ' import ' + self.moduleName + '\\n'\n        testFile += '\\n'\n        testFile += '@pytest.mark.parametrize(\"accuracy\", [1e-12])\\n'\n        testFile += '@pytest.mark.parametrize(\"param1, param2\", [\\n'\n        testFile += '     (1, 1)\\n'\n        testFile += '    ,(1, 3)\\n'\n        testFile += '])\\n'\n        testFile += '\\n'\n        testFile += 'def test_' + self.moduleName + '(show_plots, param1, param2, accuracy):\\n'\n        testFile += '    r\"\"\"\\n'\n        testFile += '    **Validation Test Description**\\n'\n        testFile += '\\n'\n        testFile += '    Compose a general description of what is being tested in this unit test script.\\n'\n        testFile += '\\n'\n        testFile += '    **Test Parameters**\\n'\n        testFile += '\\n'\n        testFile += '    Discuss the test parameters used.\\n'\n        testFile += '\\n'\n        testFile += '    Args:\\n'\n        testFile += '        param1 (int): Dummy test parameter for this parameterized unit test\\n'\n        testFile += '        param2 (int): Dummy test parameter for this parameterized unit test\\n'\n        testFile += '        accuracy (float): absolute accuracy value used in the validation tests\\n'\n        testFile += '\\n'\n        testFile += '    **Description of Variables Being Tested**\\n'\n        testFile += '\\n'\n        testFile += '    Here discuss what variables and states are being checked. \\n'\n        testFile += '    \"\"\"\\n'\n        testFile += '    [testResults, testMessage] = ' + self.moduleName + 'TestFunction(show_plots, param1, param2, accuracy)\\n'\n        testFile += '    assert testResults < 1, testMessage\\n'\n        testFile += '\\n'\n        testFile += '\\n'\n        testFile += 'def ' + self.moduleName + 'TestFunction(show_plots, param1, param2, accuracy):\\n'\n        testFile += '    \"\"\"Test method\"\"\"\\n'\n        testFile += '    testFailCount = 0\\n'\n        testFile += '    testMessages = []\\n'\n        testFile += '    unitTaskName = \"unitTask\"\\n'\n        testFile += '    unitProcessName = \"TestProcess\"\\n'\n        testFile += '\\n'\n        testFile += '    unitTestSim = SimulationBaseClass.SimBaseClass()\\n'\n        testFile += '    testProcessRate = macros.sec2nano(0.5)\\n'\n        testFile += '    testProc = unitTestSim.CreateNewProcess(unitProcessName)\\n'\n        testFile += '    testProc.addTask(unitTestSim.CreateNewTask(unitTaskName, testProcessRate))\\n'\n        testFile += '\\n'\n        testFile += '    # setup module to be tested\\n'\n        if type == \"C++\":\n            testFile += '    module = ' + self.moduleName + '.' + self._className + '()\\n'\n        elif type == \"C\":\n            testFile += '    module = ' + self.moduleName + '.' + self.moduleName + '()\\n'\n        else:\n            self.log(failColor + \"ERROR: \" + endColor + \"Wrong module type provided to test file method.\")\n            exit(0)\n        testFile += '    module.ModelTag = \"' + self.moduleName + 'Tag\"\\n'\n        testFile += '    unitTestSim.AddModelToTask(unitTaskName, module)\\n'\n        testFile += '\\n'\n        testFile += '    # Configure blank module input messages\\n'\n        for msg in self.inMsgList:\n            testFile += '    ' + msg['var'] + 'Data = messaging.' + msg['type'] + 'Payload()\\n'\n            testFile += '    ' + msg['var'] + ' = messaging.' + msg['type'] + '().write(' + msg['var'] + 'Data)' + '\\n'\n            testFile += '\\n'\n        testFile += '    # subscribe input messages to module\\n'\n        for msg in self.inMsgList:\n            testFile += '    module.' + msg['var'] + '.subscribeTo(' + msg['var'] + ')\\n'\n        testFile += '\\n'\n        testFile += '    # setup output message recorder objects\\n'\n        for msg in self.outMsgList:\n            testFile += '    ' + msg['var'] + 'Rec = module.' + msg['var'] + '.recorder()\\n'\n            testFile += '    unitTestSim.AddModelToTask(unitTaskName, ' + msg['var'] + 'Rec)\\n'\n        testFile += '\\n'\n        testFile += '    unitTestSim.InitializeSimulation()\\n'\n        testFile += '    unitTestSim.ConfigureStopTime(macros.sec2nano(1.0))\\n'\n        testFile += '    unitTestSim.ExecuteSimulation()\\n'\n        testFile += '\\n'\n        testFile += '    # pull module data and make sure it is correct\\n'\n        testFile += '\\n'\n        testFile += '    if testFailCount == 0:\\n'\n        testFile += '        print(\"PASSED: \" + module.ModelTag)\\n'\n        testFile += '    else:\\n'\n        testFile += '        print(testMessages)\\n'\n        testFile += '\\n'\n        testFile += '    return [testFailCount, \"\".join(testMessages)]\\n'\n        testFile += '\\n'\n        testFile += '\\n'\n        testFile += 'if __name__ == \"__main__\":\\n'\n        testFile += '    test_' + self.moduleName + '(False, 1, 1, 1e-12)\\n'\n        testFile += '\\n'\n        testFile += '\\n'\n\n        with open(testFileName, 'w') as w:\n            w.write(testFile)\n        self.log(\"Done\")",
  "def createCppModule(self):\n        \"\"\"\n        Create a C++ Basilisk module\n        \"\"\"\n        modulePath = self.modulePathRelSrc\n        name = self.moduleName\n        briefDescription = self.briefDescription\n        inMsgList = self.inMsgList\n        outMsgList = self.outMsgList\n\n        self.log(statusColor + '\\nCreating C++ Module: ' + endColor + name)\n        self._className = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), name, 1)\n\n        # read in the license information\n        self.readLicense()\n        licenseC = \"/*\" + self._licenseText + \"*/\\n\\n\"\n\n        # make sure the path, specified relative to basilisk/src, to the new module location is correct\n        self._absPath = os.path.join(pathToSrc, modulePath)\n        self.checkPathToNewFolderLocation()\n\n        # create new Module folder\n        self._newModuleLocation = os.path.join(self._absPath, name)\n        self.createNewModuleFolder()\n\n        #\n        # make module header file\n        #\n        headerFileName = name + \".h\"\n        self.log(statusColor + \"Creating Header File \" + headerFileName + \":\" + endColor, end=\" \")\n        headerFile = licenseC\n        headerFile += '\\n'\n        headerFile += '#ifndef ' + name.upper() + '_H\\n'\n        headerFile += '#define ' + name.upper() + '_H\\n'\n        headerFile += '\\n'\n        headerFile += '#include \"architecture/_GeneralModuleFiles/sys_model.h\"\\n'\n        # loop over message definition includes\n        includedMsgs = []\n        for msg in inMsgList + outMsgList:\n            # ensure we don't include message definition files multiple times\n            if msg['type'] not in includedMsgs:\n                if msg['wrap'] == 'C':\n                    headerFile += '#include \"architecture/msgPayloadDefC/' + msg['type'] + 'Payload.h\"\\n'\n                if msg['wrap'] == 'C++':\n                    headerFile += '#include \"architecture/msgPayloadDefCpp/' + msg['type'] + 'Payload.h\"\\n'\n                includedMsgs.append(msg['type'])\n        headerFile += '#include \"architecture/utilities/bskLogging.h\"\\n'\n        headerFile += '#include \"architecture/messaging/messaging.h\"\\n'\n        headerFile += '\\n'\n        headerFile += '/*! @brief ' + briefDescription + '\\n */\\n'\n        headerFile += 'class ' + self._className + ': public SysModel {\\n'\n        headerFile += 'public:\\n'\n        headerFile += '    ' + self._className + '();\\n'\n        headerFile += '    ~' + self._className + '();\\n'\n        headerFile += '\\n'\n        headerFile += '    void Reset(uint64_t CurrentSimNanos);\\n'\n        headerFile += '    void UpdateState(uint64_t CurrentSimNanos);\\n'\n        headerFile += '\\n'\n        headerFile += 'public:\\n'\n        for msg in inMsgList:\n            headerFile += '    ReadFunctor<' + msg['type'] + 'Payload> ' + msg['var'] \\\n                          + ';  //!< ' + msg['desc'] + '\\n'\n        headerFile += '\\n'\n        for msg in outMsgList:\n            headerFile += '    Message<' + msg['type'] + 'Payload> ' + msg['var'] \\\n                          + ';  //!< ' + msg['desc'] + '\\n'\n        headerFile += '\\n'\n        headerFile += '    BSKLogger bskLogger;              //!< -- BSK Logging\\n'\n        headerFile += '\\n'\n        headerFile += '};\\n'\n        headerFile += '\\n'\n        headerFile += \"\\n#endif\\n\"\n\n        with open(headerFileName, 'w') as w:\n            w.write(headerFile)\n        self.log(\"Done\")\n\n        #\n        # make module definition file\n        #\n        defFileName = name + \".cpp\"\n        self.log(statusColor + \"Creating Definition File \" + defFileName + \":\" + endColor, end=\" \")\n        defFile = licenseC\n        defFile += '\\n'\n        defFile += '#include \"' + modulePath + '/' + name + '/' + name + '.h\"\\n'\n        defFile += '#include <iostream>\\n'\n        defFile += '#include <cstring>\\n'\n        defFile += '\\n'\n        defFile += '/*! This is the constructor for the module class.  It sets default variable\\n'\n        defFile += '    values and initializes the various parts of the model */\\n'\n        defFile += self._className + '::' + self._className + '()\\n'\n        defFile += '{\\n'\n        defFile += '}\\n'\n        defFile += '\\n'\n        defFile += '/*! Module Destructor */\\n'\n        defFile += self._className + '::~' + self._className + '()\\n'\n        defFile += '{\\n'\n        defFile += '}\\n'\n        defFile += '\\n'\n        defFile += '/*! This method is used to reset the module and checks that required input messages are connect.\\n'\n        defFile += '    @return void\\n'\n        defFile += '*/\\n'\n        defFile += 'void ' + self._className + '::Reset(uint64_t CurrentSimNanos)\\n'\n        defFile += '{\\n'\n        defFile += '    // check that required input messages are connected\\n'\n        for msg in inMsgList:\n            defFile += '    if (!this->' + msg['var'] + '.isLinked()) {\\n'\n            defFile += '        bskLogger.bskLog(BSK_ERROR, \"' + self._className + '.' + msg['var'] + ' was not linked.\");\\n'\n            defFile += '    }\\n'\n        defFile += '\\n'\n        defFile += '}\\n'\n        defFile += '\\n'\n        defFile += '\\n'\n        defFile += '/*! This is the main method that gets called every time the module is updated.  ' \\\n                   'Provide an appropriate description.\\n'\n        defFile += '    @return void\\n'\n        defFile += '*/\\n'\n        defFile += 'void ' + self._className + '::UpdateState(uint64_t CurrentSimNanos)\\n'\n        defFile += '{\\n'\n        for msg in inMsgList + outMsgList:\n            defFile += '    ' + msg['type'] + 'Payload ' + msg['var'] + 'Buffer;  //!< local copy of message buffer\\n'\n        defFile += '\\n'\n        defFile += '    // always zero the output message buffers before assigning values\\n'\n        for msg in outMsgList:\n            defFile += '    ' + msg['var'] + 'Buffer = this->' + msg['var'] + '.zeroMsgPayload;\\n'\n        defFile += '\\n'\n        defFile += '    // read in the input messages\\n'\n        for msg in inMsgList:\n            defFile += '    ' + msg['var'] + 'Buffer = this->' + msg['var'] + '();\\n'\n        defFile += '\\n'\n        defFile += '    // do some math and stuff to populate the output messages\\n'\n        defFile += '\\n'\n        defFile += '    // write to the output messages\\n'\n        for msg in outMsgList:\n            defFile += '    this->' + msg['var'] + '.write(&' + msg['var'] + 'Buffer, this->moduleID, CurrentSimNanos);\\n'\n        defFile += '}\\n'\n        defFile += '\\n'\n\n        with open(defFileName, 'w') as w:\n            w.write(defFile)\n        self.log(\"Done\")\n\n        #\n        # make module swig interface file\n        #\n        swigFileName = name + \".i\"\n        self.log(statusColor + \"Creating Swig Interface File \" + swigFileName + \":\" + endColor, end=\" \")\n        swigFile = licenseC\n        swigFile += '%module ' + name + '\\n'\n        swigFile += '%{\\n'\n        swigFile += '    #include \"' + name + '.h\"\\n'\n        swigFile += '%}\\n'\n        swigFile += '\\n'\n        swigFile += '%pythoncode %{\\n'\n        swigFile += '    from Basilisk.architecture.swig_common_model import *\\n'\n        swigFile += '%}\\n'\n        swigFile += '%include \"std_string.i\"\\n'\n        swigFile += '%include \"swig_conly_data.i\"\\n'\n        swigFile += '\\n'\n        swigFile += '%include \"sys_model.h\"\\n'\n        swigFile += '%include \"' + name + '.h\"\\n'\n        swigFile += '\\n'\n        includedMsgs = []\n        for msg in inMsgList + outMsgList:\n            # ensure we don't include message definition files multiple times\n            if msg['type'] not in includedMsgs:\n                if msg['wrap'] == 'C':\n                    swigFile += '%include \"architecture/msgPayloadDefC/' + msg['type'] + 'Payload.h\"\\n'\n                    swigFile += 'struct ' + msg['type'] + '_C;\\n'\n                if msg['wrap'] == 'C++':\n                    swigFile += '%include \"architecture/msgPayloadDefCpp/' + msg['type'] + 'Payload.h\"\\n'\n                includedMsgs.append(msg['type'])\n        swigFile += '\\n'\n        swigFile += '%pythoncode %{\\n'\n        swigFile += 'import sys\\n'\n        swigFile += 'protectAllClasses(sys.modules[__name__])\\n'\n        swigFile += '%}\\n'\n        swigFile += '\\n'\n\n        with open(swigFileName, 'w') as w:\n            w.write(swigFile)\n        self.log(\"Done\")\n\n        # make module definition file\n        self.createRstFile()\n\n        # make module unit test file\n        self.createTestFile(\"C++\")\n\n        # restore current working directory\n        os.chdir(initialCwd)",
  "def createCModule(self):\n        \"\"\"\n        Create a C Basilisk module\n        \"\"\"\n        modulePath = self.modulePathRelSrc\n        name = self.moduleName\n        briefDescription = self.briefDescription\n        inMsgList = self.inMsgList\n        outMsgList = self.outMsgList\n\n        self.log(statusColor + \"\\nCreating C Module: \" + endColor + name)\n        self._className = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), name, 1)\n\n        # read in the license information\n        self.readLicense()\n        licenseC = \"/*\" + self._licenseText + \"*/\\n\\n\"\n\n        # make sure the path, specified relative to basilisk/src, to the new module location is correct\n        self._absPath = os.path.join(pathToSrc, modulePath)\n        self.checkPathToNewFolderLocation()\n\n        # create new Module folder\n        self._newModuleLocation = os.path.join(self._absPath, name)\n        self.createNewModuleFolder()\n\n        #\n        # make module header file\n        #\n        headerFileName = name + \".h\"\n        self.log(statusColor + \"Creating Header File \" + headerFileName + \":\" + endColor, end=\" \")\n        headerFile = licenseC\n        headerFile += '\\n'\n        headerFile += '#ifndef ' + name.upper() + '_H\\n'\n        headerFile += '#define ' + name.upper() + '_H\\n'\n        headerFile += '\\n'\n        headerFile += '#include <stdint.h>\\n'\n        # loop over message definition includes\n        includedMsgs = []\n        for msg in inMsgList + outMsgList:\n            # ensure we don't include message definition files multiple times\n            if msg['type'] not in includedMsgs:\n                if msg['wrap'] == 'C':\n                    headerFile += '#include \"cMsgCInterface/' + msg['type'] + '_C.h\"\\n'\n                if msg['wrap'] == 'C++':\n                    self.log(failColor + \"Error: \" + endColor + \"You can't include C++ messages in a C module.\")\n                    exit()\n                includedMsgs.append(msg['type'])\n        headerFile += '#include \"architecture/utilities/bskLogging.h\"\\n'\n        headerFile += '\\n'\n        headerFile += '/*! @brief ' + briefDescription + '\\n */\\n'\n        headerFile += 'typedef struct {\\n'\n        headerFile += '\\n'\n        headerFile += '    /* declare module IO interfaces */\\n'\n        for msg in inMsgList:\n            headerFile += '    ' + msg['type'] + '_C ' + msg['var'] \\\n                          + ';  //!< ' + msg['desc'] + '\\n'\n        for msg in outMsgList:\n            headerFile += '    ' + msg['type'] + '_C ' + msg['var'] \\\n                          + ';  //!< ' + msg['desc'] + '\\n'\n        headerFile += '\\n'\n        headerFile += '    BSKLogger *bskLogger;  //!< BSK Logging\\n'\n        headerFile += '}' + name + 'Config;\\n'\n        headerFile += '\\n'\n        headerFile += '#ifdef __cplusplus\\n'\n        headerFile += 'extern \"C\" {\\n'\n        headerFile += '#endif\\n'\n        headerFile += '    void SelfInit_' + name + '(' + name + 'Config *configData, int64_t moduleID);\\n'\n        headerFile += '    void Update_' + name + '(' + name + 'Config *configData, uint64_t callTime, int64_t moduleID);\\n'\n        headerFile += '    void Reset_' + name + '(' + name + 'Config *configData, uint64_t callTime, int64_t moduleID);\\n'\n        headerFile += '\\n'\n        headerFile += '#ifdef __cplusplus\\n'\n        headerFile += '}\\n'\n        headerFile += '#endif\\n'\n        headerFile += '\\n'\n        headerFile += '#endif\\n'\n\n        with open(headerFileName, 'w') as w:\n            w.write(headerFile)\n        self.log(\"Done\")\n\n        #\n        # make module definition file\n        #\n        defFileName = name + \".c\"\n        self.log(statusColor + \"Creating Definition File \" + defFileName + \":\" + endColor, end=\" \")\n        defFile = licenseC\n        defFile += '\\n'\n        defFile += '#include \"' + modulePath + '/' + name + '/' + name + '.h\"\\n'\n        defFile += '#include \"string.h\"\\n'\n        defFile += '\\n'\n        defFile += '/*!\\n'\n        defFile += '    This method initializes the output messages for this module.\\n'\n        defFile += ' @return void\\n'\n        defFile += ' @param configData The configuration data associated with this module\\n'\n        defFile += ' @param moduleID The module identifier\\n'\n        defFile += ' */\\n'\n        defFile += 'void SelfInit_' + name + '(' + name + 'Config  *configData, int64_t moduleID)\\n'\n        defFile += '{\\n'\n        for msg in outMsgList:\n            defFile += '    ' + msg['type'] + '_C_init(&configData->' + msg['var'] + ');\\n'\n        defFile += '}\\n'\n        defFile += '\\n'\n        defFile += '\\n'\n        defFile += '/*! This method performs a complete reset of the module.  Local module variables that retain\\n'\n        defFile += '    time varying states between function calls are reset to their default values.\\n'\n        defFile += '    Check if required input messages are connected.\\n'\n        defFile += ' @return void\\n'\n        defFile += ' @param configData The configuration data associated with the module\\n'\n        defFile += ' @param callTime [ns] time the method is called\\n'\n        defFile += ' @param moduleID The module identifier\\n'\n        defFile += '*/\\n'\n        defFile += 'void Reset_' + name + '(' + name + 'Config *configData, uint64_t callTime, int64_t moduleID)\\n'\n        defFile += '{\\n'\n        defFile += '    // check if the required message has not been connected\\n'\n        for msg in inMsgList:\n            defFile += '    if (!' + msg['type'] + '_C_isLinked(&configData->' + msg['var'] + ')) {\\n'\n            defFile += '        _bskLog(configData->bskLogger, BSK_ERROR, \"Error: ' + name + '.' + msg['var'] \\\n                       + ' was not connected.\");\\n'\n            defFile += '    }\\n'\n\n        defFile += '}\\n'\n        defFile += '\\n'\n        defFile += '\\n'\n        defFile += '/*! Add a description of what this main Update() routine does for this module\\n'\n        defFile += ' @return void\\n'\n        defFile += ' @param configData The configuration data associated with the module\\n'\n        defFile += ' @param callTime The clock time at which the function was called (nanoseconds)\\n'\n        defFile += ' @param moduleID The module identifier\\n'\n        defFile += '*/\\n'\n        defFile += 'void Update_' + name + '(' + name + 'Config *configData, uint64_t callTime, int64_t moduleID)\\n'\n        defFile += '{\\n'\n        for msg in inMsgList + outMsgList:\n            defFile += '    ' + msg['type'] + 'Payload ' + msg['var'] + 'Buffer;  //!< local copy of message buffer\\n'\n        defFile += '\\n'\n        defFile += '    // always zero the output message buffers before assigning values\\n'\n        for msg in outMsgList:\n            defFile += '    ' + msg['var'] + 'Buffer = ' + msg['type'] + '_C_zeroMsgPayload();\\n'\n        defFile += '\\n'\n        defFile += '    // read in the input messages\\n'\n        for msg in inMsgList:\n            defFile += '    ' + msg['var'] + 'Buffer = ' + msg['type'] + '_C_read(&configData->' + msg['var'] + ');\\n'\n        defFile += '\\n'\n        defFile += '    // do some math and stuff to populate the output messages\\n'\n        defFile += '\\n'\n        defFile += '    // write to the output messages\\n'\n        for msg in outMsgList:\n            defFile += '    ' + msg['type'] + '_C_write(&' + msg['var'] + 'Buffer, &configData->' + msg[\n                'var'] + ', moduleID, callTime);\\n'\n        defFile += '}\\n'\n        defFile += '\\n'\n\n\n        with open(defFileName, 'w') as w:\n            w.write(defFile)\n        self.log(\"Done\")\n\n        #\n        # make module swig interface file\n        #\n        swigFileName = name + \".i\"\n        self.log(statusColor + \"Creating Swig Interface File \" + swigFileName + \":\" + endColor, end=\" \")\n        swigFile = licenseC\n        swigFile += '%module ' + name + '\\n'\n        swigFile += '%{\\n'\n        swigFile += '    #include \"' + name + '.h\"\\n'\n        swigFile += '%}\\n'\n        swigFile += '\\n'\n        swigFile += '%pythoncode %{\\n'\n        swigFile += '    from Basilisk.architecture.swig_common_model import *\\n'\n        swigFile += '%}\\n'\n        swigFile += '%include \"swig_c_wrap.i\"\\n'\n        swigFile += f'%c_wrap({name});\\n'\n        swigFile += '\\n'\n        swigFile += '%include \"' + name + '.h\"\\n'\n        swigFile += '\\n'\n        includedMsgs = []\n        for msg in inMsgList + outMsgList:\n            # ensure we don't include message definition files multiple times\n            if msg['type'] not in includedMsgs:\n                if msg['wrap'] == 'C':\n                    swigFile += '%include \"architecture/msgPayloadDefC/' + msg['type'] + 'Payload.h\"\\n'\n                    swigFile += 'struct ' + msg['type'] + '_C;\\n'\n                if msg['wrap'] == 'C++':\n                    self.log(failColor + \"ERROR: \" + endColor + 'you cannot swig a C++ message in a C module.')\n                includedMsgs.append(msg['type'])\n        swigFile += '\\n'\n        swigFile += '%pythoncode %{\\n'\n        swigFile += 'import sys\\n'\n        swigFile += 'protectAllClasses(sys.modules[__name__])\\n'\n        swigFile += '%}\\n'\n        swigFile += '\\n'\n\n        with open(swigFileName, 'w') as w:\n            w.write(swigFile)\n        self.log(\"Done\")\n\n        # make module definition file\n        self.createRstFile()\n\n        # make module unit test file\n        self.createTestFile(\"C\")\n\n        os.chdir(initialCwd)",
  "def plotSpheres(posDataL_N, posDataF_N, attDataL_N, attDataF_N, spPosListLeader_H, rListLeader,\n               LeaderSpCharges, spPosListFollower_H, rListFollower, FollowerSpCharges):\n\n    figureList = {}\n    plt.figure(3)\n    ax = plt.axes(projection='3d')\n# get S/C position\n    r_LN_N = np.array([0., 0., 0.])\n    r_FL_N = posDataF_N[0, 0:3] - posDataL_N[0, 0:3]\n    # get sphere locations\n    dcm_NL = RigidBodyKinematics.MRP2C(attDataL_N[0, 0:3]).transpose()\n    dcm_NF = RigidBodyKinematics.MRP2C(attDataF_N[0, 0:3]).transpose()\n    spPosL_H = np.dot(dcm_NL, np.array(spPosListLeader_H).transpose()).transpose()\n    spPosF_H = np.dot(dcm_NF,   np.array(spPosListFollower_H).transpose()).transpose()\n    radiiL = copy.deepcopy(rListLeader)\n    radiiF = copy.deepcopy(rListFollower)\n    # Define to plot spheres\n    u = np.linspace(0, np.pi, 10)\n    v = np.linspace(0, 2 * np.pi, 10)\n    x = np.outer(np.sin(u), np.sin(v))\n    y = np.outer(np.sin(u), np.cos(v))\n    z = np.outer(np.cos(u), np.ones_like(v))\n\n    # Find the minimum and maximum charges in order to normalize the values\n    all_charges = np.array(LeaderSpCharges + FollowerSpCharges)\n    max_q = max(all_charges)\n    min_q = min(all_charges)\n\n    # Plot the spheres for the Leader spacecraft\n    for ii in range(0, len(radiiL)):\n        r_SpN_N = r_LN_N + spPosL_H[ii, 0:3]\n        # If both spacecraft are negatively charged\n        if max_q < 0 and min_q < 0:\n            # Normalize the sphere charge\n            # normcl = (LeaderSpCharges[ii] - min_q) / (0 - min_q)\n            normcl = (LeaderSpCharges[ii] - 0) / (min_q - 0)\n            # Use green colormap to denote negative charge\n            cmap = plt.get_cmap(\"Greens\")\n            color = cmap(normcl)\n            norm = mpl.colors.Normalize(vmin=0, vmax=min_q)\n        # If both spacecraft are positively charged\n        elif max_q > 0 and min_q > 0:\n            normcl = (LeaderSpCharges[ii] - 0) / (max_q - 0)\n            # Use red colormap to denote positive charge\n            cmap = plt.get_cmap(\"Reds\")\n            color = cmap(normcl)\n            norm = mpl.colors.Normalize(vmin=0, vmax=max_q)\n        # If the spacecraft have opposing charges\n        elif max_q > 0 and min_q < 0:\n            normcl = (LeaderSpCharges[ii] - min_q) / (max_q - min_q)\n            # Use yellow to denote a neutral charge\n            cmap = plt.get_cmap(\"RdYlGn\")\n            color = cmap(normcl)\n            norm = mpl.colors.Normalize(vmin=min_q, vmax=max_q)\n        else:\n            cmap = plt.get_cmap('Greys')\n            color = (.5, .5, .5)\n            norm = mpl.colors.Normalize(vmin=min_q, vmax=max_q)\n\n        ax.plot_surface(r_SpN_N[0] + radiiL[ii] * x, r_SpN_N[1] + radiiL[ii] * y, r_SpN_N[2] + radiiL[ii] * z, color=color)\n\n    for ii in range(0, len(radiiF)):\n        r_SpN_N = r_LN_N + r_FL_N + spPosF_H[ii, 0:3]\n        if max_q < 0 and min_q < 0:\n            normcf = (FollowerSpCharges[ii] - min_q) / (0 - min_q)\n            cmap = plt.get_cmap(\"Greens_r\")\n            color = cmap(normcf)\n            norm = mpl.colors.Normalize(vmin=min_q, vmax=0)\n        elif max_q > 0 and min_q > 0:\n            normcf = (FollowerSpCharges[ii] - 0) / (max_q - 0)\n            cmap = plt.get_cmap(\"Reds\")\n            color = cmap(normcf)\n            norm = mpl.colors.Normalize(vmin=0, vmax=max_q)\n        elif max_q > 0 and min_q < 0:\n            normcf = (FollowerSpCharges[ii] - min_q) / (max_q - min_q)\n            cmap = plt.get_cmap(\"RdYlGn\")\n            color = cmap(normcf)\n            norm = mpl.colors.Normalize(vmin=min_q, vmax=max_q)\n        else:\n            cmap = plt.get_cmap('Greys')\n            color = (.5, .5, .5)\n            norm = mpl.colors.Normalize(vmin=min_q, vmax=max_q)\n\n        ax.plot_surface(r_SpN_N[0] + radiiF[ii] * x, r_SpN_N[1] + radiiF[ii] * y, r_SpN_N[2] + radiiF[ii] * z, color=color)\n\n    limits = np.array([getattr(ax, f'get_{axis}lim')() for axis in 'xyz'])\n    ax.set_box_aspect(np.ptp(limits, axis=1))\n    ax.set_xlabel('Radial')\n    ax.set_ylabel('Along Track')\n    ax.set_zlabel('Direction of Angular Momentum')\n    plt.title('MSM Representation')\n\n    figureList['Charged_Spheres'] = plt.figure(3)\n\n    # Add color map based on the spacecraft charges\n    fig2, ax = plt.subplots(figsize=(6, 1))\n    fig2.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),\n                  cax=ax, orientation='horizontal', label='Sphere Charge (C)')\n\n    figureList['Colorbar'] = plt.figure(4)\n\n    return figureList",
  "def NormalizeData(data):\n    return (data - np.min(data)) / (np.max(data) - np.min(data))",
  "def Picheck(x):\n    \"\"\"\n        Picheck(x)\n        Makes sure that the angle x lies within +/- Pi.\n    \"\"\"\n    if x > M_PI:\n        return x - 2 * M_PI\n    if x < -M_PI:\n        return x + 2 * M_PI\n    return x",
  "def C2EP(C):\n    \"\"\"\n    C2EP\n        Q = C2EP(C) translates the 3x3 direction cosine matrix\n        C into the corresponding 4x1 euler parameter vector Q,\n        where the first component of Q is the non-dimensional\n        Euler parameter Beta_0 >= 0. Transformation is done\n        using the Stanley method.\n    \"\"\"\n    tr = np.trace(C)\n    b2 = np.array([(1 + tr) / 4,\n                   (1 + 2 * C[0, 0] - tr) / 4,\n                   (1 + 2 * C[1, 1] - tr) / 4,\n                   (1 + 2 * C[2, 2] - tr) / 4\n                   ])\n    case = np.argmax(b2)\n    b = b2\n    if case == 0:\n        b[0] = np.sqrt(b2[0])\n        b[1] = (C[1, 2] - C[2, 1]) / 4 / b[0]\n        b[2] = (C[2, 0] - C[0, 2]) / 4 / b[0]\n        b[3] = (C[0, 1] - C[1, 0]) / 4 / b[0]\n    elif case == 1:\n        b[1] = np.sqrt(b2[1])\n        b[0] = (C[1, 2] - C[2, 1]) / 4 / b[1]\n        if b[0] < 0:\n            b[1] = -b[1]\n            b[0] = -b[0]\n        b[2] = (C[0, 1] + C[1, 0]) / 4 / b[1]\n        b[3] = (C[2, 0] + C[0, 2]) / 4 / b[1]\n    elif case == 2:\n        b[2] = np.sqrt(b2[2])\n        b[0] = (C[2, 0] - C[0, 2]) / 4 / b[2]\n        if b[0] < 0:\n            b[2] = -b[2]\n            b[0] = -b[0]\n        b[1] = (C[0, 1] + C[1, 0]) / 4 / b[2]\n        b[3] = (C[1, 2] + C[2, 1]) / 4 / b[2]\n    elif case == 3:\n        b[3] = np.sqrt(b2[3])\n        b[0] = (C[0, 1] - C[1, 0]) / 4 / b[3]\n        if b[0] < 0:\n            b[3] = -b[3]\n            b[0] = -b[0]\n        b[1] = (C[2, 0] + C[0, 2]) / 4 / b[3]\n        b[2] = (C[1, 2] + C[2, 1]) / 4 / b[3]\n    return b",
  "def C2Euler121(C):\n    \"\"\"\n    C2Euler121\n\n    \tQ = C2Euler121(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding (1-2-1) euler angle set.\n    \"\"\"\n    q0 = math.atan2(C[0, 1], -C[0, 2])\n    q1 = math.acos(C[0, 0])\n    q2 = math.atan2(C[1, 0], C[2, 0])\n    q = np.array([q0, q1, q2])\n\n    return q",
  "def C2Euler123(C):\n    \"\"\"\n    C2Euler123\n\n    \tQ = C2Euler123(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding (1-2-3) euler angle set.\n    \"\"\"\n    q0 = np.arctan2(-C[2, 1], C[2, 2])\n    q1 = np.arcsin(C[2, 0])\n    q2 = np.arctan2(-C[1, 0], C[0, 0])\n    q = np.array([q0, q1, q2])\n    return q",
  "def C2Euler131(C):\n    \"\"\"\n    C2Euler131\n\n    \tQ = C2Euler131(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding (1-3-1) euler angle set.\n    \"\"\"\n    q0 = math.atan2(C[0, 2], C[0, 1])\n    q1 = math.acos(C[0, 0])\n    q2 = math.atan2(C[2, 0], -C[1, 0])\n    q = np.array([q0, q1, q2])\n\n    return q",
  "def C2Euler132(C):\n    \"\"\"\n    C2Euler132\n\n    \tQ = C2Euler132(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding (1-3-2) euler angle set.\n    \"\"\"\n    q0 = math.atan2(C[1, 2], C[1, 1])\n    q1 = math.asin(-C[1, 0])\n    q2 = math.atan2(C[2, 0], C[0, 0])\n    q = np.array([q0, q1, q2])\n\n    return q",
  "def C2Euler212(C):\n    \"\"\"\n    C2Euler212\n\n    \tQ = C2Euler212(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding (2-1-2) euler angle set.\n    \"\"\"\n    q0 = math.atan2(C[1, 0], C[1, 2])\n    q1 = math.acos(C[1, 1])\n    q2 = math.atan2(C[0, 1], -C[2, 1])\n    q = np.array([q0, q1, q2])\n\n    return q",
  "def C2Euler213(C):\n    \"\"\"\n    C2Euler213\n\n        Q = C2Euler213(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding (2-1-3) euler angle set.\n    \"\"\"\n\n    q0 = math.atan2(C[2, 0], C[2, 2])\n    q1 = math.asin(-C[2, 1])\n    q2 = math.atan2(C[0, 1], C[1, 1])\n    q = np.array([q0, q1, q2])\n\n    return q",
  "def C2Euler231(C):\n    \"\"\"\n    C2Euler231\n\n    \tQ = C2Euler231(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding (2-3-1) euler angle set.\n    \"\"\"\n\n    q0 = math.atan2(-C[0, 2], C[0, 0])\n    q1 = math.asin(C[0, 1])\n    q2 = math.atan2(-C[2, 1], C[1, 1])\n    q = np.array([q0, q1, q2])\n    return q",
  "def C2Euler232(C):\n    \"\"\"\n    C2Euler232\n\n    \tQ = C2Euler232(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding (2-3-2) euler angle set.\n    \"\"\"\n\n    q0 = math.atan2(C[1, 2], -C[1, 0])\n    q1 = math.acos(C[1, 1])\n    q2 = math.atan2(C[2, 1], C[0, 1])\n    q = np.array([q0, q1, q2])\n    return q",
  "def C2Euler312(C):\n    \"\"\"\n    C2Euler312\n\n    \tQ = C2Euler312(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding (3-1-2) euler angle set.\n    \"\"\"\n\n    q0 = math.atan2(-C[1, 0], C[1, 1])\n    q1 = math.asin(C[1, 2])\n    q2 = math.atan2(-C[0, 2], C[2, 2])\n    q = np.array([q0, q1, q2])\n    return q",
  "def C2Euler313(C):\n    \"\"\"\n    C2Euler313\n\n    \tQ = C2Euler313(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding (3-1-3) euler angle set.\n    \"\"\"\n\n    q0 = math.atan2(C[2, 0], -C[2, 1])\n    q1 = math.acos(C[2, 2])\n    q2 = math.atan2(C[0, 2], C[1, 2])\n    q = np.array([q0, q1, q2])\n    return q",
  "def C2Euler321(C):\n    \"\"\"\n    C2Euler321\n\n    \tQ = C2Euler321(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding (3-2-1) euler angle set.\n    \"\"\"\n\n    q0 = math.atan2(C[0, 1], C[0, 0])\n    q1 = math.asin(-C[0, 2])\n    q2 = math.atan2(C[1, 2], C[2, 2])\n    q = np.array([q0, q1, q2])\n    return q",
  "def C2Euler323(C):\n    \"\"\"\n    C2Euler323\n\n    \tQ = C2Euler323(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding (3-2-3) euler angle set.\n    \"\"\"\n\n    q0 = math.atan2(C[2, 1], C[2, 0])\n    q1 = math.acos(C[2, 2])\n    q2 = math.atan2(C[1, 2], -C[0, 2])\n    q = np.array([q0, q1, q2])\n    return q",
  "def C2Gibbs(C):\n    \"\"\"\n    C2Gibbs\n\n    \tQ = C2Gibbs(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding 3x1 gibbs vector Q.\n    \"\"\"\n\n    b = C2EP(C)\n\n    q0 = b[1] / b[0]\n    q1 = b[2] / b[0]\n    q2 = b[3] / b[0]\n    q = np.array([q0, q1, q2])\n    return q",
  "def C2MRP(C):\n    \"\"\"\n    C2MRP\n\n    \tQ = C2MRP(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding 3x1 MRP vector Q where the\n    \tMRP vector is chosen such that :math:`|Q| <= 1`.\n    \"\"\"\n\n    b = C2EP(C)\n    q = np.array([\n        b[1] / (1 + b[0]),\n        b[2] / (1 + b[0]),\n        b[3] / (1 + b[0])\n    ])\n    return q",
  "def C2PRV(C):\n    \"\"\"\n    C2PRV\n\n    \tQ = C2PRV(C) translates the 3x3 direction cosine matrix\n    \tC into the corresponding 3x1 principal rotation vector Q,\n    \twhere the first component of Q is the principal rotation angle\n    \tphi (0<= phi <= Pi)\n    \"\"\"\n\n    cp = (np.trace(C) - 1) / 2\n    p = np.arccos(cp)\n    sp = p / 2. / np.sin(p)\n    q = np.array([\n        (C[1, 2] - C[2, 1]) * sp,\n        (C[2, 0] - C[0, 2]) * sp,\n        (C[0, 1] - C[1, 0]) * sp\n    ])\n    return q",
  "def addEP(b1, b2):\n    \"\"\"\n    addEP(B1,B2)\n\n    \tQ = addEP(B1,B2) provides the euler parameter vector\n    \twhich corresponds to performing to successive\n    \trotations B1 and B2.\n    \"\"\"\n\n    q0 = b2[0] * b1[0] - b2[1] * b1[1] - b2[2] * b1[2] - b2[3] * b1[3]\n    q1 = b2[1] * b1[0] + b2[0] * b1[1] + b2[3] * b1[2] - b2[2] * b1[3]\n    q2 = b2[2] * b1[0] - b2[3] * b1[1] + b2[0] * b1[2] + b2[1] * b1[3]\n    q3 = b2[3] * b1[0] + b2[2] * b1[1] - b2[1] * b1[2] + b2[0] * b1[3]\n    q = np.array([q0, q1, q2, q3])\n\n    return q",
  "def addEuler121(e1, e2):\n    \"\"\"\n    addEuler121(E1,E2)\n\n    \tQ = addEuler121(E1,E2) computes the overall (1-2-1) euler\n    \tangle vector corresponding to two successive\n    \t(1-2-1) rotations E1 and E2.\n    \"\"\"\n\n    cp1 = math.cos(e1[1])\n    cp2 = math.cos(e2[1])\n    sp1 = math.sin(e1[1])\n    sp2 = math.sin(e2[1])\n    dum = e1[2] + e2[0]\n\n    q1 = math.acos(cp1 * cp2 - sp1 * sp2 * math.cos(dum))\n    cp3 = math.cos(q1)\n    q0 = Picheck(e1[0] + math.atan2(sp1 * sp2 * math.sin(dum), cp2 - cp3 * cp1))\n    q2 = Picheck(e2[2] + math.atan2(sp1 * sp2 * math.sin(dum), cp1 - cp3 * cp2))\n\n    q = np.array([q0, q1, q2])\n\n    return q",
  "def addEuler123(e1, e2):\n    \"\"\"\n    addEuler123(E1,E2)\n\n    \tQ = addEuler123(E1,E2) computes the overall (1-2-3) euler\n    \tangle vector corresponding to two successive\n    \t(1-2-3) rotations E1 and E2.\n    \"\"\"\n\n    C1 = euler1232C(e1)\n    C2 = euler1232C(e2)\n    C = np.dot(C2, C1)\n    return C2Euler123(C)",
  "def addEuler131(e1, e2):\n    \"\"\"\n    addEuler131(E1,E2)\n\n    \tQ = addEuler131(E1,E2) computes the overall (1-3-1) euler\n    \tangle vector corresponding to two successive\n    \t(1-3-1) rotations E1 and E2.\n    \"\"\"\n\n    cp1 = math.cos(e1[1])\n    cp2 = math.cos(e2[1])\n    sp1 = math.sin(e1[1])\n    sp2 = math.sin(e2[1])\n    dum = e1[2] + e2[0]\n\n    q1 = math.acos(cp1 * cp2 - sp1 * sp2 * math.cos(dum))\n    cp3 = math.cos(q1)\n    q0 = Picheck(e1[0] + math.atan2(sp1 * sp2 * math.sin(dum), cp2 - cp3 * cp1))\n    q2 = Picheck(e2[2] + math.atan2(sp1 * sp2 * math.sin(dum), cp1 - cp3 * cp2))\n\n    q = np.array([q0, q1, q2])\n    return q",
  "def addEuler132(e1, e2):\n    \"\"\"\n    addEuler132(E1,E2)\n\n    \tQ = addEuler132(E1,E2) computes the overall (1-3-2) euler\n    \tangle vector corresponding to two successive\n    \t(1-3-2) rotations E1 and E2.\n    \"\"\"\n\n    C1 = euler1322C(e1)\n    C2 = euler1322C(e2)\n    C = np.dot(C2, C1)\n    return C2Euler132(C)",
  "def addEuler212(e1, e2):\n    \"\"\"\n    addEuler212(E1,E2)\n\n    \tQ = addEuler212(E1,E2) computes the overall (2-1-2) euler\n    \tangle vector corresponding to two successive\n    \t(2-1-2) rotations E1 and E2.\n    \"\"\"\n\n    cp1 = math.cos(e1[1])\n    cp2 = math.cos(e2[1])\n    sp1 = math.sin(e1[1])\n    sp2 = math.sin(e2[1])\n    dum = e1[2] + e2[0]\n\n    q1 = math.acos(cp1 * cp2 - sp1 * sp2 * math.cos(dum))\n    cp3 = math.cos(q1)\n    q0 = Picheck(e1[0] + math.atan2(sp1 * sp2 * math.sin(dum), cp2 - cp3 * cp1))\n    q2 = Picheck(e2[2] + math.atan2(sp1 * sp2 * math.sin(dum), cp1 - cp3 * cp2))\n    q = np.array([q0, q1, q2])\n    return q",
  "def addEuler213(e1, e2):\n    \"\"\"\n    addEuler213(E1,E2)\n\n    \tQ = addEuler213(E1,E2) computes the overall (2-1-3) euler\n    \tangle vector corresponding to two successive\n    \t(2-1-3) rotations E1 and E2.\n    \"\"\"\n\n    C1 = euler2132C(e1)\n    C2 = euler2132C(e2)\n    C = np.dot(C2, C1)\n    return C2Euler213(C)",
  "def addEuler231(e1, e2):\n    \"\"\"\n    addEuler231(E1,E2)\n\n    \tQ = addEuler231(E1,E2) computes the overall (2-3-1) euler\n    \tangle vector corresponding to two successive\n    \t(2-3-1) rotations E1 and E2.\n    \"\"\"\n\n    C1 = euler2312C(e1)\n    C2 = euler2312C(e2)\n    C = np.dot(C2, C1)\n    return C2Euler231(C)",
  "def addEuler232(e1, e2):\n    \"\"\"\n    addEuler232(E1,E2)\n\n    \tQ = addEuler232(E1,E2) computes the overall (2-3-2) euler\n    \tangle vector corresponding to two successive\n    \t(2-3-2) rotations E1 and E2.\n    \"\"\"\n\n    cp1 = math.cos(e1[1])\n    cp2 = math.cos(e2[1])\n    sp1 = math.sin(e1[1])\n    sp2 = math.sin(e2[1])\n    dum = e1[2] + e2[0]\n\n    q1 = math.acos(cp1 * cp2 - sp1 * sp2 * math.cos(dum))\n    cp3 = math.cos(q1)\n    q0 = Picheck(e1[0] + math.atan2(sp1 * sp2 * math.sin(dum), cp2 - cp3 * cp1))\n    q2 = Picheck(e2[2] + math.atan2(sp1 * sp2 * math.sin(dum), cp1 - cp3 * cp2))\n    q = np.array([q0, q1, q2])\n    return q",
  "def addEuler312(e1, e2):\n    \"\"\"\n    addEuler312(E1,E2)\n\n    \tQ = addEuler312(E1,E2) computes the overall (3-1-2) euler\n    \tangle vector corresponding to two successive\n    \t(3-1-2) rotations E1 and E2.\n    \"\"\"\n\n    C1 = euler3122C(e1)\n    C2 = euler3122C(e2)\n    C = np.dot(C2, C1)\n    return C2Euler312(C)",
  "def addEuler313(e1, e2):\n    \"\"\"\n    addEuler313(E1,E2)\n\n    \tQ = addEuler313(E1,E2) computes the overall (3-1-3) euler\n    \tangle vector corresponding to two successive\n    \t(3-1-3) rotations E1 and E2.\n    \"\"\"\n\n    cp1 = math.cos(e1[1])\n    cp2 = math.cos(e2[1])\n    sp1 = math.sin(e1[1])\n    sp2 = math.sin(e2[1])\n    dum = e1[2] + e2[0]\n\n    q1 = math.acos(cp1 * cp2 - sp1 * sp2 * math.cos(dum))\n    cp3 = math.cos(q1)\n    q0 = Picheck(e1[0] + math.atan2(sp1 * sp2 * math.sin(dum), cp2 - cp3 * cp1))\n    q2 = Picheck(e2[2] + math.atan2(sp1 * sp2 * math.sin(dum), cp1 - cp3 * cp2))\n    q = np.array([q0, q1, q2])\n    return q",
  "def addEuler321(e1, e2):\n    \"\"\"\n    addEuler321(E1,E2)\n\n    \tQ = addEuler321(E1,E2) computes the overall (3-2-1) euler\n    \tangle vector corresponding to two successive\n    \t(3-2-1) rotations E1 and E2.\n    \"\"\"\n\n    C1 = euler3212C(e1)\n    C2 = euler3212C(e2)\n    C = np.dot(C2, C1)\n    return C2Euler321(C)",
  "def addEuler323(e1, e2):\n    \"\"\"\n    addEuler323(E1,E2)\n\n    \tQ = addEuler323(E1,E2) computes the overall (3-2-3) euler\n    \tangle vector corresponding to two successive\n    \t(3-2-3) rotations E1 and E2.\n    \"\"\"\n\n    cp1 = math.cos(e1[1])\n    cp2 = math.cos(e2[1])\n    sp1 = math.sin(e1[1])\n    sp2 = math.sin(e2[1])\n    dum = e1[2] + e2[0]\n\n    q1 = math.acos(cp1 * cp2 - sp1 * sp2 * math.cos(dum))\n    cp3 = math.cos(q1)\n    q0 = Picheck(e1[0] + math.atan2(sp1 * sp2 * math.sin(dum), cp2 - cp3 * cp1))\n    q2 = Picheck(e2[2] + math.atan2(sp1 * sp2 * math.sin(dum), cp1 - cp3 * cp2))\n    q = np.array([q0, q1, q2])\n    return q",
  "def addGibbs(q1, q2):\n    \"\"\"\n    addGibbs(Q1,Q2)\n\n    \tQ = addGibbs(Q1,Q2) provides the gibbs vector\n    \twhich corresponds to performing to successive\n    \trotations Q1 and Q2.\n    \"\"\"\n    result = (q1 + q2 + np.cross(q1, q2)) / (1 - np.dot(q1, q2))\n    return result",
  "def addMRP(q1, q2):\n    \"\"\"\n     addMRP(Q1,Q2)\n\n    \tQ = addMRP(Q1,Q2) provides the MRP vector\n    \twhich corresponds to performing to successive\n    \trotations Q1 and Q2.\n    \"\"\"\n\n    den = 1 + np.dot(q1, q1) * np.dot(q2, q2) - 2 * np.dot(q1, q2)\n\n    if np.abs(den) < 1e-5:\n        q2 = -q2/np.dot(q2,q2)\n        den = 1 + np.dot(q1, q1) * np.dot(q2, q2) - 2 * np.dot(q1, q2)\n    num = (1 - np.dot(q1, q1)) * q2 + (1 - np.dot(q2, q2)) * q1 + 2 * np.cross(q1, q2)\n\n    q = num / den\n\n    if np.dot(q,q) > 1:\n            q = - q/np.dot(q,q)\n\n    return q",
  "def PRV2elem(r):\n    \"\"\"\n    PRV2elem(R)\n\n    \tQ = PRV2elem(R) translates a prinicpal rotation vector R\n    \tinto the corresponding principal rotation element set Q.\n    \"\"\"\n    q0 = np.linalg.norm(r)\n    if q0 < 1e-12:\n        return np.zeros(4)\n    q1 = r[0] / q0\n    q2 = r[1] / q0\n    q3 = r[2] / q0\n    q = np.array([q0, q1, q2, q3])\n    return q",
  "def addPRV(qq1, qq2):\n    \"\"\"\n     addPRV(Q1,Q2)\n\n    \tQ = addPRV(Q1,Q2) provides the principal rotation vector\n    \twhich corresponds to performing to successive\n    \tprinicipal rotations Q1 and Q2.\n    \"\"\"\n\n    q1 = PRV2elem(qq1)\n    q2 = PRV2elem(qq2)\n    cp1 = math.cos(q1[0] / 2.)\n    cp2 = math.cos(q2[0] / 2.)\n    sp1 = math.sin(q1[0] / 2.)\n    sp2 = math.sin(q2[0] / 2.)\n    e1 = q1[1:4]\n    e2 = q2[1:4]\n\n    p = 2. * math.acos(cp1 * cp2 - sp1 * sp2 * np.dot(e1, e2))\n    sp = math.sin(p / 2.)\n    e = (cp1 * sp2 * e2 + cp2 * sp1 * e1 + sp1 * sp2 * np.cross(e1, e2))\n    q = (p / sp) * e\n\n    return q",
  "def BinvEP(q):\n    \"\"\"\n    BinvEP(Q)\n\n    \tB = BinvEP(Q) returns the 3x4 matrix which relates\n    \tthe derivative of euler parameter vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = 2 [B(Q)]^(-1) dQ/dt\n    \"\"\"\n    B = np.zeros([3, 4])\n    B[0, 0] = -q[1]\n    B[0, 1] = q[0]\n    B[0, 2] = q[3]\n    B[0, 3] = -q[2]\n    B[1] = -q[2]\n    B[1, 1] = -q[3]\n    B[1, 2] = q[0]\n    B[1, 3] = q[1]\n    B[2] = -q[3]\n    B[2, 1] = q[2]\n    B[2, 2] = -q[1]\n    B[2, 3] = q[0]\n\n    return B",
  "def BinvEuler121(q):\n    \"\"\"\n    BinvEuler121(Q)\n\n    \tB = BinvEuler121(Q) returns the 3x3 matrix which relates\n    \tthe derivative of the (1-2-1) euler angle vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n\n    B = np.zeros([3, 3])\n    B[0, 0] = c2\n    B[0, 1] = 0\n    B[0, 2] = 1\n    B[1, 0] = s2 * s3\n    B[1, 1] = c3\n    B[1, 2] = 0\n    B[2, 0] = s2 * c3\n    B[2, 1] = -s3\n    B[2, 2] = 0\n\n    return B",
  "def BinvEuler123(q):\n    \"\"\"\n    BinvEuler123(Q)\n\n    \tB = BinvEuler123(Q) returns the 3x3 matrix which relates\n    \tthe derivative of the (1-2-3) euler angle vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n\n    B = np.zeros([3, 3])\n    B[0, 0] = c2 * c3\n    B[0, 1] = s3\n    B[0, 2] = 0\n    B[1, 0] = -c2 * s3\n    B[1, 1] = c3\n    B[1, 2] = 0\n    B[2, 0] = s2\n    B[2, 1] = 0\n    B[2, 2] = 1\n\n    return B",
  "def BinvEuler131(q):\n    \"\"\"\n    BinvEuler131(Q)\n\n    \tB = BinvEuler131(Q) returns the 3x3 matrix which relates\n    \tthe derivative of the (1-3-1) euler angle vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n\n    B = np.zeros([3, 3])\n    B[0, 0] = c2\n    B[0, 1] = 0\n    B[0, 2] = 1\n    B[1, 0] = -s2 * c3\n    B[1, 1] = s3\n    B[1, 2] = 0\n    B[2, 0] = s2 * s3\n    B[2, 1] = c3\n    B[2, 2] = 0\n\n    return B",
  "def BinvEuler132(q):\n    \"\"\"\n    BinvEuler132(Q)\n\n    \tB = BinvEuler132(Q) returns the 3x3 matrix which relates\n    \tthe derivative of the (1-3-2) euler angle vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n\n    B = np.zeros([3, 3])\n    B[0, 0] = c2 * c3\n    B[0, 1] = -s3\n    B[0, 2] = 0\n    B[1, 0] = -s2\n    B[1, 1] = 0\n    B[1, 2] = 1\n    B[2, 0] = c2 * s3\n    B[2, 1] = c3\n    B[2, 2] = 0\n\n    return B",
  "def BinvEuler212(q):\n    \"\"\"\n    BinvEuler212(Q)\n\n    \tB = BinvEuler212(Q) returns the 3x3 matrix which relates\n    \tthe derivative of the (2-1-2) euler angle vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n\n    B = np.zeros([3, 3])\n    B[0, 0] = s2 * s3\n    B[0, 1] = c3\n    B[0, 2] = 0\n    B[1, 0] = c2\n    B[1, 1] = 0\n    B[1, 2] = 1\n    B[2, 0] = -s2 * c3\n    B[2, 1] = s3\n    B[2, 2] = 0\n\n    return B",
  "def BinvEuler213(q):\n    \"\"\"\n    BinvEuler213(Q)\n\n    \tB = BinvEuler213(Q) returns the 3x3 matrix which relates\n    \tthe derivative of the (2-1-3) euler angle vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n\n    B = np.zeros([3, 3])\n    B[0, 0] = c2 * s3\n    B[0, 1] = c3\n    B[0, 2] = 0\n    B[1, 0] = c2 * c3\n    B[1, 1] = -s3\n    B[1, 2] = 0\n    B[2, 0] = -s2\n    B[2, 1] = 0\n    B[2, 2] = 1\n\n    return B",
  "def BinvEuler231(q):\n    \"\"\"\n    BinvEuler231(Q)\n\n    \tB = BinvEuler231(Q) returns the 3x3 matrix which relates\n    \tthe derivative of the (2-3-1) euler angle vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n\n    B = np.zeros([3, 3])\n    B[0, 0] = s2\n    B[0, 1] = 0\n    B[0, 2] = 1\n    B[1, 0] = c2 * c3\n    B[1, 1] = s3\n    B[1, 2] = 0\n    B[2, 0] = -c2 * s3\n    B[2, 1] = c3\n    B[2, 2] = 0\n\n    return B",
  "def BinvEuler232(q):\n    \"\"\"\n    BinvEuler232(Q)\n\n    \tB = BinvEuler232(Q) returns the 3x3 matrix which relates\n    \tthe derivative of the (2-3-2) euler angle vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n\n    B = np.zeros([3, 3])\n    B[0, 0] = s2 * c3\n    B[0, 1] = -s3\n    B[0, 2] = 0\n    B[1, 0] = c2\n    B[1, 1] = 0\n    B[1, 2] = 1\n    B[2, 0] = s2 * s3\n    B[2, 1] = c3\n    B[2, 2] = 0\n\n    return B",
  "def BinvEuler312(q):\n    \"\"\"\n    BinvEuler312(Q)\n\n    \tB = BinvEuler312(Q) returns the 3x3 matrix which relates\n    \tthe derivative of the (3-1-2) euler angle vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n\n    B = np.zeros([3, 3])\n    B[0, 0] = -c2 * s3\n    B[0, 1] = c3\n    B[0, 2] = 0\n    B[1, 0] = s2\n    B[1, 1] = 0\n    B[1, 2] = 1\n    B[2, 0] = c2 * c3\n    B[2, 1] = s3\n    B[2, 2] = 0\n\n    return B",
  "def BinvEuler313(q):\n    \"\"\"\n    BinvEuler313(Q)\n\n    \tB = BinvEuler313(Q) returns the 3x3 matrix which relates\n    \tthe derivative of the (3-1-3) euler angle vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n\n    B = np.zeros([3, 3])\n    B[0, 0] = s2 * s3\n    B[0, 1] = c3\n    B[0, 2] = 0\n    B[1, 0] = s2 * c3\n    B[1, 1] = -s3\n    B[1, 2] = 0\n    B[2, 0] = c2\n    B[2, 1] = 0\n    B[2, 2] = 1\n\n    return B",
  "def BinvEuler321(q):\n    \"\"\"\n    BinvEuler321(Q)\n\n    \tB = BinvEuler321(Q) returns the 3x3 matrix which relates\n    \tthe derivative of the (3-2-1) euler angle vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n\n    B = np.zeros([3, 3])\n    B[0, 0] = -s2\n    B[0, 1] = 0\n    B[0, 2] = 1\n    B[1, 0] = c2 * s3\n    B[1, 1] = c3\n    B[1, 2] = 0\n    B[2, 0] = c2 * c3\n    B[2, 1] = -s3\n    B[2, 2] = 0\n\n    return B",
  "def BinvEuler323(q):\n    \"\"\"\n    BinvEuler323(Q)\n\n    \tB = BinvEuler323(Q) returns the 3x3 matrix which relates\n    \tthe derivative of the (3-2-3) euler angle vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n\n    B = np.zeros([3, 3])\n    B[0, 0] = -s2 * c3\n    B[0, 1] = s3\n    B[0, 2] = 0\n    B[1, 0] = s2 * s3\n    B[1, 1] = c3\n    B[1, 2] = 0\n    B[2, 0] = c2\n    B[2, 1] = 0\n    B[2, 2] = 1\n\n    return B",
  "def BinvGibbs(q):\n    \"\"\"\n    BinvGibbs(Q)\n\n    \tB = BinvGibbs(Q) returns the 3x3 matrix which relates\n    \tthe derivative of gibbs vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = 2 [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    B = np.zeros([3, 3])\n    B[0, 0] = 1\n    B[0, 1] = q[2]\n    B[0, 2] = -q[1]\n    B[1, 0] = -q[2]\n    B[1, 1] = 1\n    B[1, 2] = q[0]\n    B[2, 0] = q[1]\n    B[2, 1] = -q[0]\n    B[2, 2] = 1\n    B = B / (1 + np.dot(q, q))\n\n    return B",
  "def BinvMRP(q):\n    \"\"\"\n    BinvMRP(Q)\n\n    \tB = BinvMRP(Q) returns the 3x3 matrix which relates\n    \tthe derivative of MRP vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = 4 [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    s2 = np.dot(q, q)\n    B = np.zeros([3, 3])\n    B[0, 0] = 1 - s2 + 2 * q[0] * q[0]\n    B[0, 1] = 2 * (q[0] * q[1] + q[2])\n    B[0, 2] = 2 * (q[0] * q[2] - q[1])\n    B[1, 0] = 2 * (q[1] * q[0] - q[2])\n    B[1, 1] = 1 - s2 + 2 * q[1] * q[1]\n    B[1, 2] = 2 * (q[1] * q[2] + q[0])\n    B[2, 0] = 2 * (q[2] * q[0] + q[1])\n    B[2, 1] = 2 * (q[2] * q[1] - q[0])\n    B[2, 2] = 1 - s2 + 2 * q[2] * q[2]\n    B = B / (1 + s2) / (1 + s2)\n\n    return B",
  "def BinvPRV(q):\n    \"\"\"\n    BinvPRV(Q)\n\n    \tB = BinvPRV(Q) returns the 3x3 matrix which relates\n    \tthe derivative of principal rotation vector Q to the\n    \tbody angular velocity vector w.\n\n    \t\tw = [B(Q)]^(-1) dQ/dt\n    \"\"\"\n\n    p = la.norm(q)\n    c1 = (1 - math.cos(p)) / p / p\n    c2 = (p - math.sin(p)) / p / p / p\n\n    B = np.zeros([3, 3])\n    B[0, 0] = 1 - c2 * (q[1] * q[1] + q[2] * q[2])\n    B[0, 1] = c1 * q[2] + c2 * q[0] * q[1]\n    B[0, 2] = -c1 * q[1] + c2 * q[0] * q[2]\n    B[1, 0] = -c1 * q[2] + c2 * q[0] * q[1]\n    B[1, 1] = 1 - c2 * (q[0] * q[0] + q[2] * q[2])\n    B[1, 2] = c1 * q[0] + c2 * q[1] * q[2]\n    B[2, 0] = c1 * q[1] + c2 * q[2] * q[0]\n    B[2, 1] = -c1 * q[0] + c2 * q[2] * q[1]\n    B[2, 2] = 1 - c2 * (q[0] * q[0] + q[1] * q[1])\n\n    return B",
  "def BmatEP(q):\n    \"\"\"\n    BmatEP(Q)\n\n    \tB = BmatEP(Q) returns the 4x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \tEuler parameter vector Q.\n\n    \t\tdQ/dt = 1/2 [B(Q)] w\n    \"\"\"\n\n    B = np.zeros([4, 3])\n    B[0, 0] = -q[1]\n    B[0, 1] = -q[2]\n    B[0, 2] = -q[3]\n    B[1, 0] = q[0]\n    B[1, 1] = -q[3]\n    B[1, 2] = q[2]\n    B[2, 0] = q[3]\n    B[2, 1] = q[0]\n    B[2, 2] = -q[1]\n    B[3, 0] = -q[2]\n    B[3, 1] = q[1]\n    B[3, 2] = q[0]\n\n    return B",
  "def BmatEuler121(q):\n    \"\"\"\n    BmatEuler121(Q)\n\n    \tB = BmatEuler121(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \t(1-2-1) euler angle vector Q.\n\n    \t\tdQ/dt = [B(Q)] w\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n    B = np.zeros([3, 3])\n\n    B[0, 0] = 0\n    B[0, 1] = s3\n    B[0, 2] = c3\n    B[1, 0] = 0\n    B[1, 1] = s2 * c3\n    B[1, 2] = -s2 * s3\n    B[2, 0] = s2\n    B[2, 1] = -c2 * s3\n    B[2, 2] = -c2 * c3\n    B = B / s2\n\n    return B",
  "def BmatEuler123(q):\n    \"\"\"\n    BmatEuler123(Q)\n\n    \tB = BmatEuler123(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \t(1-2-3) euler angle vector Q.\n\n    \t\tdQ/dt = [B(Q)] w\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n    B = np.zeros([3, 3])\n\n    B[0, 0] = c3\n    B[0, 1] = -s3\n    B[0, 2] = 0\n    B[1, 0] = c2 * s3\n    B[1, 1] = c2 * c3\n    B[1, 2] = 0\n    B[2, 0] = -s2 * c3\n    B[2, 1] = s2 * s3\n    B[2, 2] = c2\n    B = B / c2\n\n    return B",
  "def BmatEuler131(q):\n    \"\"\"\n    BmatEuler131(Q)\n\n    \tB = BmatEuler131(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \t(1-3-1) euler angle vector Q.\n\n    \t\tdQ/dt = [B(Q)] w\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n    B = np.zeros([3, 3])\n\n    B[0, 0] = 0\n    B[0, 1] = -c3\n    B[0, 2] = s3\n    B[1, 0] = 0\n    B[1, 1] = s2 * s3\n    B[1, 2] = s2 * c3\n    B[2, 0] = s2\n    B[2, 1] = c2 * c3\n    B[2, 2] = -c2 * s3\n    B = B / s2\n\n    return B",
  "def BmatEuler132(q):\n    \"\"\"\n    BmatEuler132(Q)\n\n    \tB = BmatEuler132(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \t(1-3-2) euler angle vector Q.\n\n    \t\tdQ/dt = [B(Q)] w\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n    B = np.zeros([3, 3])\n\n    B[0, 0] = c3\n    B[0, 1] = 0\n    B[0, 2] = s3\n    B[1, 0] = -c2 * s3\n    B[1, 1] = 0\n    B[1, 2] = c2 * c3\n    B[2, 0] = s2 * c3\n    B[2, 1] = c2\n    B[2, 2] = s2 * s3\n    B = B / c2\n\n    return B",
  "def BmatEuler212(q):\n    \"\"\"\n    BmatEuler212(Q)\n\n    \tB = BmatEuler212(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \t(2-1-2) euler angle vector Q.\n\n    \t\tdQ/dt = [B(Q)] w\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n    B = np.zeros([3, 3])\n\n    B[0, 0] = s3\n    B[0, 1] = 0\n    B[0, 2] = -c3\n    B[1, 0] = s2 * c3\n    B[1, 1] = 0\n    B[1, 2] = s2 * s3\n    B[2, 0] = -c2 * s3\n    B[2, 1] = s2\n    B[2, 2] = c2 * c3\n    B = B / s2\n\n    return B",
  "def BmatEuler213(q):\n    \"\"\"\n    BmatEuler213(Q)\n\n    \tB = BmatEuler213(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \t(2-1-3) euler angle vector Q.\n\n    \t\tdQ/dt = [B(Q)] w\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n    B = np.zeros([3, 3])\n\n    B[0, 0] = s3\n    B[0, 1] = c3\n    B[0, 2] = 0\n    B[1, 0] = c2 * c3\n    B[1, 1] = -c2 * s3\n    B[1, 2] = 0\n    B[2, 0] = s2 * s3\n    B[2, 1] = s2 * c3\n    B[2, 2] = c2\n    B = B / c2\n\n    return B",
  "def BmatEuler231(q):\n    \"\"\"\n    BmatEuler231(Q)\n\n    \tB = BmatEuler231(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \t(2-3-1) euler angle vector Q.\n\n    \t\tdQ/dt = [B(Q)] w\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n    B = np.zeros([3, 3])\n\n    B[0, 0] = 0\n    B[0, 1] = c3\n    B[0, 2] = -s3\n    B[1, 0] = 0\n    B[1, 1] = c2 * s3\n    B[1, 2] = c2 * c3\n    B[2, 0] = c2\n    B[2, 1] = -s2 * c3\n    B[2, 2] = s2 * s3\n    B = B / c2\n\n    return B",
  "def BmatEuler232(q):\n    \"\"\"\n    BmatEuler232(Q)\n\n    \tB = BmatEuler232(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \t(2-3-2) euler angle vector Q.\n\n    \t\tdQ/dt = [B(Q)] w\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n    B = np.zeros([3, 3])\n\n    B[0, 0] = c3\n    B[0, 1] = 0\n    B[0, 2] = s3\n    B[1, 0] = -s2 * s3\n    B[1, 1] = 0\n    B[1, 2] = s2 * c3\n    B[2, 0] = -c2 * c3\n    B[2, 1] = s2\n    B[2, 2] = -c2 * s3\n    B = B / s2\n\n    return B",
  "def BmatEuler312(q):\n    \"\"\"\n    BmatEuler312(Q)\n\n    \tB = BmatEuler312(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \t(3-1-2) euler angle vector Q.\n\n    \t\tdQ/dt = [B(Q)] w\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n    B = np.zeros([3, 3])\n\n    B[0, 0] = -s3\n    B[0, 1] = 0\n    B[0, 2] = c3\n    B[1, 0] = c2 * c3\n    B[1, 1] = 0\n    B[1, 2] = c2 * s3\n    B[2, 0] = s2 * s3\n    B[2, 1] = c2\n    B[2, 2] = -s2 * c3\n    B = B / c2\n\n    return B",
  "def BmatEuler313(q):\n    \"\"\"\n    BmatEuler313(Q)\n\n    \tB = BmatEuler313(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \t(3-1-3) euler angle vector Q.\n\n    \t\tdQ/dt = [B(Q)] w\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n    B = np.zeros([3, 3])\n\n    B[0, 0] = s3\n    B[0, 1] = c3\n    B[0, 2] = 0\n    B[1, 0] = c3 * s2\n    B[1, 1] = -s3 * s2\n    B[1, 2] = 0\n    B[2, 0] = -s3 * c2\n    B[2, 1] = -c3 * c2\n    B[2, 2] = s2\n    B = B / s2\n\n    return B",
  "def BmatEuler321(q):\n    \"\"\"\n    BmatEuler321(Q)\n\n    \tB = BmatEuler321(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \t(3-2-1) euler angle vector Q.\n\n    \t\tdQ/dt = [B(Q)] w\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n    B = np.zeros([3, 3])\n\n    B[0, 0] = 0\n    B[0, 1] = s3\n    B[0, 2] = c3\n    B[1, 0] = 0\n    B[1, 1] = c2 * c3\n    B[1, 2] = -c2 * s3\n    B[2, 0] = c2\n    B[2, 1] = s2 * s3\n    B[2, 2] = s2 * c3\n    B = B / c2\n\n    return B",
  "def BmatEuler323(q):\n    \"\"\"\n    BmatEuler323(Q)\n\n    \tB = BmatEuler323(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \t(3-2-3) euler angle vector Q.\n\n    \t\tdQ/dt = [B(Q)] w\n    \"\"\"\n\n    s2 = math.sin(q[1])\n    c2 = math.cos(q[1])\n    s3 = math.sin(q[2])\n    c3 = math.cos(q[2])\n    B = np.zeros([3, 3])\n\n    B[0, 0] = -c3\n    B[0, 1] = s3\n    B[0, 2] = 0\n    B[1, 0] = s2 * s3\n    B[1, 1] = s2 * c3\n    B[1, 2] = 0\n    B[2, 0] = c2 * c3\n    B[2, 1] = -c2 * s3\n    B[2, 2] = s2\n    B = B / s2\n\n    return B",
  "def BmatGibbs(q):\n    \"\"\"\n    BmatGibbs(Q)\n\n    \tB = BmatGibbs(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \tGibbs vector Q.\n\n    \t\tdQ/dt = 1/2 [B(Q)] w\n    \"\"\"\n\n    B = np.zeros([3, 3])\n    B[0, 0] = 1 + q[0] * q[0]\n    B[0, 1] = q[0] * q[1] - q[2]\n    B[0, 2] = q[0] * q[2] + q[1]\n    B[1, 0] = q[1] * q[0] + q[2]\n    B[1, 1] = 1 + q[1] * q[1]\n    B[1, 2] = q[1] * q[2] - q[0]\n    B[2, 0] = q[2] * q[0] - q[1]\n    B[2, 1] = q[2] * q[1] + q[0]\n    B[2, 2] = 1 + q[2] * q[2]\n\n    return B",
  "def BmatMRP(q):\n    \"\"\"\n    BmatMRP(Q)\n\n    \tB = BmatMRP(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \tMRP vector Q.\n\n    \t\tdQ/dt = 1/4 [B(Q)] w\n    \"\"\"\n\n    B = np.zeros([3, 3])\n    s2 = np.dot(q, q)\n    B[0, 0] = 1 - s2 + 2 * q[0] * q[0]\n    B[0, 1] = 2 * (q[0] * q[1] - q[2])\n    B[0, 2] = 2 * (q[0] * q[2] + q[1])\n    B[1, 0] = 2 * (q[1] * q[0] + q[2])\n    B[1, 1] = 1 - s2 + 2 * q[1] * q[1]\n    B[1, 2] = 2 * (q[1] * q[2] - q[0])\n    B[2, 0] = 2 * (q[2] * q[0] - q[1])\n    B[2, 1] = 2 * (q[2] * q[1] + q[0])\n    B[2, 2] = 1 - s2 + 2 * q[2] * q[2]\n\n    return B",
  "def BdotmatMRP(q, dq):\n    \"\"\"\n    BdotmatMRP(Q, dQ)\n\n    \tB = BdotmatMRP(Q, dQ) returns the derivative of the 3x3 BmatMRP \n        matrix, which is used to calculate the second order derivative \n        of the MRP vector Q.\n\n    \t(d^2Q)/(dt^2) = 1/4 ( [B(Q)] dw + [Bdot(Q,dQ)] w )\n    \"\"\"\n\n    Bdot = np.zeros([3, 3])\n    s = -2 * np.dot(q, dq)\n    Bdot[0, 0] = s + 4 * (q[0] * dq[0])\n    Bdot[0, 1] = 2 * (-dq[2] + q[0] * dq[1] + dq[0] * q[1])\n    Bdot[0, 2] = 2 * ( dq[1] + q[0] * dq[2] + dq[0] * q[2])\n    Bdot[1, 0] = 2 * ( dq[2] + q[0] * dq[1] + dq[0] * q[1])\n    Bdot[1, 1] = s + 4 * (q[1] * dq[1])\n    Bdot[1, 2] = 2 * (-dq[0] + q[1] * dq[2] + dq[1] * q[2])\n    Bdot[2, 0] = 2 * (-dq[1] + q[0] * dq[2] + dq[0] * q[2])\n    Bdot[2, 1] = 2 * ( dq[0] + q[1] * dq[2] + dq[1] * q[2])\n    Bdot[2, 2] = s + 4 * (q[2] * dq[2])\n\n    return Bdot",
  "def BmatPRV(q):\n    \"\"\"\n    BmatPRV(Q)\n\n    \tB = BmatPRV(Q) returns the 3x3 matrix which relates the\n    \tbody angular velocity vector w to the derivative of\n    \tprincipal rotation vector Q.\n\n    \t\tdQ/dt = [B(Q)] w\n    \"\"\"\n\n    p = np.linalg.norm(q)\n    c = 1 / p / p * (1 - p / 2 / math.tan(p / 2))\n    B = np.zeros([3, 3])\n    B[0, 0] = 1 - c * (q[1] * q[1] + q[2] * q[2])\n    B[0, 1] = -q[2] / 2 + c * (q[0] * q[1])\n    B[0, 2] = q[1] / 2 + c * (q[0] * q[2])\n    B[1, 0] = q[2] / 2 + c * (q[0] * q[1])\n    B[1, 1] = 1 - c * (q[0] * q[0] + q[2] * q[2])\n    B[1, 2] = -q[0] / 2 + c * (q[1] * q[2])\n    B[2, 0] = -q[1] / 2 + c * (q[0] * q[2])\n    B[2, 1] = q[0] / 2 + c * (q[1] * q[2])\n    B[2, 2] = 1 - c * (q[0] * q[0] + q[1] * q[1])\n\n    return B",
  "def dEP(q, w):\n    \"\"\"\n    dEP(Q,W)\n\n    \tdq = dEP(Q,W) returns the euler parameter derivative\n    \tfor a given euler parameter vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt = 1/2 [B(Q)] w\n    \"\"\"\n\n    return .5 * np.dot(BmatEP(q), w)",
  "def dEuler121(q, w):\n    \"\"\"\n    dEuler121(Q,W)\n\n    \tdq = dEuler121(Q,W) returns the (1-2-1) euler angle derivative\n    \tvector for a given (1-2-1) euler angle vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt =  [B(Q)] w\n    \"\"\"\n\n    return np.dot(BmatEuler121(q), w)",
  "def dEuler123(q, w):\n    \"\"\"\n    dEuler123(Q,W)\n\n    \tdq = dEuler123(Q,W) returns the (1-2-3) euler angle derivative\n    \tvector for a given (1-2-3) euler angle vector Q and body\n    \tangular velocity vector w.\n\n        dQ/dt =  [B(Q)] w\n    \"\"\"\n\n    return np.dot(BmatEuler123(q), w)",
  "def dEuler131(q, w):\n    \"\"\"\n    dEuler131(Q,W)\n\n    \tdq = dEuler131(Q,W) returns the (1-3-1) euler angle derivative\n    \tvector for a given (1-3-1) euler angle vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt =  [B(Q)] w\n    \"\"\"\n\n    return np.dot(BmatEuler131(q), w)",
  "def dEuler132(q, w):\n    \"\"\"\n    dEuler132(Q,W)\n\n    \tdq = dEuler132(Q,W) returns the (1-3-2) euler angle derivative\n    \tvector for a given (1-3-2) euler angle vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt =  [B(Q)] w\n    \"\"\"\n\n    return np.dot(BmatEuler132(q), w)",
  "def dEuler212(q, w):\n    \"\"\"\n    dEuler212(Q,W)\n\n    \tdq = dEuler212(Q,W) returns the (2-1-2) euler angle derivative\n    \tvector for a given (2-1-2) euler angle vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt =  [B(Q)] w\n    \"\"\"\n\n    return np.dot(BmatEuler212(q), w)",
  "def dEuler213(q, w):\n    \"\"\"\n    dEuler213(Q,W)\n\n    \tdq = dEuler213(Q,W) returns the (2-1-3) euler angle derivative\n    \tvector for a given (2-1-3) euler angle vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt =  [B(Q)] w\n    \"\"\"\n\n    return np.dot(BmatEuler213(q), w)",
  "def dEuler231(q, w):\n    \"\"\"\n    dEuler231(Q,W)\n\n    \tdq = dEuler231(Q,W) returns the (2-3-1) euler angle derivative\n    \tvector for a given (2-3-1) euler angle vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt =  [B(Q)] w\n    \"\"\"\n\n    return np.dot(BmatEuler231(q), w)",
  "def dEuler232(q, w):\n    \"\"\"\n    dEuler232(Q,W)\n\n    \tdq = dEuler232(Q,W) returns the (2-3-2) euler angle derivative\n    \tvector for a given (2-3-2) euler angle vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt =  [B(Q)] w\n    \"\"\"\n\n    return np.dot(BmatEuler232(q), w)",
  "def dEuler312(q, w):\n    \"\"\"\n    dEuler312(Q,W)\n\n    \tdq = dEuler312(Q,W) returns the (3-1-2) euler angle derivative\n    \tvector for a given (3-1-2) euler angle vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt =  [B(Q)] w\n    \"\"\"\n\n    return np.dot(BmatEuler312(q), w)",
  "def dEuler313(q, w):\n    \"\"\"\n    dEuler313(Q,W)\n\n    \tdq = dEuler313(Q,W) returns the (3-1-3) euler angle derivative\n    \tvector for a given (3-1-3) euler angle vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt =  [B(Q)] w\n    \"\"\"\n\n    return np.dot(BmatEuler313(q), w)",
  "def dEuler321(q, w):\n    \"\"\"\n    dEuler321(Q,W)\n\n    \tdq = dEuler321(Q,W) returns the (3-2-1) euler angle derivative\n    \tvector for a given (3-2-1) euler angle vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt =  [B(Q)] w\n    \"\"\"\n\n    return np.dot(BmatEuler321(q), w)",
  "def dEuler323(q, w):\n    \"\"\"\n    dEuler323(Q,W)\n\n    \tdq = dEuler323(Q,W) returns the (3-2-3) euler angle derivative\n    \tvector for a given (3-2-3) euler angle vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt =  [B(Q)] w\n    \"\"\"\n\n    return np.dot(BmatEuler323(q), w)",
  "def dGibbs(q, w):\n    \"\"\"\n    dGibbs(Q,W)\n\n    \tdq = dGibbs(Q,W) returns the gibbs derivative\n    \tfor a given gibbs vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt = 1/2 [B(Q)] w\n    \"\"\"\n\n    return .5 * np.dot(BmatGibbs(q), w)",
  "def dMRP(q, w):\n    \"\"\"\n    dMRP(Q,W)\n\n    \tdq = dMRP(Q,W) returns the MRP derivative\n    \tfor a given MRP vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt = 1/4 [B(Q)] w\n    \"\"\"\n\n    return .25 * np.dot(BmatMRP(q), w)",
  "def dMRP2Omega(q, dq):\n    \"\"\"\n    dMRP(Q,dQ)\n\n    \tW = dMRP(Q,dQ) returns the angular rate\n    \tfor a given MRP set q MRP derivative dq.\n\n        W = 4 [B(Q)]^(-1) dQ\n    \"\"\"\n\n    return 4 * np.matmul(BinvMRP(q), dq)",
  "def ddMRP(q, dq, w, dw):\n    \"\"\"\n    dMRP(Q,dQ,W,dW)\n\n    \tddQ = ddMRP(Q,dQ,W,dW) returns the MRP second derivative\n    \tfor a given MRP vector q, MRP derivative dq, body\n    \tangular velocity vector w and body angulat acceleration\n        vector dw.\n\n    \t(d^2Q)/(dt^2) = 1/4 ( [B(Q)] dw + [Bdot(Q,dQ)] w )\n    \"\"\"\n\n    return .25 * ( np.dot(BmatMRP(q), dw) + np.dot(BdotmatMRP(q, dq), w) )",
  "def ddMRP2dOmega(q, dq, ddq):\n    \"\"\"\n    ddMRP2dOmega(Q,dQ,ddQ)\n\n    \tdW = ddMRP2dOmega(Q,dQ,ddQ) returns the body angular acceleration\n        dW given the MRP vector Q, the MRP derivative dQ and the MRP\n        second order derivative ddQ.\n\n    \tdW/dt = 4 [B(Q)]^(-1) ( ddQ - [Bdot(Q,dQ)] [B(Q)]^(-1) dQ )\n    \"\"\"\n\n    Binv = BinvMRP(q)\n    Bdot = BdotmatMRP(q, dq)\n\n    return 4 * np.dot(Binv, (ddq - np.dot(Bdot, np.dot(Binv, dq))) )",
  "def dPRV(q, w):\n    \"\"\"\n    dPRV(Q,W)\n\n    \tdq = dPRV(Q,W) returns the PRV derivative\n    \tfor a given PRV vector Q and body\n    \tangular velocity vector w.\n\n    \tdQ/dt =  [B(Q)] w\n    \"\"\"\n\n    return np.dot(BmatPRV(q), w)",
  "def elem2PRV(r):\n    \"\"\"\n    elem2PRV(R)\n\n    \tQ = elem2PRV(R) translates a prinicpal rotation\n    \telement set R into the corresponding principal\n    \trotation vector Q.\n    \"\"\"\n\n    q0 = r[1] * r[0]\n    q1 = r[2] * r[0]\n    q2 = r[3] * r[0]\n    q = np.array([q0, q1, q2])\n\n    return q",
  "def gibbs2C(q):\n    \"\"\"\n    gibbs2C\n\n    \tC = gibbs2C(Q) returns the direction cosine\n    \tmatrix in terms of the 3x1 gibbs vector Q.\n    \"\"\"\n\n    q1 = q[0]\n    q2 = q[1]\n    q3 = q[2]\n    qm = np.linalg.norm(q)\n    d1 = qm * qm\n    C = np.zeros([3, 3])\n    C[0, 0] = 1 + 2 * q1 * q1 - d1\n    C[0, 1] = 2 * (q1 * q2 + q3)\n    C[0, 2] = 2 * (q1 * q3 - q2)\n    C[1, 0] = 2 * (q2 * q1 - q3)\n    C[1, 1] = 1 + 2 * q2 * q2 - d1\n    C[1, 2] = 2 * (q2 * q3 + q1)\n    C[2, 0] = 2 * (q3 * q1 + q2)\n    C[2, 1] = 2 * (q3 * q2 - q1)\n    C[2, 2] = 1 + 2 * q3 * q3 - d1\n    C = C / (1 + d1)\n    return C",
  "def gibbs2EP(q1):\n    \"\"\"\n    gibbs2EP(Q1)\n\n    \tQ = gibbs2EP(Q1) translates the gibbs vector Q1\n    \tinto the euler parameter vector Q.\n    \"\"\"\n\n    qm = np.linalg.norm(q1)\n    ps = np.sqrt(1 + qm * qm)\n    q = np.array([\n        1 / ps,\n        q1[0] / ps,\n        q1[1] / ps,\n        q1[2] / ps\n    ])\n    return q",
  "def gibbs2Euler121(q):\n    \"\"\"\n    gibbs2Euler121(Q)\n\n    \tE = gibbs2Euler121(Q) translates the gibbs\n        vector Q into the (1-2-1) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler121(gibbs2EP(q))",
  "def gibbs2Euler123(q):\n    \"\"\"\n    gibbs2Euler123(Q)\n\n    \tE = gibbs2Euler123(Q) translates the gibbs\n    \t vector Q into the (1-2-3) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler123(gibbs2EP(q))",
  "def gibbs2Euler131(q):\n    \"\"\"\n    gibbs2Euler131(Q)\n\n    \tE = gibbs2Euler131(Q) translates the gibbs\n    \t vector Q into the (1-3-1) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler131(gibbs2EP(q))",
  "def gibbs2Euler132(q):\n    \"\"\"\n    gibbs2Euler132(Q)\n\n    \tE = gibbs2Euler132(Q) translates the gibbs\n        vector Q into the (1-3-2) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler132(gibbs2EP(q))",
  "def gibbs2Euler212(q):\n    \"\"\"\n    gibbs2Euler212(Q)\n\n    \tE = gibbs2Euler212(Q) translates the gibbs\n    \t vector Q into the (2-1-2) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler212(gibbs2EP(q))",
  "def gibbs2Euler213(q):\n    \"\"\"\n    gibbs2Euler213(Q)\n\n    \tE = gibbs2Euler213(Q) translates the gibbs\n    \t vector Q into the (2-1-3) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler213(gibbs2EP(q))",
  "def gibbs2Euler231(q):\n    \"\"\"\n    gibbs2Euler231(Q)\n\n    \tE = gibbs2Euler231(Q) translates the gibbs\n    \t vector Q into the (2-3-1) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler231(gibbs2EP(q))",
  "def gibbs2Euler232(q):\n    \"\"\"\n    gibbs2Euler232(Q)\n\n    \tE = gibbs2Euler232(Q) translates the gibbs\n    \t vector Q into the (2-3-2) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler232(gibbs2EP(q))",
  "def gibbs2Euler312(q):\n    \"\"\"\n    gibbs2Euler312(Q)\n\n    \tE = gibbs2Euler312(Q) translates the gibbs\n    \t vector Q into the (3-1-2) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler312(gibbs2EP(q))",
  "def gibbs2Euler313(q):\n    \"\"\"\n    gibbs2Euler313(Q)\n\n    \tE = gibbs2Euler313(Q) translates the gibbs\n    \t vector Q into the (3-1-3) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler313(gibbs2EP(q))",
  "def gibbs2Euler321(q):\n    \"\"\"\n    gibbs2Euler321(Q)\n\n    \tE = gibbs2Euler321(Q) translates the gibbs\n    \t vector Q into the (3-2-1) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler321(gibbs2EP(q))",
  "def gibbs2Euler323(q):\n    \"\"\"\n    gibbs2Euler323(Q)\n\n    \tE = gibbs2Euler323(Q) translates the gibbs\n    \t vector Q into the (3-2-3) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler323(gibbs2EP(q))",
  "def gibbs2MRP(q1):\n    \"\"\"\n    gibbs2MRP(Q1)\n\n    \tQ = gibbs2MRP(Q1) translates the gibbs vector Q1\n    \tinto the MRP vector Q.\n    \"\"\"\n\n    return q1 / (1 + math.sqrt(1 + np.dot(q1, q1)))",
  "def gibbs2PRV(q):\n    \"\"\"\n    gibbs2PRV(Q)\n\n    \tQ = gibbs2PRV(Q1) translates the gibbs vector Q1\n    \tinto the principal rotation vector Q.\n    \"\"\"\n\n    tp = np.linalg.norm(q)\n    p = 2 * math.atan(tp)\n    q0 = q[0] / tp * p\n    q1 = q[1] / tp * p\n    q2 = q[2] / tp * p\n    q = np.array([q0, q1, q2])\n    return q",
  "def MRP2C(q):\n    \"\"\"\n    MRP2C\n\n    \tC = MRP2C(Q) returns the direction cosine\n    \tmatrix in terms of the 3x1 MRP vector Q.\n    \"\"\"\n\n    q1 = q[0]\n    q2 = q[1]\n    q3 = q[2]\n    qm = np.linalg.norm(q)\n    d1 = qm * qm\n    S = 1 - d1\n    d = (1 + d1) * (1 + d1)\n    C = np.zeros((3, 3))\n    C[0, 0] = 4 * (2 * q1 * q1 - d1) + S * S\n    C[0, 1] = 8 * q1 * q2 + 4 * q3 * S\n    C[0, 2] = 8 * q1 * q3 - 4 * q2 * S\n    C[1, 0] = 8 * q2 * q1 - 4 * q3 * S\n    C[1, 1] = 4 * (2 * q2 * q2 - d1) + S * S\n    C[1, 2] = 8 * q2 * q3 + 4 * q1 * S\n    C[2, 0] = 8 * q3 * q1 + 4 * q2 * S\n    C[2, 1] = 8 * q3 * q2 - 4 * q1 * S\n    C[2, 2] = 4 * (2 * q3 * q3 - d1) + S * S\n    C = C / d\n    return C",
  "def MRP2EP(q1):\n    \"\"\"\n    MRP2EP(Q1)\n\n    \tQ = MRP2EP(Q1) translates the MRP vector Q1\n    \tinto the euler parameter vector Q.\n    \"\"\"\n    qm = np.linalg.norm(q1)\n    ps = 1 + qm * qm\n    q = np.array([\n        (1 - qm * qm) / ps,\n        2 * q1[0] / ps,\n        2 * q1[1] / ps,\n        2 * q1[2] / ps\n    ])\n    return q",
  "def MRP2Euler121(q):\n    \"\"\"\n    MRP2Euler121(Q)\n\n    \tE = MRP2Euler121(Q) translates the MRP\n    \t vector Q into the (1-2-1) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler121(MRP2EP(q))",
  "def MRP2Euler123(q):\n    \"\"\"\n    MRP2Euler123(Q)\n\n    \tE = MRP2Euler123(Q) translates the MRP\n    \t vector Q into the (1-2-3) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler123(MRP2EP(q))",
  "def MRP2Euler131(q):\n    \"\"\"\n    MRP2Euler131(Q)\n\n    \tE = MRP2Euler131(Q) translates the MRP\n    \t vector Q into the (1-3-1) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler131(MRP2EP(q))",
  "def MRP2Euler132(q):\n    \"\"\"\n    MRP2Euler132(Q)\n\n    \tE = MRP2Euler132(Q) translates the MRP\n    \t vector Q into the (1-3-2) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler132(MRP2EP(q))",
  "def MRP2Euler212(q):\n    \"\"\"\n    MRP2Euler212(Q)\n\n    \tE = MRP2Euler212(Q) translates the MRP\n    \t vector Q into the (2-1-2) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler212(MRP2EP(q))",
  "def MRP2Euler213(q):\n    \"\"\"\n    MRP2Euler213(Q)\n\n    \tE = MRP2Euler213(Q) translates the MRP\n    \t vector Q into the (2-1-3) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler213(MRP2EP(q))",
  "def MRP2Euler231(q):\n    \"\"\"\n    MRP2Euler231(Q)\n\n    \tE = MRP2Euler231(Q) translates the MRP\n    \t vector Q into the (2-3-1) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler231(MRP2EP(q))",
  "def MRP2Euler232(q):\n    \"\"\"\n    MRP2Euler232(Q)\n\n       E = MRP2Euler232(Q) translates the MRP\n    \t vector Q into the (2-3-2) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler232(MRP2EP(q))",
  "def MRP2Euler312(q):\n    \"\"\"\n    MRP2Euler312(Q)\n\n    \tE = MRP2Euler312(Q) translates the MRP\n    \t vector Q into the (3-1-2) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler312(MRP2EP(q))",
  "def MRP2Euler313(q):\n    \"\"\"\n    MRP2Euler313(Q)\n\n    \tE = MRP2Euler313(Q) translates the MRP\n    \t vector Q into the (3-1-3) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler313(MRP2EP(q))",
  "def MRP2Euler321(q):\n    \"\"\"\n    MRP2Euler321(Q)\n\n    \tE = MRP2Euler321(Q) translates the MRP\n    \t vector Q into the (3-2-1) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler321(MRP2EP(q))",
  "def MRP2Euler323(q):\n    \"\"\"\n    MRP2Euler323(Q)\n\n    \tE = MRP2Euler323(Q) translates the MRP\n    \t vector Q into the (3-2-3) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler323(MRP2EP(q))",
  "def MRP2Gibbs(q1):\n    \"\"\"\n    MRP2Gibbs(Q1)\n\n    \tQ = MRP2Gibbs(Q1) translates the MRP vector Q1\n    \tinto the gibbs vector Q.\n    \"\"\"\n\n    return 2 * q1 / (1 - np.dot(q1, q1))",
  "def MRP2PRV(q):\n    \"\"\"\n    MRP2PRV(Q1)\n\n    \tQ = MRP2PRV(Q1) translates the MRP vector Q1\n    \tinto the principal rotation vector Q.\n    \"\"\"\n\n    tp = np.linalg.norm(q)\n    p = 4 * math.atan(tp)\n    q0 = q[0] / tp * p\n    q1 = q[1] / tp * p\n    q2 = q[2] / tp * p\n    q = np.array([q0, q1, q2])\n\n    return q",
  "def MRPswitch(q, s2):\n    \"\"\"\n    MRPswitch\n\n    \tS = MRPswitch(Q,s2) checks to see if norm(Q) is larger than s2.\n    \tIf yes, then the MRP vector Q is mapped to its shadow set.\n    \"\"\"\n\n    q2 = np.dot(q, q)\n    if (q2 > s2 * s2):\n        s = -q / q2\n    else:\n        s = q\n\n    return s",
  "def PRV2C(q):\n    \"\"\"\n    PRV2C\n\n    \tC = PRV2C(Q) returns the direction cosine\n    \tmatrix in terms of the 3x1 principal rotation vector\n    \tQ.\n    \"\"\"\n\n    q0 = np.linalg.norm(q)\n    if q0 == 0.0:\n        q1 = q[0]\n        q2 = q[1]\n        q3 = q[2]\n    else:\n        q1 = q[0] / q0\n        q2 = q[1] / q0\n        q3 = q[2] / q0\n    cp = np.cos(q0)\n    sp = np.sin(q0)\n    d1 = 1 - cp\n    C = np.zeros((3, 3))\n    C[0, 0] = q1 * q1 * d1 + cp\n    C[0, 1] = q1 * q2 * d1 + q3 * sp\n    C[0, 2] = q1 * q3 * d1 - q2 * sp\n    C[1, 0] = q2 * q1 * d1 - q3 * sp\n    C[1, 1] = q2 * q2 * d1 + cp\n    C[1, 2] = q2 * q3 * d1 + q1 * sp\n    C[2, 0] = q3 * q1 * d1 + q2 * sp\n    C[2, 1] = q3 * q2 * d1 - q1 * sp\n    C[2, 2] = q3 * q3 * d1 + cp\n    return C",
  "def PRV2EP(qq1):\n    \"\"\"\"\n    PRV2EP(Q1)\n\n    \tQ = PRV2EP(Q1) translates the principal rotation vector Q1\n    \tinto the euler parameter vector Q.\n    \"\"\"\n\n    q = np.zeros(4)\n    q1 = PRV2elem(qq1)\n    sp = math.sin(q1[0] / 2)\n    q[0] = math.cos(q1[0] / 2)\n    q[1] = q1[1] * sp\n    q[2] = q1[2] * sp\n    q[3] = q1[3] * sp\n\n    return q",
  "def PRV2Euler121(q):\n    \"\"\"\n    PRV2Euler121(Q)\n\n    \tE = PRV2Euler121(Q) translates the principal rotation\n    \tvector Q into the (1-2-1) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler121(PRV2EP(q))",
  "def PRV2Euler123(q):\n    \"\"\"\n    PRV2Euler123(Q)\n\n    \tE = PRV2Euler123(Q) translates the principal rotation\n    \tvector Q into the (1-2-3) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler123(PRV2EP(q))",
  "def PRV2Euler131(q):\n    \"\"\"\n    PRV2Euler131(Q)\n\n    \tE = PRV2Euler131(Q) translates the principal rotation\n    \tvector Q into the (1-3-1) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler131(PRV2EP(q))",
  "def PRV2Euler132(q):\n    \"\"\"\n    PRV2Euler132(Q)\n\n    \tE = PRV2Euler132(Q) translates the principal rotation\n    \tvector Q into the (1-3-2) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler132(PRV2EP(q))",
  "def PRV2Euler212(q):\n    \"\"\"\n    PRV2Euler212(Q)\n\n    \tE = PRV2Euler212(Q) translates the principal rotation\n    \tvector Q into the (2-1-2) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler212(PRV2EP(q))",
  "def PRV2Euler213(q):\n    \"\"\"\n    PRV2Euler213(Q)\n\n    \tE = PRV2Euler213(Q) translates the principal rotation\n    \tvector Q into the (2-1-3) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler213(PRV2EP(q))",
  "def PRV2Euler231(q):\n    \"\"\"\n    PRV2Euler231(Q)\n\n    \tE = PRV2Euler231(Q) translates the principal rotation\n    \tvector Q into the (2-3-1) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler231(PRV2EP(q))",
  "def PRV2Euler232(q):\n    \"\"\"\n    PRV2Euler232(Q)\n\n    \tE = PRV2Euler232(Q) translates the principal rotation\n    \tvector Q into the (2-3-2) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler232(PRV2EP(q))",
  "def PRV2Euler312(q):\n    \"\"\"\n    PRV2Euler312(Q)\n\n    \tE = PRV2Euler312(Q) translates the principal rotation\n    \tvector Q into the (3-1-2) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler312(PRV2EP(q))",
  "def PRV2Euler313(q):\n    \"\"\"\n    PRV2Euler313(Q)\n\n    \tE = PRV2Euler313(Q) translates the principal rotation\n    \tvector Q into the (3-1-3) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler313(PRV2EP(q))",
  "def PRV2Euler321(q):\n    \"\"\"\n    PRV2Euler321(Q)\n\n    \tE = PRV2Euler321(Q) translates the principal rotation\n    \tvector Q into the (3-2-1) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler321(PRV2EP(q))",
  "def PRV2Euler323(q):\n    \"\"\"\n    PRV2Euler323(Q)\n\n    \tE = PRV2Euler323(Q) translates the principal rotation\n    \tvector Q into the (3-2-3) euler angle vector E.\n    \"\"\"\n\n    return EP2Euler323(PRV2EP(q))",
  "def PRV2Gibbs(q):\n    \"\"\"\n    PRV2Gibbs(Q1)\n\n    \tQ = PRV2Gibbs(Q1) translates the principal rotation vector Q1\n    \tinto the gibbs vector Q.\n    \"\"\"\n\n    q = PRV2elem(q)\n    tp = math.tan(q[0] / 2)\n    q0 = q[1] * tp\n    q1 = q[2] * tp\n    q2 = q[3] * tp\n    q = np.array([q0, q1, q2])\n\n    return q",
  "def PRV2MRP(q):\n    \"\"\"\n     PRV2MRP(Q1)\n\n    \tQ = PRV2MRP(Q1) translates the principal rotation vector Q1\n    \tinto the MRP vector Q.\n    \"\"\"\n\n    q = PRV2elem(q)\n    tp = math.tan(q[0] / 4)\n    q0 = q[1] * tp\n    q1 = q[2] * tp\n    q2 = q[3] * tp\n\n    q = np.array([q0, q1, q2])\n    return q",
  "def subEP(b1, b2):\n    \"\"\"\n    subEP(B1,B2)\n\n    \tQ = subEP(B1,B2) provides the euler parameter vector\n    \twhich corresponds to relative rotation from B2\n    \tto B1.\n    \"\"\"\n\n    q = np.zeros(4)\n    q[0] = b2[0] * b1[0] + b2[1] * b1[1] + b2[2] * b1[2] + b2[3] * b1[3]\n    q[1] = -b2[1] * b1[0] + b2[0] * b1[1] + b2[3] * b1[2] - b2[2] * b1[3]\n    q[2] = -b2[2] * b1[0] - b2[3] * b1[1] + b2[0] * b1[2] + b2[1] * b1[3]\n    q[3] = -b2[3] * b1[0] + b2[2] * b1[1] - b2[1] * b1[2] + b2[0] * b1[3]\n\n    return q",
  "def subEuler121(e, e1):\n    \"\"\"\n    subEuler121(E,E1)\n\n    \tE2 = subEuler121(E,E1) computes the relative\n    \t(1-2-1) euler angle vector from E1 to E.\n    \"\"\"\n\n    cp = math.cos(e[1])\n    cp1 = math.cos(e1[1])\n    sp = math.sin(e[1])\n    sp1 = math.sin(e1[1])\n    dum = e[0] - e1[0]\n\n    e2 = np.zeros(3)\n    e2[1] = math.acos(cp1 * cp + sp1 * sp * math.cos(dum))\n    cp2 = math.cos(e2[1])\n    e2[0] = Picheck(-e1[2] + math.atan2(sp1 * sp * math.sin(dum), cp2 * cp1 - cp))\n    e2[2] = Picheck(e[2] - math.atan2(sp1 * sp * math.sin(dum), cp1 - cp * cp2))\n\n    return e2",
  "def subEuler123(e, e1):\n    \"\"\"\n    subEuler123(E,E1)\n\n    \tE2 = subEuler123(E,E1) computes the relative\n    \t(1-2-3) euler angle vector from E1 to E.\n    \"\"\"\n\n    C = euler1232C(e)\n    C1 = euler1232C(e1)\n    C2 = np.dot(C, C1.T)\n    e2 = C2Euler123(C2)\n\n    return e2",
  "def subEuler131(e, e1):\n    \"\"\"\n    subEuler131(E,E1)\n\n    \tE2 = subEuler131(E,E1) computes the relative\n    \t(1-3-1) euler angle vector from E1 to E.\n    \"\"\"\n\n    cp = math.cos(e[1])\n    cp1 = math.cos(e1[1])\n    sp = math.sin(e[1])\n    sp1 = math.sin(e1[1])\n    dum = e[0] - e1[0]\n\n    e2 = np.zeros(3)\n    e2[1] = math.acos(cp1 * cp + sp1 * sp * math.cos(dum))\n    cp2 = math.cos(e2[1])\n    e2[0] = Picheck(-e1[2] + math.atan2(sp1 * sp * math.sin(dum), cp2 * cp1 - cp))\n    e2[2] = Picheck(e[2] - math.atan2(sp1 * sp * math.sin(dum), cp1 - cp * cp2))\n\n    return e2",
  "def subEuler132(e, e1):\n    \"\"\"\n    subEuler132(E,E1)\n\n    \tE2 = subEuler132(E,E1) computes the relative\n    \t(1-3-2) euler angle vector from E1 to E.\n    \"\"\"\n\n    C = euler1322C(e)\n    C1 = euler1322C(e1)\n    C2 = np.dot(C, C1.T)\n    e2 = C2Euler132(C2)\n\n    return e2",
  "def subEuler212(e, e1):\n    \"\"\"\n    subEuler212(E,E1)\n\n    \tE2 = subEuler212(E,E1) computes the relative\n    \t(2-1-2) euler angle vector from E1 to E.\n    \"\"\"\n\n    cp = math.cos(e[1])\n    cp1 = math.cos(e1[1])\n    sp = math.sin(e[1])\n    sp1 = math.sin(e1[1])\n    dum = e[0] - e1[0]\n\n    e2 = np.zeros(3)\n    e2[1] = math.acos(cp1 * cp + sp1 * sp * math.cos(dum))\n    cp2 = math.cos(e2[1])\n    e2[0] = Picheck(-e1[2] + math.atan2(sp1 * sp * math.sin(dum), cp2 * cp1 - cp))\n    e2[2] = Picheck(e[2] - math.atan2(sp1 * sp * math.sin(dum), cp1 - cp * cp2))\n\n    return e2",
  "def subEuler213(e, e1):\n    \"\"\"\n    subEuler213(E,E1)\n\n    \tE2 = subEuler213(E,E1) computes the relative\n    \t(2-1-3) euler angle vector from E1 to E.\n    \"\"\"\n\n    C = euler2132C(e)\n    C1 = euler2132C(e1)\n    C2 = np.dot(C, C1.T)\n    e2 = C2Euler213(C2)\n\n    return e2",
  "def subEuler231(e, e1):\n    \"\"\"\n    subEuler231(E,E1)\n\n    \tE2 = subEuler231(E,E1) computes the relative\n    \t(2-3-1) euler angle vector from E1 to E.\n    \"\"\"\n\n    C = euler2312C(e)\n    C1 = euler2312C(e1)\n    C2 = np.dot(C, C1.T)\n    e2 = C2Euler231(C2)\n\n    return e2",
  "def subEuler232(e, e1):\n    \"\"\"\n    subEuler232(E,E1)\n\n    \tE2 = subEuler232(E,E1) computes the relative\n    \t(2-3-2) euler angle vector from E1 to E.\n    \"\"\"\n\n    cp = math.cos(e[1])\n    cp1 = math.cos(e1[1])\n    sp = math.sin(e[1])\n    sp1 = math.sin(e1[1])\n    dum = e[0] - e1[0]\n\n    e2 = np.zeros(3)\n    e2[1] = math.acos(cp1 * cp + sp1 * sp * math.cos(dum))\n    cp2 = math.cos(e2[1])\n    e2[0] = Picheck(-e1[2] + math.atan2(sp1 * sp * math.sin(dum), cp2 * cp1 - cp))\n    e2[2] = Picheck(e[2] - math.atan2(sp1 * sp * math.sin(dum), cp1 - cp * cp2))\n\n    return e2",
  "def subEuler312(e, e1):\n    \"\"\"\n    subEuler312(E,E1)\n\n    \tE2 = subEuler312(E,E1) computes the relative\n    \t(3-1-2) euler angle vector from E1 to E.\n    \"\"\"\n\n    C = euler3122C(e)\n    C1 = euler3122C(e1)\n    C2 = np.dot(C, C1.T)\n    e2 = C2Euler312(C2)\n\n    return e2",
  "def subEuler313(e, e1):\n    \"\"\"\n    subEuler313(E,E1)\n\n    \tE2 = subEuler313(E,E1) computes the relative\n    \t(3-1-3) euler angle vector from E1 to E.\n    \"\"\"\n\n    cp = math.cos(e[1])\n    cp1 = math.cos(e1[1])\n    sp = math.sin(e[1])\n    sp1 = math.sin(e1[1])\n    dum = e[0] - e1[0]\n\n    e2 = np.zeros(3)\n    e2[1] = math.acos(cp1 * cp + sp1 * sp * math.cos(dum))\n    cp2 = math.cos(e2[1])\n    e2[0] = Picheck(-e1[2] + math.atan2(sp1 * sp * math.sin(dum), cp2 * cp1 - cp))\n    e2[2] = Picheck(e[2] - math.atan2(sp1 * sp * math.sin(dum), cp1 - cp * cp2))\n\n    return e2",
  "def subEuler321(e, e1):\n    \"\"\"\n    subEuler321(E,E1)\n\n    \tE2 = subEuler321(E,E1) computes the relative\n    \t(3-2-1) euler angle vector from E1 to E.\n    \"\"\"\n\n    C = euler3212C(e)\n    C1 = euler3212C(e1)\n    C2 = np.dot(C, C1.T)\n    e2 = C2Euler321(C2)\n\n    return e2",
  "def subEuler323(e, e1):\n    \"\"\"\n    subEuler323(E,E1)\n\n    \tE2 = subEuler323(E,E1) computes the relative\n    \t(3-2-3) euler angle vector from E1 to E.\n    \"\"\"\n\n    cp = math.cos(e[1])\n    cp1 = math.cos(e1[1])\n    sp = math.sin(e[1])\n    sp1 = math.sin(e1[1])\n    dum = e[0] - e1[0]\n\n    e2 = np.zeros(3)\n    e2[1] = math.acos(cp1 * cp + sp1 * sp * math.cos(dum))\n    cp2 = math.cos(e2[1])\n    e2[0] = Picheck(-e1[2] + math.atan2(sp1 * sp * math.sin(dum), cp2 * cp1 - cp))\n    e2[2] = Picheck(e[2] - math.atan2(sp1 * sp * math.sin(dum), cp1 - cp * cp2))\n\n    return e2",
  "def subGibbs(q1, q2):\n    \"\"\"\n    subGibbs(Q1,Q2)\n\n    \tQ = subGibbs(Q1,Q2) provides the gibbs vector\n    \twhich corresponds to relative rotation from Q2\n    \tto Q1.\n    \"\"\"\n    return (q1 - q2 + np.cross(q1, q2)) / (1. + np.dot(q1, q2))",
  "def subMRP(q1, q2):\n    \"\"\"\n    subMRP(Q1,Q2)\n\n    \tQ = subMRP(Q1,Q2) provides the MRP vector\n    \twhich corresponds to relative rotation from Q2\n    \tto Q1.\n    \"\"\"\n    q2m = np.linalg.norm(q2)\n    q1m = np.linalg.norm(q1)\n\n    den = 1 + (q1m * q1m) * (q2m * q2m) + 2 * np.dot(q1, q2)\n    if den < 1e-5:\n        q2 = -q2/np.dot(q2,q2)\n        den = 1 + (q1m * q1m) * (q2m * q2m) + 2 * np.dot(q1, q2)\n    num = (1 - q2m * q2m) * q1 - (1 - q1m * q1m) * q2 + 2 * np.cross(q1, q2)\n\n    q = num / den\n    if np.dot(q,q) > 1:\n        q = -q/np.dot(q, q)\n\n    return q",
  "def subPRV(q1, q2):\n    \"\"\"\n    subPRV(Q1,Q2)\n\n    \tQ = subPRV(Q1,Q2) provides the prinipal rotation vector\n    \twhich corresponds to relative principal rotation from Q2\n    \tto Q1.\n    \"\"\"\n\n    q1 = PRV2elem(q1)\n    q2 = PRV2elem(q2)\n    cp1 = math.cos(q1[0] / 2)\n    cp2 = math.cos(q2[0] / 2)\n    sp1 = math.sin(q1[0] / 2)\n    sp2 = math.sin(q2[0] / 2)\n    e1 = q1[1:4]\n    e2 = q2[1:4]\n\n    p = 2 * math.acos(cp1 * cp2 + sp1 * sp2 * np.dot(e1, e2))\n    sp = math.sin(p / 2)\n    e = (-cp1 * sp2 * e2 + cp2 * sp1 * e1 + sp1 * sp2 * np.cross(e1, e2)) / sp\n    q = p * e\n\n    return q",
  "def EP2C(q):\n    \"\"\"\n\tEP2C\n\n        C = EP2C(Q) returns the direction math.cosine\n        matrix in terms of the 4x1 euler parameter vector\n        Q.  The first element is the non-dimensional euler\n        parameter, while the remain three elements form\n        the eulerparameter vector.\n\t\"\"\"\n    q0 = q[0]\n    q1 = q[1]\n    q2 = q[2]\n    q3 = q[3]\n    C = np.zeros([3, 3])\n    C[0, 0] = q0 * q0 + q1 * q1 - q2 * q2 - q3 * q3\n    C[0, 1] = 2 * (q1 * q2 + q0 * q3)\n    C[0, 2] = 2 * (q1 * q3 - q0 * q2)\n    C[1, 0] = 2 * (q1 * q2 - q0 * q3)\n    C[1, 1] = q0 * q0 - q1 * q1 + q2 * q2 - q3 * q3\n    C[1, 2] = 2 * (q2 * q3 + q0 * q1)\n    C[2, 0] = 2 * (q1 * q3 + q0 * q2)\n    C[2, 1] = 2 * (q2 * q3 - q0 * q1)\n    C[2, 2] = q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3\n    return C",
  "def EP2Euler121(q):\n    \"\"\"\n\tEP2Euler121(Q)\n\n        E = EP2Euler121(Q) translates the euler parameter\n        vector Q into the corresponding (1-2-1) euler angle\n        vector E.\n\t\"\"\"\n\n    t1 = math.atan2(q[3], q[2])\n    t2 = math.atan2(q[1], q[0])\n\n    e1 = t1 + t2\n    e2 = 2 * math.acos(math.sqrt(q[0] * q[0] + q[1] * q[1]))\n    e3 = t2 - t1\n\n    e = np.array([e1, e2, e3])\n    return e",
  "def EP2Euler123(q):\n    \"\"\"\n\tEP2Euler123\n\n        Q = EP2Euler123(Q) translates the euler parameter vector\n        Q into the corresponding (1-2-3) euler angle set.\n\t\"\"\"\n\n    q0 = q[0]\n    q1 = q[1]\n    q2 = q[2]\n    q3 = q[3]\n\n    e1 = math.atan2(-2 * (q2 * q3 - q0 * q1), q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3)\n    e2 = math.asin(2 * (q1 * q3 + q0 * q2))\n    e3 = math.atan2(-2 * (q1 * q2 - q0 * q3), q0 * q0 + q1 * q1 - q2 * q2 - q3 * q3)\n\n    e = np.array([e1, e2, e3])\n    return e",
  "def EP2Euler131(q):\n    \"\"\"\n\tEP2Euler131(Q)\n\n        E = EP2Euler131(Q) translates the euler parameter\n        vector Q into the corresponding (1-3-1) euler angle\n        vector E.\n\t\"\"\"\n\n    t1 = math.atan2(q[2], q[3])\n    t2 = math.atan2(q[1], q[0])\n\n    e1 = t2 - t1\n    e2 = 2 * math.acos(math.sqrt(q[0] * q[0] + q[1] * q[1]))\n    e3 = t2 + t1\n\n    e = np.array([e1, e2, e3])\n    return e",
  "def EP2Euler132(q):\n    \"\"\"\n    EP2Euler132\n\n    \tE = EP2Euler132(Q) translates the euler parameter vector\n    \tQ into the corresponding (1-3-2) euler angle set.\n\n    \"\"\"\n    q0 = q[0]\n    q1 = q[1]\n    q2 = q[2]\n    q3 = q[3]\n\n    e1 = math.atan2(2 * (q2 * q3 + q0 * q1), q0 * q0 - q1 * q1 + q2 * q2 - q3 * q3)\n    e2 = math.asin(-2 * (q1 * q2 - q0 * q3))\n    e3 = math.atan2(2 * (q1 * q3 + q0 * q2), q0 * q0 + q1 * q1 - q2 * q2 - q3 * q3)\n\n    e = np.array([e1, e2, e3])\n    return e",
  "def EP2Euler212(q):\n    \"\"\"\n    EP2Euler212(Q)\n\n        E = EP2Euler212(Q) translates the euler parameter\n        vector Q into the corresponding (2-1-2) euler angle\n        vector E.\n    \"\"\"\n\n    t1 = math.atan2(q[3], q[1])\n    t2 = math.atan2(q[2], q[0])\n\n    e1 = t2 - t1\n    e2 = 2 * math.acos(math.sqrt(q[0] * q[0] + q[2] * q[2]))\n    e3 = t2 + t1\n\n    e = np.array([e1, e2, e3])\n    return e",
  "def EP2Euler213(q):\n    \"\"\"\n    EP2Euler213\n\n    \tQ = EP2Euler213(Q) translates the euler parameter vector\n    \tQ into the corresponding (2-1-3) euler angle set.\n    \"\"\"\n\n    q0 = q[0]\n    q1 = q[1]\n    q2 = q[2]\n    q3 = q[3]\n\n    e1 = math.atan2(2 * (q1 * q3 + q0 * q2), q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3)\n    e2 = math.asin(-2 * (q2 * q3 - q0 * q1))\n    e3 = math.atan2(2 * (q1 * q2 + q0 * q3), q0 * q0 - q1 * q1 + q2 * q2 - q3 * q3)\n\n    e = np.array([e1, e2, e3])\n    return e",
  "def EP2Euler231(q):\n    \"\"\"\n    EP2Euler231\n\n    \tE = EP2Euler231(Q) translates the euler parameter vector\n    \tQ into the corresponding (2-3-1) euler angle set.\n    \"\"\"\n\n    q0 = q[0]\n    q1 = q[1]\n    q2 = q[2]\n    q3 = q[3]\n\n    e1 = math.atan2(-2 * (q1 * q3 - q0 * q2), q0 * q0 + q1 * q1 - q2 * q2 - q3 * q3)\n    e2 = math.asin(2 * (q1 * q2 + q0 * q3))\n    e3 = math.atan2(-2 * (q2 * q3 - q0 * q1), q0 * q0 - q1 * q1 + q2 * q2 - q3 * q3)\n\n    e = np.array([e1, e2, e3])\n    return e",
  "def EP2Euler232(q):\n    \"\"\"\n    EP2Euler232(Q)\n\n    \tE = EP2Euler232(Q) translates the euler parameter\n    \tvector Q into the corresponding (2-3-2) euler angle\n    \tvector E.\n    \"\"\"\n\n    t1 = math.atan2(q[1], q[3])\n    t2 = math.atan2(q[2], q[0])\n\n    e1 = t1 + t2\n    e2 = 2 * math.acos(math.sqrt(q[0] * q[0] + q[2] * q[2]))\n    e3 = t2 - t1\n\n    e = np.array([e1, e2, e3])\n    return e",
  "def EP2Euler312(q):\n    \"\"\"\n    EP2Euler312\n\n    \tE = EP2Euler312(Q) translates the euler parameter vector\n    \tQ into the corresponding (3-1-2) euler angle set.\n    \"\"\"\n\n    q0 = q[0]\n    q1 = q[1]\n    q2 = q[2]\n    q3 = q[3]\n\n    e1 = math.atan2(-2 * (q1 * q2 - q0 * q3), q0 * q0 - q1 * q1 + q2 * q2 - q3 * q3)\n    e2 = math.asin(2 * (q2 * q3 + q0 * q1))\n    e3 = math.atan2(-2 * (q1 * q3 - q0 * q2), q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3)\n\n    e = np.array([e1, e2, e3])\n    return e",
  "def EP2Euler313(q):\n    \"\"\"\n    EP2Euler313(Q)\n\n    \tE = EP2Euler313(Q) translates the euler parameter\n    \tvector Q into the corresponding (3-1-3) euler angle\n    \tvector E.\n    \"\"\"\n\n    t1 = math.atan2(q[2], q[1])\n    t2 = math.atan2(q[3], q[0])\n\n    e1 = t1 + t2\n    e2 = 2 * math.acos(math.sqrt(q[0] * q[0] + q[3] * q[3]))\n    e3 = t2 - t1\n\n    e = np.array([e1, e2, e3])\n    return e",
  "def EP2Euler321(q):\n    \"\"\"\n    EP2Euler321\n\n    \tE = EP2Euler321(Q) translates the euler parameter vector\n    \tQ into the corresponding (3-2-1) euler angle set.\n    \"\"\"\n\n    q0 = q[0]\n    q1 = q[1]\n    q2 = q[2]\n    q3 = q[3]\n\n    e1 = math.atan2(2 * (q1 * q2 + q0 * q3), q0 * q0 + q1 * q1 - q2 * q2 - q3 * q3)\n    e2 = math.asin(-2 * (q1 * q3 - q0 * q2))\n    e3 = math.atan2(2 * (q2 * q3 + q0 * q1), q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3)\n\n    e = np.array([e1, e2, e3])\n    return e",
  "def EP2Euler323(q):\n    \"\"\"\n    EP2Euler323(Q)\n\n    \tE = EP2Euler323(Q) translates the euler parameter\n    \tvector Q into the corresponding (3-2-3) euler angle\n    \tvector E.\n    \"\"\"\n\n    t1 = math.atan2(q[1], q[2])\n    t2 = math.atan2(q[3], q[0])\n\n    e1 = t2 - t1\n    e2 = 2 * math.acos(math.sqrt(q[0] * q[0] + q[3] * q[3]))\n    e3 = t2 + t1\n\n    e = np.array([e1, e2, e3])\n    return e",
  "def EP2Gibbs(q):\n    \"\"\"\n    EP2Gibbs(Q1)\n\n    \tQ = EP2Gibbs(Q1) translates the euler parameter vector Q1\n    \tinto the gibbs vector Q.\n    \"\"\"\n\n    q1 = q[1] / q[0]\n    q2 = q[2] / q[0]\n    q3 = q[3] / q[0]\n\n    return np.array([q1, q2, q3])",
  "def EP2MRP(q):\n    \"\"\"\n    EP2MRP(Q1)\n        Q = EP2MRP(Q1) translates the euler parameter vector Q1\n        into the MRP vector Q.\n    \"\"\"\n\n    if q[0] < 0:\n        q = -q\n\n    q1 = q[1] / (1 + q[0])\n    q2 = q[2] / (1 + q[0])\n    q3 = q[3] / (1 + q[0])\n\n    return np.array([q1, q2, q3])",
  "def EP2PRV(q):\n    \"\"\"\n    EP2PRV(Q1)\n\n    \tQ = EP2PRV(Q1) translates the euler parameter vector Q1\n    \tinto the principal rotation vector Q.\n    \"\"\"\n\n    p = 2 * math.acos(q[0])\n    sp = math.sin(p / 2)\n    q1 = q[1] / sp * p\n    q2 = q[2] / sp * p\n    q3 = q[3] / sp * p\n\n    return np.array([q1, q2, q3])",
  "def euler1(x):\n    \"\"\"\n\tEULER1 \tElementary rotation matrix\n\tReturns the elementary rotation matrix about the first body axis.\n\t\"\"\"\n    m = np.identity(3)\n    m[1, 1] = math.cos(x)\n    m[1, 2] = math.sin(x)\n    m[2, 1] = -m[1, 2]\n    m[2, 2] = m[1, 1]\n\n    return m",
  "def euler2(x):\n    \"\"\"\n\tEULER2 \tElementary rotation matrix\n\tReturns the elementary rotation matrix about the\n\tsecond body axis.\n\t\"\"\"\n    m = np.identity(3)\n    m[0, 0] = math.cos(x)\n    m[0, 2] = -math.sin(x)\n    m[2, 0] = -m[0, 2]\n    m[2, 2] = m[0, 0]\n\n    return m",
  "def euler3(x):\n    \"\"\"\n\tEULER3 \tElementary rotation matrix\n\tReturns the elementary rotation matrix about the\n\tthird body axis.\n\t\"\"\"\n    m = np.identity(3)\n    m[0, 0] = math.cos(x)\n    m[0, 1] = math.sin(x)\n    m[1, 0] = -m[0, 1]\n    m[1, 1] = m[0, 0]\n\n    return m",
  "def euler1212C(q):\n    \"\"\"\n\tEuler1212C\n\n        C = euler1212C(Q) returns the direction cosine\n        matrix in terms of the 1-2-1 euler angles.\n        Input Q must be a 3x1 vector of euler angles.\n\t\"\"\"\n    st1 = math.sin(q[0])\n    ct1 = math.cos(q[0])\n    st2 = math.sin(q[1])\n    ct2 = math.cos(q[1])\n    st3 = math.sin(q[2])\n    ct3 = math.cos(q[2])\n\n    C = np.identity(3)\n    C[0, 0] = ct2\n    C[0, 1] = st1 * st2\n    C[0, 2] = -ct1 * st2\n    C[1, 0] = st2 * st3\n    C[1, 1] = ct1 * ct3 - ct2 * st1 * st3\n    C[1, 2] = ct3 * st1 + ct1 * ct2 * st3\n    C[2, 0] = ct3 * st2\n    C[2, 1] = -ct2 * ct3 * st1 - ct1 * st3\n    C[2, 2] = ct1 * ct2 * ct3 - st1 * st3\n\n    return C",
  "def euler1212EP(e):\n    \"\"\"\n\tEuler1212EP(E)\n\n        Q = euler1212EP(E) translates the 121 euler angle\n        vector E into the euler parameter vector Q.\n\t\"\"\"\n\n    e1 = e[0] / 2\n    e2 = e[1] / 2\n    e3 = e[2] / 2\n\n    q0 = math.cos(e2) * math.cos(e1 + e3)\n    q1 = math.cos(e2) * math.sin(e1 + e3)\n    q2 = math.sin(e2) * math.cos(e1 - e3)\n    q3 = math.sin(e2) * math.sin(e1 - e3)\n\n    return np.array([q0, q1, q2, q3])",
  "def euler1212Gibbs(e):\n    \"\"\"\n\tEuler1212Gibbs(E)\n\n        Q = euler1212Gibbs(E) translates the (1-2-1) euler\n        angle vector E into the gibbs vector Q.\n\t\"\"\"\n\n    return EP2Gibbs(euler1212EP(e))",
  "def euler1212MRP(e):\n    \"\"\"\n    euler1212MRP(E)\n\n    \tQ = euler1212MRP(E) translates the (1-2-1) euler\n    \tangle vector E into the MRP vector Q.\n    \"\"\"\n\n    return EP2MRP(euler1212EP(e))",
  "def euler1212PRV(e):\n    \"\"\"\n    euler1212PRV(E)\n\n    \tQ = euler1212PRV(E) translates the (1-2-1) euler\n    \tangle vector E into the principal rotation vector Q.\n    \"\"\"\n\n    return EP2PRV(euler1212EP(e))",
  "def euler1232C(q):\n    \"\"\"\n    euler1232C\n\n    \tC = euler1232C(Q) returns the direction cosine\n    \tmatrix in terms of the 1-2-3 euler angles.\n    \tInput Q must be a 3x1 vector of euler angles.\n    \"\"\"\n\n    st1 = math.sin(q[0])\n    ct1 = math.cos(q[0])\n    st2 = math.sin(q[1])\n    ct2 = math.cos(q[1])\n    st3 = math.sin(q[2])\n    ct3 = math.cos(q[2])\n\n    C = np.identity(3)\n    C[0, 0] = ct2 * ct3\n    C[0, 1] = ct3 * st1 * st2 + ct1 * st3\n    C[0, 2] = st1 * st3 - ct1 * ct3 * st2\n    C[1, 0] = -ct2 * st3\n    C[1, 1] = ct1 * ct3 - st1 * st2 * st3\n    C[1, 2] = ct3 * st1 + ct1 * st2 * st3\n    C[2, 0] = st2\n    C[2, 1] = -ct2 * st1\n    C[2, 2] = ct1 * ct2\n\n    return C",
  "def euler1232EP(e):\n    \"\"\"\n    euler1232EP(E)\n\n    \tQ = euler1232EP(E) translates the 123 euler angle\n    \tvector E into the euler parameter vector Q.\n    \"\"\"\n\n    c1 = math.cos(e[0] / 2)\n    s1 = math.sin(e[0] / 2)\n    c2 = math.cos(e[1] / 2)\n    s2 = math.sin(e[1] / 2)\n    c3 = math.cos(e[2] / 2)\n    s3 = math.sin(e[2] / 2)\n\n    q0 = c1 * c2 * c3 - s1 * s2 * s3\n    q1 = s1 * c2 * c3 + c1 * s2 * s3\n    q2 = c1 * s2 * c3 - s1 * c2 * s3\n    q3 = c1 * c2 * s3 + s1 * s2 * c3\n\n    return np.array([q0, q1, q2, q3])",
  "def euler1232Gibbs(e):\n    \"\"\"\n    euler1232Gibbs(E)\n\n    \tQ = euler1232Gibbs(E) translates the (1-2-3) euler\n    \tangle vector E into the gibbs vector Q.\n    \"\"\"\n\n    return EP2Gibbs(euler1232EP(e))",
  "def euler1232MRP(e):\n    \"\"\"\n    euler1232MRP(E)\n\n    \tQ = euler1232MRP(E) translates the (1-2-3) euler\n    \tangle vector E into the MRP vector Q.\n    \"\"\"\n\n    return EP2MRP(euler1232EP(e))",
  "def euler1232PRV(e):\n    \"\"\"\n    euler1232PRV(E)\n\n    \tQ = euler1232PRV(E) translates the (1-2-3) euler\n    \tangle vector E into the principal rotation vector Q.\n    \"\"\"\n\n    return EP2PRV(euler1232EP(e))",
  "def euler1312C(q):\n    \"\"\"\n    euler1312C\n\n    \tC = euler1312C(Q) returns the direction cosine\n    \tmatrix in terms of the 1-3-1 euler angles.\n    \tInput Q must be a 3x1 vector of euler angles.\n    \"\"\"\n\n    st1 = math.sin(q[0])\n    ct1 = math.cos(q[0])\n    st2 = math.sin(q[1])\n    ct2 = math.cos(q[1])\n    st3 = math.sin(q[2])\n    ct3 = math.cos(q[2])\n\n    C = np.identity(3)\n    C[0, 0] = ct2\n    C[0, 1] = ct1 * st2\n    C[0, 2] = st1 * st2\n    C[1, 0] = -ct3 * st2\n    C[1, 1] = ct1 * ct2 * ct3 - st1 * st3\n    C[1, 2] = ct2 * ct3 * st1 + ct1 * st3\n    C[2, 0] = st2 * st3\n    C[2, 1] = -ct3 * st1 - ct1 * ct2 * st3\n    C[2, 2] = ct1 * ct3 - ct2 * st1 * st3\n\n    return C",
  "def euler1312EP(e):\n    \"\"\"\n    euler1312EP(E)\n\n    \tQ = euler1312EP(E) translates the 131 euler angle\n    \tvector E into the euler parameter vector Q.\n    \"\"\"\n\n    e1 = e[0] / 2\n    e2 = e[1] / 2\n    e3 = e[2] / 2\n\n    q0 = math.cos(e2) * math.cos(e1 + e3)\n    q1 = math.cos(e2) * math.sin(e1 + e3)\n    q2 = math.sin(e2) * math.sin(-e1 + e3)\n    q3 = math.sin(e2) * math.cos(-e1 + e3)\n\n    return np.array([q0, q1, q2, q3])",
  "def euler1312Gibbs(e):\n    \"\"\"\n    euler1312Gibbs(E)\n\n    \tQ = euler1312Gibbs(E) translates the (1-3-1) euler\n    \tangle vector E into the gibbs vector Q.\n    \"\"\"\n\n    return EP2Gibbs(euler1312EP(e))",
  "def euler1312MRP(e):\n    \"\"\"\n    euler1312MRP(E)\n\n    \tQ = euler1312MRP(E) translates the (1-3-1) euler\n    \tangle vector E into the MRP vector Q.\n    \"\"\"\n\n    return EP2MRP(euler1312EP(e))",
  "def euler1312PRV(e):\n    \"\"\"\n    euler1312PRV(E)\n\n    \tQ = euler1312PRV(E) translates the (1-3-1) euler\n    \tangle vector E into the principal rotation vector Q.\n    \"\"\"\n\n    return EP2PRV(euler1312EP(e))",
  "def euler1322C(q):\n    \"\"\"\n    euler1322C\n\n    \tC = euler1322C(Q) returns the direction cosine\n    \tmatrix in terms of the 1-3-2 euler angles.\n    \tInput Q must be a 3x1 vector of euler angles.\n    \"\"\"\n\n    st1 = math.sin(q[0])\n    ct1 = math.cos(q[0])\n    st2 = math.sin(q[1])\n    ct2 = math.cos(q[1])\n    st3 = math.sin(q[2])\n    ct3 = math.cos(q[2])\n\n    C = np.identity(3)\n    C[0, 0] = ct2 * ct3\n    C[0, 1] = ct1 * ct3 * st2 + st1 * st3\n    C[0, 2] = ct3 * st1 * st2 - ct1 * st3\n    C[1, 0] = -st2\n    C[1, 1] = ct1 * ct2\n    C[1, 2] = ct2 * st1\n    C[2, 0] = ct2 * st3\n    C[2, 1] = -ct3 * st1 + ct1 * st2 * st3\n    C[2, 2] = ct1 * ct3 + st1 * st2 * st3\n\n    return C",
  "def euler1322EP(e):\n    \"\"\"\n    euler1322EP(E)\n\n    \tQ = euler1322EP(E) translates the 132 euler angle\n    \tvector E into the euler parameter vector Q.\n    \"\"\"\n\n    c1 = math.cos(e[0] / 2)\n    s1 = math.sin(e[0] / 2)\n    c2 = math.cos(e[1] / 2)\n    s2 = math.sin(e[1] / 2)\n    c3 = math.cos(e[2] / 2)\n    s3 = math.sin(e[2] / 2)\n\n    q0 = c1 * c2 * c3 + s1 * s2 * s3\n    q1 = s1 * c2 * c3 - c1 * s2 * s3\n    q2 = c1 * c2 * s3 - s1 * s2 * c3\n    q3 = c1 * s2 * c3 + s1 * c2 * s3\n\n    return np.array([q0, q1, q2, q3])",
  "def euler1322Gibbs(e):\n    \"\"\"\n    euler1322Gibbs(E)\n\n    \tQ = euler1322Gibbs(E) translates the (1-3-2) euler\n    \tangle vector E into the gibbs vector Q.\n    \"\"\"\n\n    return EP2Gibbs(euler1322EP(e))",
  "def euler1322MRP(e):\n    \"\"\"\n    euler1322MRP(E)\n\n    \tQ = euler1322MRP(E) translates the (1-3-2) euler\n    \tangle vector E into the MRP vector Q.\n    \"\"\"\n\n    return EP2MRP(euler1322EP(e))",
  "def euler1322PRV(e):\n    \"\"\"\n    euler1322PRV(E)\n\n    \tQ = euler1322PRV(E) translates the (1-3-2) euler\n    \tangle vector E into the principal rotation vector Q.\n    \"\"\"\n\n    return EP2PRV(euler1322EP(e))",
  "def euler2122C(q):\n    \"\"\"\n    euler2122C\n\n    \tC = euler2122C(Q) returns the direction cosine\n    \tmatrix in terms of the 2-1-2 euler angles.\n    \tInput Q must be a 3x1 vector of euler angles.\n    \"\"\"\n\n    st1 = math.sin(q[0])\n    ct1 = math.cos(q[0])\n    st2 = math.sin(q[1])\n    ct2 = math.cos(q[1])\n    st3 = math.sin(q[2])\n    ct3 = math.cos(q[2])\n\n    C = np.identity(3)\n    C[0, 0] = ct1 * ct3 - ct2 * st1 * st3\n    C[0, 1] = st2 * st3\n    C[0, 2] = -ct3 * st1 - ct1 * ct2 * st3\n    C[1, 0] = st1 * st2\n    C[1, 1] = ct2\n    C[1, 2] = ct1 * st2\n    C[2, 0] = ct2 * ct3 * st1 + ct1 * st3\n    C[2, 1] = -ct3 * st2\n    C[2, 2] = ct1 * ct2 * ct3 - st1 * st3\n\n    return C",
  "def euler2132C(q):\n    \"\"\"\n    euler2132C\n\n    \tC = euler2132C(Q) returns the direction cosine\n    \tmatrix in terms of the 2-1-3 euler angles.\n    \tInput Q must be a 3x1 vector of euler angles.\n    \"\"\"\n\n    st1 = math.sin(q[0])\n    ct1 = math.cos(q[0])\n    st2 = math.sin(q[1])\n    ct2 = math.cos(q[1])\n    st3 = math.sin(q[2])\n    ct3 = math.cos(q[2])\n\n    C = np.identity(3)\n    C[0, 0] = ct1 * ct3 + st1 * st2 * st3\n    C[0, 1] = ct2 * st3\n    C[0, 2] = -ct3 * st1 + ct1 * st2 * st3\n    C[1, 0] = ct3 * st1 * st2 - ct1 * st3\n    C[1, 1] = ct2 * ct3\n    C[1, 2] = ct1 * ct3 * st2 + st1 * st3\n    C[2, 0] = ct2 * st1\n    C[2, 1] = -st2\n    C[2, 2] = ct1 * ct2\n\n    return C",
  "def euler2312C(q):\n    \"\"\"\n    euler2312C\n\n    \tC = euler2312C(Q) returns the direction cosine\n    \tmatrix in terms of the 2-3-1 euler angles.\n    \tInput Q must be a 3x1 vector of euler angles.\n    \"\"\"\n\n    st1 = math.sin(q[0])\n    ct1 = math.cos(q[0])\n    st2 = math.sin(q[1])\n    ct2 = math.cos(q[1])\n    st3 = math.sin(q[2])\n    ct3 = math.cos(q[2])\n\n    C = np.identity(3)\n    C[0, 0] = ct1 * ct2\n    C[0, 1] = st2\n    C[0, 2] = -ct2 * st1\n    C[1, 0] = -ct1 * ct3 * st2 + st1 * st3\n    C[1, 1] = ct2 * ct3\n    C[1, 2] = ct3 * st1 * st2 + ct1 * st3\n    C[2, 0] = ct3 * st1 + ct1 * st2 * st3\n    C[2, 1] = -ct2 * st3\n    C[2, 2] = ct1 * ct3 - st1 * st2 * st3\n\n    return C",
  "def euler2322C(q):\n    \"\"\"\n    euler2322C\n\n    \tC = euler2322C(Q) returns the direction cosine\n    \tmatrix in terms of the 2-3-2 euler angles.\n    \tInput Q must be a 3x1 vector of euler angles.\n    \"\"\"\n\n    st1 = math.sin(q[0])\n    ct1 = math.cos(q[0])\n    st2 = math.sin(q[1])\n    ct2 = math.cos(q[1])\n    st3 = math.sin(q[2])\n    ct3 = math.cos(q[2])\n\n    C = np.identity(3)\n    C[0, 0] = ct1 * ct2 * ct3 - st1 * st3\n    C[0, 1] = ct3 * st2\n    C[0, 2] = -ct2 * ct3 * st1 - ct1 * st3\n    C[1, 0] = -ct1 * st2\n    C[1, 1] = ct2\n    C[1, 2] = st1 * st2\n    C[2, 0] = ct3 * st1 + ct1 * ct2 * st3\n    C[2, 1] = st2 * st3\n    C[2, 2] = ct1 * ct3 - ct2 * st1 * st3\n\n    return C",
  "def euler3122C(q):\n    \"\"\"\n    euler3122C\n\n    \tC = euler3122C(Q) returns the direction cosine\n    \tmatrix in terms of the 1-2-3 euler angles.\n    \tInput Q must be a 3x1 vector of euler angles.\n    \"\"\"\n\n    st1 = math.sin(q[0])\n    ct1 = math.cos(q[0])\n    st2 = math.sin(q[1])\n    ct2 = math.cos(q[1])\n    st3 = math.sin(q[2])\n    ct3 = math.cos(q[2])\n\n    C = np.identity(3)\n    C[0, 0] = ct1 * ct3 - st1 * st2 * st3\n    C[0, 1] = ct3 * st1 + ct1 * st2 * st3\n    C[0, 2] = -ct2 * st3\n    C[1, 0] = -ct2 * st1\n    C[1, 1] = ct1 * ct2\n    C[1, 2] = st2\n    C[2, 0] = ct3 * st1 * st2 + ct1 * st3\n    C[2, 1] = st1 * st3 - ct1 * ct3 * st2\n    C[2, 2] = ct2 * ct3\n\n    return C",
  "def euler3132C(q):\n    \"\"\"\n    euler3132C\n\n    \tC = euler3132C(Q) returns the direction cosine\n    \tmatrix in terms of the 3-1-3 euler angles.\n    \tInput Q must be a 3x1 vector of euler angles.\n    \"\"\"\n\n    st1 = math.sin(q[0])\n    ct1 = math.cos(q[0])\n    st2 = math.sin(q[1])\n    ct2 = math.cos(q[1])\n    st3 = math.sin(q[2])\n    ct3 = math.cos(q[2])\n\n    C = np.identity(3)\n    C[0, 0] = ct3 * ct1 - st3 * ct2 * st1\n    C[0, 1] = ct3 * st1 + st3 * ct2 * ct1\n    C[0, 2] = st3 * st2\n    C[1, 0] = -st3 * ct1 - ct3 * ct2 * st1\n    C[1, 1] = -st3 * st1 + ct3 * ct2 * ct1\n    C[1, 2] = ct3 * st2\n    C[2, 0] = st2 * st1\n    C[2, 1] = -st2 * ct1\n    C[2, 2] = ct2\n\n    return C",
  "def euler3212C(q):\n    \"\"\"\n    euler3212C\n    \tC = euler3212C(Q) returns the direction cosine\n    \tmatrix in terms of the 3-2-1 euler angles.\n    \tInput Q must be a 3x1 vector of euler angles.\n    \"\"\"\n\n    st1 = math.sin(q[0])\n    ct1 = math.cos(q[0])\n    st2 = math.sin(q[1])\n    ct2 = math.cos(q[1])\n    st3 = math.sin(q[2])\n    ct3 = math.cos(q[2])\n\n    C = np.identity(3)\n    C[0, 0] = ct2 * ct1\n    C[0, 1] = ct2 * st1\n    C[0, 2] = -st2\n    C[1, 0] = st3 * st2 * ct1 - ct3 * st1\n    C[1, 1] = st3 * st2 * st1 + ct3 * ct1\n    C[1, 2] = st3 * ct2\n    C[2, 0] = ct3 * st2 * ct1 + st3 * st1\n    C[2, 1] = ct3 * st2 * st1 - st3 * ct1\n    C[2, 2] = ct3 * ct2\n\n    return C",
  "def euler3232C(q):\n    \"\"\"\n    euler3232C\n\n    \tC = euler3232C(Q) returns the direction cosine\n    \tmatrix in terms of the 3-2-3 euler angles.\n    \tInput Q must be a 3x1 vector of euler angles.\n    \"\"\"\n\n    st1 = math.sin(q[0])\n    ct1 = math.cos(q[0])\n    st2 = math.sin(q[1])\n    ct2 = math.cos(q[1])\n    st3 = math.sin(q[2])\n    ct3 = math.cos(q[2])\n\n    C = np.identity(3)\n    C[0, 0] = ct1 * ct2 * ct3 - st1 * st3\n    C[0, 1] = ct2 * ct3 * st1 + ct1 * st3\n    C[0, 2] = -ct3 * st2\n    C[1, 0] = -ct3 * st1 - ct1 * ct2 * st3\n    C[1, 1] = ct1 * ct3 - ct2 * st1 * st3\n    C[1, 2] = st2 * st3\n    C[2, 0] = ct1 * st2\n    C[2, 1] = st1 * st2\n    C[2, 2] = ct2\n\n    return C",
  "def euler2122EP(e):\n    \"\"\"\n    euler2122EP(E)\n\n    \tQ = euler2122EP(E) translates the 212 euler angle\n    \tvector E into the euler parameter vector Q.\n    \"\"\"\n\n    e1 = e[0] / 2\n    e2 = e[1] / 2\n    e3 = e[2] / 2\n\n    q0 = math.cos(e2) * math.cos(e1 + e3)\n    q1 = math.sin(e2) * math.cos(-e1 + e3)\n    q2 = math.cos(e2) * math.sin(e1 + e3)\n    q3 = math.sin(e2) * math.sin(-e1 + e3)\n\n    return np.array([q0, q1, q2, q3])",
  "def euler2132EP(e):\n    \"\"\"\n    euler2132EP(E)\n\n    \tQ = euler2132EP(E) translates the 213 euler angle\n    \tvector E into the euler parameter vector Q.\n    \"\"\"\n\n    c1 = math.cos(e[0] / 2)\n    s1 = math.sin(e[0] / 2)\n    c2 = math.cos(e[1] / 2)\n    s2 = math.sin(e[1] / 2)\n    c3 = math.cos(e[2] / 2)\n    s3 = math.sin(e[2] / 2)\n\n    q0 = c1 * c2 * c3 + s1 * s2 * s3\n    q1 = c1 * s2 * c3 + s1 * c2 * s3\n    q2 = s1 * c2 * c3 - c1 * s2 * s3\n    q3 = c1 * c2 * s3 - s1 * s2 * c3\n\n    return np.array([q0, q1, q2, q3])",
  "def euler2312EP(e):\n    \"\"\"\n    euler2312EP(E)\n\n    \tQ = euler2312EP(E) translates the 231 euler angle\n    \tvector E into the euler parameter vector Q.\n    \"\"\"\n\n    c1 = math.cos(e[0] / 2)\n    s1 = math.sin(e[0] / 2)\n    c2 = math.cos(e[1] / 2)\n    s2 = math.sin(e[1] / 2)\n    c3 = math.cos(e[2] / 2)\n    s3 = math.sin(e[2] / 2)\n\n    q0 = c1 * c2 * c3 - s1 * s2 * s3\n    q1 = c1 * c2 * s3 + s1 * s2 * c3\n    q2 = s1 * c2 * c3 + c1 * s2 * s3\n    q3 = c1 * s2 * c3 - s1 * c2 * s3\n\n    return np.array([q0, q1, q2, q3])",
  "def euler2322EP(e):\n    \"\"\"\n    euler2322EP(E)\n\n    \tQ = euler2322EP(E) translates the 232 euler angle\n    \tvector E into the euler parameter vector Q.\n    \"\"\"\n\n    e1 = e[0] / 2\n    e2 = e[1] / 2\n    e3 = e[2] / 2\n\n    q0 = math.cos(e2) * math.cos(e1 + e3)\n    q1 = math.sin(e2) * math.sin(e1 - e3)\n    q2 = math.cos(e2) * math.sin(e1 + e3)\n    q3 = math.sin(e2) * math.cos(e1 - e3)\n\n    return np.array([q0, q1, q2, q3])",
  "def euler3122EP(e):\n    \"\"\"\n    euler3122EP(E)\n\n    \tQ = euler3122EP(E) translates the 312 euler angle\n    \tvector E into the euler parameter vector Q.\n    \"\"\"\n\n    c1 = math.cos(e[0] / 2)\n    s1 = math.sin(e[0] / 2)\n    c2 = math.cos(e[1] / 2)\n    s2 = math.sin(e[1] / 2)\n    c3 = math.cos(e[2] / 2)\n    s3 = math.sin(e[2] / 2)\n\n    q0 = c1 * c2 * c3 - s1 * s2 * s3\n    q1 = c1 * s2 * c3 - s1 * c2 * s3\n    q2 = c1 * c2 * s3 + s1 * s2 * c3\n    q3 = s1 * c2 * c3 + c1 * s2 * s3\n\n    return np.array([q0, q1, q2, q3])",
  "def euler3132EP(e):\n    \"\"\"\n    euler3132EP(E)\n\n    \tQ = euler3132EP(E) translates the 313 euler angle\n    \tvector E into the euler parameter vector Q.\n    \"\"\"\n\n    e1 = e[0] / 2\n    e2 = e[1] / 2\n    e3 = e[2] / 2\n\n    q0 = math.cos(e2) * math.cos(e1 + e3)\n    q1 = math.sin(e2) * math.cos(e1 - e3)\n    q2 = math.sin(e2) * math.sin(e1 - e3)\n    q3 = math.cos(e2) * math.sin(e1 + e3)\n\n    return np.array([q0, q1, q2, q3])",
  "def euler3212EP(e):\n    \"\"\"\n    euler3212EP(E)\n        Q = euler3212EP(E) translates the 321 euler angle\n        vector E into the euler parameter vector Q.\n    \"\"\"\n\n    c1 = math.cos(e[0] / 2)\n    s1 = math.sin(e[0] / 2)\n    c2 = math.cos(e[1] / 2)\n    s2 = math.sin(e[1] / 2)\n    c3 = math.cos(e[2] / 2)\n    s3 = math.sin(e[2] / 2)\n\n    q0 = c1 * c2 * c3 + s1 * s2 * s3\n    q1 = c1 * c2 * s3 - s1 * s2 * c3\n    q2 = c1 * s2 * c3 + s1 * c2 * s3\n    q3 = s1 * c2 * c3 - c1 * s2 * s3\n\n    return np.array([q0, q1, q2, q3])",
  "def euler3232EP(e):\n    \"\"\"\n    euler3232EP(E)\n        Q = euler3232EP(E) translates the 323 euler angle\n        vector E into the euler parameter vector Q.\n    \"\"\"\n\n    e1 = e[0] / 2\n    e2 = e[1] / 2\n    e3 = e[2] / 2\n\n    q0 = math.cos(e2) * math.cos(e1 + e3)\n    q1 = math.sin(e2) * math.sin(-e1 + e3)\n    q2 = math.sin(e2) * math.cos(-e1 + e3)\n    q3 = math.cos(e2) * math.sin(e1 + e3)\n\n    return np.array([q0, q1, q2, q3])",
  "def euler2122Gibbs(e):\n    \"\"\"\n    euler2122Gibbs(E)\n\n    \tQ = euler2122Gibbs(E) translates the (2-1-2) euler\n    \tangle vector E into the gibbs vector Q.\n    \"\"\"\n\n    return EP2Gibbs(euler2122EP(e))",
  "def euler2122MRP(e):\n    \"\"\"\n    euler2122MRP(E)\n\n    \tQ = euler2122MRP(E) translates the (2-1-2) euler\n    \tangle vector E into the MRP vector Q.\n    \"\"\"\n\n    return EP2MRP(euler2122EP(e))",
  "def euler2122PRV(e):\n    \"\"\"\n    euler2122PRV(E)\n\n    \tQ = euler2122PRV(E) translates the (2-1-2) euler\n    \tangle vector E into the principal rotation vector Q.\n    \"\"\"\n\n    return EP2PRV(euler2122EP(e))",
  "def euler2132Gibbs(e):\n    \"\"\"\n    euler2132Gibbs(E)\n\n    \tQ = euler2132Gibbs(E) translates the (2-1-3) euler\n    \tangle vector E into the gibbs vector Q.\n    \"\"\"\n\n    return EP2Gibbs(euler2132EP(e))",
  "def euler2132MRP(e):\n    \"\"\"\n    euler2132MRP(E)\n\n    \tQ = euler2132MRP(E) translates the (2-1-3) euler\n    \tangle vector E into the MRP vector Q.\n    \"\"\"\n\n    return EP2MRP(euler2132EP(e))",
  "def euler2132PRV(e):\n    \"\"\"\n    euler2132PRV(E)\n\n    \tQ = euler2132PRV(E) translates the (2-1-3) euler\n    \tangle vector E into the principal rotation vector Q.\n    \"\"\"\n\n    return EP2PRV(euler2132EP(e))",
  "def euler2312Gibbs(e):\n    \"\"\"\n    euler2312Gibbs(E)\n\n    \tQ = euler2312Gibbs(E) translates the (2-3-1) euler\n    \tangle vector E into the gibbs vector Q.\n    \"\"\"\n\n    return EP2Gibbs(euler2312EP(e))",
  "def euler2312MRP(e):\n    \"\"\"\n    euler2312MRP(E)\n\n    \tQ = euler2312MRP(E) translates the (2-3-1) euler\n    \tangle vector E into the MRP vector Q.\n    \"\"\"\n\n    return EP2MRP(euler2312EP(e))",
  "def euler2312PRV(e):\n    \"\"\"\n    euler2312PRV(E)\n\n    \tQ = euler2312PRV(E) translates the (2-3-1) euler\n    \tangle vector E into the principal rotation vector Q.\n    \"\"\"\n\n    return EP2PRV(euler2312EP(e))",
  "def euler2322Gibbs(e):\n    \"\"\"\n    euler2322Gibbs(E)\n\n    \tQ = euler2322Gibbs(E) translates the (2-3-2) euler\n    \tangle vector E into the gibbs vector Q.\n    \"\"\"\n\n    return EP2Gibbs(euler2322EP(e))",
  "def euler2322MRP(e):\n    \"\"\"\n    euler2322MRP(E)\n\n    \tQ = euler2322MRP(E) translates the (2-3-2) euler\n    \tangle vector E into the MRP vector Q.\n    \"\"\"\n\n    return EP2MRP(euler2322EP(e))",
  "def euler2322PRV(e):\n    \"\"\"\n    euler2322PRV(E)\n\n    \tQ = euler2322PRV(E) translates the (2-3-2) euler\n    \tangle vector E into the principal rotation vector Q.\n    \"\"\"\n\n    return EP2PRV(euler2322EP(e))",
  "def euler3122Gibbs(e):\n    \"\"\"\n    euler3122Gibbs(E)\n\n    \tQ = euler3122Gibbs(E) translates the (3-1-2) euler\n    \tangle vector E into the gibbs vector Q.\n    \"\"\"\n\n    return EP2Gibbs(euler3122EP(e))",
  "def euler3122MRP(e):\n    \"\"\"\n    euler3122MRP(E)\n\n    \tQ = euler3122MRP(E) translates the (3-1-2) euler\n    \tangle vector E into the MRP vector Q.\n    \"\"\"\n\n    return EP2MRP(euler3122EP(e))",
  "def euler3122PRV(e):\n    \"\"\"\n    euler3122PRV(E)\n\n    \tQ = euler3122PRV(E) translates the (3-1-2) euler\n    \tangle vector E into the principal rotation vector Q.\n    \"\"\"\n\n    return EP2PRV(euler3122EP(e))",
  "def euler3132Gibbs(e):\n    \"\"\"\n    euler3132Gibbs(E)\n\n    \tQ = euler3132Gibbs(E) translates the (3-1-3) euler\n    \tangle vector E into the gibbs vector Q.\n    \"\"\"\n\n    return EP2Gibbs(euler3132EP(e))",
  "def euler3132MRP(e):\n    \"\"\"\n    euler3132MRP(E)\n\n    \tQ = euler3132MRP(E) translates the (3-1-3) euler\n    \tangle vector E into the MRP vector Q.\n    \"\"\"\n\n    return EP2MRP(euler3132EP(e))",
  "def euler3132PRV(e):\n    \"\"\"\n    euler3132PRV(E)\n\n    \tQ = euler3132PRV(E) translates the (3-1-3) euler\n    \tangle vector E into the principal rotation vector Q.\n    \"\"\"\n\n    return EP2PRV(euler3132EP(e))",
  "def euler3212Gibbs(e):\n    \"\"\"\n    euler3212Gibbs(E)\n\n    \tQ = euler3212Gibbs(E) translates the (3-2-1) euler\n    \tangle vector E into the gibbs vector Q.\n    \"\"\"\n\n    return EP2Gibbs(euler3212EP(e))",
  "def euler3212MRP(e):\n    \"\"\"\n    euler3212MRP(E)\n        Q = euler3212MRP(E) translates the (3-2-1) euler\n        angle vector E into the MRP vector Q.\n    \"\"\"\n\n    return EP2MRP(euler3212EP(e))",
  "def euler3212PRV(e):\n    \"\"\"\n     euler3212PRV(E)\n\n    \tQ = euler3212PRV(E) translates the (3-2-1) euler\n    \tangle vector E into the principal rotation vector Q.\n    \"\"\"\n\n    return EP2PRV(euler3212EP(e))",
  "def euler3232Gibbs(e):\n    \"\"\"\n    euler3232Gibbs(E)\n        Q = euler3232Gibbs(E) translates the (3-2-3) euler\n        angle vector E into the gibbs vector Q.\n    \"\"\"\n\n    return EP2Gibbs(euler3232EP(e))",
  "def euler3232MRP(e):\n    \"\"\"\n    euler3232MRP(E)\n\n    \tQ = euler3232MRP(E) translates the (3-2-3) euler\n    \tangle vector E into the MRP vector Q.\n    \"\"\"\n\n    return EP2MRP(euler3232EP(e))",
  "def euler3232PRV(e):\n    \"\"\"\n    euler3232PRV(E)\n\n    \tQ = euler3232PRV(E) translates the (3-2-3) euler\n    \tangle vector Q1 into the principal rotation vector Q.\n    \"\"\"\n\n    return EP2PRV(euler3232EP(e))",
  "def Mi(theta, i):\n    c = np.cos(theta)\n    s = np.sin(theta)\n    case = i\n    C = np.zeros((3, 3))\n    if case == 1:\n        C[0][0] = 1.\n        C[0][1] = 0.\n        C[0][2] = 0.\n        C[1][0] = 0.\n        C[1][1] = c\n        C[1][2] = s\n        C[2][0] = 0.\n        C[2][1] = -s\n        C[2][2] = c\n    elif case == 2:\n        C[0][0] = c\n        C[0][1] = 0.\n        C[0][2] = -s\n        C[1][0] = 0.\n        C[1][1] = 1.\n        C[1][2] = 0.\n        C[2][0] = s\n        C[2][1] = 0.\n        C[2][2] = c\n    elif case == 3:\n        C[0][0] = c\n        C[0][1] = s\n        C[0][2] = 0.\n        C[1][0] = -s\n        C[1][1] = c\n        C[1][2] = 0.\n        C[2][0] = 0.\n        C[2][1] = 0.\n        C[2][2] = 1.\n    else:\n        print('Mi() error: incorrect axis', i, 'selected')\n    return C",
  "def v3Tilde(vector):\n    x1 = vector[0]\n    x2 = vector[1]\n    x3 = vector[2]\n\n    xTilde = [[0, -x3, x2]\n        ,[x3, 0, -x1]\n        ,[-x2, x1, 0]\n              ]\n\n    return xTilde",
  "def create(\n        gsHat_B,\n        Js,\n        uMax = numpy.NaN\n    ):\n    \"\"\"\n    Create a FSW RW object\n\n    This function is called to setup a FSW RW device in python, and adds it to the of RW\n    devices in rwList[].  This list is accessible from the parent python script that\n    imported this rw library script, and thus any particular value can be over-ridden\n    by the user.\n    \"\"\"\n    global rwList\n\n    # create the blank RW object\n    RW = messaging.RWConfigElementMsgPayload()\n\n    norm = numpy.linalg.norm(gsHat_B)\n    if norm > 1e-10:\n        gsHat_B = gsHat_B / norm\n    else:\n        print('Error: RW gsHat input must be non-zero 3x1 vector')\n        exit(1)\n\n    RW.gsHat_B = gsHat_B\n    RW.uMax = uMax\n    RW.Js = Js\n\n    # add RW to the list of RW devices\n    rwList.append(RW)\n\n    return",
  "def writeConfigMessage():\n    \"\"\"\n    Write FSW RW array msg\n\n    This function should be called after all devices are created with create()\n    It creates the C-class container for the array of RW devices, and attaches\n    this container to the spacecraft object\n\n    \"\"\"\n    global rwList\n\n    GsMatrix_B = []\n    JsList = []\n    uMaxList = []\n    for rw in rwList:\n        GsMatrix_B.extend(rw.gsHat_B)\n        JsList.extend([rw.Js])\n        uMaxList.extend([rw.uMax])\n\n    rwConfigParams = messaging.RWArrayConfigMsgPayload()\n    rwConfigParams.GsMatrix_B = GsMatrix_B\n    rwConfigParams.JsList = JsList\n    rwConfigParams.uMax = uMaxList\n    rwConfigParams.numRW = len(rwList)\n    rwConfigMsg = messaging.RWArrayConfigMsg().write(rwConfigParams)\n    rwConfigMsg.this.disown()\n\n    return rwConfigMsg",
  "def clearSetup():\n    global rwList\n\n    rwList = []\n\n    return",
  "def getNumOfDevices():\n    return len(rwList)",
  "class BSKDeprecationWarning(Warning):\n    __color__ = \"\\x1b[33;20m\"",
  "class BSKUrgentDeprecationWarning(Warning):\n    __color__ = \"\\x1b[31;1m\"",
  "def filterwarnings(\n    action: Literal[\"error\", \"ignore\", \"always\", \"default\", \"module\", \"once\"],\n    identifier: str,\n    **kwargs: Any,\n):\n    \"\"\"Use this function to create global deprecation warning filters.\n\n    The most common use of this function is suppressing warnings for deprecated systems\n    that you still intend to use. Imagine you want to ignore deprecation warnings\n    for the method `myMethod` in class `ValidClass` in module `my_module`. You would add\n    the following line to your simulation script::\n\n        deprecated.filterwarnings(\"ignore\", \"my_module.ValidClass.myMethod\")\n\n    Note that deprecation warnings should not be ignored blindly. Deprecated code WILL\n    be removed in future releases, so use warning suppression carefully.\n\n    Args:\n        action (Literal[\"error\", \"ignore\", \"always\", \"default\", \"module\", \"once\"]):\n            Controls how the filtered warnings will behave.\n        identifier (str): The warning message must contain this string. This can be\n            the function or variable identifier (qualified name) in order to hide\n            deprecation warnings for specific features.\n        **kwargs (Any): Any other keyword arguments are passed directly to\n            `warnings.filterwarnings`.\n    \"\"\"\n    warnings.filterwarnings(\n        action, f\".*{identifier}.*\", category=BSKDeprecationWarning, **kwargs\n    )",
  "class ignore:\n    \"\"\"Use this context manager to ignore warnings in a precise section of code.\n\n    The most common use of this function is suppressing warnings for specific calls.\n    Imagine you want to ignore deprecation warnings for the method `myMethod` in\n    class `ValidClass` in module `my_module` for a single call to this function.\n    You would do::\n\n        myClass = my_module.ValidClass()\n\n        with deprecated.ignore(\"my_module.ValidClass.myMethod\"):\n            myClass.myMethod() # Does not raise a warning\n\n        myClass.myMethod() # Raises a warning\n\n    Note that deprecation warnings should not be ignored blindly. Deprecated code WILL\n    be removed in future releases, so use warning suppression carefully.\n    \"\"\"\n\n    def __init__(self, identifier: str) -> None:\n        self.catch = catch_warnings()\n        self.identifier = identifier\n\n    def __enter__(self):\n        self.catch.__enter__()\n        filterwarnings(\"ignore\", self.identifier)\n\n    def __exit__(self, *exc_info):\n        self.catch.__exit__(*exc_info)",
  "def deprecationWarn(id: str, removalDate: Union[datetime.date, str], msg: str):\n    \"\"\"Utility function to raise deprecation warnings inside a function body.\n\n    This function should rarely be used on its own. For deprecated Python code,\n    prefer the `@deprecated` decorator. For deprecated C++ code, use the SWIG\n    macros in `swig_deprecated.i`.\n\n    Args:\n        id (str): An identifier for the deprecated feature (function/variable\n            qualified name)\n        removalDate (Union[datetime.date, str]): The date when we expect to remove this\n            deprecated feature, in the format 'YYYY/MM/DD' or as a ``datetime.date``.\n            Think of an amount of time that would let users update their code, and then\n            add that duration to today's date to find a reasonable removal date.\n        msg (str, optional): a text that is directly shown to the users. Here, you may\n            explain why the function is deprecated, alternative functions, links to\n            documentation or scenarios that show how to translate deprecated code...\n    \"\"\"\n\n    id = id.replace(\")\", \"\").replace(\"(\", \"\")\n    if isinstance(removalDate, str):\n        removalDate = datetime.datetime.strptime(removalDate, r\"%Y/%m/%d\").date()\n\n    if removalDate > datetime.date.today():\n        warnings.warn(\n            f\"{id} will be removed after {removalDate}: {msg}\",\n            category=BSKDeprecationWarning,\n            stacklevel=3,\n        )\n    else:\n        warnings.warn(\n            f\"{id} will be removed soon: {msg}\",\n            category=BSKUrgentDeprecationWarning,\n            stacklevel=3,\n        )",
  "def deprecated(removalDate: str, msg: str):\n    \"\"\"A decorator for functions or classes that are deprecated.\n\n    Usage::\n\n        @deprecated.deprecated(\"2024/05/28\", \"Use MyNewClass\")\n        class MyClass:\n            ...\n\n    or::\n\n        @deprecated.deprecated(\"2024/05/28\", \"myFun is unsafe now\")\n        def myFun(a, b):\n            ...\n\n    or::\n\n        class ValidClass:\n\n            @deprecated.deprecated(\"2024/05/28\", \"myMethod is slow, use myBetterMethod\")\n            def myMethod(self, a, b):\n                ...\n\n    Args:\n        removalDate (Union[datetime.date, str]): The date when we expect to remove this\n            deprecated feature, in the format 'YYYY/MM/DD' or as a ``datetime.date``.\n            Think of an amount of time that would let users update their code, and then\n            add that duration to today's date to find a reasonable removal date.\n        msg (str, optional): a text that is directly shown to the users. Here, you may\n            explain why the function is deprecated, alternative functions, links to\n            documentation or scenarios that show how to translate deprecated code...\n    \"\"\"\n\n    def wrapper(func):\n        id = f\"{func.__module__}.{func.__qualname__}\"\n\n        def inner_wrapper(*args, **kwargs):\n            deprecationWarn(id, removalDate, msg)\n            return func(*args, **kwargs)\n\n        return inner_wrapper\n\n    return wrapper",
  "class DeprecatedAttribute:\n    \"\"\"Use this descriptor to deprecate class attributes (variables).\n\n    If you want to deprecate ``myAttribute`` in the following class::\n\n        class MyClass:\n\n            def __init__(self) -> None:\n                self.myAttribute = 0\n\n    You can use the following syntax::\n\n        class PythonTest:\n\n            myAttribute = deprecated.DeprecatedAttribute(\"2099/05/05\", \"myAttribute is no longer used in the simulation\")\n\n            def __init__(self) -> None:\n                with deprecated.ignore(\"myAttribute\"): # Prevents warnings here\n                    self.myAttribute = 0\n\n    The attribute will work as before, but deprecation warnings will be raised\n    everytime it's used (read or set).\n    \"\"\"\n\n    def __init__(self, removalDate: str, msg: str) -> None:\n        self.removalDate = removalDate\n        self.msg = msg\n\n    def __set_name__(self, owner, name):\n        self.id = f\"{owner.__module__}.{owner.__qualname__}.{name}\"\n        self.name = name\n\n    def __get__(self, obj, objtype=None):\n        deprecationWarn(self.id, self.removalDate, self.msg)\n        return getattr(obj, f\"_{self.name}\")\n\n    def __set__(self, obj, value):\n        deprecationWarn(self.id, self.removalDate, self.msg)\n        setattr(obj, f\"_{self.name}\", value)",
  "class DeprecatedProperty:  # type: ignore\n    \"\"\"Use this descriptor to deprecate class properties.\n\n    If you want to deprecate ``myProperty`` in the following class::\n\n        class MyClass:\n\n            @property\n            def myProperty(self):\n                return 0\n\n            @myProperty.setter\n            def myProperty(self, value: int):\n                ...\n\n    You can use the following syntax::\n\n        class PythonTest:\n\n            @property\n            def myProperty(self):\n                return 0\n\n            @myProperty.setter\n            def myProperty(self, value: int):\n                ...\n\n            myProperty = deprecated.DeprecatedProperty(\n                \"2099/05/05\",\n                \"myProperty is no longer used in the simulation\",\n                myProperty)\n\n    The property will work as before, but deprecation warnings will be raised\n    everytime it's used (read or set).\n    \"\"\"\n\n    def __init__(self, removalDate: str, msg: str, property: property) -> None:\n        self.removalDate = removalDate\n        self.msg = msg\n        self.property = property\n\n        if not hasattr(self.property, \"__get__\") or not hasattr(\n            self.property, \"__set__\"\n        ):\n            raise ValueError(\"DeprecatedProperty must be given an existing property\")\n\n    def __set_name__(self, owner, name):\n        self.id = f\"{owner.__module__}.{owner.__qualname__}.{name}\"\n\n    def __get__(self, *args, **kwargs):\n        deprecationWarn(self.id, self.removalDate, self.msg)\n        return self.property.__get__(*args, **kwargs)\n\n    def __set__(self, *args, **kwargs):\n        deprecationWarn(self.id, self.removalDate, self.msg)\n        self.property.__set__(*args, **kwargs)\n\n    def __delete__(self, *args, **kwargs):\n        self.property.__delete__(*args, **kwargs)",
  "def formatwarning(\n    message,\n    category,\n    filename,\n    lineno,\n    line=None,\n    __defaultformatwarning=warnings.formatwarning,\n):\n    \"\"\"Hook to write a warning to a file; replace if you like.\"\"\"\n    if issubclass(category, (BSKDeprecationWarning, BSKUrgentDeprecationWarning)):\n        message = category(str(message) + \"\\x1b[0m\")  # Append the color reset character\n\n        # Produce a \"fake object\" with sole attribute __name__ which is the name of\n        # the actual category prepended by the color character\n        category = types.SimpleNamespace(\n            __name__=category.__color__ + category.__name__\n        )\n\n    return __defaultformatwarning(message, category, filename, lineno, line)",
  "def __init__(self, identifier: str) -> None:\n        self.catch = catch_warnings()\n        self.identifier = identifier",
  "def __enter__(self):\n        self.catch.__enter__()\n        filterwarnings(\"ignore\", self.identifier)",
  "def __exit__(self, *exc_info):\n        self.catch.__exit__(*exc_info)",
  "def wrapper(func):\n        id = f\"{func.__module__}.{func.__qualname__}\"\n\n        def inner_wrapper(*args, **kwargs):\n            deprecationWarn(id, removalDate, msg)\n            return func(*args, **kwargs)\n\n        return inner_wrapper",
  "def __init__(self, removalDate: str, msg: str) -> None:\n        self.removalDate = removalDate\n        self.msg = msg",
  "def __set_name__(self, owner, name):\n        self.id = f\"{owner.__module__}.{owner.__qualname__}.{name}\"\n        self.name = name",
  "def __get__(self, obj, objtype=None):\n        deprecationWarn(self.id, self.removalDate, self.msg)\n        return getattr(obj, f\"_{self.name}\")",
  "def __set__(self, obj, value):\n        deprecationWarn(self.id, self.removalDate, self.msg)\n        setattr(obj, f\"_{self.name}\", value)",
  "def __init__(self, removalDate: str, msg: str, property: property) -> None:\n        self.removalDate = removalDate\n        self.msg = msg\n        self.property = property\n\n        if not hasattr(self.property, \"__get__\") or not hasattr(\n            self.property, \"__set__\"\n        ):\n            raise ValueError(\"DeprecatedProperty must be given an existing property\")",
  "def __set_name__(self, owner, name):\n        self.id = f\"{owner.__module__}.{owner.__qualname__}.{name}\"",
  "def __get__(self, *args, **kwargs):\n        deprecationWarn(self.id, self.removalDate, self.msg)\n        return self.property.__get__(*args, **kwargs)",
  "def __set__(self, *args, **kwargs):\n        deprecationWarn(self.id, self.removalDate, self.msg)\n        self.property.__set__(*args, **kwargs)",
  "def __delete__(self, *args, **kwargs):\n        self.property.__delete__(*args, **kwargs)",
  "def DeprecatedProperty(removalDate: str, msg: str) -> Any:  # type: ignore\n        ...",
  "def inner_wrapper(*args, **kwargs):\n            deprecationWarn(id, removalDate, msg)\n            return func(*args, **kwargs)",
  "def create(\n        rThrust_B,\n        tHatThrust_B,\n        Fmax\n    ):\n    \"\"\"\n    This function is called to setup a FSW RW device in python, and adds it to the of RW\n    devices in rwList[].  This list is accessible from the parent python script that\n    imported this rw library script, and thus any particular value can be over-ridden\n    by the user.\n\n    Args:\n        rThrust_B: position of thruster in spacecraft body frame\n        tHatThrust_B: direction of thrust vector in B frame\n        Fmax: maximum thrust force value\n\n    \"\"\"\n    global thrList\n\n    # create the blank Thruster object\n    thrPointer = messaging.THRConfigMsgPayload()\n\n    thrPointer.rThrust_B = rThrust_B\n    thrPointer.tHatThrust_B = tHatThrust_B\n    thrPointer.maxThrust = Fmax\n\n    # add RW to the list of RW devices\n    thrList.append(thrPointer)\n\n    return",
  "def writeConfigMessage():\n    \"\"\"\n    This function should be called after all devices are created with create()\n    It creates the C-class container for the array of RW devices, and attaches\n    this container to the spacecraft object\n    :return:\n    \"\"\"\n    global thrList\n\n    thrClass = messaging.THRArrayConfigMsgPayload()\n\n    i = 0\n    for item in thrList:\n        messaging.ThrustConfigArray_setitem(thrClass.thrusters, i, item)\n        i += 1\n\n    thrClass.numThrusters = len(thrList)\n    thrConfigInMsg = messaging.THRArrayConfigMsg().write(thrClass)\n    thrConfigInMsg.this.disown()\n\n    return thrConfigInMsg",
  "def clearSetup():\n    global thrList\n\n    thrList = []\n\n    return",
  "def getNumOfDevices():\n    return len(thrList)",
  "class thrusterFactory(object):\n    \"\"\"Simulation Thruster Factory Class\"\"\"\n\n    def __init__(self):\n        self.useMinPulseTime = True\n        self.thrusterList = OrderedDict()\n\n    def create(self, thrusterType, r_B, tHat_B, **kwargs):\n        \"\"\"\n        This function is called to setup a thruster device in python, and adds it to the of thruster\n        factory in ``thrusterList{}``.  The function returns a copy of the device that can be changed if needed.\n        The first 3 arguments are required, the remaining arguments are optional with:\n\n        Parameters\n        ----------\n        thrusterType : string\n                thruster manufacturing name.:\n        r_B : list\n                vector with thruster location in B-frame components:\n        tHat_B : list\n                vector with thruster force direction unit vector:\n        kwargs:\n            useMinPulseTime: BOOL\n                flag if the thruster model should use a minimum impulse time\n            areaNozzle: float\n                thruster nozzle exhaust cone exit area\n            steadyIsp: float\n                thruster fuel efficiency in Isp (seconds)\n            MaxThrust: float\n                maximum thruster force in Newtons\n            thrusterMagDisp: float\n                thruster dispersion percentage\n            MinOnTime: float\n                thruster minimum on time\n            cutoffFrequency: float\n                frequency of first-order filter dynamics\n            swirlTorque: float\n                constant momentum from ionic thrusters\n\n        \"\"\"\n        # create the blank thruster object\n        TH = thrusterDynamicEffector.THRSimConfig()\n\n        # set default thruster values\n        TH.areaNozzle = 0.1  # [m^2]\n        TH.steadyIsp = 100  # [s]\n        TH.MaxThrust = 0.200  # [N]\n        TH.thrusterMagDisp = 0.0  # [%]\n        TH.MinOnTime = 0.020  # [s]\n        TH.cutoffFrequency = 10.0  # [rad/s]\n        TH.MaxSwirlTorque = 0.0  # [Nm]\n\n        # populate the thruster object with the type specific parameters\n        try:\n            eval('self.' + thrusterType + '(TH)')\n        except:\n            print('ERROR: Thruster type ' + thrusterType + ' is not implemented')\n            exit(1)\n\n        # set device states from the input arguments.  Note that these may override what is set in\n        # the above function call\n        if 'areaNozzle' in kwargs:\n            varAreaNozzle = kwargs['areaNozzle']\n            if not isinstance(varAreaNozzle, (float)):\n                print('ERROR: areaNozzle must be a float argument')\n                exit(1)\n            else:\n                TH.areaNozzle = varAreaNozzle\n\n        if 'steadyIsp' in kwargs:\n            varSteadyIsp = kwargs['steadyIsp']\n            if not isinstance(varSteadyIsp, (float)):\n                print('ERROR: steadyIsp must be a float argument')\n                exit(1)\n            else:\n                TH.steadyIsp = varSteadyIsp\n\n        if 'MaxThrust' in kwargs:\n            varMaxThrust = kwargs['MaxThrust']\n            if not isinstance(varMaxThrust, (float)):\n                print('ERROR: MaxThrust must be a float argument')\n                exit(1)\n            else:\n                TH.MaxThrust = varMaxThrust\n\n        if 'MaxSwirlTorque' in kwargs:\n            varMaxSwirlTorque = kwargs['MaxSwirlTorque']\n            if not isinstance(varMaxSwirlTorque, (float)):\n                print('ERROR: MaxSwirlTorque must be a float argument')\n                exit(1)\n            else:\n                TH.MaxSwirlTorque = varMaxSwirlTorque\n\n        if 'thrusterMagDisp' in kwargs:\n            varThrusterMagDisp = kwargs['thrusterMagDisp']\n            if not isinstance(varMaxThrust, (float)):\n                print('ERROR: varThrusterMagDisp must be a float argument')\n                exit(1)\n            else:\n                TH.thrusterMagDisp = varThrusterMagDisp\n\n        if 'MinOnTime' in kwargs:\n            varMinOnTime = kwargs['MinOnTime']\n            if not isinstance(varMinOnTime, (float)):\n                print('ERROR: MinOnTime must be a float argument')\n                exit(1)\n            else:\n                TH.MinOnTime = varMinOnTime\n\n        if 'cutoffFrequency' in kwargs:\n            varCutoffFrequency = kwargs['cutoffFrequency']\n            if not isinstance(varCutoffFrequency, (float)):\n                print('ERROR: cutoffFrequency must be a float argument')\n                exit(1)\n            else:\n                TH.cutoffFrequency = varCutoffFrequency\n\n        if 'useMinPulseTime' in kwargs:\n            varUseMinPulseTime = kwargs['useMinPulseTime']\n            if not isinstance(varUseMinPulseTime, (bool)):\n                print('ERROR: useMinPulseTime must be a BOOL argument')\n                exit(1)\n        else:\n            varUseMinPulseTime = False  # default value\n        if not varUseMinPulseTime:\n            TH.MinOnTime = 0.0\n\n        if 'label' in kwargs:\n            varLabel = kwargs['label']\n            if not isinstance(varLabel, (str)):\n                print('ERROR: TH label must be a string')\n                exit(1)\n            if len(varLabel) > 5:\n                print('ERROR: TH label string is longer than 5 characters')\n                exit(1)\n        else:\n            varLabel = 'TH' + str(len(self.thrusterList) + 1)  # default device labeling\n        TH.label = varLabel\n\n        # set thruster force direction axis\n        norm = numpy.linalg.norm(tHat_B)\n        if norm > 1e-10:\n            tHat_B = tHat_B / norm\n        else:\n            print(\n                'Error: Thruster ' + sys._getframe().f_code.co_name + ' direction tHat input must be non-zero 3x1 vector')\n            exit(1)\n        TH.thrDir_B = [[tHat_B[0]], [tHat_B[1]], [tHat_B[2]]]\n\n        # set thruster position vector\n        TH.thrLoc_B = [[r_B[0]], [r_B[1]], [r_B[2]]]\n\n        # add TH to the list of TH devices\n        self.thrusterList[varLabel] = TH\n        return TH\n\n    def addToSpacecraft(self, modelTag, thEffector, sc):\n        \"\"\"\n            This function should be called after all Thruster devices are created with create()\n            It creates the C-class container for the array of TH devices, and attaches\n            this container to the spacecraft object\n\n            Parameters\n            ----------\n            modelTag:  string\n                module model tag string\n            thEffector: thrusterEffector\n                thruster effector handle\n            sc: spacecraft\n        \"\"\"\n\n        thEffector.ModelTag = modelTag\n\n        for key, th in list(self.thrusterList.items()):\n            thEffector.addThruster(th)\n\n        # Check the type of thruster effector\n        thrusterType = str(type(thEffector))\n        if 'ThrusterDynamicEffector' in thrusterType:\n            sc.addDynamicEffector(thEffector)\n        elif 'ThrusterStateEffector' in thrusterType:\n            sc.addStateEffector(thEffector)\n        else:\n            print(\"This isn't a thruster effector. You did something wrong.\")\n\n        return\n\n    def getNumOfDevices(self):\n        \"\"\"\n            Returns the number of RW devices setup.\n\n        :return: number of thruster devices\n\n        \"\"\"\n        return len(self.thrusterList)\n\n    def getConfigMessage(self):\n        \"\"\"\n            Returns a FSW THRArrayConfigMsg reflecting the current thruster setup.\n\n        :return: thrMessage\n        \"\"\"\n\n        thrMessage = messaging.THRArrayConfigMsgPayload()\n\n        i = 0\n        for simThruster in self.thrusterList.values():\n            #   Converts from THRConfigSimMsg to THRConfigFswMsg\n            fswThruster = messaging.THRConfigMsgPayload()\n            fswThruster.maxThrust = simThruster.MaxThrust\n            fswThruster.rThrust_B = [val for sublist in simThruster.thrLoc_B for val in sublist]\n            fswThruster.tHatThrust_B = [val for sublist in simThruster.thrDir_B for val in sublist]\n            messaging.ThrustConfigArray_setitem(thrMessage.thrusters, i, fswThruster)\n            i += 1\n\n        thrMessage.numThrusters = len(self.thrusterList.values())\n\n        thrConfigMsg = messaging.THRArrayConfigMsg().write(thrMessage)\n        thrConfigMsg.this.disown()\n\n        return thrConfigMsg\n\n    #\n    #   MOOG Monarc-1\n    #\n    #   Information Source:\n    #   http://www.moog.com/literature/Space_Defense/Spacecraft/Propulsion/Monopropellant_Thrusters_Rev_0613.pdf\n    #   http://www.moog.com/content/dam/moog/literature/Space_Defense/Spacecraft/Monopropellant_Thrusters_Rev_0613.pdf\n    #\n    #   This is a MOOG mono-propellant thruster\n    #\n    def MOOG_Monarc_1(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 0.9\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.020\n        # Isp value [s]\n        TH.steadyIsp = 227.5\n\n        TH.areaNozzle = 0.000079  # [m^2]\n\n        return\n\n    #\n    #   MOOG Monarc-5\n    #\n    #   Information Source:\n    #   http://www.moog.com/literature/Space_Defense/Spacecraft/Propulsion/Monopropellant_Thrusters_Rev_0613.pdf\n    #   http://www.moog.com/content/dam/moog/literature/Space_Defense/Spacecraft/Monopropellant_Thrusters_Rev_0613.pdf\n    #\n    #   This is a MOOG mono-propellant thruster\n    #\n    def MOOG_Monarc_5(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 4.5\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.020\n        # Isp value [s]\n        TH.steadyIsp = 226.1\n\n        TH.areaNozzle = 0.0020  # [m^2]\n\n        return\n\n    #\n    #   MOOG Monarc-22-6\n    #\n    #   Information Source:\n    #   http://www.moog.com/literature/Space_Defense/Spacecraft/Propulsion/Monopropellant_Thrusters_Rev_0613.pdf\n    #   http://www.moog.com/content/dam/moog/literature/Space_Defense/Spacecraft/Monopropellant_Thrusters_Rev_0613.pdf\n    #\n    #   This is a MOOG mono-propellant thruster\n    #\n    def MOOG_Monarc_22_6(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 22.0\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.020\n        # Isp value [s]\n        TH.steadyIsp = 229.5\n\n        TH.areaNozzle = 0.0045  # [m^2]\n\n        return\n\n    #\n    #   MOOG Monarc-22-12\n    #\n    #   Information Source:\n    #   http://www.moog.com/literature/Space_Defense/Spacecraft/Propulsion/Monopropellant_Thrusters_Rev_0613.pdf\n    #   http://www.moog.com/content/dam/moog/literature/Space_Defense/Spacecraft/Monopropellant_Thrusters_Rev_0613.pdf\n    #\n    #   This is a MOOG mono-propellant thruster\n    #\n    def MOOG_Monarc_22_12(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 22.0\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.020\n        # Isp value [s]\n        TH.steadyIsp = 228.1\n\n        TH.areaNozzle = 0.0088  # [m^2]\n\n        return\n\n    #\n    #   MOOG Monarc-90LT\n    #\n    #   Information Source:\n    #   http://www.moog.com/literature/Space_Defense/Spacecraft/Propulsion/Monopropellant_Thrusters_Rev_0613.pdf\n    #   http://www.moog.com/content/dam/moog/literature/Space_Defense/Spacecraft/Monopropellant_Thrusters_Rev_0613.pdf\n    #\n    #   This is a MOOG mono-propellant thruster\n    #\n    def MOOG_Monarc_90LT(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 90.0\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.020\n        # Isp value [s]\n        TH.steadyIsp = 232.1\n\n        TH.areaNozzle = 0.0222  # [m^2]\n\n        return\n\n    #\n    #   MOOG Monarc-90HT\n    #\n    #   Information Source:\n    #   http://www.moog.com/literature/Space_Defense/Spacecraft/Propulsion/Monopropellant_Thrusters_Rev_0613.pdf\n    #   http://www.moog.com/content/dam/moog/literature/Space_Defense/Spacecraft/Monopropellant_Thrusters_Rev_0613.pdf\n    #   This is a MOOG mono-propellant thruster\n    #\n    def MOOG_Monarc_90HT(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 116.0\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.010\n        # Isp value [s]\n        TH.steadyIsp = 234.0\n\n        TH.areaNozzle = 0.0222  # [m^2]\n\n        return\n\n    #\n    #   MOOG Monarc-445\n    #\n    #   Information Source:\n    #   http://www.moog.com/literature/Space_Defense/Spacecraft/Propulsion/Monopropellant_Thrusters_Rev_0613.pdf\n    #   http://www.moog.com/content/dam/moog/literature/Space_Defense/Spacecraft/Monopropellant_Thrusters_Rev_0613.pdf\n    #\n    #   This is a MOOG mono-propellant thruster\n    #\n    def MOOG_Monarc_445(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 445.0\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.025\n        # Isp value [s]\n        TH.steadyIsp = 234.0\n\n        TH.areaNozzle = 0.06881  # [m^2]\n\n        return\n\n    def SEP(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 0.030\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.025\n        # Isp value [s]\n        TH.steadyIsp = 3000.0\n        # maximum swirl torque [Nm]\n        TH.MaxSwirlTorque = 0.05\n\n        TH.areaNozzle = 0.06881  # [m^2]\n\n        return\n\n    def TEST_Thruster(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 0.9\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.020\n        # Isp value [s]\n        TH.steadyIsp = 227.5\n        # nozzle area [m^2]\n        TH.areaNozzle = 0.07\n\n        return\n\n    def Blank_Thruster(self, TH):\n        # this method doesn't set any thruster properties.  Rather, it is assumed that all thruster\n        # properties are defined explicitly in the create function, or external to the create function\n\n        return",
  "def __init__(self):\n        self.useMinPulseTime = True\n        self.thrusterList = OrderedDict()",
  "def create(self, thrusterType, r_B, tHat_B, **kwargs):\n        \"\"\"\n        This function is called to setup a thruster device in python, and adds it to the of thruster\n        factory in ``thrusterList{}``.  The function returns a copy of the device that can be changed if needed.\n        The first 3 arguments are required, the remaining arguments are optional with:\n\n        Parameters\n        ----------\n        thrusterType : string\n                thruster manufacturing name.:\n        r_B : list\n                vector with thruster location in B-frame components:\n        tHat_B : list\n                vector with thruster force direction unit vector:\n        kwargs:\n            useMinPulseTime: BOOL\n                flag if the thruster model should use a minimum impulse time\n            areaNozzle: float\n                thruster nozzle exhaust cone exit area\n            steadyIsp: float\n                thruster fuel efficiency in Isp (seconds)\n            MaxThrust: float\n                maximum thruster force in Newtons\n            thrusterMagDisp: float\n                thruster dispersion percentage\n            MinOnTime: float\n                thruster minimum on time\n            cutoffFrequency: float\n                frequency of first-order filter dynamics\n            swirlTorque: float\n                constant momentum from ionic thrusters\n\n        \"\"\"\n        # create the blank thruster object\n        TH = thrusterDynamicEffector.THRSimConfig()\n\n        # set default thruster values\n        TH.areaNozzle = 0.1  # [m^2]\n        TH.steadyIsp = 100  # [s]\n        TH.MaxThrust = 0.200  # [N]\n        TH.thrusterMagDisp = 0.0  # [%]\n        TH.MinOnTime = 0.020  # [s]\n        TH.cutoffFrequency = 10.0  # [rad/s]\n        TH.MaxSwirlTorque = 0.0  # [Nm]\n\n        # populate the thruster object with the type specific parameters\n        try:\n            eval('self.' + thrusterType + '(TH)')\n        except:\n            print('ERROR: Thruster type ' + thrusterType + ' is not implemented')\n            exit(1)\n\n        # set device states from the input arguments.  Note that these may override what is set in\n        # the above function call\n        if 'areaNozzle' in kwargs:\n            varAreaNozzle = kwargs['areaNozzle']\n            if not isinstance(varAreaNozzle, (float)):\n                print('ERROR: areaNozzle must be a float argument')\n                exit(1)\n            else:\n                TH.areaNozzle = varAreaNozzle\n\n        if 'steadyIsp' in kwargs:\n            varSteadyIsp = kwargs['steadyIsp']\n            if not isinstance(varSteadyIsp, (float)):\n                print('ERROR: steadyIsp must be a float argument')\n                exit(1)\n            else:\n                TH.steadyIsp = varSteadyIsp\n\n        if 'MaxThrust' in kwargs:\n            varMaxThrust = kwargs['MaxThrust']\n            if not isinstance(varMaxThrust, (float)):\n                print('ERROR: MaxThrust must be a float argument')\n                exit(1)\n            else:\n                TH.MaxThrust = varMaxThrust\n\n        if 'MaxSwirlTorque' in kwargs:\n            varMaxSwirlTorque = kwargs['MaxSwirlTorque']\n            if not isinstance(varMaxSwirlTorque, (float)):\n                print('ERROR: MaxSwirlTorque must be a float argument')\n                exit(1)\n            else:\n                TH.MaxSwirlTorque = varMaxSwirlTorque\n\n        if 'thrusterMagDisp' in kwargs:\n            varThrusterMagDisp = kwargs['thrusterMagDisp']\n            if not isinstance(varMaxThrust, (float)):\n                print('ERROR: varThrusterMagDisp must be a float argument')\n                exit(1)\n            else:\n                TH.thrusterMagDisp = varThrusterMagDisp\n\n        if 'MinOnTime' in kwargs:\n            varMinOnTime = kwargs['MinOnTime']\n            if not isinstance(varMinOnTime, (float)):\n                print('ERROR: MinOnTime must be a float argument')\n                exit(1)\n            else:\n                TH.MinOnTime = varMinOnTime\n\n        if 'cutoffFrequency' in kwargs:\n            varCutoffFrequency = kwargs['cutoffFrequency']\n            if not isinstance(varCutoffFrequency, (float)):\n                print('ERROR: cutoffFrequency must be a float argument')\n                exit(1)\n            else:\n                TH.cutoffFrequency = varCutoffFrequency\n\n        if 'useMinPulseTime' in kwargs:\n            varUseMinPulseTime = kwargs['useMinPulseTime']\n            if not isinstance(varUseMinPulseTime, (bool)):\n                print('ERROR: useMinPulseTime must be a BOOL argument')\n                exit(1)\n        else:\n            varUseMinPulseTime = False  # default value\n        if not varUseMinPulseTime:\n            TH.MinOnTime = 0.0\n\n        if 'label' in kwargs:\n            varLabel = kwargs['label']\n            if not isinstance(varLabel, (str)):\n                print('ERROR: TH label must be a string')\n                exit(1)\n            if len(varLabel) > 5:\n                print('ERROR: TH label string is longer than 5 characters')\n                exit(1)\n        else:\n            varLabel = 'TH' + str(len(self.thrusterList) + 1)  # default device labeling\n        TH.label = varLabel\n\n        # set thruster force direction axis\n        norm = numpy.linalg.norm(tHat_B)\n        if norm > 1e-10:\n            tHat_B = tHat_B / norm\n        else:\n            print(\n                'Error: Thruster ' + sys._getframe().f_code.co_name + ' direction tHat input must be non-zero 3x1 vector')\n            exit(1)\n        TH.thrDir_B = [[tHat_B[0]], [tHat_B[1]], [tHat_B[2]]]\n\n        # set thruster position vector\n        TH.thrLoc_B = [[r_B[0]], [r_B[1]], [r_B[2]]]\n\n        # add TH to the list of TH devices\n        self.thrusterList[varLabel] = TH\n        return TH",
  "def addToSpacecraft(self, modelTag, thEffector, sc):\n        \"\"\"\n            This function should be called after all Thruster devices are created with create()\n            It creates the C-class container for the array of TH devices, and attaches\n            this container to the spacecraft object\n\n            Parameters\n            ----------\n            modelTag:  string\n                module model tag string\n            thEffector: thrusterEffector\n                thruster effector handle\n            sc: spacecraft\n        \"\"\"\n\n        thEffector.ModelTag = modelTag\n\n        for key, th in list(self.thrusterList.items()):\n            thEffector.addThruster(th)\n\n        # Check the type of thruster effector\n        thrusterType = str(type(thEffector))\n        if 'ThrusterDynamicEffector' in thrusterType:\n            sc.addDynamicEffector(thEffector)\n        elif 'ThrusterStateEffector' in thrusterType:\n            sc.addStateEffector(thEffector)\n        else:\n            print(\"This isn't a thruster effector. You did something wrong.\")\n\n        return",
  "def getNumOfDevices(self):\n        \"\"\"\n            Returns the number of RW devices setup.\n\n        :return: number of thruster devices\n\n        \"\"\"\n        return len(self.thrusterList)",
  "def getConfigMessage(self):\n        \"\"\"\n            Returns a FSW THRArrayConfigMsg reflecting the current thruster setup.\n\n        :return: thrMessage\n        \"\"\"\n\n        thrMessage = messaging.THRArrayConfigMsgPayload()\n\n        i = 0\n        for simThruster in self.thrusterList.values():\n            #   Converts from THRConfigSimMsg to THRConfigFswMsg\n            fswThruster = messaging.THRConfigMsgPayload()\n            fswThruster.maxThrust = simThruster.MaxThrust\n            fswThruster.rThrust_B = [val for sublist in simThruster.thrLoc_B for val in sublist]\n            fswThruster.tHatThrust_B = [val for sublist in simThruster.thrDir_B for val in sublist]\n            messaging.ThrustConfigArray_setitem(thrMessage.thrusters, i, fswThruster)\n            i += 1\n\n        thrMessage.numThrusters = len(self.thrusterList.values())\n\n        thrConfigMsg = messaging.THRArrayConfigMsg().write(thrMessage)\n        thrConfigMsg.this.disown()\n\n        return thrConfigMsg",
  "def MOOG_Monarc_1(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 0.9\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.020\n        # Isp value [s]\n        TH.steadyIsp = 227.5\n\n        TH.areaNozzle = 0.000079  # [m^2]\n\n        return",
  "def MOOG_Monarc_5(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 4.5\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.020\n        # Isp value [s]\n        TH.steadyIsp = 226.1\n\n        TH.areaNozzle = 0.0020  # [m^2]\n\n        return",
  "def MOOG_Monarc_22_6(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 22.0\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.020\n        # Isp value [s]\n        TH.steadyIsp = 229.5\n\n        TH.areaNozzle = 0.0045  # [m^2]\n\n        return",
  "def MOOG_Monarc_22_12(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 22.0\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.020\n        # Isp value [s]\n        TH.steadyIsp = 228.1\n\n        TH.areaNozzle = 0.0088  # [m^2]\n\n        return",
  "def MOOG_Monarc_90LT(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 90.0\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.020\n        # Isp value [s]\n        TH.steadyIsp = 232.1\n\n        TH.areaNozzle = 0.0222  # [m^2]\n\n        return",
  "def MOOG_Monarc_90HT(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 116.0\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.010\n        # Isp value [s]\n        TH.steadyIsp = 234.0\n\n        TH.areaNozzle = 0.0222  # [m^2]\n\n        return",
  "def MOOG_Monarc_445(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 445.0\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.025\n        # Isp value [s]\n        TH.steadyIsp = 234.0\n\n        TH.areaNozzle = 0.06881  # [m^2]\n\n        return",
  "def SEP(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 0.030\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.025\n        # Isp value [s]\n        TH.steadyIsp = 3000.0\n        # maximum swirl torque [Nm]\n        TH.MaxSwirlTorque = 0.05\n\n        TH.areaNozzle = 0.06881  # [m^2]\n\n        return",
  "def TEST_Thruster(self, TH):\n        # maximum thrust [N]\n        TH.MaxThrust = 0.9\n        # minimum thruster on time [s]\n        TH.MinOnTime = 0.020\n        # Isp value [s]\n        TH.steadyIsp = 227.5\n        # nozzle area [m^2]\n        TH.areaNozzle = 0.07\n\n        return",
  "def Blank_Thruster(self, TH):\n        # this method doesn't set any thruster properties.  Rather, it is assumed that all thruster\n        # properties are defined explicitly in the create function, or external to the create function\n\n        return",
  "def readAtmTable(filename,typename):\n    if typename.lower() == 'earthgram':\n        altList, rhoList, tempList = readEarthGRAM(filename)\n    elif typename.lower() == 'stdatm76':\n        altList, rhoList, tempList = readStdAtm76(filename)\n    elif typename.lower() == 'msis':\n        altList, rhoList, tempList = readMSIS(filename)\n    elif typename.lower() == 'marsgram':\n        altList, rhoList, tempList = readMarsGRAM(filename)\n    elif typename.lower() == 'venusgram':\n        altList, rhoList, tempList = readVenusGRAM(filename)\n    elif typename.lower() == 'uranusgram':\n        altList, rhoList, tempList = readUranusGRAM(filename)\n    elif typename.lower() == 'titangram':\n        altList, rhoList, tempList = readTitanGRAM(filename)\n    elif typename.lower() == 'jupitergram':\n        altList, rhoList, tempList = readJupiterGRAM(filename)\n    else:\n        print('Type not recognized')\n        return np.NaN, np.NaN, np.NaN\n    \n    return altList, rhoList, tempList",
  "def readStdAtm76(filename):\n    df = pd.read_csv(filename, skiprows=[1])\n    df.sort_values(by=['Altitude'], ascending = True, inplace=True)\n    altList = df.Altitude.to_list()\n    tempList = df.Temperature.to_list()\n    rhoList = df.Density.to_list()\n    return altList, rhoList, tempList",
  "def readEarthGRAM(filename):\n    df = pd.read_csv(filename, delim_whitespace = True) \n    df.sort_values(by=['Hgtkm'],ascending=True, inplace=True)\n    df.Hgtkm = df.Hgtkm * 1000\n    altList = df.Hgtkm.to_list()\n    rhoList = df.DensMean.to_list()\n    tempList = df.Tmean.to_list()\n    \n    return altList, rhoList, tempList",
  "def readMarsGRAM(filename):\n\tdf = pd.read_csv(filename, delim_whitespace = True)\n\tdf.sort_values(by=['HgtMOLA'],ascending=True, inplace=True)\n\tdf.HgtMOLA = df.HgtMOLA * 1000\n\taltList = df.HgtMOLA.to_list()\n\trhoList = df.Denkgm3.to_list()\n\ttempList = df.Temp.to_list()\n\n\treturn altList, rhoList, tempList",
  "def readVenusGRAM(filename):\n\tdf = pd.read_csv(filename, skiprows=[1])\n\tdf.sort_values(by=['Height_km'],ascending=True, inplace=True)\n\tdf.Height_km = df.Height_km * 1000\n\taltList = df.Height_km.to_list()\n\trhoList = df.Density_kgm3.to_list()\n\ttempList = df.Temperature_K.to_list()\n\n\treturn altList, rhoList, tempList",
  "def readUranusGRAM(filename):\n\tdf = pd.read_csv(filename, skiprows=[1])\n\tdf.sort_values(by=['Height_km'],ascending=True, inplace=True)\n\tdf.Height_km = df.Height_km * 1000\n\taltList = df.Height_km.to_list()\n\trhoList = df.Density_kgm3.to_list()\n\ttempList = df.Temperature_K.to_list()\n\n\treturn altList, rhoList, tempList",
  "def readTitanGRAM(filename):\n\tdf = pd.read_csv(filename, skiprows=[1])\n\tdf.sort_values(by=['Height_km'],ascending=True, inplace=True)\n\tdf.Height_km = df.Height_km * 1000\n\taltList = df.Height_km.to_list()\n\trhoList = df.Density_kgm3.to_list()\n\ttempList = df.Temperature_K.to_list()\n\n\treturn altList, rhoList, tempList",
  "def readJupiterGRAM(filename):\n\tdf = pd.read_csv(filename, skiprows=[1])\n\tdf.sort_values(by=['Height_km'],ascending=True, inplace=True)\n\tdf.Height_km = df.Height_km * 1000\n\taltList = df.Height_km.to_list()\n\trhoList = df.Density_kgm3.to_list()\n\ttempList = df.Temperature_K.to_list()\n\n\treturn altList, rhoList, tempList",
  "def readMSIS(filename):\n    df = pd.read_csv(filename, skiprows = 29, header=0,delim_whitespace = True,\n                   names=[\"alt\", \"rho\", \"temp\"])\n    df.sort_values(by=['alt'],ascending=True, inplace=True)\n    df.alt = df.alt * 1000\n    altList = df.alt.to_list()\n    df.rho = df.rho / 1000 * 100**3 \n    rhoList = df.rho.to_list()\n    tempList = df.temp.to_list()\n \t\n    return altList, rhoList, tempList",
  "def planetPositionVelocity(planetName, time, ephemerisPath = '/supportData/EphemerisData/pck00010.tpc', observer = 'SSB', frame = 'J2000'):\n    \"\"\"\n        A convenience function to get planet position from spice\n\n        Parameters\n        ----------\n        planetName : name of planet to get position of\n            planet name must be a valid SPICE celestial body string.\n        time : UTC time as string\n        ephemerisPath : a string path to ephemeris file if something other than the default is desired\n        observer : observer to get vectors relative to\n\n        Returns\n        -------\n        position and velocity vector of planet in Solar System Barycenter inertial frame as lists [m], [m/s]\n    \"\"\"\n\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/de430.bsp')\n    pyswice.furnsh_c(bskPath + '/supportData/EphemerisData/naif0012.tls') #load leap seconds\n    pyswice.furnsh_c(bskPath + ephemerisPath)\n    positionVelocity = spkRead(planetName, time, frame, observer)\n    position = positionVelocity[0:3] * 1000\n    velocity = positionVelocity[3:6] * 1000\n    pyswice.unload_c(bskPath + ephemerisPath)\n\n    return position, velocity",
  "def toRGBA255(color, alpha=None):\n    answer = [0, 0, 0, 0]\n    if isinstance(color, str):\n        # convert color name to 4D array of values with 0-255\n        if is_color_like(color):\n\n            answer = np.array(colors.to_rgba(color, alpha=alpha)) * 255\n            answer = [round(a) for a in answer]\n        else:\n            print(\"toRGBA255() was provided unknown color name \" + color)\n            exit(1)\n    else:\n        if not isinstance(color, list):\n            print('ERROR: vizSupport: color must be a 4D array of integers')\n            exit(1)\n        if max(color) > 255 or min(color) < 0:\n            print('ERROR: vizSupport: color values must be between [0,255]')\n            exit(1)\n        answer = color\n    return answer",
  "def setSprite(shape, **kwargs):\n    \"\"\"\n    Helper function to set the sprite shape and optional sprite color.\n    :param shape: Sprite shape, must be either \"CIRCLE\", \"SQUARE\", \"TRIANGLE\", \"STAR\", or \"bskSat\"\n    :param kwargs: RGBA color, can be either color name string or a 4D list of [0,255] values\n    :return: string of the protobuffer sprite setting\n    \"\"\"\n    unitTestSupport.checkMethodKeyword(\n        ['color'],\n        kwargs)\n    shapeList = [\"CIRCLE\", \"SQUARE\", \"TRIANGLE\", \"STAR\", \"bskSat\"]\n\n    if not isinstance(shape, str):\n        print(\"In setSprite() the shape argument must be a string using \" + str(shapeList))\n        exit(1)\n\n    if (shape not in shapeList):\n        print(\"The setSprite() method was provided this unknown sprite shape primitive: \" + shape)\n        exit(1)\n\n    answer = shape\n\n    if 'color' in kwargs:\n        colorInfo = kwargs['color']\n\n        if shape == \"bskSat\":\n            print(\"cannot set a color for the bskSat sprite option\")\n            exit(1)\n\n        colorValues = toRGBA255(colorInfo)\n\n        answer += \" \" + \" \".join(map(str, colorValues))\n\n    return answer",
  "def addLocation(viz, **kwargs):\n    if not vizFound:\n        print('vizFound is false. Skipping this method.')\n        return\n\n    vizElement = vizInterface.LocationPbMsg()\n\n    unitTestSupport.checkMethodKeyword(\n        ['stationName', 'parentBodyName', 'r_GP_P', 'gHat_P', 'fieldOfView', 'color', 'range'],\n        kwargs)\n\n    if 'stationName' in kwargs:\n        stationName = kwargs['stationName']\n        if not isinstance(stationName, str):\n            print('ERROR: stationName must be a string')\n            exit(1)\n        vizElement.stationName = stationName\n    else:\n        print(\"ERROR: stationName argument must be provided to addLocation\")\n        exit(0)\n\n    if 'parentBodyName' in kwargs:\n        parentBodyName = kwargs['parentBodyName']\n        if not isinstance(parentBodyName, str):\n            print('ERROR: parentBodyName must be a string')\n            exit(1)\n        vizElement.parentBodyName = parentBodyName\n    else:\n        print(\"ERROR: parentBodyName argument must be provided to addLocation\")\n        exit(1)\n\n    r_GP_P = [0, 0, 0]\n    if 'r_GP_P' in kwargs:\n        r_GP_P = kwargs['r_GP_P']\n        if not isinstance(r_GP_P, list):\n            print('ERROR: r_GP_P must be a list of floats')\n            print(r_GP_P)\n            exit(1)\n        if len(r_GP_P) != 3:\n            print('ERROR: r_GP_P must be list of three floats')\n            exit(1)\n        try:\n            # check if vector is a list\n            vizElement.r_GP_P = r_GP_P\n        except:\n            try:\n                # convert Eigen array to list\n                vizElement.r_GP_P = unitTestSupport.EigenVector3d2np(r_GP_P).tolist()\n            except:\n                pass\n    else:\n        print(\"ERROR: r_GP_P argument must be provided to addLocation\")\n        exit(0)\n\n    if 'gHat_P' in kwargs:\n        gHat_P = kwargs['gHat_P']\n        if not isinstance(gHat_P, list):\n            print('ERROR: gHat_P must be a list of three floats')\n            exit(1)\n        if len(gHat_P) != 3:\n            print('ERROR: gHat_P must be list of three floats')\n            exit(1)\n        vizElement.gHat_P = gHat_P\n    else:\n        vizElement.gHat_P = r_GP_P / np.linalg.norm(r_GP_P)\n\n    if 'fieldOfView' in kwargs:\n        fieldOfView = kwargs['fieldOfView']\n        if not isinstance(fieldOfView, float):\n            print('ERROR: fieldOfView must be a float value in radians')\n            exit(1)\n        if fieldOfView > np.pi or fieldOfView < 0.0:\n            print('ERROR: fieldOfView must be a value between 0 and Pi')\n            exit(1)\n        vizElement.fieldOfView = fieldOfView\n\n    if 'color' in kwargs:\n        color = kwargs['color']\n        vizElement.color = toRGBA255(color)\n\n    if 'range' in kwargs:\n        range = kwargs['range']\n        if not isinstance(range, float):\n            print('ERROR: range must be a float')\n            exit(1)\n        vizElement.range = range\n\n    locationList.append(vizElement)\n    del viz.locations[:]  # clear settings list to replace it with updated list\n    viz.locations = vizInterface.LocationConfig(locationList)\n\n    return",
  "def createPointLine(viz, **kwargs):\n    if not vizFound:\n        print('vizFound is false. Skipping this method.')\n        return\n    global firstSpacecraftName\n    vizElement = vizInterface.PointLine()\n\n    unitTestSupport.checkMethodKeyword(\n        ['fromBodyName', 'toBodyName', 'lineColor'],\n        kwargs)\n\n    if 'fromBodyName' in kwargs:\n        fromName = kwargs['fromBodyName']\n        if not isinstance(fromName, str):\n            print('ERROR: vizSupport: fromBodyName must be a string')\n            exit(1)\n        vizElement.fromBodyName = fromName\n    else:\n        vizElement.fromBodyName = firstSpacecraftName\n\n    if 'toBodyName' in kwargs:\n        toName = kwargs['toBodyName']\n        if not isinstance(toName, str):\n            print('ERROR: vizSupport: toBodyName must be a string')\n            exit(1)\n        vizElement.toBodyName = toName\n    else:\n        print('ERROR: vizSupport: toBodyName must be a specified')\n        exit(1)\n\n    if 'lineColor' in kwargs:\n        vizElement.lineColor = toRGBA255(kwargs['lineColor'])\n    else:\n        print('ERROR: vizSupport: lineColor must be a specified')\n        exit(1)\n\n    pointLineList.append(vizElement)\n    del viz.settings.pointLineList[:]  # clear settings list to replace it with updated list\n    viz.settings.pointLineList = vizInterface.PointLineConfig(pointLineList)\n    return",
  "def createTargetLine(viz, **kwargs):\n    if not vizFound:\n        print('vizFound is false. Skipping this method.')\n        return\n    global firstSpacecraftName\n    vizElement = vizInterface.PointLine()\n\n    unitTestSupport.checkMethodKeyword(\n        ['fromBodyName', 'toBodyName', 'lineColor'],\n        kwargs)\n\n    if 'fromBodyName' in kwargs:\n        fromName = kwargs['fromBodyName']\n        if not isinstance(fromName, str):\n            print('ERROR: vizSupport: fromBodyName must be a string')\n            exit(1)\n        vizElement.fromBodyName = fromName\n    else:\n        vizElement.fromBodyName = firstSpacecraftName\n\n    if 'toBodyName' in kwargs:\n        toName = kwargs['toBodyName']\n        if not isinstance(toName, str):\n            print('ERROR: vizSupport: toBodyName must be a string')\n            exit(1)\n        vizElement.toBodyName = toName\n    else:\n        print('ERROR: vizSupport: toBodyName must be a specified')\n        exit(1)\n\n    if 'lineColor' in kwargs:\n        vizElement.lineColor = toRGBA255(kwargs['lineColor'])\n    else:\n        print('ERROR: vizSupport: lineColor must be a specified')\n        exit(1)\n\n    targetLineList.append(vizElement)\n    updateTargetLineList(viz)\n    return",
  "def updateTargetLineList(viz):\n    del viz.liveSettings.targetLineList[:]  # clear settings list to replace it with updated list\n    viz.liveSettings.targetLineList = vizInterface.PointLineConfig(targetLineList)\n    return",
  "def createCustomModel(viz, **kwargs):\n    if not vizFound:\n        print('vizFound is false. Skipping this method.')\n        return\n    global firstSpacecraftName\n    vizElement = vizInterface.CustomModel()\n\n    unitTestSupport.checkMethodKeyword(\n        ['modelPath', 'simBodiesToModify', 'offset', 'rotation', 'scale', 'customTexturePath',\n         'normalMapPath', 'shader', 'color'],\n        kwargs)\n\n    if 'modelPath' in kwargs:\n        modelPathName = kwargs['modelPath']\n        if not isinstance(modelPathName, str):\n            print('ERROR: vizSupport: modelPath must be a string')\n            exit(1)\n        if len(modelPathName) == 0:\n            print('ERROR: vizSupport: modelPath is required and must be specified.')\n            exit(1)\n        vizElement.modelPath = modelPathName\n    else:\n        print('ERROR: vizSupport: modelPath is required and must be specified.')\n        exit(1)\n\n    if 'simBodiesToModify' in kwargs:\n        simBodiesList = kwargs['simBodiesToModify']\n        if not isinstance(simBodiesList, list):\n            print('ERROR: vizSupport: simBodiesToModify must be a list of strings')\n            exit(1)\n        if len(simBodiesList) == 0:\n            print('ERROR: vizSupport: simBodiesToModify must be a non-empty list of strings')\n            exit(1)\n        for item in simBodiesList:\n            if not isinstance(item, str):\n                print('ERROR: vizSupport: the simBody name must be a string, not ' + str(item))\n                exit(1)\n        vizElement.simBodiesToModify = vizInterface.StringVector(simBodiesList)\n    else:\n        vizElement.simBodiesToModify = vizInterface.StringVector([firstSpacecraftName])\n\n    if 'offset' in kwargs:\n        offsetVariable = kwargs['offset']\n        if not isinstance(offsetVariable, list):\n            print('ERROR: vizSupport: offset must be a list of three floats')\n            exit(1)\n        if len(offsetVariable) != 3:\n            print('ERROR: vizSupport: offset must be list of three floats')\n            exit(1)\n        vizElement.offset = offsetVariable\n    else:\n        vizElement.offset = [0.0, 0.0, 0.0]\n\n    if 'rotation' in kwargs:\n        rotationVariable = kwargs['rotation']\n        if not isinstance(rotationVariable, list):\n            print('ERROR: vizSupport: rotation must be a list of three floats')\n            exit(1)\n        if len(rotationVariable) != 3:\n            print('ERROR: vizSupport: rotation must be list of three floats')\n            exit(1)\n        vizElement.rotation = rotationVariable\n    else:\n        vizElement.rotation = [0.0, 0.0, 0.0]\n\n    if 'scale' in kwargs:\n        scaleVariable = kwargs['scale']\n        if not isinstance(scaleVariable, list):\n            print('ERROR: vizSupport: scale must be a list of three floats')\n            exit(1)\n        if len(scaleVariable) != 3:\n            print('ERROR: vizSupport: scale must be list of three floats')\n            exit(1)\n        vizElement.scale = scaleVariable\n    else:\n        vizElement.scale = [1.0, 1.0, 1.0]\n\n    if 'customTexturePath' in kwargs:\n        customTexturePathName = kwargs['customTexturePath']\n        if not isinstance(customTexturePathName, str):\n            print('ERROR: vizSupport: customTexturePath must be a string')\n            exit(1)\n        vizElement.customTexturePath = customTexturePathName\n    else:\n        vizElement.customTexturePath = \"\"\n\n    if 'normalMapPath' in kwargs:\n        normalMapPathName = kwargs['normalMapPath']\n        if not isinstance(normalMapPathName, str):\n            print('ERROR: vizSupport: normalMapPath must be a string')\n            exit(1)\n        vizElement.normalMapPath = normalMapPathName\n    else:\n        vizElement.normalMapPath = \"\"\n\n    if 'shader' in kwargs:\n        shaderVariable = kwargs['shader']\n        if not isinstance(shaderVariable, int):\n            print('ERROR: vizSupport: shader must be a an integer.')\n            exit(1)\n        if abs(shaderVariable) > 1:\n            print('ERROR: vizSupport: shader must have a value of -1, 0 or +1.')\n            exit(1)\n\n        vizElement.shader = shaderVariable\n\n    if 'color' in kwargs:\n        colorVariable = kwargs['color']\n        if not isinstance(colorVariable, list):\n            print('ERROR: vizSupport: color must be a list of 4 integers')\n            exit(1)\n        if len(colorVariable) != 4:\n            print('ERROR: vizSupport: offset must be list of 4 integers')\n            exit(1)\n        vizElement.color = vizInterface.IntVector(colorVariable)\n\n    customModelList.append(vizElement)\n    del viz.settings.customModelList[:]  # clear settings list to replace it with updated list\n    viz.settings.customModelList = vizInterface.CustomModelConfig(customModelList)\n    return",
  "def setActuatorGuiSetting(viz, **kwargs):\n    \"\"\"\n    This method sets the actuator GUI properties for a particular spacecraft.  If no ``spacecraftName`` is\n    provided, then the name of the first spacecraft in the simulation is assumed.\n\n    :param viz: copy of the vizInterface module\n    :param kwargs: list of keyword arguments that this method supports\n    :return: void\n\n    Keyword Args\n    ------------\n    spacecraftName: str\n        The name of the spacecraft for which the actuator GUI options are set.\n        Default: If not provided, then the name of the first spacecraft in the simulation is used.\n    viewThrusterPanel: bool\n        flag if the GUI panel should be shown illustrating the thruster states\n        Default: if not provided, then the Vizard default settings are used\n    viewRWPanel: bool\n        flag if the GUI panel should be shown illustrating the reaction wheel states\n        Default: if not provided, then the Vizard default settings are used\n    viewThrusterHUD: bool\n        flag if the HUD visualization of the thruster states should be shown\n        Default: if not provided, then the Vizard default settings are used\n    viewRWHUD: bool\n        flag if the HUD visualization of the reaction wheel states should be shown\n        Default: if not provided, then the Vizard default settings are used\n    showThrusterLabels: bool\n        flag if the thruster labels should be shown\n        Default: if not provided, then the Vizard default settings are used\n    showRWLabels: bool\n        flag if the reaction wheel labels should be shown\n        Default: if not provided, then the Vizard default settings are used\n\n    \"\"\"\n    if not vizFound:\n        print('vizFound is false. Skipping this method.')\n        return\n\n    global firstSpacecraftName\n    vizElement = vizInterface.ActuatorGuiSettings()\n\n    unitTestSupport.checkMethodKeyword(\n        ['spacecraftName', 'viewThrusterPanel', 'viewThrusterHUD', 'viewRWPanel', 'viewRWHUD',\n         'showThrusterLabels', 'showRWLabels'],\n        kwargs)\n\n    if 'spacecraftName' in kwargs:\n        scName = kwargs['spacecraftName']\n        if not isinstance(scName, str):\n            print('ERROR: vizSupport: spacecraftName must be a string')\n            exit(1)\n        vizElement.spacecraftName = scName\n    else:\n        vizElement.spacecraftName = firstSpacecraftName\n\n    if 'viewThrusterPanel' in kwargs:\n        setting = kwargs['viewThrusterPanel']\n        if not isinstance(setting, bool):\n            print('ERROR: vizSupport: viewThrusterPanel must be True or False')\n            exit(1)\n        vizElement.viewThrusterPanel = setting\n\n    if 'viewThrusterHUD' in kwargs:\n        setting = kwargs['viewThrusterHUD']\n        if not isinstance(setting, bool):\n            print('ERROR: vizSupport: viewThrusterHUD must be True or False')\n            exit(1)\n        vizElement.viewThrusterHUD = setting\n\n    if 'viewRWPanel' in kwargs:\n        setting = kwargs['viewRWPanel']\n        if not isinstance(setting, bool):\n            print('ERROR: vizSupport: viewRWPanel must be True or False')\n            exit(1)\n        vizElement.viewRWPanel = setting\n\n    if 'viewRWHUD' in kwargs:\n        setting = kwargs['viewRWHUD']\n        if not isinstance(setting, bool):\n            print('ERROR: vizSupport: viewRWHUD must be True or False')\n            exit(1)\n        vizElement.viewRWHUD = setting\n\n    if 'showThrusterLabels' in kwargs:\n        setting = kwargs['showThrusterLabels']\n        if not isinstance(setting, bool):\n            print('ERROR: vizSupport: showThrusterLabels must be True or False')\n            exit(1)\n        vizElement.showThrusterLabels = setting\n\n    if 'showRWLabels' in kwargs:\n        setting = kwargs['showRWLabels']\n        if not isinstance(setting, bool):\n            print('ERROR: vizSupport: showRWLabels must be an True or False')\n            exit(1)\n        vizElement.showRWLabels = setting\n\n    actuatorGuiSettingList.append(vizElement)\n    del viz.settings.actuatorGuiSettingsList[:]  # clear settings list to replace it with updated list\n    viz.settings.actuatorGuiSettingsList = vizInterface.ActuatorGuiSettingsConfig(actuatorGuiSettingList)\n    return",
  "def setInstrumentGuiSetting(viz, **kwargs):\n    \"\"\"\n    This method sets the instrument GUI properties for a particular spacecraft.  If no ``spacecraftName`` is\n    provided, then the name of the first spacecraft in the simulation is assumed.\n\n    :param viz: copy of the vizInterface module\n    :param kwargs: list of keyword arguments that this method supports\n    :return: void\n\n    Keyword Args\n    ------------\n    spacecraftName: str\n        The name of the spacecraft for which the actuator GUI options are set.\n        Default: 0 - If not provided, then the name of the first spacecraft in the simulation is used.\n    viewCSSPanel: int\n        flag if the GUI panel should be shown (1) or hidden (-1) illustrating the CSS states\n        Default: 0 - if not provided, then the Vizard default settings are used\n    viewCSSCoverage: int\n        flag if the HUD spherical coverage of the CSS states should be shown (1) or hidden (-1)\n        Default: 0 - if not provided, then the Vizard default settings are used\n    viewCSSBoresight: int\n        flag if the HUD boresight axes of the CSS states should be shown (1) or hidden (-1)\n        Default: 0 - if not provided, then the Vizard default settings are used\n    showCSSLabels: int\n        flag if the CSS labels should be shown (1) or hidden (-1)\n        Default: 0 - if not provided, then the Vizard default settings are used\n    showGenericSensorLabels: int\n        flag if the generic sensor labels should be shown (1) or hidden (-1)\n        Default: 0 - if not provided, then the Vizard default settings are used\n    showTransceiverLabels: int\n        flag if the generic sensor labels should be shown (1) or hidden (-1)\n        Default: 0 - if not provided, then the Vizard default settings are used\n    showTransceiverFrustrum: int\n        flag if the generic sensor labels should be shown (1) or hidden (-1)\n        Default: 0 - if not provided, then the Vizard default settings are used\n    showGenericStoragePanel: int\n        flag if the generic sensor labels should be shown (1) or hidden (-1)\n        Default: 0 - if not provided, then the Vizard default settings are used\n    showMultiSphereLabels: int\n        flag if the generic sensor labels should be shown (1) or hidden (-1)\n        Default: 0 - if not provided, then the Vizard default settings are used\n    \"\"\"\n    if not vizFound:\n        print('vizFound is false. Skipping this method.')\n        return\n\n    global firstSpacecraftName\n    vizElement = vizInterface.InstrumentGuiSettings()\n\n    unitTestSupport.checkMethodKeyword(\n        ['spacecraftName', 'viewCSSPanel', 'viewCSSCoverage', 'viewCSSBoresight', 'showCSSLabels',\n         'showGenericSensorLabels', 'showTransceiverLabels', 'showTransceiverFrustrum',\n         'showGenericStoragePanel', 'showMultiSphereLabels'],\n        kwargs)\n\n    if 'spacecraftName' in kwargs:\n        scName = kwargs['spacecraftName']\n        if not isinstance(scName, str):\n            print('ERROR: vizSupport: spacecraftName must be a string')\n            exit(1)\n        vizElement.spacecraftName = scName\n    else:\n        vizElement.spacecraftName = firstSpacecraftName\n\n    if 'viewCSSPanel' in kwargs:\n        setting = kwargs['viewCSSPanel']\n        if not isinstance(setting, int):\n            print('ERROR: vizSupport: viewCSSPanel must be -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        if setting is False:\n            setting = -1\n        if setting*setting > 1:\n            print('ERROR: vizSupport: viewCSSPanel must be -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        vizElement.viewCSSPanel = setting\n        print(vizElement.viewCSSPanel)\n\n    if 'viewCSSCoverage' in kwargs:\n        setting = kwargs['viewCSSCoverage']\n        if not isinstance(setting, int):\n            print('ERROR: vizSupport: viewCSSCoverage must be  -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        if setting is False:\n            setting = -1\n        if setting*setting > 1:\n            print('ERROR: vizSupport: viewCSSPanel must be -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        vizElement.viewCSSCoverage = setting\n\n    if 'viewCSSBoresight' in kwargs:\n        setting = kwargs['viewCSSBoresight']\n        if not isinstance(setting, int):\n            print('ERROR: vizSupport: viewCSSBoresight must be  -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        if setting is False:\n            setting = -1\n        if setting*setting > 1:\n            print('ERROR: vizSupport: viewCSSPanel must be -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        vizElement.viewCSSBoresight = setting\n\n    if 'showCSSLabels' in kwargs:\n        setting = kwargs['showCSSLabels']\n        if not isinstance(setting, int):\n            print('ERROR: vizSupport: showCSSLabels must be  -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        if setting is False:\n            setting = -1\n        if setting*setting > 1:\n            print('ERROR: vizSupport: viewCSSPanel must be -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        vizElement.showCSSLabels = setting\n\n    if 'showGenericSensorLabels' in kwargs:\n        setting = kwargs['showGenericSensorLabels']\n        if not isinstance(setting, int):\n            print('ERROR: vizSupport: showGenericSensorLabels must be  -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        if setting is False:\n            setting = -1\n        if setting*setting > 1:\n            print('ERROR: vizSupport: showGenericSensorLabels must be -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        vizElement.showGenericSensorLabels = setting\n\n    if 'showTransceiverLabels' in kwargs:\n        setting = kwargs['showTransceiverLabels']\n        if not isinstance(setting, int):\n            print('ERROR: vizSupport: showTransceiverLabels must be  -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        if setting is False:\n            setting = -1\n        if setting*setting > 1:\n            print('ERROR: vizSupport: showTransceiverLabels must be -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        vizElement.showTransceiverLabels = setting\n\n    if 'showTransceiverFrustrum' in kwargs:\n        setting = kwargs['showTransceiverFrustrum']\n        if not isinstance(setting, int):\n            print('ERROR: vizSupport: showTransceiverFrustrum must be  -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        if setting is False:\n            setting = -1\n        if setting*setting > 1:\n            print('ERROR: vizSupport: showTransceiverFrustrum must be -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        vizElement.showTransceiverFrustrum = setting\n\n    if 'showGenericStoragePanel' in kwargs:\n        setting = kwargs['showGenericStoragePanel']\n        if not isinstance(setting, int):\n            print('ERROR: vizSupport: showGenericStoragePanel must be  -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        if setting is False:\n            setting = -1\n        if setting*setting > 1:\n            print('ERROR: vizSupport: showGenericStoragePanel must be -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        vizElement.showGenericStoragePanel = setting\n\n    if 'showMultiSphereLabels' in kwargs:\n        setting = kwargs['showMultiSphereLabels']\n        if not isinstance(setting, int):\n            print('ERROR: vizSupport: showMultiSphereLabels must be  -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        if setting is False:\n            setting = -1\n        if setting*setting > 1:\n            print('ERROR: vizSupport: showMultiSphereLabels must be -1 (Off), 0 (default) or 1 (On)')\n            exit(1)\n        vizElement.showMultiSphereLabels = setting\n\n    instrumentGuiSettingList.append(vizElement)\n    del viz.settings.instrumentGuiSettingsList[:]  # clear settings list to replace it with updated list\n    viz.settings.instrumentGuiSettingsList = vizInterface.InstrumentGuiSettingsConfig(instrumentGuiSettingList)\n    return",
  "def createConeInOut(viz, **kwargs):\n    if not vizFound:\n        print('vizFound is false. Skipping this method.')\n        return\n    global firstSpacecraftName\n    vizElement = vizInterface.KeepOutInCone()\n\n    unitTestSupport.checkMethodKeyword(\n        ['fromBodyName', 'toBodyName', 'coneColor', 'isKeepIn', 'position_B', 'normalVector_B',\n         'incidenceAngle', 'coneHeight', 'coneName'],\n        kwargs)\n\n    if 'fromBodyName' in kwargs:\n        fromName = kwargs['fromBodyName']\n        if not isinstance(fromName, str):\n            print('ERROR: vizSupport: fromBodyName must be a string')\n            exit(1)\n        vizElement.fromBodyName = fromName\n    else:\n        vizElement.fromBodyName = firstSpacecraftName\n\n    if 'toBodyName' in kwargs:\n        toName = kwargs['toBodyName']\n        if not isinstance(toName, str):\n            print('ERROR: vizSupport: toBodyName must be a string')\n            exit(1)\n        vizElement.toBodyName = toName\n    else:\n        print('ERROR: vizSupport: toBodyName must be a specified')\n        exit(1)\n\n    if 'coneColor' in kwargs:\n        vizElement.coneColor = toRGBA255(kwargs['coneColor'])\n    else:\n        print('ERROR: vizSupport: coneColor must be a specified')\n        exit(1)\n\n    if 'isKeepIn' in kwargs:\n        keepInFlag = kwargs['isKeepIn']\n        if not isinstance(keepInFlag, bool):\n            print('ERROR: vizSupport: isKeepIn must be a BOOL')\n            exit(1)\n        vizElement.isKeepIn = keepInFlag\n    else:\n        print('ERROR: vizSupport: isKeepIn must be a specified')\n        exit(1)\n\n    if 'position_B' in kwargs:\n        pos_B = kwargs['position_B']\n        if not isinstance(pos_B, list):\n            print('ERROR: vizSupport: position_B must be a 3D array of doubles')\n            exit(1)\n        vizElement.position_B = pos_B\n    else:\n        vizElement.position_B = [0.0, 0.0, 0.0]\n\n    if 'normalVector_B' in kwargs:\n        n_B = kwargs['normalVector_B']\n        if not isinstance(n_B, list):\n            print('ERROR: vizSupport: normalVector_B must be a 3D array of doubles')\n            exit(1)\n        vizElement.normalVector_B = n_B\n    else:\n        print('ERROR: vizSupport: normalVector_B must be a specified')\n        exit(1)\n\n    if 'incidenceAngle' in kwargs:\n        angle = kwargs['incidenceAngle']\n        if not isinstance(angle, float):\n            print('ERROR: vizSupport: incidenceAngle must be a float value in radians')\n            exit(1)\n        vizElement.incidenceAngle = angle\n    else:\n        print('ERROR: vizSupport: incidenceAngle must be a specified')\n        exit(1)\n\n    if 'coneHeight' in kwargs:\n        height = kwargs['coneHeight']\n        if not isinstance(height, float):\n            print('ERROR: vizSupport: coneHeight must be a float value')\n            exit(1)\n        vizElement.coneHeight = height\n    else:\n        print('ERROR: vizSupport: coneHeight must be a specified')\n        exit(1)\n\n    if 'coneName' in kwargs:\n        coneName = kwargs['coneName']\n        if not isinstance(coneName, str):\n            print('ERROR: vizSupport: coneName must be a string')\n            exit(1)\n        vizElement.coneName = coneName\n    else:\n        vizElement.coneName = \"\"\n\n    coneInOutList.append(vizElement)\n    del viz.settings.coneList[:]  # clear settings list to replace it with updated list\n    viz.settings.coneList = vizInterface.KeepOutInConeConfig(coneInOutList)\n    return",
  "def createStandardCamera(viz, **kwargs):\n    '''\n    add a standard camera window\n    '''\n    if not vizFound:\n        print('vizFound is false. Skipping this method.')\n        return\n    cam = vizInterface.StdCameraSettings()\n\n    unitTestSupport.checkMethodKeyword(\n        ['spacecraftName', 'setMode', 'setView', 'fieldOfView',\n         'bodyTarget', 'pointingVector_B', 'position_B', 'displayName'],\n        kwargs)\n\n    if 'spacecraftName' in kwargs:\n        scName = kwargs['spacecraftName']\n        if not isinstance(scName, str):\n            print('ERROR: vizSupport: spacecraftName must be a string, you provided ' + str(scName))\n            exit(1)\n        cam.spacecraftName = scName\n    else:\n        cam.spacecraftName = firstSpacecraftName\n\n    if 'setMode' in kwargs:\n        setMode = kwargs['setMode']\n        if not isinstance(setMode, int):\n            print('ERROR: vizSupport: setMode must be an integer')\n            exit(1)\n        if setMode < 0 or setMode > 2:\n            print('ERROR: vizSupport: setMode must be a 0 (body targeting) or 1 (pointing vector)')\n            exit(1)\n        cam.setMode = setMode\n\n    if 'setView' in kwargs:\n        setView = kwargs['setView']\n        if cam.setMode == 1:\n            print('ERROR: vizSupport: setView does not apply to pointing vector mode.')\n            exit(1)\n        if not isinstance(setView, int):\n            print('ERROR: vizSupport: setView must be an integer')\n            exit(1)\n        if setView < 0 or setView > 2:\n            print('ERROR: vizSupport: setView must be a number of [0,2]')\n            print('0 -> Nadir, 1 -> Orbit Normal, 2 -> Along Track (default to nadir). '\n                  'This is a setting for body targeting mode.')\n            exit(1)\n        cam.setView = setView\n\n    if 'fieldOfView' in kwargs:\n        fieldOfView = kwargs['fieldOfView']\n        if not isinstance(fieldOfView, float):\n            print('ERROR: vizSupport: spacecraftVisible must be a float in radians')\n            exit(1)\n        cam.fieldOfView = fieldOfView\n\n    if 'bodyTarget' in kwargs:\n        if cam.setMode == 1:\n            print('ERROR: vizSupport: bodyTarget does not apply in pointing vector mode')\n            exit(1)\n        bodyTargetName = kwargs['bodyTarget']\n        if not isinstance(bodyTargetName, str):\n            print('ERROR: vizSupport: targetBodyName must be a string')\n            exit(1)\n        cam.bodyTarget = bodyTargetName\n    else:\n        cam.bodyTarget = \"\"\n\n    if 'pointingVector_B' in kwargs:\n        if cam.setMode == 0:\n            print('ERROR: vizSupport: pointingVector_B does not apply in body pointing mode')\n            exit(1)\n        pointingVector_B = kwargs['pointingVector_B']\n        if not isinstance(pointingVector_B, list):\n            print('ERROR: vizSupport: pointingVector_B must be a 3D array of doubles')\n            exit(1)\n        if len(pointingVector_B) != 3:\n            print('ERROR: vizSupport: pointingVector_B must be 3D list')\n            exit(1)\n        cam.pointingVector_B = pointingVector_B\n    else:\n        cam.pointingVector_B = [1.0, 0.0, 0.0]\n\n    if 'position_B' in kwargs:\n        position_B = kwargs['position_B']\n        if len(position_B) != 3:\n            print('ERROR: vizSupport: position_B must be 3D list of float values')\n            exit(1)\n        cam.position_B = position_B\n    else:\n        cam.position_B = [0, 0, 0]\n\n    if 'displayName' in kwargs:\n        displayName = kwargs['displayName']\n        if not isinstance(displayName, str):\n            print('ERROR: vizSupport: createStandardCamera: displayName must be a string')\n            exit(1)\n        cam.displayName = displayName\n\n    stdCameraList.append(cam)\n    del viz.settings.stdCameraList[:]  # clear settings list to replace it with updated list\n    viz.settings.stdCameraList = vizInterface.StdCameraConfig(stdCameraList)\n    return",
  "def createCameraConfigMsg(viz, **kwargs):\n    if not vizFound:\n        print('vizFound is false. Skipping this method.')\n        return\n    global firstSpacecraftName\n    unitTestSupport.checkMethodKeyword(\n        ['cameraID', 'parentName', 'fieldOfView', 'resolution', 'renderRate', 'cameraPos_B',\n         'sigma_CB', 'skyBox', 'postProcessingOn', 'ppFocusDistance', 'ppAperture', 'ppFocalLength',\n         'ppMaxBlurSize', 'updateCameraParameters', 'renderMode', 'depthMapClippingPlanes'],\n        kwargs)\n\n    cameraConfigMsgPayload = messaging.CameraConfigMsgPayload()\n\n    if 'cameraID' in kwargs:\n        val = kwargs['cameraID']\n        if not isinstance(val, int) or val < 0:\n            print('ERROR: vizSupport: cameraID must be non-negative integer value.')\n            exit(1)\n        cameraConfigMsgPayload.cameraID = val\n    else:\n        print('ERROR: vizSupport: cameraID must be defined in createCameraConfigMsg()')\n        exit(1)\n\n    if 'parentName' in kwargs:\n        val = kwargs['parentName']\n        if not isinstance(val, str):\n            print('ERROR: vizSupport: parentName must be a string')\n            exit(1)\n        cameraConfigMsgPayload.parentName = val\n    else:\n        cameraConfigMsgPayload.parentName = firstSpacecraftName\n\n    if 'fieldOfView' in kwargs:\n        val = kwargs['fieldOfView']\n        if not isinstance(val, float):\n            print('ERROR: vizSupport: fieldOfView must be a float in radians')\n            exit(1)\n        cameraConfigMsgPayload.fieldOfView = val\n    else:\n        print('ERROR: vizSupport: fieldOfView must be defined in createCameraConfigMsg()')\n        exit(1)\n\n    if 'resolution' in kwargs:\n        val = kwargs['resolution']\n        if not isinstance(val, list):\n            print('ERROR: vizSupport: resolution must be a list')\n            exit(1)\n        if len(val) != 2:\n            print('ERROR: vizSupport: resolution list ' + str(val) + 'must be of length 2')\n            exit(1)\n        if not isinstance(val[0], int) or not isinstance(val[1], int):\n            print('ERROR: vizSupport: resolution list ' + str(val) + ' must contain integers')\n            exit(1)\n        cameraConfigMsgPayload.resolution = val\n    else:\n        print('ERROR: vizSupport: resolution must be defined in createCameraConfigMsg()')\n        exit(1)\n\n    if 'renderRate' in kwargs:\n        val = kwargs['renderRate']\n        if not isinstance(val, float) or val < 0:\n            print('ERROR: vizSupport: renderRate ' + str(val) + ' must be positive float value in units of seconds.')\n            exit(1)\n        cameraConfigMsgPayload.renderRate = int(val * 1e9)     # convert to nano-seconds\n\n    if 'cameraPos_B' in kwargs:\n        val = kwargs['cameraPos_B']\n        if not isinstance(val, list):\n            print('ERROR: vizSupport: cameraPos_B must be a list')\n            exit(1)\n        if len(val) != 3:\n            print('ERROR: vizSupport: cameraPos_B list ' + str(val) + 'must be of length 3')\n            exit(1)\n        if not isinstance(val[0], float) or not isinstance(val[1], float) or not isinstance(val[2], float):\n            print('ERROR: vizSupport: cameraPos_B list ' + str(val) + ' must contain floats')\n            exit(1)\n        cameraConfigMsgPayload.cameraPos_B = val\n    else:\n        print('ERROR: vizSupport: cameraPos_B must be defined in createCameraConfigMsg()')\n        exit(1)\n\n    if 'sigma_CB' in kwargs:\n        val = kwargs['sigma_CB']\n        if not isinstance(val, list):\n            print('ERROR: vizSupport: sigma_CB must be a list')\n            exit(1)\n        if len(val) != 3:\n            print('ERROR: vizSupport: sigma_CB list ' + str(val) + 'must be of length 3')\n            exit(1)\n        if not isinstance(val[0], float) or not isinstance(val[1], float) or not isinstance(val[2], float):\n            print('ERROR: vizSupport: sigma_CB list ' + str(val) + ' must contain floats')\n            exit(1)\n        cameraConfigMsgPayload.sigma_CB = val\n    else:\n        print('ERROR: vizSupport: sigma_CB must be defined in createCameraConfigMsg()')\n        exit(1)\n\n    if 'skyBox' in kwargs:\n        val = kwargs['skyBox']\n        if not isinstance(val, str):\n            print('ERROR: vizSupport: skyBox must be a string')\n            exit(1)\n        cameraConfigMsgPayload.skyBox = val\n    else:\n        cameraConfigMsgPayload.skyBox = \"\"\n\n    if 'postProcessingOn' in kwargs:\n        val = kwargs['postProcessingOn']\n        if not isinstance(val, int) or val < 0:\n            print('ERROR: vizSupport: postProcessingOn must be non-negative integer value.')\n            exit(1)\n        cameraConfigMsgPayload.postProcessingOn = val\n\n    if 'ppFocusDistance' in kwargs:\n        val = kwargs['ppFocusDistance']\n        if not isinstance(val, float) or val < 0:\n            print('ERROR: vizSupport: ppFocusDistance ' + str(val) + ' must be 0 or greater than 0.1.')\n            exit(1)\n        cameraConfigMsgPayload.ppFocusDistance = int(val)\n\n    if 'ppAperture' in kwargs:\n        val = kwargs['ppAperture']\n        if not isinstance(val, float) or val < 0 or val > 32:\n            print('ERROR: vizSupport: ppAperture ' + str(val) + ' must be 0 or with [0.05, 32].')\n            exit(1)\n        cameraConfigMsgPayload.ppAperture = int(val)\n\n    if 'ppFocalLength' in kwargs:\n        val = kwargs['ppFocalLength']\n        if not isinstance(val, float) or val < 0 or val > 0.3:\n            print('ERROR: vizSupport: ppFocalLength ' + str(val) + ' must be 0 or with [0.001, 0.3] meters.')\n            exit(1)\n        cameraConfigMsgPayload.ppFocalLength = int(val)\n\n    if 'ppMaxBlurSize' in kwargs:\n        val = kwargs['ppMaxBlurSize']\n        if not isinstance(val, int) or val < 0 or val > 4:\n            print('ERROR: vizSupport: ppMaxBlurSize must be non-negative integer value between [0, 4].')\n            exit(1)\n        cameraConfigMsgPayload.ppMaxBlurSize = val\n\n    if 'updateCameraParameters' in kwargs:\n        val = kwargs['updateCameraParameters']\n        if not isinstance(val, int) or val < 0 or val > 1:\n            print('ERROR: vizSupport: updateCameraParameters must be 0 or 1.')\n            exit(1)\n        cameraConfigMsgPayload.cameraID = val\n    else:\n        cameraConfigMsgPayload.cameraID = 0\n\n    if 'renderMode' in kwargs:\n        val = kwargs['renderMode']\n        if not isinstance(val, int) or val < 0 or val > 1:\n            print('ERROR: vizSupport: renderMode must be 0 or 1.')\n            exit(1)\n        cameraConfigMsgPayload.renderMode = val\n    else:\n        cameraConfigMsgPayload.renderMode = 0\n\n    if 'depthMapClippingPlanes' in kwargs:\n        if cameraConfigMsgPayload.renderMode != 1:\n            print('WARNING: vizSupport: depthMapClippingPlanes only works with renderMode set to 1 (depthMap).')\n            exit(1)\n        val = kwargs['depthMapClippingPlanes']\n        if not isinstance(val, list):\n            print('ERROR: vizSupport: depthMapClippingPlanes must be a list of two doubles.')\n            exit(1)\n        if len(val) != 2:\n            print('ERROR: vizSupport: depthMapClippingPlanes list ' + str(val) + 'must be of length 2')\n            exit(1)\n        if not isinstance(val[0], float) or not isinstance(val[1], float):\n            print('ERROR: vizSupport: depthMapClippingPlanes list ' + str(val) + ' must contain floats')\n            exit(1)\n        print(val)\n        cameraConfigMsgPayload.depthMapClippingPlanes = val\n    else:\n        cameraConfigMsgPayload.depthMapClippingPlanes = [-1.0, -1.0]\n\n    cameraConfigMsg = messaging.CameraConfigMsg().write(cameraConfigMsgPayload)\n    cameraConfigMsg.this.disown()\n    viz.addCamMsgToModule(cameraConfigMsg)\n\n    return",
  "def enableUnityVisualization(scSim, simTaskName, scList, **kwargs):\n    \"\"\"\n    This methods creates an instance of the vizInterface() modules and setups up associated Vizard\n    configuration setting messages.\n\n    Parameters\n    ----------\n    scSim:\n        variable with the simulationBaseClass copy\n    simTaskName:\n        task to which to add the vizInterface module\n    scList:\n        :ref:`spacecraft` objects.  Can be a single object or list of objects\n\n    Keyword Args\n    ------------\n    saveFile: str\n        can be a single file name, or a full path + file name. In both cases a local results are stored\n        in a local sub-folder.\n        Default: empty string resulting in the data not being saved to a file\n    rwEffectorList: single or list of ``ReactionWheelStateEffector``\n        The list must have the same length ``scList``.  Each entry is the :ref:`ReactionWheelStateEffector` instance\n        for the spacecraft, or ``None`` if the spacecraft has no RW devices.\n    thrEffectorList: single or double-list of :ref:`ThrusterDynamicEffector`\n        The list must have the same length ``scList``.  Each entry is a list of :ref:`ReactionWheelStateEffector`\n        instances\n        for the spacecraft denoting a thruster cluster, or ``None`` if the spacecraft has no thruster devices.\n    thrColors: single or vector of int(4)\n        array of RGBA color values for each thruster set.  The list must have the same length as ``scList``.\n        Each list entry is a list of RGBA array values for each cluster set.\n    cssList:\n        list of lists of :ref:`CoarseSunSensor` objects.  The outer list length must match ``scList``.\n    genericSensorList:\n        list of lists of ``GenericSensor`` structures.  The outer list length must match ``scList``.\n    genericSensorCmdInMsgs:\n        list of lists of :ref:`DeviceCmdMsgPayload` sensor state messages.  The outer list length must\n        match ``scList``.  If the spacecraft has no sensor command msg, then use ``None``.\n    opNavMode: bool\n        flag if opNaveMode should be used\n    liveStream: bool\n        flag if live data streaming to Vizard should be used\n    genericStorageList:\n        list of lists of ``GenericStorage`` structures.  The outer list length must match ``scList``.\n    lightList:\n        list of lists of ``Light`` structures.   The outer list length must match ``scList``.\n    spriteList:\n        list of sprite information for each spacecraft\n    modelDictionaryKeyList:\n        list of the spacecraft model dictionary.  Use ``None`` if default values are used\n    oscOrbitColorList:\n        list of spacecraft osculating orbit colors.  Can be 4 RGBA integer value (0-255), a color string, or\n        ``None`` if default values should be used.  The array must be of the length of the spacecraft list\n    trueOrbitColorList:\n        list of spacecraft true or actual orbit colors.  Can be 4 RGBA integer value (0-255), a color string, or\n        ``None`` if default values should be used.  The array must be of the length of the spacecraft list\n    trueOrbitColorInMsgList:\n        list of color messages to read and provide the true orbit color at each time step.  This overwrites\n        the values set with trueOrbitColorList.\n    msmInfoList:\n        list of MSM configuration messages\n    ellipsoidList:\n        list of lists of ``Ellipsoid`` structures.  The outer list length must match ``scList``.\n\n    Returns\n    -------\n    :ref:`vizInterface` object\n        copy of the vizInterface instance\n\n    \"\"\"\n    if not vizFound:\n        print('Could not find vizInterface when import attempted.  Be sure to build BSK with vizInterface support.')\n        return\n\n    # clear the list of point line elements\n    del pointLineList[:]\n    del actuatorGuiSettingList[:]\n    del coneInOutList[:]\n    global firstSpacecraftName\n\n    unitTestSupport.checkMethodKeyword(\n        ['saveFile', 'opNavMode', 'rwEffectorList', 'thrEffectorList', 'thrColors', 'liveStream', 'cssList',\n         'genericSensorList', 'transceiverList', 'genericStorageList', 'lightList', 'spriteList',\n         'modelDictionaryKeyList', 'oscOrbitColorList', 'trueOrbitColorList', 'logoTextureList',\n         'msmInfoList', 'ellipsoidList', 'trueOrbitColorInMsgList'],\n        kwargs)\n\n    # setup the Vizard interface module\n    vizMessenger = vizInterface.VizInterface()\n    vizMessenger.ModelTag = \"vizMessenger\"\n    scSim.AddModelToTask(simTaskName, vizMessenger)\n\n    # ensure the spacecraft object list is a list\n    if not isinstance(scList, list):\n        scList = [scList]\n    scListLength = len(scList)\n\n    firstSpacecraftName = scList[0].ModelTag\n\n    # process the RW effector argument\n    rwEffectorScList = False\n    if 'rwEffectorList' in kwargs:\n        rwEffectorScList = kwargs['rwEffectorList']\n        if not isinstance(rwEffectorScList, list):\n            rwEffectorScList = [rwEffectorScList]\n        if len(rwEffectorScList) != scListLength:\n            print('ERROR: vizSupport: rwEffectorList should have the same length as the number of spacecraft')\n            exit(1)\n\n    thrEffectorScList = False\n    if 'thrEffectorList' in kwargs:\n        thrEffectorScList = kwargs['thrEffectorList']\n        if not isinstance(thrEffectorScList, list):\n            thrEffectorScList = [[thrEffectorScList]]\n        if len(thrEffectorScList) != scListLength:\n            print('ERROR: vizSupport: thrEffectorList should have the same length as the number of spacecraft')\n            exit(1)\n    thrColorsScList = False\n    if 'thrColors' in kwargs:\n        thrColorsScList = kwargs['thrColors']\n        if len(thrColorsScList) == 4:\n            colorCheck = True\n            for c in thrColorsScList:\n                if not isinstance(c, int):\n                    colorCheck = False\n            if colorCheck:\n                thrColorsScList = [[thrColorsScList]]\n        if len(thrColorsScList) != scListLength:\n            print('ERROR: vizSupport: thrColors should have the same length as the number of spacecraft')\n            exit(1)\n\n    cssScList = False\n    if 'cssList' in kwargs:\n        cssScList = kwargs['cssList']\n        if not isinstance(cssScList, list):\n            cssScList = [[cssScList]]\n        if len(cssScList) != scListLength:\n            print('ERROR: vizSupport: cssList should have the same length as the number '\n                  'of spacecraft and contain lists of CSSs')\n            exit(1)\n\n    gsScList = False\n    if 'genericSensorList' in kwargs:\n        gsScList = kwargs['genericSensorList']\n        if not isinstance(gsScList, list):\n            gsScList = [[gsScList]]\n        if len(gsScList) != scListLength:\n            print('ERROR: vizSupport: genericSensorList should have the same length as the '\n                  'number of spacecraft and contain lists of generic sensors')\n            exit(1)\n\n    elScList = False\n    if 'ellipsoidList' in kwargs:\n        elScList = kwargs['ellipsoidList']\n        if not isinstance(elScList, list):\n            elScList = [[elScList]]\n        if len(elScList) != scListLength:\n            print('ERROR: vizSupport: ellipsoidList should have the same length as the '\n                  'number of spacecraft and contain lists of generic sensors')\n            exit(1)\n\n    liScList = False\n    if 'lightList' in kwargs:\n        liScList = kwargs['lightList']\n        if not isinstance(liScList, list):\n            liScList = [[liScList]]\n        if len(liScList) != scListLength:\n            print('ERROR: vizSupport: lightList should have the same length as the '\n                  'number of spacecraft and contain lists of light devices')\n            exit(1)\n\n    gsdScList = False\n    if 'genericStorageList' in kwargs:\n        gsdScList = kwargs['genericStorageList']\n        if not isinstance(gsdScList, list):\n            gsdScList = [[gsdScList]]\n        if len(gsdScList) != scListLength:\n            print('ERROR: vizSupport: genericStorageList should have the same length as the '\n                  'number of spacecraft and contain lists of generic sensors')\n            exit(1)\n\n    tcScList = False\n    if 'transceiverList' in kwargs:\n        tcScList = kwargs['transceiverList']\n        if not isinstance(tcScList, list):\n            tcScList = [[tcScList]]\n        if len(tcScList) != scListLength:\n            print('ERROR: vizSupport: tcScList should have the same length as the '\n                  'number of spacecraft and contain lists of transceivers')\n            exit(1)\n\n    spriteScList = False\n    if 'spriteList' in kwargs:\n        spriteScList = kwargs['spriteList']\n        if not isinstance(spriteScList, list):\n            spriteScList = [spriteScList]\n        if len(spriteScList) != scListLength:\n            print('ERROR: vizSupport: spriteScList should have the same length as the '\n                  'number of spacecraft and contain lists of transceivers')\n            exit(1)\n\n    modelDictionaryKeyList = False\n    if 'modelDictionaryKeyList' in kwargs:\n        modelDictionaryKeyList = kwargs['modelDictionaryKeyList']\n        if not isinstance(modelDictionaryKeyList, list):\n            modelDictionaryKeyList = [modelDictionaryKeyList]\n        if len(modelDictionaryKeyList) != scListLength:\n            print('ERROR: vizSupport: modelDictionaryKeyList should have the same length as the '\n                  'number of spacecraft and contain lists of transceivers')\n            exit(1)\n\n    logoTextureList = False\n    if 'logoTextureList' in kwargs:\n        logoTextureList = kwargs['logoTextureList']\n        if not isinstance(logoTextureList, list):\n            logoTextureList = [logoTextureList]\n        if len(logoTextureList) != scListLength:\n            print('ERROR: vizSupport: logoTextureList should have the same length as the '\n                  'number of spacecraft and contain lists of transceivers')\n            exit(1)\n\n    oscOrbitColorList = False\n    if 'oscOrbitColorList' in kwargs:\n        oscOrbitColorList = kwargs['oscOrbitColorList']\n        if len(oscOrbitColorList) != scListLength:\n            print('ERROR: vizSupport: oscOrbitColorList should have the same length as the '\n                  'number of spacecraft and contain lists of transceivers')\n            exit(1)\n        for elem in oscOrbitColorList:\n            if isinstance(elem, list):\n                if len(elem) != 4:\n                    print('ERROR: vizSupport: if specifying oscOrbitColorList color via RGBA values, you '\n                          'must provide 4 integers values from 0 to 255 ')\n                    exit(1)\n                for color in elem:\n                    if color < 0 or color > 255:\n                        print('ERROR: vizSupport:  oscOrbitColorList color contained negative value ')\n                        exit(1)\n\n    trueOrbitColorList = False\n    if 'trueOrbitColorList' in kwargs:\n        trueOrbitColorList = kwargs['trueOrbitColorList']\n        if len(trueOrbitColorList) != scListLength:\n            print('ERROR: vizSupport: trueOrbitColorList should have the same length as the '\n                  'number of spacecraft and contain lists of transceivers')\n            exit(1)\n        for elem in trueOrbitColorList:\n            if isinstance(elem, list):\n                if len(elem) != 4:\n                    print('ERROR: vizSupport: if specifying trueOrbitColorList color via RGBA values, you '\n                          'must provide 4 integers values from 0 to 255 ')\n                    exit(1)\n                for color in elem:\n                    if color < 0 or color > 255:\n                        print('ERROR: vizSupport:  trueOrbitColorList color contained negative value ')\n                        exit(1)\n\n    msmInfoList = False\n    if 'msmInfoList' in kwargs:\n        msmInfoList = kwargs['msmInfoList']\n        if not isinstance(msmInfoList, list):\n            msmInfoList = [msmInfoList]\n        if len(msmInfoList) != scListLength:\n            print('ERROR: vizSupport: msmInfoList should have the same length as the '\n                  'number of spacecraft')\n            exit(1)\n\n    trueOrbitColorInMsgList = False\n    if 'trueOrbitColorInMsgList' in kwargs:\n        trueOrbitColorInMsgList = kwargs['trueOrbitColorInMsgList']\n        if not isinstance(trueOrbitColorInMsgList, list):\n            trueOrbitColorInMsgList = [trueOrbitColorInMsgList]\n        if len(trueOrbitColorInMsgList) != scListLength:\n            print('ERROR: vizSupport: trueOrbitColorInMsgList should have the same length as the '\n                  'number of spacecraft')\n            exit(1)\n\n    # loop over all spacecraft to associated states and msg information\n    planetNameList = []\n    planetInfoList = []\n    spiceMsgList = []\n    vizMessenger.scData.clear()\n    c = 0\n    spacecraftParentName = \"\"\n\n    for sc in scList:\n        # create spacecraft information container\n        scData = vizInterface.VizSpacecraftData()\n\n        # link to spacecraft state message\n        if isinstance(sc, type(spacecraft.Spacecraft())):\n            # set spacecraft name\n            scData.spacecraftName = sc.ModelTag\n            spacecraftParentName = sc.ModelTag\n            scData.scStateInMsg.subscribeTo(sc.scStateOutMsg)\n\n            # link to celestial bodies information\n            for gravBody in sc.gravField.gravBodies:\n                # check if the celestial object has already been added\n                if gravBody.planetName not in planetNameList:\n                    planetNameList.append(gravBody.planetName)\n                    planetInfo = vizInterface.GravBodyInfo()\n                    if gravBody.displayName == \"\":\n                        planetInfo.bodyName = gravBody.planetName\n                    else:\n                        planetInfo.bodyName = gravBody.displayName\n                    planetInfo.mu = gravBody.mu\n                    planetInfo.radEquator = gravBody.radEquator\n                    planetInfo.radiusRatio = gravBody.radiusRatio\n                    planetInfo.modelDictionaryKey = gravBody.modelDictionaryKey\n                    planetInfoList.append(planetInfo)\n                    spiceMsgList.append(gravBody.planetBodyInMsg)\n        else:\n            # the scList object is an effector belonging to the parent spacecraft\n            scData.parentSpacecraftName = spacecraftParentName\n            ModelTag = sc[0]\n            effStateOutMsg = sc[1]\n            scData.spacecraftName = ModelTag\n            scData.scStateInMsg.subscribeTo(effStateOutMsg)\n\n        # process RW effectors\n        if rwEffectorScList:\n            rwList = []\n            if rwEffectorScList[c] is not None:\n                # RWs have been added to this spacecraft\n                for rwLogMsg in rwEffectorScList[c].rwOutMsgs:\n                    rwList.append(rwLogMsg.addSubscriber())\n            scData.rwInMsgs = messaging.RWConfigLogMsgInMsgsVector(rwList)\n\n        # process THR effectors\n        if thrEffectorScList:\n            thrList = []\n            thrInfo = []\n            if thrEffectorScList[c] is not None:  # THR clusters have been added to this spacecraft\n                clusterCounter = 0\n                for thrEff in thrEffectorScList[c]:  # loop over the THR effectors attached to this spacecraft\n                    thSet = vizInterface.ThrClusterMap()\n                    thSet.thrTag = thrEff.ModelTag  # set the label for this cluster of THR devices\n                    if thrColorsScList:\n                        if thrColorsScList[c] is not None:\n                            thSet.color = thrColorsScList[c][clusterCounter]\n                    for thrLogMsg in thrEff.thrusterOutMsgs:  # loop over the THR cluster log message\n                        thrList.append(thrLogMsg.addSubscriber())\n                        thrInfo.append(thSet)\n                    clusterCounter += 1\n            scData.thrInMsgs = messaging.THROutputMsgInMsgsVector(thrList)\n            scData.thrInfo = vizInterface.ThrClusterVector(thrInfo)\n\n        # process CSS information\n        if cssScList:\n            cssDeviceList = []\n            if cssScList[c] is not None:  # CSS list has been added to this spacecraft\n                for css in cssScList[c]:\n                    cssDeviceList.append(css.cssConfigLogOutMsg.addSubscriber())\n                scData.cssInMsgs = messaging.CSSConfigLogMsgInMsgsVector(cssDeviceList)\n\n        # process generic sensor HUD information\n        if gsScList:\n            gsList = []\n            if gsScList[c] is not None:  # generic sensor(s) have been added to this spacecraft\n                for gs in gsScList[c]:\n                    gsList.append(gs)\n                scData.genericSensorList = vizInterface.GenericSensorVector(gsList)\n\n        # process spacecraft ellipsoids\n        if elScList:\n            elList = []\n            if elScList[c] is not None:  # generic sensor(s) have been added to this spacecraft\n                for el in elScList[c]:\n                    elList.append(el)\n                scData.ellipsoidList = vizInterface.EllipsoidVector(elList)\n\n        # process spacecraft lights\n        if liScList:\n            liList = []\n            if liScList[c] is not None: # light objects(s) have been added to this spacecraft\n                for li in liScList[c]:\n                    liList.append(li)\n                scData.lightList = vizInterface.LightVector(liList)\n\n        # process generic storage HUD information\n        if gsdScList:\n            gsdList = []\n            if gsdScList[c] is not None:  # generic storage device(s) have been added to this spacecraft\n                for gsd in gsdScList[c]:\n                    if len(gsd.color) > 1:\n                        if len(gsd.color)/4 != len(gsd.thresholds) + 1:\n                            print(\"ERROR: vizSupport: generic storage \" + gsd.label +\n                                  \" threshold list does not have the correct dimension.  \"\n                                  \"It should be 1 smaller than the list of colors.\")\n                            exit(1)\n                    else:\n                        if len(gsd.thresholds) > 0:\n                            print(\"ERROR: vizSupport: generic storage \" + gsd.label +\n                                  \" threshold list is set, but no multiple of colors are provided.\")\n                            exit(1)\n                    gsdList.append(gsd)\n                scData.genericStorageList = vizInterface.GenericStorageVector(gsdList)\n\n        # process transceiver HUD information\n        if tcScList:\n            tcList = []\n            if tcScList[c] is not None:  # transceiver(s) have been added to this spacecraft\n                for tc in tcScList[c]:\n                    tcList.append(tc)\n                scData.transceiverList = vizInterface.TransceiverVector(tcList)\n\n        # process sprite information\n        if spriteScList:\n            if spriteScList[c] is not None:\n                scData.spacecraftSprite = spriteScList[c]\n        # process modelDictionaryKey information\n        if modelDictionaryKeyList:\n            if modelDictionaryKeyList[c] is not None:\n                scData.modelDictionaryKey = modelDictionaryKeyList[c]\n        # process logoTexture information\n        if logoTextureList:\n            if logoTextureList[c] is not None:\n                scData.logoTexture = logoTextureList[c]\n\n        if oscOrbitColorList:\n            if oscOrbitColorList[c] is not None:\n                scData.oscOrbitLineColor = vizInterface.IntVector(oscOrbitColorList[c])\n\n        if trueOrbitColorList:\n            if trueOrbitColorList[c] is not None:\n                scData.trueTrajectoryLineColor = vizInterface.IntVector(trueOrbitColorList[c])\n\n        if trueOrbitColorInMsgList:\n            if trueOrbitColorInMsgList[c] is not None:\n                scData.trueTrajectoryLineColorInMsg = trueOrbitColorInMsgList[c]\n\n        # process MSM information\n        if msmInfoList:\n            if msmInfoList[c] is not None:  # MSM have been added to this spacecraft\n                scData.msmInfo = msmInfoList[c]\n\n        vizMessenger.scData.push_back(scData)\n\n        c += 1\n\n    vizMessenger.gravBodyInformation = vizInterface.GravBodyInfoVector(planetInfoList)\n    vizMessenger.spiceInMsgs = messaging.SpicePlanetStateMsgInMsgsVector(spiceMsgList)\n\n    # note that the following logic can receive a single file name, or a full path + file name.\n    # In both cases a local results are stored in a local sub-folder.\n    vizMessenger.saveFile = False\n    if 'saveFile' in kwargs:\n        fileNamePath = kwargs['saveFile']\n        fileName = os.path.splitext(os.path.basename(fileNamePath))[0]\n        filePath = os.path.dirname(fileNamePath)\n        if filePath == \"\":\n            filePath = \".\"\n        if not os.path.isdir(filePath + '/_VizFiles'):\n            os.mkdir(filePath + '/_VizFiles')\n        vizFileNamePath = filePath + '/_VizFiles/' + fileName + '_UnityViz.bin'\n        vizMessenger.saveFile = True\n        vizMessenger.protoFilename = vizFileNamePath\n        print(\"Saving Viz file to \" + vizFileNamePath)\n\n    if 'liveStream' in kwargs:\n        val = kwargs['liveStream']\n        if not isinstance(val, bool):\n            print('ERROR: vizSupport: liveStream must True or False')\n            exit(1)\n        vizMessenger.liveStream = val\n        if 'opNavMode' in kwargs:\n            if kwargs['opNavMode'] > 0:\n                print('ERROR: vizSupport: do not use liveStream and opNavMode flags at the same time.')\n                exit(1)\n\n    vizMessenger.opNavMode = 0\n    if 'opNavMode' in kwargs:\n        val = kwargs['opNavMode']\n        if not isinstance(val, int):\n            print('ERROR: vizSupport: opNavMode must be 0 (off), 1 (regular opNav) or 2 (high performance opNav)')\n            exit(1)\n        if val < 0 or val > 2:\n            print('ERROR: vizSupport: opNavMode must be 0 (off), 1 (regular opNav) or 2 (high performance opNav)')\n            exit(1)\n        vizMessenger.opNavMode = val\n        if val > 0:\n            vizMessenger.opnavImageOutMsgName = \"opnav_circles\"\n\n    return vizMessenger",
  "class LogBaseClass:\n    \"\"\"Logging Base class\"\"\"\n    def __init__(self, ReplaceName, LogPeriod, RefFunction, DataCols=1):\n        self.Period = LogPeriod\n        self.Name = ReplaceName\n        self.PrevLogTime = None\n        self.PrevValue = None\n        self.TimeValuePairs = array.array('d')\n        self.ArrayDim = DataCols + 1\n        self.CallableFunction = RefFunction\n\n    def clearItem(self):\n        self.TimeValuePairs = array.array('d')\n        self.PrevLogTime = None\n        self.PrevValue = None",
  "class EventHandlerClass:\n    \"\"\"Event Handler Class\"\"\"\n    def __init__(self, eventName, eventRate=int(1E9), eventActive=False,\n                 conditionList=[], actionList=[], terminal=False):\n        self.eventName = eventName\n        self.eventActive = eventActive\n        self.eventRate = eventRate\n        self.conditionList = conditionList\n        self.actionList = actionList\n        self.occurCounter = 0\n        self.prevTime = -1\n        self.checkCall = None\n        self.operateCall = None\n        self.terminal = terminal\n\n    def methodizeEvent(self):\n        if self.checkCall != None:\n            return\n        funcString = 'def EVENT_check_' + self.eventName + '(self):\\n'\n        funcString += '    if('\n        for condValue in self.conditionList:\n            funcString += ' ' + condValue + ' and'\n        funcString = funcString[:-3] + '):\\n'\n        funcString += '        return 1\\n'\n        funcString += '    return 0'\n\n        exec (funcString)\n        self.checkCall = eval('EVENT_check_' + self.eventName)\n        funcString = 'def EVENT_operate_' + self.eventName + '(self):\\n'\n        for actionValue in self.actionList:\n            funcString += '    '\n            funcString += actionValue + '\\n'\n        funcString += '    return 0'\n        exec (funcString)\n        self.operateCall = eval('EVENT_operate_' + self.eventName)\n\n    def checkEvent(self, parentSim):\n        nextTime = int(-1)\n        if self.eventActive == False:\n            return(nextTime)\n        nextTime = self.prevTime + self.eventRate - (self.prevTime%self.eventRate)\n        if self.prevTime < 0 or (parentSim.TotalSim.CurrentNanos%self.eventRate == 0):\n            nextTime = parentSim.TotalSim.CurrentNanos + self.eventRate\n            eventCount = self.checkCall(parentSim)\n            self.prevTime = parentSim.TotalSim.CurrentNanos\n            if eventCount > 0:\n                self.eventActive = False\n                self.operateCall(parentSim)\n                self.occurCounter += 1\n                if self.terminal:\n                    parentSim.terminate = True\n        return(nextTime)",
  "class StructDocData:\n    \"\"\"Structure data documentation class\"\"\"\n    class StructElementDef:\n        def __init__(self, type, name, argstring, desc=''):\n            self.type = type\n            self.name = name\n            self.argstring = argstring\n            self.desc = desc\n\n    def __init__(self, strName):\n        self.strName = strName\n        self.structPopulated = False\n        self.structElements = {}\n\n    def clearItem(self):\n        self.structPopulated = False\n        self.structElements = {}\n\n    def populateElem(self, xmlSearchPath):\n        if self.structPopulated == True:\n            return\n        xmlFileUse = xmlSearchPath + '/' + self.strName + '.xml'\n        try:\n            xmlData = ET.parse(xmlFileUse)\n        except:\n            print(\"Failed to parse the XML structure for: \" + self.strName)\n            print(\"This file does not exist most likely: \" + xmlFileUse)\n            return\n        root = xmlData.getroot()\n        validElement = root.find(\"./compounddef[@id='\" + self.strName + \"']\")\n        for newVariable in validElement.findall(\".//memberdef[@kind='variable']\"):\n            typeUse = newVariable.find('type').text if newVariable.find('type') is not None else \\\n                None\n            nameUse = newVariable.find('name').text if newVariable.find('type') is not None else \\\n                None\n            argstringUse = newVariable.find('argsstring').text if newVariable.find('argsstring') is not None else \\\n                None\n            descUse = newVariable.find('./detaileddescription/para').text if newVariable.find(\n                './detaileddescription/para') is not None else \\\n                None\n            if descUse == None:\n                descUse = newVariable.find('./briefdescription/para').text if newVariable.find(\n                    './briefdescription/para') is not None else \\\n                    None\n            newElement = StructDocData.StructElementDef(typeUse, nameUse, argstringUse, descUse)\n            self.structElements.update({nameUse: newElement})\n            self.structPopulated = True\n\n    def printElem(self):\n        print(\"    \" + self.strName + \" Structure Elements:\")\n        for key, value in self.structElements.items():\n            outputString = ''\n            outputString += value.type + \" \" + value.name\n            outputString += value.argstring if value.argstring is not None else ''\n            outputString += ': ' + value.desc if value.desc is not None else ''\n        print(\"      \" + outputString)",
  "class DataPairClass:\n    def __init__(self):\n        self.outputMessages = set([])\n        self.inputMessages = set([])\n        self.name = \"\"\n        self.outputDict = {}",
  "class SimBaseClass:\n    \"\"\"Simulation Base Class\"\"\"\n    def __init__(self):\n        self.TotalSim = sim_model.SimModel()\n        self.TaskList = []\n        self.procList = []\n        self.pyProcList = []\n        self.StopTime = 0\n        self.nextEventTime = 0\n        self.terminate = False\n        self.NameReplace = {}\n        self.VarLogList = {}\n        self.eventMap = {}\n        self.simModules = set()\n        self.simBasePath = os.path.dirname(os.path.realpath(__file__)) + '/../'\n        self.dataStructIndex = self.simBasePath + '/xml/index.xml'\n        self.indexParsed = False\n        self.simulationInitialized = False\n        self.simulationFinished = False\n        self.bskLogger = bskLogging.BSKLogger()\n        self.showProgressBar = False\n        self.allModules = set()\n\n    def SetProgressBar(self, value):\n        \"\"\"\n        Shows a dynamic progress in the terminal while the simulation is executing.\n        \"\"\"\n        self.showProgressBar = value\n\n    def ShowExecutionOrder(self):\n        \"\"\"\n        Shows in what order the Basilisk processes, task lists and modules are executed\n        \"\"\"\n\n        for processData in self. TotalSim.processList:\n            print(f\"{processColor}Process Name: {endColor}\" + processData.processName +\n                  \" , \" + processColor + \"priority: \" + endColor + str(processData.processPriority))\n            for task in processData.processTasks:\n                print(f\"{taskColor}Task Name: {endColor}\" + task.TaskPtr.TaskName +\n                      \", \" + taskColor + \"priority: \" + endColor + str(task.taskPriority) +\n                      \", \" + taskColor + \"TaskPeriod: \" + endColor + str(task.TaskPtr.TaskPeriod/1.0e9) + \"s\")\n                for module in task.TaskPtr.TaskModels:\n                    print(moduleColor + \"ModuleTag: \" + endColor + module.ModelPtr.ModelTag +\n                          \", \" + moduleColor + \"priority: \" + endColor + str(module.CurrentModelPriority))\n            print(\"\")\n\n        for pyProc in self.pyProcList:\n            print(f\"{processColor}PyProcess Name: {endColor}\" + pyProc.Name +\n                  \" , \" + processColor + \"priority: \" + endColor + str(pyProc.pyProcPriority))\n            for task in pyProc.taskList:\n                print(f\"{taskColor}PyTask Name: {endColor}\" + task.name +\n                      \", \" + taskColor + \"priority: \" + endColor + str(task.priority) +\n                      \", \" + taskColor + \"TaskPeriod: \" + endColor + str(task.rate / 1.0e9) + \"s\")\n                for module in task.modelList:\n                    print(moduleColor + \"PyModuleTag: \" + endColor + module.modelName +\n                          \", \" + moduleColor + \"priority: \" + endColor + str(module.modelPriority))\n            print(\"\")\n\n    def ShowExecutionFigure(self, show_plots=False):\n        \"\"\"\n        Shows in what order the Basilisk processes, task lists and modules are executed\n        \"\"\"\n        processList = OrderedDict()\n        for processData in self. TotalSim.processList:\n            taskList = OrderedDict()\n            for task in processData.processTasks:\n                moduleList = []\n                for module in task.TaskPtr.TaskModels:\n                    moduleList.append(module.ModelPtr.ModelTag + \" (\" + str(module.CurrentModelPriority) + \")\")\n                taskList[task.TaskPtr.TaskName + \" (\" + str(task.taskPriority) + \", \" + str(task.TaskPtr.TaskPeriod/1.0e9) + \"s)\"] = moduleList\n            processList[processData.processName + \" (\" + str(processData.processPriority) + \")\"] = taskList\n\n        for pyProc in self.pyProcList:\n            taskList = OrderedDict()\n            for task in pyProc.taskList:\n                moduleList = []\n                for module in task.modelList:\n                    moduleList.append(module.modelName + \" (\" + str(module.modelPriority) + \")\")\n                taskList[task.name + \" (\" + str(task.priority) + \", \" + str(\n                    task.rate / 1.0e9) + \"s)\"] = moduleList\n            processList[pyProc.Name + \" (\" + str(pyProc.pyProcPriority) + \")\"] = taskList\n\n        fig = plt.figure()\n        plt.rcParams.update({'font.size': 8})\n        plt.axis('off')\n\n        processNo = 0\n        processWidth = 6\n        lineHeight = 0.5\n        textBuffer = lineHeight*0.75\n        textIndent = lineHeight*0.25\n        processGap = 0.5\n        for process in processList:\n            # Draw process box + priority\n            rectangle = plt.Rectangle(((processWidth+processGap)*processNo, 0), processWidth, -lineHeight, ec='g', fc='g')\n            plt.gca().add_patch(rectangle)\n            plt.text((processWidth+processGap)*processNo + textIndent, -textBuffer, process, color='w')\n\n            taskNo = 0\n            currentLine = -lineHeight - textIndent\n            for task in processList[process]:\n                # Draw task box + priority + task rate\n                rectangle = plt.Rectangle(((processWidth + processGap) * processNo + textIndent, currentLine)\n                                          , processWidth - 2 * textIndent\n                                          , - (1+len(processList[process][task])) * (lineHeight + textIndent),\n                                          ec='y', fc=(1,1,1,0))\n                plt.gca().add_patch(rectangle)\n                rectangle = plt.Rectangle(((processWidth + processGap) * processNo + textIndent, currentLine)\n                                          , processWidth - 2 * textIndent, -lineHeight,\n                                          ec='y', fc='y')\n                plt.gca().add_patch(rectangle)\n                plt.text((processWidth + processGap) * processNo + 2*textIndent,\n                         currentLine-textBuffer, task, color='black')\n\n                for module in processList[process][task]:\n                    # Draw modules + priority\n                    currentLine -= lineHeight + textIndent\n                    rectangle = plt.Rectangle(((processWidth + processGap) * processNo + 2*textIndent, currentLine)\n                                              , processWidth - 4 * textIndent, -lineHeight,\n                                              ec='c', fc=(1,1,1,0))\n                    plt.gca().add_patch(rectangle)\n                    plt.text((processWidth + processGap) * processNo + 3*textIndent,\n                             currentLine-textBuffer, module, color='black')\n\n                taskNo += 1\n                currentLine -=  lineHeight + 2 * textIndent\n\n            rectangle = plt.Rectangle(((processWidth+processGap)*processNo, 0), processWidth, currentLine, ec='g', fc=(1,1,1,0))\n            plt.gca().add_patch(rectangle)\n            processNo += 1\n\n        plt.axis('scaled')\n\n        if show_plots:\n            plt.show()\n\n        return fig\n\n    def AddModelToTask(self, TaskName, NewModel, ModelData=None, ModelPriority=-1):\n        \"\"\"\n        This function is responsible for passing on the logger to a module instance (model), adding the\n        model to a particular task, and defining\n        the order/priority that the model gets updated within the task.\n\n        :param TaskName (str): Name of the task\n        :param NewModel (obj): Model to add to the task\n        :param ModelData: None or struct containing, only used for C BSK modules\n        :param ModelPriority (int): Priority that determines when the model gets updated. (Higher number = Higher priority)\n        :return:\n        \"\"\"\n        # Supports calling AddModelToTask(TaskName, NewModel, ModelPriority)\n        if isinstance(ModelData, int):\n            ModelPriority = ModelData\n            ModelData = None\n\n        i = 0\n        for Task in self.TaskList:\n            if Task.Name == TaskName:\n                Task.TaskData.AddNewObject(NewModel, ModelPriority)\n                TaskReplaceTag = 'self.TaskList[' + str(i) + ']'\n                TaskReplaceTag += '.TaskModels[' + str(len(Task.TaskModels)) + ']'\n                self.NameReplace[TaskReplaceTag] = NewModel.ModelTag\n                if ModelData is not None:\n                    try:\n                        ModelData.bskLogger = self.bskLogger\n                    except:\n                        pass\n                    Task.TaskModels.append(ModelData)\n                    self.simModules.add(inspect.getmodule(ModelData))\n                else:\n                    try:\n                        NewModel.bskLogger = self.bskLogger\n                    except:\n                        pass\n                    Task.TaskModels.append(NewModel)\n                    self.simModules.add(inspect.getmodule(NewModel))\n                return\n            i += 1\n        print(\"Could not find a Task with name: %(TaskName)s\" % \\\n              {\"TaskName\": TaskName})\n\n    def CreateNewProcess(self, procName, priority = -1):\n        \"\"\"\n        Creates a process and adds it to the sim\n\n        :param procName (str): Name of process\n        :param priority (int): Priority that determines when the model gets updated. (Higher number = Higher priority)\n        :return: simulationArchTypes.ProcessBaseClass object\n        \"\"\"\n        proc = simulationArchTypes.ProcessBaseClass(procName, priority)\n        self.procList.append(proc)\n        self.TotalSim.addNewProcess(proc.processData)\n        return proc\n\n    @deprecated.deprecated(\n        \"2024/04/01\",\n        \"PythonProcess and Python modules that inherit from \"\n        \"'simulationArchTypes.PythonModelClass' are deprecated. \"\n        \"See 'examples/scenarioAttitudePointingPy' for details.\",\n    )\n    def CreateNewPythonProcess(self, procName, priority = -1):\n        \"\"\"\n        Creates the python analog of a sim-level process, that exists only on the python level in self.pyProcList\n\n        :param procName (str): Name of process\n        :param priority (int): Priority that determines when the model gets updated. (Higher number = Higher priority)\n        :return: simulationArchTypes.PythonProcessClass object\n        \"\"\"\n        proc = simulationArchTypes.PythonProcessClass(procName, priority)\n        i=0;\n        for procLoc in self.pyProcList:\n            if priority > procLoc.pyProcPriority:\n                self.pyProcList.insert(i, proc)\n                return proc\n            i+=1\n        self.pyProcList.append(proc)\n        return proc\n\n    def CreateNewTask(self, TaskName, TaskRate, InputDelay=0, FirstStart=0):\n        \"\"\"\n        Creates a simulation task on the C-level with a specific update-frequency (TaskRate), an optional delay, and\n        an optional start time.\n\n        :param TaskName (str): Name of Task\n        :param TaskRate (int): Number of nanoseconds to elapse before update() is called\n        :param InputDelay (int): Number of nanoseconds simulating a lag of the particular task# TODO: Check that this is [ns]\n        :param FirstStart (int): Number of nanoseconds to elapse before task is officially enabled\n        :return: simulationArchTypes.TaskBaseClass object\n        \"\"\"\n        Task = simulationArchTypes.TaskBaseClass(TaskName, TaskRate, InputDelay, FirstStart)\n        self.TaskList.append(Task)\n        return Task\n\n    def AddVariableForLogging(self, VarName, LogPeriod=0, StartIndex=0, StopIndex=0, VarType=None):\n        \"\"\"\n        Informs the sim to log a particular variable within a message\n\n        :param VarName:   must be module tag string + period + variable name\n        :param LogPeriod: update rate at which to record the variable [ns]\n        :param StartIndex: starting index if the variable is an array\n        :param StopIndex: end index if the variable is an idea\n        :param VarType:\n        :return:\n        \"\"\"\n        SplitName = VarName.split('.')\n        Subname = '.'\n        Subname = Subname.join(SplitName[1:])\n        NoDotName = ''\n        NoDotName = NoDotName.join(SplitName)\n        tr = str.maketrans(\"\",\"\", \"[]'()\")\n        NoDotName = NoDotName.translate(tr)\n        #NoDotName = NoDotName.translate({ord(c): None for c in \"[]'()\"})\n        inv_map = {v: k for k, v in list(self.NameReplace.items())}\n        if SplitName[0] in inv_map:\n            LogName = inv_map[SplitName[0]] + '.' + Subname\n            if (LogName in self.VarLogList):\n                return\n            if (type(eval(LogName)).__name__ == 'SwigPyObject'):\n                RefFunctionString = 'def Get' + NoDotName + '(self):\\n'\n                RefFunctionString += '   return ['\n                LoopTerminate = False\n                i = 0\n                while not LoopTerminate:\n                    RefFunctionString += 'sim_model.' + VarType + 'Array_getitem('\n                    RefFunctionString += LogName + ', ' + str(StartIndex + i) + '),'\n                    i += 1\n                    if (i > StopIndex - StartIndex):\n                        LoopTerminate = True\n                RefFunctionString = RefFunctionString[:-1] + ']'\n                exec (RefFunctionString)\n                methodHandle = eval('Get' + NoDotName)\n\n            elif (type(eval(LogName)).__name__ == 'list'):\n                RefFunctionString = 'def Get' + NoDotName + '(self):\\n'\n                RefFunctionString += '   if isinstance(' + LogName + '[0], list):\\n'\n                RefFunctionString += '      localList = sum(' + LogName + ',[])\\n'\n                RefFunctionString += '   else:\\n      localList = ' + LogName + '\\n'\n                RefFunctionString += '   return ['\n                LoopTerminate = False\n                i = 0\n                while not LoopTerminate:\n                    RefFunctionString +=  'localList[' + str(StartIndex + i) + '],'\n                    i += 1\n                    if (i > StopIndex - StartIndex):\n                        LoopTerminate = True\n                RefFunctionString = RefFunctionString[:-1] + ']'\n                exec (RefFunctionString)\n                methodHandle = eval('Get' + NoDotName)\n            else:\n                RefFunctionString = 'def Get' + NoDotName + '(self):\\n'\n                RefFunctionString += '   return ' + LogName\n                exec (RefFunctionString)\n                methodHandle = eval('Get' + NoDotName)\n            self.VarLogList[VarName] = LogBaseClass(LogName, LogPeriod,\n                                                    methodHandle, StopIndex - StartIndex + 1)\n        else:\n            print(\"Could not find a structure that has the ModelTag: %(ModName)s\" % \\\n                  {\"ModName\": SplitName[0]})\n\n    def ResetTask(self, taskName):\n        for Task in self.TaskList:\n            if Task.Name == taskName:\n                Task.resetTask(self.TotalSim.CurrentNanos)\n\n    def InitializeSimulation(self):\n        \"\"\"\n        Initialize the BSK simulation.  This runs the SelfInit() and Reset() methods on each module.\n        \"\"\"\n        if(self.simulationInitialized):\n            self.TotalSim.resetThreads(self.TotalSim.getThreadCount())\n        self.TotalSim.assignRemainingProcs()\n        self.TotalSim.ResetSimulation()\n        self.TotalSim.selfInitSimulation()\n        for proc in self.pyProcList:\n            proc.selfInitProcess()\n        self.TotalSim.resetInitSimulation()\n        for proc in self.pyProcList:\n            proc.resetProcess(0)\n        for LogItem, LogValue in self.VarLogList.items():\n            LogValue.clearItem()\n        self.simulationInitialized = True\n\n\n    def ConfigureStopTime(self, TimeStop):\n        \"\"\"\n        Set the simulation stop time in nano-seconds.\n        \"\"\"\n        self.StopTime = TimeStop\n\n    def RecordLogVars(self):\n        CurrSimTime = self.TotalSim.CurrentNanos\n        minNextTime = -1\n        for LogItem, LogValue in self.VarLogList.items():\n            LocalPrev = LogValue.PrevLogTime\n            if (LocalPrev != None and (CurrSimTime -\n                                           LocalPrev) < LogValue.Period):\n                if(minNextTime < 0 or LocalPrev + LogValue.Period < minNextTime):\n                    minNextTime = LocalPrev + LogValue.Period\n                continue\n            CurrentVal = LogValue.CallableFunction(self)\n            LocalTimeVal = LogValue.TimeValuePairs\n            if (LocalPrev != CurrentVal):\n                LocalTimeVal.append(CurrSimTime)\n                try:\n                    temp = (len(CurrentVal))\n                    for Value in CurrentVal:\n                        LocalTimeVal.append(Value)\n                except TypeError:\n                    LocalTimeVal.append(CurrentVal)\n                LogValue.PrevLogTime = CurrSimTime\n                LogValue.PrevValue = CurrentVal\n                if(minNextTime < 0 or CurrSimTime + LogValue.Period < minNextTime):\n                    minNextTime = CurrSimTime + LogValue.Period\n        return minNextTime\n\n    def ExecuteSimulation(self):\n        \"\"\"\n        run the simulation until the prescribed stop time or termination.\n        \"\"\"\n        self.initializeEventChecks()\n\n        nextStopTime = self.TotalSim.NextTaskTime\n        nextPriority = -1\n        pyProcPresent = False\n        if len(self.pyProcList) > 0:\n            nextPriority = self.pyProcList[0].pyProcPriority\n            pyProcPresent = True\n            nextStopTime = self.pyProcList[0].nextCallTime()\n        progressBar = SimulationProgressBar(self.StopTime, self.showProgressBar)\n        while self.TotalSim.NextTaskTime <= self.StopTime and not self.terminate:\n            if self.TotalSim.CurrentNanos >= self.nextEventTime >= 0:\n                self.nextEventTime = self.checkEvents()\n                self.nextEventTime = self.nextEventTime if self.nextEventTime >= self.TotalSim.NextTaskTime else self.TotalSim.NextTaskTime\n            if 0 <= self.nextEventTime < nextStopTime:\n                nextStopTime = self.nextEventTime\n                nextPriority = -1\n            self.TotalSim.StepUntilStop(nextStopTime, nextPriority)\n            progressBar.update(self.TotalSim.NextTaskTime)\n            nextPriority = -1\n            nextStopTime = self.StopTime\n            nextLogTime = self.RecordLogVars()\n            procStopTimes = []\n            for pyProc in self.pyProcList:\n                nextCallTime = pyProc.nextCallTime()\n                if nextCallTime <= self.TotalSim.CurrentNanos:\n                    pyProc.executeTaskList(self.TotalSim.CurrentNanos)\n                nextCallTime = pyProc.nextCallTime()\n                procStopTimes.append(nextCallTime)\n\n            if pyProcPresent and nextStopTime >= min(procStopTimes):\n                nextStopTime = min(procStopTimes)\n                nextPriority = self.pyProcList[procStopTimes.index(nextStopTime)].pyProcPriority\n            if 0 <= nextLogTime < nextStopTime:\n                nextStopTime = nextLogTime\n                nextPriority = -1\n            nextStopTime = nextStopTime if nextStopTime >= self.TotalSim.NextTaskTime else self.TotalSim.NextTaskTime\n        self.terminate = False\n        progressBar.markComplete()\n        progressBar.close()\n\n    def GetLogVariableData(self, LogName):\n        \"\"\"\n        Pull the recorded module recorded variable.  The first column is the variable recording time in\n        nano-seconds, the additional column(s) are the message data columns.\n        \"\"\"\n        TheArray = np.array(self.VarLogList[LogName].TimeValuePairs)\n        ArrayDim = self.VarLogList[LogName].ArrayDim\n        TheArray = np.reshape(TheArray, (TheArray.shape[0] // ArrayDim, ArrayDim))\n        return TheArray\n\n    def disableTask(self, TaskName):\n        \"\"\"\n        Disable this particular task from being executed.\n        \"\"\"\n        for Task in self.TaskList:\n            if Task.Name == TaskName:\n                Task.disable()\n\n    def enableTask(self, TaskName):\n        \"\"\"\n        Enable this particular task to be executed.\n        \"\"\"\n        for Task in self.TaskList:\n            if Task.Name == TaskName:\n                Task.enable()\n\n    def parseDataIndex(self):\n        self.dataStructureDictionary = {}\n        try:\n            xmlData = ET.parse(self.dataStructIndex)\n        except:\n            print(\"Failed to parse the XML index.  Likely that it isn't present\")\n            return\n        root = xmlData.getroot()\n        for child in root:\n            newStruct = StructDocData(child.attrib['refid'])\n            self.dataStructureDictionary.update({child.find('name').text:\n                                                     newStruct})\n        self.indexParsed = True\n\n    def createNewEvent(self, eventName, eventRate=int(1E9), eventActive=False,\n                       conditionList=[], actionList=[], terminal=False):\n        \"\"\"\n        Create an event sequence that contains a series of tasks to be executed.\n        \"\"\"\n        if (eventName in list(self.eventMap.keys())):\n            return\n        newEvent = EventHandlerClass(eventName, eventRate, eventActive,\n                                     conditionList, actionList, terminal)\n        self.eventMap.update({eventName: newEvent})\n\n    def initializeEventChecks(self):\n        self.eventList = []\n        for key, value in self.eventMap.items():\n            value.methodizeEvent()\n            self.eventList.append(value)\n        self.nextEventTime = 0\n\n    def checkEvents(self):\n        nextTime = -1\n        for localEvent in self.eventList:\n            localNextTime = localEvent.checkEvent(self)\n            if(localNextTime >= 0 and (localNextTime < nextTime or nextTime <0)):\n                nextTime = localNextTime\n        return nextTime\n\n    def setEventActivity(self, eventName, activityCommand):\n        if eventName not in list(self.eventMap.keys()):\n            print(\"You asked me to set the status of an event that I don't have.\")\n            return\n        self.eventMap[eventName].eventActive = activityCommand\n\n    def setAllButCurrentEventActivity(self, currentEventName, activityCommand, useIndex=False):\n        \"\"\"Set all event activity variables except for the currentEventName event. The ``useIndex`` flag can be used to\n        prevent enabling or disabling every task, and instead only alter the ones that belong to the same group (for\n        example, the same spacecraft). The distinction is made through an index set after the ``_`` symbol in the event\n        name. All events of the same group must have the same index.\"\"\"\n\n        if useIndex:\n            index = currentEventName.partition('_')[2]  # save the current event's index\n\n        for eventName in list(self.eventMap.keys()):\n            if currentEventName != eventName:\n                if useIndex:\n                    if eventName.partition('_')[2] == index:\n                        self.eventMap[eventName].eventActive = activityCommand\n                else:\n                    self.eventMap[eventName].eventActive = activityCommand\n\n    def setModelDataWrap(self, modelData):\n        \"\"\"\n        Takes a module and returns an object that provides access to said module's SelfInit, Update, and Reset\n        methods.\n\n        Takes the module instance, collects all SwigPyObjects generated from the .i file (SelfInit,\n        Update and Reset), and attaches it to a alg_contain model instance so the modules standard functions can be\n        run at the python level.\n\n        :param modelData: model to gather functions for\n        :return: An alg_contain model that provides access to the original model's core functions\n        \"\"\"\n        deprecationId = f\"{SimBaseClass.setModelDataWrap.__module__}.{SimBaseClass.setModelDataWrap.__qualname__}\"\n        removalDate = \"2024/07/30\"\n\n        if hasattr(modelData, \"createWrapper\"):\n            deprecated.deprecationWarn(\n                deprecationId,\n                removalDate,\n                \"C modules no longer require having separate 'Config' and 'Wrap' objects. \"\n                \"Treat C modules like C++ modules. For example, instead of:\\n\"\n                \"\\tinertial3DConfig = inertial3D.inertial3DConfig()\\n\"\n                \"\\tinertial3DWrap = scSim.setModelDataWrap(inertial3DConfig)\\n\"\n                \"\\tinertial3DWrap.ModelTag = 'inertial3D'\\n\"\n                \"\\tscSim.AddModelToTask(simTaskName, inertial3DWrap, inertial3DConfig, 10)\\n\"\n                \"Do:\\n\"\n                \"\\tinertial3D = inertial3D.inertial3D()\\n\"\n                \"\\tinertial3D.ModelTag = 'inertial3D'\\n\"\n                \"\\tscSim.AddModelToTask(simTaskName, inertial3D, 10)\\n\"\n            )\n            return modelData.createWrapper()\n    \n        deprecated.deprecationWarn(\n            deprecationId, \n            removalDate, \n            \"This C module has not been converted yet to the new way of defining C \"\n            \"modules, which makes using them more intuitive. Take the time to see how \"\n            \"the new C module '.i' file looks by checking out a default Basilisk module\"\n            \" and adapt your module to use a similar format.\"\n        )\n\n        algDict = {}\n        STR_SELFINIT = 'SelfInit'\n        STR_UPDATE = 'Update'\n        STR_RESET = 'Reset'\n\n        # SwigPyObject's Parsing:\n        # Collect all the SwigPyObjects present in the list. Only the methods SelfInit, Update and Restart\n        # are wrapped by Swig in the .i files. Therefore they are the only SwigPyObjects\n        def parseDirList(dirList):\n            algNames = []\n            for methodName in dirList:\n                methodObject = eval('sys.modules[\"' + module + '\"].' + methodName)\n                if type(methodObject).__name__ == \"SwigPyObject\":\n                    algNames.append(methodName)\n            return algNames\n\n        # Check the type of the algorithm, i.e. SelfInit, Update or Reset,\n        # and return the key to create a new dictionary D[str_method] = method\n        def checkMethodType(methodName):\n            if methodName[0:len(STR_SELFINIT)] == STR_SELFINIT:\n                return STR_SELFINIT\n            elif methodName[0:len(STR_UPDATE)] == STR_UPDATE:\n                return STR_UPDATE\n            elif methodName[0:len(STR_RESET)] == STR_RESET:\n                return STR_RESET\n            else:\n                raise ValueError('Cannot recognize the method'\n                                 '(I only assess SelfInit, Update and Reset methods). '\n                                 'Parse better.')\n\n        module = modelData.__module__\n        sysMod = sys.modules[module]\n        dirList = dir(sysMod)\n        algList = parseDirList(dirList)\n\n        # if the package has different levels we need to access the correct level of the package\n        currMod = __import__(module, globals(), locals(), [], 0)\n\n        moduleString = \"currMod.\"\n        moduleNames = module.split(\".\")\n        if len(moduleNames) > 1:\n            moduleString += \".\".join(moduleNames[1:]) + \".\"\n\n        for alg in algList:\n            key = checkMethodType(alg)\n            algDict[key] = alg\n\n        update = eval(moduleString + algDict[STR_UPDATE])\n        selfInit = eval(moduleString + algDict[STR_SELFINIT])\n        try:\n            resetArg = algDict[STR_RESET]\n            reset = eval(moduleString + resetArg)\n            modelWrap = alg_contain.AlgContain(modelData, update, selfInit, reset)\n        except:\n            modelWrap = alg_contain.AlgContain(modelData, update, selfInit)\n        return modelWrap",
  "def SetCArray(InputList, VarType, ArrayPointer):\n    if(isinstance(ArrayPointer, (list, tuple))):\n        raise TypeError('Cannot set a C array if it is actually a python list.  Just assign the variable to the list directly.')\n    CmdString = 'sim_model.' + VarType + 'Array_setitem(ArrayPointer, CurrIndex, CurrElem)'\n    CurrIndex = 0\n    for CurrElem in InputList:\n        exec (CmdString)\n        CurrIndex += 1",
  "def getCArray(varType, arrayPointer, arraySize):\n    CmdString = 'outputList.append(sim_model.' + varType + 'Array_getitem(arrayPointer, currIndex))'\n    outputList = []\n    currIndex = 0\n    for currIndex in range(arraySize):\n        exec (CmdString)\n        currIndex += 1\n    return outputList",
  "def synchronizeTimeHistories(arrayList):\n    returnArrayList = arrayList\n    timeCounter = 0\n    for i in range(len(returnArrayList)):\n        while returnArrayList[i][0,0] > returnArrayList[0][timeCounter,0]:\n            timeCounter += 1\n    for i in range(len(returnArrayList)):\n        while(returnArrayList[i][1,0] < returnArrayList[0][timeCounter,0]):\n            returnArrayList[i] = np.delete(returnArrayList[i], 0, 0)\n\n    timeCounter = -1\n    for i in range(len(returnArrayList)):\n        while returnArrayList[i][-1,0] < returnArrayList[0][timeCounter,0]:\n                timeCounter -= 1\n    for i in range(len(returnArrayList)):\n        while(returnArrayList[i][-2,0] > returnArrayList[0][timeCounter,0]):\n            returnArrayList[i] = np.delete(returnArrayList[i], -1, 0)\n\n    timeNow = returnArrayList[0][0,0] #Desirement is to have synched arrays match primary time\n    outputArrayList = []\n    indexPrev = [0]*len(returnArrayList)\n    outputArrayList = [[]]*len(returnArrayList)\n    timeNow = returnArrayList[0][0,0]\n\n    outputArrayList[0] = returnArrayList[0][0:-2, :]\n    for i in range(1, returnArrayList[0].shape[0]-1):\n        for j in range(1, len(returnArrayList)):\n            while(returnArrayList[j][indexPrev[j]+1,0] < returnArrayList[0][i,0]):\n                indexPrev[j] += 1\n\n            dataProp = returnArrayList[j][indexPrev[j]+1,1:] - returnArrayList[j][indexPrev[j],1:]\n            dataProp *= (timeNow - returnArrayList[j][indexPrev[j],0])/(returnArrayList[j][indexPrev[j]+1,0] - returnArrayList[j][indexPrev[j],0])\n            dataProp += returnArrayList[j][indexPrev[j],1:]\n            dataRow = [timeNow]\n            dataRow.extend(dataProp.tolist())\n            outputArrayList[j].append(dataRow)\n        timePrevious = timeNow\n        timeNow = returnArrayList[0][i,0]\n    for j in range(1, len(returnArrayList)):\n        outputArrayList[j] = np.array(outputArrayList[j])\n\n    return outputArrayList",
  "def __init__(self, ReplaceName, LogPeriod, RefFunction, DataCols=1):\n        self.Period = LogPeriod\n        self.Name = ReplaceName\n        self.PrevLogTime = None\n        self.PrevValue = None\n        self.TimeValuePairs = array.array('d')\n        self.ArrayDim = DataCols + 1\n        self.CallableFunction = RefFunction",
  "def clearItem(self):\n        self.TimeValuePairs = array.array('d')\n        self.PrevLogTime = None\n        self.PrevValue = None",
  "def __init__(self, eventName, eventRate=int(1E9), eventActive=False,\n                 conditionList=[], actionList=[], terminal=False):\n        self.eventName = eventName\n        self.eventActive = eventActive\n        self.eventRate = eventRate\n        self.conditionList = conditionList\n        self.actionList = actionList\n        self.occurCounter = 0\n        self.prevTime = -1\n        self.checkCall = None\n        self.operateCall = None\n        self.terminal = terminal",
  "def methodizeEvent(self):\n        if self.checkCall != None:\n            return\n        funcString = 'def EVENT_check_' + self.eventName + '(self):\\n'\n        funcString += '    if('\n        for condValue in self.conditionList:\n            funcString += ' ' + condValue + ' and'\n        funcString = funcString[:-3] + '):\\n'\n        funcString += '        return 1\\n'\n        funcString += '    return 0'\n\n        exec (funcString)\n        self.checkCall = eval('EVENT_check_' + self.eventName)\n        funcString = 'def EVENT_operate_' + self.eventName + '(self):\\n'\n        for actionValue in self.actionList:\n            funcString += '    '\n            funcString += actionValue + '\\n'\n        funcString += '    return 0'\n        exec (funcString)\n        self.operateCall = eval('EVENT_operate_' + self.eventName)",
  "def checkEvent(self, parentSim):\n        nextTime = int(-1)\n        if self.eventActive == False:\n            return(nextTime)\n        nextTime = self.prevTime + self.eventRate - (self.prevTime%self.eventRate)\n        if self.prevTime < 0 or (parentSim.TotalSim.CurrentNanos%self.eventRate == 0):\n            nextTime = parentSim.TotalSim.CurrentNanos + self.eventRate\n            eventCount = self.checkCall(parentSim)\n            self.prevTime = parentSim.TotalSim.CurrentNanos\n            if eventCount > 0:\n                self.eventActive = False\n                self.operateCall(parentSim)\n                self.occurCounter += 1\n                if self.terminal:\n                    parentSim.terminate = True\n        return(nextTime)",
  "class StructElementDef:\n        def __init__(self, type, name, argstring, desc=''):\n            self.type = type\n            self.name = name\n            self.argstring = argstring\n            self.desc = desc",
  "def __init__(self, strName):\n        self.strName = strName\n        self.structPopulated = False\n        self.structElements = {}",
  "def clearItem(self):\n        self.structPopulated = False\n        self.structElements = {}",
  "def populateElem(self, xmlSearchPath):\n        if self.structPopulated == True:\n            return\n        xmlFileUse = xmlSearchPath + '/' + self.strName + '.xml'\n        try:\n            xmlData = ET.parse(xmlFileUse)\n        except:\n            print(\"Failed to parse the XML structure for: \" + self.strName)\n            print(\"This file does not exist most likely: \" + xmlFileUse)\n            return\n        root = xmlData.getroot()\n        validElement = root.find(\"./compounddef[@id='\" + self.strName + \"']\")\n        for newVariable in validElement.findall(\".//memberdef[@kind='variable']\"):\n            typeUse = newVariable.find('type').text if newVariable.find('type') is not None else \\\n                None\n            nameUse = newVariable.find('name').text if newVariable.find('type') is not None else \\\n                None\n            argstringUse = newVariable.find('argsstring').text if newVariable.find('argsstring') is not None else \\\n                None\n            descUse = newVariable.find('./detaileddescription/para').text if newVariable.find(\n                './detaileddescription/para') is not None else \\\n                None\n            if descUse == None:\n                descUse = newVariable.find('./briefdescription/para').text if newVariable.find(\n                    './briefdescription/para') is not None else \\\n                    None\n            newElement = StructDocData.StructElementDef(typeUse, nameUse, argstringUse, descUse)\n            self.structElements.update({nameUse: newElement})\n            self.structPopulated = True",
  "def printElem(self):\n        print(\"    \" + self.strName + \" Structure Elements:\")\n        for key, value in self.structElements.items():\n            outputString = ''\n            outputString += value.type + \" \" + value.name\n            outputString += value.argstring if value.argstring is not None else ''\n            outputString += ': ' + value.desc if value.desc is not None else ''\n        print(\"      \" + outputString)",
  "def __init__(self):\n        self.outputMessages = set([])\n        self.inputMessages = set([])\n        self.name = \"\"\n        self.outputDict = {}",
  "def __init__(self):\n        self.TotalSim = sim_model.SimModel()\n        self.TaskList = []\n        self.procList = []\n        self.pyProcList = []\n        self.StopTime = 0\n        self.nextEventTime = 0\n        self.terminate = False\n        self.NameReplace = {}\n        self.VarLogList = {}\n        self.eventMap = {}\n        self.simModules = set()\n        self.simBasePath = os.path.dirname(os.path.realpath(__file__)) + '/../'\n        self.dataStructIndex = self.simBasePath + '/xml/index.xml'\n        self.indexParsed = False\n        self.simulationInitialized = False\n        self.simulationFinished = False\n        self.bskLogger = bskLogging.BSKLogger()\n        self.showProgressBar = False\n        self.allModules = set()",
  "def SetProgressBar(self, value):\n        \"\"\"\n        Shows a dynamic progress in the terminal while the simulation is executing.\n        \"\"\"\n        self.showProgressBar = value",
  "def ShowExecutionOrder(self):\n        \"\"\"\n        Shows in what order the Basilisk processes, task lists and modules are executed\n        \"\"\"\n\n        for processData in self. TotalSim.processList:\n            print(f\"{processColor}Process Name: {endColor}\" + processData.processName +\n                  \" , \" + processColor + \"priority: \" + endColor + str(processData.processPriority))\n            for task in processData.processTasks:\n                print(f\"{taskColor}Task Name: {endColor}\" + task.TaskPtr.TaskName +\n                      \", \" + taskColor + \"priority: \" + endColor + str(task.taskPriority) +\n                      \", \" + taskColor + \"TaskPeriod: \" + endColor + str(task.TaskPtr.TaskPeriod/1.0e9) + \"s\")\n                for module in task.TaskPtr.TaskModels:\n                    print(moduleColor + \"ModuleTag: \" + endColor + module.ModelPtr.ModelTag +\n                          \", \" + moduleColor + \"priority: \" + endColor + str(module.CurrentModelPriority))\n            print(\"\")\n\n        for pyProc in self.pyProcList:\n            print(f\"{processColor}PyProcess Name: {endColor}\" + pyProc.Name +\n                  \" , \" + processColor + \"priority: \" + endColor + str(pyProc.pyProcPriority))\n            for task in pyProc.taskList:\n                print(f\"{taskColor}PyTask Name: {endColor}\" + task.name +\n                      \", \" + taskColor + \"priority: \" + endColor + str(task.priority) +\n                      \", \" + taskColor + \"TaskPeriod: \" + endColor + str(task.rate / 1.0e9) + \"s\")\n                for module in task.modelList:\n                    print(moduleColor + \"PyModuleTag: \" + endColor + module.modelName +\n                          \", \" + moduleColor + \"priority: \" + endColor + str(module.modelPriority))\n            print(\"\")",
  "def ShowExecutionFigure(self, show_plots=False):\n        \"\"\"\n        Shows in what order the Basilisk processes, task lists and modules are executed\n        \"\"\"\n        processList = OrderedDict()\n        for processData in self. TotalSim.processList:\n            taskList = OrderedDict()\n            for task in processData.processTasks:\n                moduleList = []\n                for module in task.TaskPtr.TaskModels:\n                    moduleList.append(module.ModelPtr.ModelTag + \" (\" + str(module.CurrentModelPriority) + \")\")\n                taskList[task.TaskPtr.TaskName + \" (\" + str(task.taskPriority) + \", \" + str(task.TaskPtr.TaskPeriod/1.0e9) + \"s)\"] = moduleList\n            processList[processData.processName + \" (\" + str(processData.processPriority) + \")\"] = taskList\n\n        for pyProc in self.pyProcList:\n            taskList = OrderedDict()\n            for task in pyProc.taskList:\n                moduleList = []\n                for module in task.modelList:\n                    moduleList.append(module.modelName + \" (\" + str(module.modelPriority) + \")\")\n                taskList[task.name + \" (\" + str(task.priority) + \", \" + str(\n                    task.rate / 1.0e9) + \"s)\"] = moduleList\n            processList[pyProc.Name + \" (\" + str(pyProc.pyProcPriority) + \")\"] = taskList\n\n        fig = plt.figure()\n        plt.rcParams.update({'font.size': 8})\n        plt.axis('off')\n\n        processNo = 0\n        processWidth = 6\n        lineHeight = 0.5\n        textBuffer = lineHeight*0.75\n        textIndent = lineHeight*0.25\n        processGap = 0.5\n        for process in processList:\n            # Draw process box + priority\n            rectangle = plt.Rectangle(((processWidth+processGap)*processNo, 0), processWidth, -lineHeight, ec='g', fc='g')\n            plt.gca().add_patch(rectangle)\n            plt.text((processWidth+processGap)*processNo + textIndent, -textBuffer, process, color='w')\n\n            taskNo = 0\n            currentLine = -lineHeight - textIndent\n            for task in processList[process]:\n                # Draw task box + priority + task rate\n                rectangle = plt.Rectangle(((processWidth + processGap) * processNo + textIndent, currentLine)\n                                          , processWidth - 2 * textIndent\n                                          , - (1+len(processList[process][task])) * (lineHeight + textIndent),\n                                          ec='y', fc=(1,1,1,0))\n                plt.gca().add_patch(rectangle)\n                rectangle = plt.Rectangle(((processWidth + processGap) * processNo + textIndent, currentLine)\n                                          , processWidth - 2 * textIndent, -lineHeight,\n                                          ec='y', fc='y')\n                plt.gca().add_patch(rectangle)\n                plt.text((processWidth + processGap) * processNo + 2*textIndent,\n                         currentLine-textBuffer, task, color='black')\n\n                for module in processList[process][task]:\n                    # Draw modules + priority\n                    currentLine -= lineHeight + textIndent\n                    rectangle = plt.Rectangle(((processWidth + processGap) * processNo + 2*textIndent, currentLine)\n                                              , processWidth - 4 * textIndent, -lineHeight,\n                                              ec='c', fc=(1,1,1,0))\n                    plt.gca().add_patch(rectangle)\n                    plt.text((processWidth + processGap) * processNo + 3*textIndent,\n                             currentLine-textBuffer, module, color='black')\n\n                taskNo += 1\n                currentLine -=  lineHeight + 2 * textIndent\n\n            rectangle = plt.Rectangle(((processWidth+processGap)*processNo, 0), processWidth, currentLine, ec='g', fc=(1,1,1,0))\n            plt.gca().add_patch(rectangle)\n            processNo += 1\n\n        plt.axis('scaled')\n\n        if show_plots:\n            plt.show()\n\n        return fig",
  "def AddModelToTask(self, TaskName, NewModel, ModelData=None, ModelPriority=-1):\n        \"\"\"\n        This function is responsible for passing on the logger to a module instance (model), adding the\n        model to a particular task, and defining\n        the order/priority that the model gets updated within the task.\n\n        :param TaskName (str): Name of the task\n        :param NewModel (obj): Model to add to the task\n        :param ModelData: None or struct containing, only used for C BSK modules\n        :param ModelPriority (int): Priority that determines when the model gets updated. (Higher number = Higher priority)\n        :return:\n        \"\"\"\n        # Supports calling AddModelToTask(TaskName, NewModel, ModelPriority)\n        if isinstance(ModelData, int):\n            ModelPriority = ModelData\n            ModelData = None\n\n        i = 0\n        for Task in self.TaskList:\n            if Task.Name == TaskName:\n                Task.TaskData.AddNewObject(NewModel, ModelPriority)\n                TaskReplaceTag = 'self.TaskList[' + str(i) + ']'\n                TaskReplaceTag += '.TaskModels[' + str(len(Task.TaskModels)) + ']'\n                self.NameReplace[TaskReplaceTag] = NewModel.ModelTag\n                if ModelData is not None:\n                    try:\n                        ModelData.bskLogger = self.bskLogger\n                    except:\n                        pass\n                    Task.TaskModels.append(ModelData)\n                    self.simModules.add(inspect.getmodule(ModelData))\n                else:\n                    try:\n                        NewModel.bskLogger = self.bskLogger\n                    except:\n                        pass\n                    Task.TaskModels.append(NewModel)\n                    self.simModules.add(inspect.getmodule(NewModel))\n                return\n            i += 1\n        print(\"Could not find a Task with name: %(TaskName)s\" % \\\n              {\"TaskName\": TaskName})",
  "def CreateNewProcess(self, procName, priority = -1):\n        \"\"\"\n        Creates a process and adds it to the sim\n\n        :param procName (str): Name of process\n        :param priority (int): Priority that determines when the model gets updated. (Higher number = Higher priority)\n        :return: simulationArchTypes.ProcessBaseClass object\n        \"\"\"\n        proc = simulationArchTypes.ProcessBaseClass(procName, priority)\n        self.procList.append(proc)\n        self.TotalSim.addNewProcess(proc.processData)\n        return proc",
  "def CreateNewPythonProcess(self, procName, priority = -1):\n        \"\"\"\n        Creates the python analog of a sim-level process, that exists only on the python level in self.pyProcList\n\n        :param procName (str): Name of process\n        :param priority (int): Priority that determines when the model gets updated. (Higher number = Higher priority)\n        :return: simulationArchTypes.PythonProcessClass object\n        \"\"\"\n        proc = simulationArchTypes.PythonProcessClass(procName, priority)\n        i=0;\n        for procLoc in self.pyProcList:\n            if priority > procLoc.pyProcPriority:\n                self.pyProcList.insert(i, proc)\n                return proc\n            i+=1\n        self.pyProcList.append(proc)\n        return proc",
  "def CreateNewTask(self, TaskName, TaskRate, InputDelay=0, FirstStart=0):\n        \"\"\"\n        Creates a simulation task on the C-level with a specific update-frequency (TaskRate), an optional delay, and\n        an optional start time.\n\n        :param TaskName (str): Name of Task\n        :param TaskRate (int): Number of nanoseconds to elapse before update() is called\n        :param InputDelay (int): Number of nanoseconds simulating a lag of the particular task# TODO: Check that this is [ns]\n        :param FirstStart (int): Number of nanoseconds to elapse before task is officially enabled\n        :return: simulationArchTypes.TaskBaseClass object\n        \"\"\"\n        Task = simulationArchTypes.TaskBaseClass(TaskName, TaskRate, InputDelay, FirstStart)\n        self.TaskList.append(Task)\n        return Task",
  "def AddVariableForLogging(self, VarName, LogPeriod=0, StartIndex=0, StopIndex=0, VarType=None):\n        \"\"\"\n        Informs the sim to log a particular variable within a message\n\n        :param VarName:   must be module tag string + period + variable name\n        :param LogPeriod: update rate at which to record the variable [ns]\n        :param StartIndex: starting index if the variable is an array\n        :param StopIndex: end index if the variable is an idea\n        :param VarType:\n        :return:\n        \"\"\"\n        SplitName = VarName.split('.')\n        Subname = '.'\n        Subname = Subname.join(SplitName[1:])\n        NoDotName = ''\n        NoDotName = NoDotName.join(SplitName)\n        tr = str.maketrans(\"\",\"\", \"[]'()\")\n        NoDotName = NoDotName.translate(tr)\n        #NoDotName = NoDotName.translate({ord(c): None for c in \"[]'()\"})\n        inv_map = {v: k for k, v in list(self.NameReplace.items())}\n        if SplitName[0] in inv_map:\n            LogName = inv_map[SplitName[0]] + '.' + Subname\n            if (LogName in self.VarLogList):\n                return\n            if (type(eval(LogName)).__name__ == 'SwigPyObject'):\n                RefFunctionString = 'def Get' + NoDotName + '(self):\\n'\n                RefFunctionString += '   return ['\n                LoopTerminate = False\n                i = 0\n                while not LoopTerminate:\n                    RefFunctionString += 'sim_model.' + VarType + 'Array_getitem('\n                    RefFunctionString += LogName + ', ' + str(StartIndex + i) + '),'\n                    i += 1\n                    if (i > StopIndex - StartIndex):\n                        LoopTerminate = True\n                RefFunctionString = RefFunctionString[:-1] + ']'\n                exec (RefFunctionString)\n                methodHandle = eval('Get' + NoDotName)\n\n            elif (type(eval(LogName)).__name__ == 'list'):\n                RefFunctionString = 'def Get' + NoDotName + '(self):\\n'\n                RefFunctionString += '   if isinstance(' + LogName + '[0], list):\\n'\n                RefFunctionString += '      localList = sum(' + LogName + ',[])\\n'\n                RefFunctionString += '   else:\\n      localList = ' + LogName + '\\n'\n                RefFunctionString += '   return ['\n                LoopTerminate = False\n                i = 0\n                while not LoopTerminate:\n                    RefFunctionString +=  'localList[' + str(StartIndex + i) + '],'\n                    i += 1\n                    if (i > StopIndex - StartIndex):\n                        LoopTerminate = True\n                RefFunctionString = RefFunctionString[:-1] + ']'\n                exec (RefFunctionString)\n                methodHandle = eval('Get' + NoDotName)\n            else:\n                RefFunctionString = 'def Get' + NoDotName + '(self):\\n'\n                RefFunctionString += '   return ' + LogName\n                exec (RefFunctionString)\n                methodHandle = eval('Get' + NoDotName)\n            self.VarLogList[VarName] = LogBaseClass(LogName, LogPeriod,\n                                                    methodHandle, StopIndex - StartIndex + 1)\n        else:\n            print(\"Could not find a structure that has the ModelTag: %(ModName)s\" % \\\n                  {\"ModName\": SplitName[0]})",
  "def ResetTask(self, taskName):\n        for Task in self.TaskList:\n            if Task.Name == taskName:\n                Task.resetTask(self.TotalSim.CurrentNanos)",
  "def InitializeSimulation(self):\n        \"\"\"\n        Initialize the BSK simulation.  This runs the SelfInit() and Reset() methods on each module.\n        \"\"\"\n        if(self.simulationInitialized):\n            self.TotalSim.resetThreads(self.TotalSim.getThreadCount())\n        self.TotalSim.assignRemainingProcs()\n        self.TotalSim.ResetSimulation()\n        self.TotalSim.selfInitSimulation()\n        for proc in self.pyProcList:\n            proc.selfInitProcess()\n        self.TotalSim.resetInitSimulation()\n        for proc in self.pyProcList:\n            proc.resetProcess(0)\n        for LogItem, LogValue in self.VarLogList.items():\n            LogValue.clearItem()\n        self.simulationInitialized = True",
  "def ConfigureStopTime(self, TimeStop):\n        \"\"\"\n        Set the simulation stop time in nano-seconds.\n        \"\"\"\n        self.StopTime = TimeStop",
  "def RecordLogVars(self):\n        CurrSimTime = self.TotalSim.CurrentNanos\n        minNextTime = -1\n        for LogItem, LogValue in self.VarLogList.items():\n            LocalPrev = LogValue.PrevLogTime\n            if (LocalPrev != None and (CurrSimTime -\n                                           LocalPrev) < LogValue.Period):\n                if(minNextTime < 0 or LocalPrev + LogValue.Period < minNextTime):\n                    minNextTime = LocalPrev + LogValue.Period\n                continue\n            CurrentVal = LogValue.CallableFunction(self)\n            LocalTimeVal = LogValue.TimeValuePairs\n            if (LocalPrev != CurrentVal):\n                LocalTimeVal.append(CurrSimTime)\n                try:\n                    temp = (len(CurrentVal))\n                    for Value in CurrentVal:\n                        LocalTimeVal.append(Value)\n                except TypeError:\n                    LocalTimeVal.append(CurrentVal)\n                LogValue.PrevLogTime = CurrSimTime\n                LogValue.PrevValue = CurrentVal\n                if(minNextTime < 0 or CurrSimTime + LogValue.Period < minNextTime):\n                    minNextTime = CurrSimTime + LogValue.Period\n        return minNextTime",
  "def ExecuteSimulation(self):\n        \"\"\"\n        run the simulation until the prescribed stop time or termination.\n        \"\"\"\n        self.initializeEventChecks()\n\n        nextStopTime = self.TotalSim.NextTaskTime\n        nextPriority = -1\n        pyProcPresent = False\n        if len(self.pyProcList) > 0:\n            nextPriority = self.pyProcList[0].pyProcPriority\n            pyProcPresent = True\n            nextStopTime = self.pyProcList[0].nextCallTime()\n        progressBar = SimulationProgressBar(self.StopTime, self.showProgressBar)\n        while self.TotalSim.NextTaskTime <= self.StopTime and not self.terminate:\n            if self.TotalSim.CurrentNanos >= self.nextEventTime >= 0:\n                self.nextEventTime = self.checkEvents()\n                self.nextEventTime = self.nextEventTime if self.nextEventTime >= self.TotalSim.NextTaskTime else self.TotalSim.NextTaskTime\n            if 0 <= self.nextEventTime < nextStopTime:\n                nextStopTime = self.nextEventTime\n                nextPriority = -1\n            self.TotalSim.StepUntilStop(nextStopTime, nextPriority)\n            progressBar.update(self.TotalSim.NextTaskTime)\n            nextPriority = -1\n            nextStopTime = self.StopTime\n            nextLogTime = self.RecordLogVars()\n            procStopTimes = []\n            for pyProc in self.pyProcList:\n                nextCallTime = pyProc.nextCallTime()\n                if nextCallTime <= self.TotalSim.CurrentNanos:\n                    pyProc.executeTaskList(self.TotalSim.CurrentNanos)\n                nextCallTime = pyProc.nextCallTime()\n                procStopTimes.append(nextCallTime)\n\n            if pyProcPresent and nextStopTime >= min(procStopTimes):\n                nextStopTime = min(procStopTimes)\n                nextPriority = self.pyProcList[procStopTimes.index(nextStopTime)].pyProcPriority\n            if 0 <= nextLogTime < nextStopTime:\n                nextStopTime = nextLogTime\n                nextPriority = -1\n            nextStopTime = nextStopTime if nextStopTime >= self.TotalSim.NextTaskTime else self.TotalSim.NextTaskTime\n        self.terminate = False\n        progressBar.markComplete()\n        progressBar.close()",
  "def GetLogVariableData(self, LogName):\n        \"\"\"\n        Pull the recorded module recorded variable.  The first column is the variable recording time in\n        nano-seconds, the additional column(s) are the message data columns.\n        \"\"\"\n        TheArray = np.array(self.VarLogList[LogName].TimeValuePairs)\n        ArrayDim = self.VarLogList[LogName].ArrayDim\n        TheArray = np.reshape(TheArray, (TheArray.shape[0] // ArrayDim, ArrayDim))\n        return TheArray",
  "def disableTask(self, TaskName):\n        \"\"\"\n        Disable this particular task from being executed.\n        \"\"\"\n        for Task in self.TaskList:\n            if Task.Name == TaskName:\n                Task.disable()",
  "def enableTask(self, TaskName):\n        \"\"\"\n        Enable this particular task to be executed.\n        \"\"\"\n        for Task in self.TaskList:\n            if Task.Name == TaskName:\n                Task.enable()",
  "def parseDataIndex(self):\n        self.dataStructureDictionary = {}\n        try:\n            xmlData = ET.parse(self.dataStructIndex)\n        except:\n            print(\"Failed to parse the XML index.  Likely that it isn't present\")\n            return\n        root = xmlData.getroot()\n        for child in root:\n            newStruct = StructDocData(child.attrib['refid'])\n            self.dataStructureDictionary.update({child.find('name').text:\n                                                     newStruct})\n        self.indexParsed = True",
  "def createNewEvent(self, eventName, eventRate=int(1E9), eventActive=False,\n                       conditionList=[], actionList=[], terminal=False):\n        \"\"\"\n        Create an event sequence that contains a series of tasks to be executed.\n        \"\"\"\n        if (eventName in list(self.eventMap.keys())):\n            return\n        newEvent = EventHandlerClass(eventName, eventRate, eventActive,\n                                     conditionList, actionList, terminal)\n        self.eventMap.update({eventName: newEvent})",
  "def initializeEventChecks(self):\n        self.eventList = []\n        for key, value in self.eventMap.items():\n            value.methodizeEvent()\n            self.eventList.append(value)\n        self.nextEventTime = 0",
  "def checkEvents(self):\n        nextTime = -1\n        for localEvent in self.eventList:\n            localNextTime = localEvent.checkEvent(self)\n            if(localNextTime >= 0 and (localNextTime < nextTime or nextTime <0)):\n                nextTime = localNextTime\n        return nextTime",
  "def setEventActivity(self, eventName, activityCommand):\n        if eventName not in list(self.eventMap.keys()):\n            print(\"You asked me to set the status of an event that I don't have.\")\n            return\n        self.eventMap[eventName].eventActive = activityCommand",
  "def setAllButCurrentEventActivity(self, currentEventName, activityCommand, useIndex=False):\n        \"\"\"Set all event activity variables except for the currentEventName event. The ``useIndex`` flag can be used to\n        prevent enabling or disabling every task, and instead only alter the ones that belong to the same group (for\n        example, the same spacecraft). The distinction is made through an index set after the ``_`` symbol in the event\n        name. All events of the same group must have the same index.\"\"\"\n\n        if useIndex:\n            index = currentEventName.partition('_')[2]  # save the current event's index\n\n        for eventName in list(self.eventMap.keys()):\n            if currentEventName != eventName:\n                if useIndex:\n                    if eventName.partition('_')[2] == index:\n                        self.eventMap[eventName].eventActive = activityCommand\n                else:\n                    self.eventMap[eventName].eventActive = activityCommand",
  "def setModelDataWrap(self, modelData):\n        \"\"\"\n        Takes a module and returns an object that provides access to said module's SelfInit, Update, and Reset\n        methods.\n\n        Takes the module instance, collects all SwigPyObjects generated from the .i file (SelfInit,\n        Update and Reset), and attaches it to a alg_contain model instance so the modules standard functions can be\n        run at the python level.\n\n        :param modelData: model to gather functions for\n        :return: An alg_contain model that provides access to the original model's core functions\n        \"\"\"\n        deprecationId = f\"{SimBaseClass.setModelDataWrap.__module__}.{SimBaseClass.setModelDataWrap.__qualname__}\"\n        removalDate = \"2024/07/30\"\n\n        if hasattr(modelData, \"createWrapper\"):\n            deprecated.deprecationWarn(\n                deprecationId,\n                removalDate,\n                \"C modules no longer require having separate 'Config' and 'Wrap' objects. \"\n                \"Treat C modules like C++ modules. For example, instead of:\\n\"\n                \"\\tinertial3DConfig = inertial3D.inertial3DConfig()\\n\"\n                \"\\tinertial3DWrap = scSim.setModelDataWrap(inertial3DConfig)\\n\"\n                \"\\tinertial3DWrap.ModelTag = 'inertial3D'\\n\"\n                \"\\tscSim.AddModelToTask(simTaskName, inertial3DWrap, inertial3DConfig, 10)\\n\"\n                \"Do:\\n\"\n                \"\\tinertial3D = inertial3D.inertial3D()\\n\"\n                \"\\tinertial3D.ModelTag = 'inertial3D'\\n\"\n                \"\\tscSim.AddModelToTask(simTaskName, inertial3D, 10)\\n\"\n            )\n            return modelData.createWrapper()\n    \n        deprecated.deprecationWarn(\n            deprecationId, \n            removalDate, \n            \"This C module has not been converted yet to the new way of defining C \"\n            \"modules, which makes using them more intuitive. Take the time to see how \"\n            \"the new C module '.i' file looks by checking out a default Basilisk module\"\n            \" and adapt your module to use a similar format.\"\n        )\n\n        algDict = {}\n        STR_SELFINIT = 'SelfInit'\n        STR_UPDATE = 'Update'\n        STR_RESET = 'Reset'\n\n        # SwigPyObject's Parsing:\n        # Collect all the SwigPyObjects present in the list. Only the methods SelfInit, Update and Restart\n        # are wrapped by Swig in the .i files. Therefore they are the only SwigPyObjects\n        def parseDirList(dirList):\n            algNames = []\n            for methodName in dirList:\n                methodObject = eval('sys.modules[\"' + module + '\"].' + methodName)\n                if type(methodObject).__name__ == \"SwigPyObject\":\n                    algNames.append(methodName)\n            return algNames\n\n        # Check the type of the algorithm, i.e. SelfInit, Update or Reset,\n        # and return the key to create a new dictionary D[str_method] = method\n        def checkMethodType(methodName):\n            if methodName[0:len(STR_SELFINIT)] == STR_SELFINIT:\n                return STR_SELFINIT\n            elif methodName[0:len(STR_UPDATE)] == STR_UPDATE:\n                return STR_UPDATE\n            elif methodName[0:len(STR_RESET)] == STR_RESET:\n                return STR_RESET\n            else:\n                raise ValueError('Cannot recognize the method'\n                                 '(I only assess SelfInit, Update and Reset methods). '\n                                 'Parse better.')\n\n        module = modelData.__module__\n        sysMod = sys.modules[module]\n        dirList = dir(sysMod)\n        algList = parseDirList(dirList)\n\n        # if the package has different levels we need to access the correct level of the package\n        currMod = __import__(module, globals(), locals(), [], 0)\n\n        moduleString = \"currMod.\"\n        moduleNames = module.split(\".\")\n        if len(moduleNames) > 1:\n            moduleString += \".\".join(moduleNames[1:]) + \".\"\n\n        for alg in algList:\n            key = checkMethodType(alg)\n            algDict[key] = alg\n\n        update = eval(moduleString + algDict[STR_UPDATE])\n        selfInit = eval(moduleString + algDict[STR_SELFINIT])\n        try:\n            resetArg = algDict[STR_RESET]\n            reset = eval(moduleString + resetArg)\n            modelWrap = alg_contain.AlgContain(modelData, update, selfInit, reset)\n        except:\n            modelWrap = alg_contain.AlgContain(modelData, update, selfInit)\n        return modelWrap",
  "def __init__(self, type, name, argstring, desc=''):\n            self.type = type\n            self.name = name\n            self.argstring = argstring\n            self.desc = desc",
  "def parseDirList(dirList):\n            algNames = []\n            for methodName in dirList:\n                methodObject = eval('sys.modules[\"' + module + '\"].' + methodName)\n                if type(methodObject).__name__ == \"SwigPyObject\":\n                    algNames.append(methodName)\n            return algNames",
  "def checkMethodType(methodName):\n            if methodName[0:len(STR_SELFINIT)] == STR_SELFINIT:\n                return STR_SELFINIT\n            elif methodName[0:len(STR_UPDATE)] == STR_UPDATE:\n                return STR_UPDATE\n            elif methodName[0:len(STR_RESET)] == STR_RESET:\n                return STR_RESET\n            else:\n                raise ValueError('Cannot recognize the method'\n                                 '(I only assess SelfInit, Update and Reset methods). '\n                                 'Parse better.')",
  "def overwriteSwigImports(buildDir):\n    initFiles = findInitFiles(buildDir)\n    for initFile in initFiles:\n        replaceImport(initFile)",
  "def findInitFiles(buildDir):\n    initFiles = []\n    for root, dirs, files in os.walk(buildDir):\n        for file in files:\n            if file == '__init__.py':\n                initFiles.append(os.path.join(root,file))\n    return initFiles",
  "def replaceImport(initFile):\n    fh, path = mkstemp()\n    with os.fdopen(fh,'w+') as newFile:\n        with open(initFile) as oldFile:\n            for line in oldFile:\n                if 'import' in line:\n                    importMod = line.split(' ')[1]\n                    importMod = importMod.strip('.')\n                    if importMod != \".\":\n                        newFile.write('from .{} import * \\n'.format(importMod))\n                else:\n                    newFile.write(line)\n    os.remove(initFile)\n    move(path, initFile)",
  "def overwriteSwigCode(buildDir):\n    editFiles = findFiles(buildDir)\n    for editFile in editFiles:\n        replaceCode(editFile)",
  "def findFiles(buildDir):\n    editFiles = []\n    for root, dirs, files in os.walk(buildDir):\n        for file in files:\n            if file == 'thrusterDynamicEffector.py' or file == 'reactionWheelStateEffector.py' or file == 'vscmgStateEffector.py':\n                editFiles.append(os.path.join(root,file))\n    return editFiles",
  "def replaceCode(editFile):\n    fh, path = mkstemp()\n    with os.fdopen(fh,'w+') as newFile:\n        with open(editFile) as oldFile:\n            for line in oldFile:\n                if 'if(hasattr(self, name) or name == \\'this\\')' in line:\n                    newFile.write(line.replace('name == \\'this\\'', 'name == \\'this\\' or name == \\'__swig_container\\''))\n                else:\n                    newFile.write(line)\n    os.remove(editFile)\n    move(path, editFile)",
  "def Honeywell_HR16(maxMomentum_level):\n    \"\"\"\n    Honeywell HR16 (100Nm, 75Nm, 50Nm)\n\n    RW Information Source:\n    http://www51.honeywell.com/aero/common/documents/Constellation_Series_Reaction_Wheels.pdf\n\n    There are 3 momentum capacity options for this RW type.  The maximum momentum\n    capacity must be set prior to creating the HR16 RW type using::\n\n        maxMomentum = 100, 75 or 50\n\n    :param maxMomentum_level:\n    :return:\n    \"\"\"\n    Omega_max = 6000.0 * mc.rpm2radsec  # maximum speed\n    u_max = 0.200  # maximum RW torque [Nm]\n    u_min = 0.00001  # minimum RW torque [Nm]\n    u_f = 0.0005  # static friction torque [Nm]\n    maxMomentum_large = 100\n    maxMomentum_medium = 75\n    maxMomentum_small = 50\n\n\n    # mass = RW rotor mass [kg]. Note: the rotor mass here is set equal to the RW mass of the above spec sheet.\n    # U_s = static RW imbalance [kg*m]\n    # U_d = dynamic RW imbalance [kg*m^2]\n    if maxMomentum_level == 'large':\n        mass = 12.0\n        U_s = 4.8E-6\n        U_d = 15.4E-7\n    elif maxMomentum_level == 'medium':\n        mass = 10.4\n        U_s = 3.8E-6\n        U_d = 11.5E-7\n    elif maxMomentum_level == 'small':\n        mass = 9.0\n        U_s = 2.8E-6\n        U_d = 7.7E-7\n    else:\n        raise ValueError('Honeywell_HR16(maxMomentum_level) only has arg options maxMomentum = [large, medium, small]')\n\n    maxMomentum = eval('maxMomentum_'+ maxMomentum_level)\n    return (Omega_max, u_max, u_min, u_f, mass, U_s, U_d, maxMomentum)",
  "def Honeywell_HR14(maxMomentum):\n    \"\"\"\n    Honeywell HR14 (25Nm, 50Nm, 75Nm)\n\n    RW Information Source:\n    http://www51.honeywell.com/aero/common/documents/Constellation_Series_Reaction_Wheels.pdf\n\n    There are 3 momentum capacity options for this RW type.  The maximum momentum\n    capacity must be set prior to creating the HR14 RW type using::\n\n        options.maxMomentum = 75, 50 or 25\n\n    :param maxMomentum:\n    :return:\n    \"\"\"\n    Omega_max = 6000.0 * mc.rpm2radsec  # maximum speed\n    u_max = 0.200  # maximum RW torque [Nm]\n    u_min = 0.00001  # minimum RW torque [Nm]\n    u_f = 0.0005  # static friction torque [Nm]\n\n    # mass = RW rotor mass [kg]. Note: the rotor mass here is set equal to the RW mass of the above spec sheet.\n    # U_s = static RW imbalance [kg*m]\n    # U_d = dynamic RW imbalance [kg*m^2]\n    large = 75\n    medium = 50\n    small = 25\n    if maxMomentum == large:\n        mass = 10.6\n        U_s = 4.8E-6\n        U_d = 13.7E-7\n    elif maxMomentum == medium:\n        mass = 8.5\n        U_s = 3.5E-6\n        U_d = 9.1E-7\n    elif maxMomentum == small:\n        mass = 7.5\n        U_s = 2.2E-6\n        U_d = 4.6E-7\n    else:\n        raise ValueError('Honeywell_HR14(maxMomentum) only has arg options maxMomentum = [large, medium, small]')\n\n    return (Omega_max, u_max, u_min, u_f, mass, U_s, U_d)",
  "def Honeywell_HR12(maxMomentum):\n    \"\"\"\n    Honeywell HR12 (12Nm, 25Nm, 50Nm)\n\n    RW Information Source:\n    http://www51.honeywell.com/aero/common/documents/Constellation_Series_Reaction_Wheels.pdf\n\n    There are 3 momentum capacity options for this RW type.  The maximum momentum\n    capacity must be set prior to creating the HR12 RW type using::\n\n        options.maxMomentum = 12, 25 or 50\n\n    :param maxMomentum:\n    :return:\n    \"\"\"\n    Omega_max = 6000.0 * mc.rpm2radsec  # maximum speed\n    u_max = 0.200  # maximum RW torque [Nm]\n    u_min = 0.00001  # minimum RW torque [Nm]\n    u_f = 0.0005  # static friction torque [Nm]\n\n    # mass = RW rotor mass [kg]. Note: the rotor mass here is set equal to the RW mass of the above spec sheet.\n    # U_s = static RW imbalance [kg*m]\n    # U_d = dynamic RW imbalance [kg*m^2]\n    large = 50\n    medium = 25\n    small = 12\n    if maxMomentum == large:\n        mass = 9.5\n        U_s = 4.4E-6\n        U_d = 9.1E-7\n    elif maxMomentum == medium:\n        mass = 7.0\n        U_s = 2.4E-6\n        U_d = 4.6E-7\n    elif maxMomentum == small:\n        mass = 6.0\n        U_s = 1.5E-6\n        U_d = 2.2E-7\n    else:\n        raise ValueError('Honeywell_HR12(maxMomentum) only has arg options maxMomentum = [large, medium, small]')\n\n    return (Omega_max, u_max, u_min, u_f, mass, U_s, U_d)",
  "class ClassicElements(object):\n    a = None\n    e = None\n    i = None\n    Omega = None\n    omega = None\n    f = None\n    rmag = None\n    alpha = None\n    rPeriap = None\n    rApoap = None",
  "class EquinoctialElements(object):\n    a = None\n    P1 = None\n    P2 = None\n    Q1 = None\n    Q2 = None\n    l = None\n    L = None",
  "def E2f(Ecc, e):\n    \"\"\"\n    Maps eccentric anomaly angles into true anomaly angles\n    This function requires the orbit to be either circular or\n    non-rectilinear elliptic orbit\n\n    :param Ecc: eccentric anomaly (rad)\n    :param e: eccentric (0 <= e < 1)\n    :return: f, true anomaly (rad)\n    \"\"\"\n    if e >= 0.0 and e < 1.0:\n        f = 2.0 * math.atan2(math.sqrt(1.0 + e) * math.sin(Ecc / 2.0), math.sqrt(1.0 - e) * math.cos(Ecc / 2.0))\n        return f\n    raise ValueError('Error: E2f() received e = {}, the value of e should be 0 <= e < 1'.format(str(e)))",
  "def E2M(Ecc, e):\n    \"\"\"\n    Maps the eccentric anomaly angle into the corresponding\n    mean elliptic anomaly angle.  Both 2D and 1D elliptic\n    orbit are allowed.\n\n    :param Ecc: eccentric anomaly (rad)\n    :param e: eccentricity (0 <= e < 1)\n    :return: M, mean elliptic anomaly (rad)\n    \"\"\"\n    if e >= 0.0 and e < 1.0:\n        M = Ecc - e * math.sin(Ecc)\n        return M\n    raise ValueError('Error: E2M() received e = {}, the value of e should be 0 <= e < 1'.format(str(e)))",
  "def f2E(f, e):\n    \"\"\"\n    Maps true anomaly angles into eccentric anomaly angles.\n    This function requires the orbit to be either circular or\n    non-rectilinear elliptic orbit.\n\n    :param f: true anomaly angle (rad)\n    :param e: eccentricity (0 <= e < 1)\n    :return: Ecc, eccentric anomaly (rad)\n    \"\"\"\n    if e >= 0.0 and e < 1.0:\n        Ecc = 2.0 * math.atan2(math.sqrt(1.0 - e) * math.sin(f / 2.0), math.sqrt(1.0 + e) * math.cos(f / 2.0))\n        return Ecc\n    raise ValueError('Error: f2E() received e = {}, the value of e should be 0 <= e < 1'.format(str(e)))",
  "def f2H(f, e):\n    \"\"\"\n    Maps true anomaly angles into hyperbolic anomaly angles.\n    This function requires the orbit to be hyperbolic\n\n    :param f: true anomaly angle (rad)\n    :param e: eccentricity (e > 1)\n    :return:  H, hyperbolic anomaly (rad)\n    \"\"\"\n    if e > 1.0:\n        H = 2.0 * math.atanh(math.sqrt((e - 1.0) / (e + 1.0)) * math.tan(f / 2.0))\n        return H\n    raise ValueError('Error: f2H() received e = {}, the value of e should be 0 <= e < 1'.format(str(e)))",
  "def H2f(H, e):\n    \"\"\"\n    Maps hyperbolic anomaly angles into true anomaly angles.\n    This function requires the orbit to be hyperbolic\n\n    :param H: hyperbolic anomaly (rad)\n    :param e: eccentricity (e > 1)\n    :return: f, true anomaly angle (rad)\n    \"\"\"\n    if e > 1.0:\n        f = 2.0 * math.atan(math.sqrt((e + 1.0) / (e - 1.0)) * math.tanh(H / 2.0))\n        return f\n    raise ValueError('Error: H2f() received e = {}, the value of e should be 0 <= e < 1'.format(str(e)))",
  "def H2N(H, e):\n    \"\"\"\n    Maps the hyperbolic anomaly angle H into the corresponding\n    mean hyperbolic anomaly angle N.\n\n    :param H: hyperbolic anomaly (rad)\n    :param e: eccentricity (e > 1)\n    :return: N, mean hyperbolic anomaly (rad)\n    \"\"\"\n    if e > 1.0:\n        N = e * math.sinh(H) - H\n        return N\n    raise ValueError('Error: H2N() received e = {}, the value of e should be 0 <= e < 1'.format(str(e)))",
  "def M2E(M, e):\n    \"\"\"\n    Maps the mean elliptic anomaly angle into the corresponding\n    eccentric anomaly angle.  Both 2D and 1D elliptic\n    orbit are allowed.\n\n    :param M: mean elliptic anomaly (rad)\n    :param e: eccentricity (0 <= e < 1)\n    :return: Ecc, eccentric anomaly (rad)\n    \"\"\"\n    dE = 10.0 * eps\n    E1 = M\n    count = 0\n\n    if e >= 0.0 and e < 1.0:\n        while math.fabs(dE) > eps:\n            dE = (E1 - e * math.sin(E1) - M) / (1 - e * math.cos(E1))\n            E1 -= dE\n            count += 1\n            if count > maxIteration:\n                print('Iteration error in M2E({},{})'.format(str(M), str(e)))\n                dE = 0.0\n        return E1\n    raise ValueError('Error: M2E() received e = {}, the value of e should be 0 <= e < 1'.format(str(e)))",
  "def N2H(N, e):\n    \"\"\"\n    Maps the mean hyperbolic anomaly angle N into the corresponding\n    hyperbolic anomaly angle H.\n\n    :param N: mean hyperbolic anomaly (rad)\n    :param e: eccentricity (e > 1)\n    :return: H, hyperbolic anomaly (rad)\n    \"\"\"\n    dH = 10.0 * eps\n    H1 = N\n    count = 0\n\n    if e > 1.0:\n        while math.fabs(dH) > eps:\n            dH = (e * math.sinh(H1) - H1 - N) / (e * math.cosh(H1) - 1.0)\n            H1 -= dH\n            count += 1\n            if count > maxIteration:\n                print('Iteration error in M2E({},{})'.format(str(N), str(e)))\n                dH = 0.\n        return H1\n    raise ValueError('Error: N2H() received e = {}, the value of e should be 0 <= e < 1'.format(str(e)))",
  "def elem2rv_parab(mu, elements):\n    \"\"\"\n    Translates the orbit elements:\n\n    === ========================= =======\n    a   semi-major axis           km\n    e   eccentricity\n    i   inclination               rad\n    AN  ascending node            rad\n    AP  argument of periapses     rad\n    f   true anomaly angle        rad\n    === ========================= =======\n\n    to the inertial Cartesian position and velocity vectors.\n    The attracting body is specified through the supplied\n    gravitational constant mu (units of km^3/s^2).\n\n    The code can handle the following cases:\n\n    ================== ============  ===========   =======================\n        circular:       e = 0           a > 0\n        elliptical-2D:  0 < e < 1       a > 0\n        elliptical-1D:  e = 1           a > 0        f = Ecc. Anom. here\n        parabolic:      e = 1           rp = -a\n        hyperbolic:     e > 1           a < 0\n    ================== ============  ===========   =======================\n\n    .. note::\n\n        To handle the parabolic case and distinguish it form the\n        rectilinear elliptical case, instead of passing along the\n        semi-major axis a in the \"a\" input slot, the negative radius\n        at periapses is supplied.  Having \"a\" be negative and e = 1\n        is a then a unique identified for the code for the parabolic\n        case.\n\n    :param mu: gravitational parameter\n    :param elements: orbital elements\n    :return:   rVec = position vector, vVec = velocity vector\n    \"\"\"\n    # map classical elements structure into local variables #\n    a = elements.a\n    e = elements.e\n    i = elements.i\n    AN = elements.Omega\n    AP = elements.omega\n    f = elements.f\n\n    ir = np.zeros(3)\n    rVec = np.zeros(3)\n    vVec = np.zeros(3)\n\n    # TODO: Might want to have an error band on this equality #\n    if e == 1.0 and a > 0.0:  # rectilinear elliptic orbit case #\n        Ecc = f  # f is treated as ecc. anomaly #\n        r = a * (1.0 - e * math.cos(Ecc))  # orbit radius #\n        v = math.sqrt(2.0 * mu / r - mu / a)\n        ir[0] = math.cos(AN) * math.cos(AP) - math.sin(AN) * math.sin(AP) * math.cos(i)\n        ir[1] = math.sin(AN) * math.cos(AP) + math.cos(AN) * math.sin(AP) * math.cos(i)\n        ir[2] = math.sin(AP) * math.sin(i)\n        rVec = r * ir\n        if math.sin(Ecc) > 0.0:\n            vVec = -v * ir\n        else:\n            vVec = v * ir\n\n    else:\n        if e == 1.0 and a < 0.0:    # parabolic case #\n            rp = -a                  # radius at periapses #\n            p = 2.0 * rp             # semi-latus rectum #\n        else:                       # elliptic and hyperbolic cases #\n            p = a * (1.0 - e * e)   # semi-latus rectum #\n\n        r = p / (1.0 + e * math.cos(f))  # orbit radius #\n        theta = AP + f                   # true latitude angle #\n        h = math.sqrt(mu * p)            # orbit ang. momentum mag.\n\n        rVec[0] = r * (math.cos(AN) * math.cos(theta) - math.sin(AN) * math.sin(theta) * math.cos(i))\n        rVec[1] = r * (math.sin(AN) * math.cos(theta) + math.cos(AN) * math.sin(theta) * math.cos(i))\n        rVec[2] = r * (math.sin(theta) * math.sin(i))\n\n        vVec[0] = -mu / h * (math.cos(AN) * (math.sin(theta) + e * math.sin(AP)) + math.sin(AN) * (math.cos(\n            theta) + e * math.cos(AP)) * math.cos(i))\n        vVec[1] = -mu / h * (math.sin(AN) * (math.sin(theta) + e * math.sin(AP)) - math.cos(AN) * (math.cos(\n            theta) + e * math.cos(AP)) * math.cos(i))\n        vVec[2] = -mu / h * (-(math.cos(theta) + e * math.cos(AP)) * math.sin(i))\n\n    return rVec, vVec",
  "def elem2rv(mu, elements):\n    \"\"\"\n    Translates the orbit elements:\n\n    === ========================= =======\n    a   semi-major axis           km\n    e   eccentricity\n    i   inclination               rad\n    AN  ascending node            rad\n    AP  argument of periapses     rad\n    f   true anomaly angle        rad\n    === ========================= =======\n\n    to the inertial Cartesian position and velocity vectors.\n    The attracting body is specified through the supplied\n    gravitational constant mu (units of km^3/s^2).\n\n    :param mu: gravitational parameter\n    :param elements: orbital elements\n    :return:   rVec, position vector\n    :return:   vVec, velocity vector\n    \"\"\"\n    rVec = np.zeros(3)\n    vVec = np.zeros(3)\n\n    if 1.0 + elements.e * math.cos(elements.f) < tolerance:\n        print('WARNING: Radius is near infinite in elem2rv conversion.')\n\n    # Calculate the semilatus rectum and the radius #\n    p = elements.a * (1.0 - elements.e * elements.e)\n    r = p / (1.0 + elements.e * math.cos(elements.f))\n    theta = elements.omega + elements.f\n    rVec[0] = r * (\n        math.cos(theta) * math.cos(elements.Omega) - math.cos(elements.i) * math.sin(theta) * math.sin(\n            elements.Omega))\n    rVec[1] = r * (\n        math.cos(theta) * math.sin(elements.Omega) + math.cos(elements.i) * math.sin(theta) * math.cos(\n            elements.Omega))\n    rVec[2] = r * (math.sin(theta) * math.sin(elements.i))\n\n    if math.fabs(p) < tolerance:\n        if math.fabs(1.0 - elements.e) < tolerance:\n            # Rectilinear orbit #\n            raise ValueError('elem2rv does not support rectilinear orbits')\n        # Parabola #\n        rp = -elements.a\n        p = 2.0 * rp\n\n    h = math.sqrt(mu * p)\n    vVec[0] = -mu / h * (math.cos(elements.Omega) * (elements.e * math.sin(elements.omega) + math.sin(theta)) +\n                         math.cos(elements.i) * (\n                             elements.e * math.cos(elements.omega) + math.cos(theta)) * math.sin(elements.Omega))\n    vVec[1] = -mu / h * (math.sin(elements.Omega) * (elements.e * math.sin(elements.omega) + math.sin(theta)) -\n                         math.cos(elements.i) * (elements.e * math.cos(elements.omega) + math.cos(theta)) *\n                         math.cos(elements.Omega))\n    vVec[2] = mu / h * (elements.e * math.cos(elements.omega) + math.cos(theta)) * math.sin(elements.i)\n\n    return rVec, vVec",
  "def rv2elem_parab(mu, rVec, vVec):\n    \"\"\"\n    Translates the orbit elements inertial Cartesian position\n    vector rVec and velocity vector vVec into the corresponding\n    classical orbit elements where\n\n    === ========================= =======\n    a   semi-major axis             km\n    e   eccentricity\n    i   inclination                 rad\n    AN  ascending node              rad\n    AP  argument of periapses       rad\n    f   true anomaly angle          rad\n    === ========================= =======\n\n    If the orbit is rectilinear, then f will be the eccentric or hyperbolic anomaly\n\n    The attracting body is specified through the supplied\n    gravitational constant mu (units of km^3/s^2).\n\n    The code can handle the following cases:\n\n    ============== ============= ===========\n    circular:       e = 0           a > 0\n    elliptical-2D:  0 < e < 1       a > 0\n    elliptical-1D:  e = 1           a > 0\n    parabolic:      e = 1           a = -rp\n    hyperbolic:     e > 1           a < 0\n    ============== ============= ===========\n\n    For the parabolic case the semi-major axis is not defined.\n    In this case -rp (radius at periapses) is returned instead\n    of a.  For the circular case, the AN and AP are ill-defined,\n    along with the associated ie and ip unit direction vectors\n    of the perifocal frame. In this circular orbit case, the\n    unit vector ie is set equal to the normalized inertial\n    position vector ir.\n\n    :param   mu:  gravitational parameter\n    :param   rVec:  position vector\n    :param   vVec: velocity vector\n    :return: orbital elements\n\n\n    Todo: Modify this code to return true longitude of periapsis\n    (non-circular, equatorial), argument of latitude (circular, inclined),\n    and true longitude (circular, equatorial) when appropriate instead of\n    simply zeroing out omega and Omega\n\n    \"\"\"\n\n    dum = np.zeros(3)\n    dum2 = np.zeros(3)\n    ie = np.zeros(3)\n    ip = np.zeros(3)\n    ih = np.zeros(3)\n    cVec = np.zeros(3)\n    hVec = np.zeros(3)\n    ir = np.zeros(3)\n    elements = ClassicElements()\n\n    # compute orbit radius #\n    r = la.norm(rVec)\n    elements.rmag = r\n    ir = v3Normalize(rVec)\n\n    # compute the angular momentum vector #\n    hVec = np.cross(rVec, vVec)\n    h = la.norm(hVec)\n\n    # compute the eccentricity vector #\n    cVec = np.cross(vVec, hVec)\n    dum = (-mu / r) * rVec\n    cVec = cVec + dum\n    elements.e = la.norm(cVec) / mu\n\n    # compute semi-major axis #\n    elements.alpha = 2.0 / r - np.dot(vVec, vVec) / mu\n    if math.fabs(elements.alpha) > eps:\n        # elliptic or hyperbolic case #\n        elements.a = 1.0 / elements.alpha\n        elements.rPeriap = elements.a * (1.0 - elements.e)\n        elements.rApoap = elements.a * (1.0 + elements.e)\n    else:\n        #  parabolic case #\n        elements.alpha = 0.\n        p = h * h / mu\n        rp = p / 2.0\n        elements.a = -rp  # a is not defined for parabola, so - rp is returned instead #\n        elements.e = 1.0\n        elements.rPeriap = rp\n        elements.rApoap = -rp  # periapses radius doesn't exist, returning -rp instead #\n\n    if h < eps:  # rectilinear motion case #\n        dum = np.array([0.0, 0.0, 1.0])\n        dum2 = np.array([0.0, 1.0, 0.0])\n        ih = np.cross(ie, dum)\n        ip = np.cross(ie, dum2)\n        if la.norm(ih) > la.norm(ip):\n            ih = v3Normalize(ih)\n        else:\n            ih = v3Normalize(ip)\n        ip = np.cross(ih, ie)\n    else:\n        ih = v3Normalize(hVec)\n        if math.fabs(elements.e) > eps:\n            ie = (1.0 / mu / elements.e) * cVec\n        else:\n            ie = ir\n        # circular orbit case.  Here ie, ip are arbitrary, as long as they #\n        # are perpenticular to the ih vector. #\n        ip = np.cross(ih, ie)\n\n    # compute the 3-1-3 orbit plane orientation angles #\n    elements.i = math.acos(ih[2])\n    if elements.i > eps and elements.i < np.pi - eps:\n        elements.Omega = math.atan2(ih[0], -ih[1])\n        elements.omega = math.atan2(ie[2], ip[2])\n    else:\n        elements.Omega = 0.\n        elements.omega = math.atan2(ie[1], ie[0])\n\n    if h < eps:  # rectilinear motion case #\n        if elements.alpha > 0:  # elliptic case #\n            Ecc = math.acos(1 - r * elements.alpha)\n            if np.dot(rVec, vVec) > 0:\n                Ecc = 2.0 * np.pi - Ecc\n            elements.f = Ecc  # for this mode the eccentric anomaly is returned #\n        else:  # hyperbolic case #\n            H = math.acosh(r * elements.alpha + 1)\n            if np.dot(rVec, vVec) < 0:\n                H = 2.0 * np.pi - H\n            elements.f = H  # for this mode the hyperbolic anomaly is returned #\n    else:\n        # compute true anomaly #\n        dum = np.cross(ie, ir)\n        elements.f = math.atan2(np.dot(dum, ih), np.dot(ie, ir))\n\n    return elements",
  "def rv2elem(mu, rVec, vVec):\n    \"\"\"\n    Translates the orbit elements inertial Cartesian position\n    vector rVec and velocity vector vVec into the corresponding\n    classical orbit elements where\n\n    === ========================= =======\n    a   semi-major axis           km\n    e   eccentricity\n    i   inclination               rad\n    AN  ascending node            rad\n    AP  argument of periapses     rad\n    f   true anomaly angle        rad\n    === ========================= =======\n\n    If the orbit is rectilinear, then this will be the eccentric or hyperbolic anomaly\n\n    The attracting body is specified through the supplied\n    gravitational constant mu (units of km^3/s^2).\n\n    :param mu:  gravitational parameter\n    :param rVec: position vector\n    :param vVec: velocity vector\n    :return:  orbital elements\n    \"\"\"\n    hVec = [0.0] * 3\n    v3 = [0.0] * 3\n    nVec = [0.0] * 3\n    eVec = [0.0] * 3\n    eVec2 = [0.0] * 3\n\n    elements = ClassicElements()\n\n    if (np.isnan(np.sum(rVec)) or np.isnan(np.sum(vVec))):\n        print(\"ERROR: received NAN rVec or vVec values.\")\n        elements.a = np.NaN\n        elements.alpha = np.NaN\n        elements.e = np.NaN\n        elements.i = np.NaN\n        elements.AN = np.NaN\n        elements.AP = np.NaN\n        elements.f = np.NaN\n        elements.rmag = np.NaN\n        return\n\n\n    # Calculate the specific angular momentum and its magnitude #\n    hVec = np.cross(rVec, vVec)\n    h = la.norm(hVec)\n    p = h * h / mu\n\n    # Calculate the line of nodes #\n    v3 = np.array([0.0, 0.0, 1.0])\n    nVec = np.cross(v3, hVec)\n    n = la.norm(nVec)\n\n    # Orbit eccentricity and energy #\n    r = la.norm(rVec)\n    v = la.norm(vVec)\n    eVec = (v * v / mu - 1.0 / r) * rVec\n    v3 = (np.dot(rVec, vVec) / mu) * vVec\n    eVec = eVec - v3\n    elements.e = la.norm(eVec)\n    elements.rmag = r\n    elements.rPeriap = p / (1.0 + elements.e)\n\n    # compute semi-major axis #\n    elements.alpha = 2.0 / r - v * v / mu\n    if math.fabs(elements.alpha) > eps:\n        # elliptic or hyperbolic case #\n        elements.a = 1.0 / elements.alpha\n        elements.rApoap = p / (1.0 - elements.e)\n    else:\n        rp = p / 2.\n        elements.a = -rp\n        elements.rApoap = -1.0\n\n    # Calculate the inclination #\n    elements.i = math.acos(hVec[2] / h)\n\n    if elements.e >= 1e-11 and elements.i >= 1e-11:\n        # Case 1: Non-circular, inclined orbit #\n        elements.Omega = math.acos(nVec[0] / n)\n        if nVec[1] < 0.0:\n            elements.Omega = 2.0 * np.pi - elements.Omega\n        elements.omega = math.acos(np.clip(np.dot(nVec, eVec) / n / elements.e, a_min=-1.0, a_max=1.0))\n        if eVec[2] < 0.0:\n            elements.omega = 2.0 * np.pi - elements.omega\n        elements.f = math.acos(np.clip(np.dot(eVec, rVec) / elements.e / r, a_min=-1.0, a_max=1.0))\n        if np.dot(rVec, vVec) < 0.0:\n            elements.f = 2.0 * np.pi - elements.f\n    elif elements.e >= 1e-11 and elements.i < 1e-11:\n        # Case 2: Non-circular, equatorial orbit #\n        # Equatorial orbit has no ascending node #\n        elements.Omega = 0.0\n        # True longitude of periapsis, omegatilde_true #\n        elements.omega = math.acos(eVec[0] / elements.e)\n        if eVec[1] < 0.0:\n            elements.omega = 2.0 * np.pi - elements.omega\n        elements.f = math.acos(np.clip(np.dot(eVec, rVec) / elements.e / r, a_min=-1.0, a_max=1.0))\n        if np.dot(rVec, vVec) < 0.0:\n            elements.f = 2.0 * np.pi - elements.f\n    elif elements.e < 1e-11 and elements.i >= 1e-11:\n        # Case 3: Circular, inclined orbit #\n        elements.Omega = math.acos(nVec[0] / n)\n        if nVec[1] < 0.0:\n            elements.Omega = 2.0 * np.pi - elements.Omega\n        elements.omega = 0.0\n        # Argument of latitude, u = omega + f #\n        elements.f = math.acos(np.clip(np.dot(nVec, rVec) / n / r, a_min=-1.0, a_max=1.0))\n        if rVec[2] < 0.0:\n            elements.f = 2.0 * np.pi - elements.f\n    elif elements.e < 1e-11 and elements.i < 1e-11:\n        # Case 4: Circular, equatorial orbit #\n        elements.Omega = 0.0\n        elements.omega = 0.0\n        # True longitude, lambda_true #\n        elements.f = math.acos(rVec[0] / r)\n        if rVec[1] < 0:\n            elements.f = 2.0 * np.pi - elements.f\n    else:\n        print(\"Error: rv2elem couldn't identify orbit type.\")\n    if elements.e > 1.0 and math.fabs(elements.f) > np.pi:\n        twopiSigned = math.copysign(2.0 * np.pi, elements.f)\n        elements.f -= twopiSigned\n\n    return elements",
  "def atmosphericDensity(alt):\n    \"\"\"\n    This program computes the atmospheric density based on altitude\n    supplied by user.  This function uses a curve fit based on\n    atmospheric data from the Standard Atmosphere 1976 Data. This\n    function is valid for altitudes ranging from 100km to 1000km.\n\n    .. note::\n\n        This code can only be applied to spacecraft orbiting the Earth\n\n    :param alt: altitude in km\n    :return:  density at the given altitude in kg/m^3\n    \"\"\"\n    # Smooth exponential drop-off after 1000 km #\n    if alt > 1000.:\n        logdensity = (-7E-05) * alt - 14.464\n        density = math.pow(10., logdensity)\n        return density\n\n    # Calculating the density based on a scaled 6th order polynomial fit to the log of density #\n    val = (alt - 526.8000) / 292.8563\n    logdensity = 0.34047 * math.pow(val, 6) - 0.5889 * math.pow(val, 5) - 0.5269 * math.pow(val, 4) \\\n                 + 1.0036 * math.pow(val, 3) + 0.60713 * math.pow(val, 2) - 2.3024 * val - 12.575\n\n    # Calculating density by raising 10 to the log of density #\n    density = math.pow(10., logdensity)\n\n    return density",
  "def debyeLength(alt):\n    \"\"\"\n    This program computes the debyeLength length for a given\n    altitude and is valid for altitudes ranging\n    from 200 km to GEO (35000km).  However, all values above\n    1000 km are HIGHLY speculative at this point.\n\n    :param alt: altitude in km\n    :return: debye length given in m\n    \"\"\"\n    X = [200.0, 250.0, 300.0, 350.0, 400., 450., 500., 550., 600., 650., 700., 750., 800., 850.,\n         900., 950., 1000., 1050., 1100., 1150., 1200., 1250., 1300., 1350., 1400., 1450.,\n         1500., 1550., 1600., 1650., 1700., 1750., 1800., 1850., 1900., 1950., 2000.]\n\n    Y = [5.64E-03, 3.92E-03, 3.24E-03, 3.59E-03, 4.04E-03, 4.28E-03, 4.54E-03, 5.30E-03, 6.55E-03,\n         7.30E-03, 8.31E-03, 8.38E-03, 8.45E-03, 9.84E-03, 1.22E-02, 1.37E-02, 1.59E-02, 1.75E-02,\n         1.95E-02, 2.09E-02, 2.25E-02, 2.25E-02, 2.25E-02, 2.47E-02, 2.76E-02, 2.76E-02, 2.76E-02,\n         2.76E-02, 2.76E-02, 2.76E-02, 2.76E-02, 3.21E-02, 3.96E-02, 3.96E-02, 3.96E-02, 3.96E-02, 3.96E-02]\n\n    # Flat debyeLength length for altitudes above 2000 km #\n    if alt > 2000.0 and alt <= 30000.0:\n        alt = 2000.0\n    elif alt > 30000.0 and alt <= 35000.0:\n        debyedist = 0.1 * alt - 2999.7\n        return debyedist\n    elif alt < 200.0 or alt > 35000.0:\n        raise ValueError(\"ERROR: debyeLength() received alt = {}, the value of alt should be in the range \"\n                         \"of [200 35000].\".format(str(alt)))\n    # Interpolation of data #\n    i = 0\n    for i in range(0, N_DEBYE_PARAMETERS - 1):\n        if X[i + 1] > alt:\n            break\n    a = (alt - X[i]) / (X[i + 1] - X[i])\n    debyedist = Y[i] + a * (Y[i + 1] - Y[i])\n\n    return debyedist",
  "def atmosphericDrag(Cd, A, m, rvec, vvec):\n    \"\"\"\n     This program computes the atmospheric drag acceleration\n     vector acting on a spacecraft.\n     Note the acceleration vector output is inertial, and is\n     only valid for altitudes up to 1000 km.\n     Afterwards the drag force is zero. Only valid for Earth.\n\n     :param Cd:  drag coefficient of the spacecraft\n     :param A: cross-sectional area of the spacecraft in m^2\n     :param m: mass of the spacecraft in kg\n     :param rvec: Inertial position vector of the spacecraft in km  [x;y;z]\n     :param vvec: Inertial velocity vector of the spacecraft in km/s [vx;vy;vz]\n     :return: The inertial acceleration vector due to atmospheric drag in km/sec^2\n    \"\"\"\n    # find the altitude and velocity #\n    r = la.norm(rvec)\n    v = la.norm(vvec)\n    alt = r - REQ_EARTH\n    advec = np.zeros(3)\n\n    # Checking if user supplied a orbital position is insede the earth #\n    if alt <= 0.:\n        print(\"ERROR: atmosphericDrag() received rvec = [{} {} {}].\". \\\n            format(str(rvec[1]), str(rvec[2]), str(rvec[3])))\n        print('The value of rvec should produce a positive altitude for the Earth.')\n        advec.fill(np.NaN)\n        return\n\n    # get the Atmospheric density at the given altitude in kg/m^3 #\n    density = atmosphericDensity(alt)\n\n    # compute the magnitude of the drag acceleration #\n    ad = ((-0.5) * density * (Cd * A / m) * (math.pow(v * 1000., 2))) / 1000.\n\n    # computing the vector for drag acceleration #\n    advec = (ad / v) * vvec\n\n    return advec",
  "def jPerturb(rvec, num, planet):\n    \"\"\"\n    Computes the J2_EARTH-J6_EARTH zonal gravitational perturbation\n    accelerations.\n\n    :param rvec: Cartesian Position vector in kilometers [x;y;z].\n    :param num: Corresponds to which J components to use,\n                must be an integer between 2 and 6.\n                (note: Additive- 2 corresponds to J2_EARTH while 3 will\n                correspond to J2_EARTH + J3_EARTH)\n    :param planet: planet variable, can be\n                 CELESTIAL_MERCURY\n                 CELESTIAL_VENUS\n                 CELESTIAL_EARTH\n                 CELESTIAL_MOON\n                 CELESTIAL_MARS\n                 CELESTIAL_JUPITER\n                 CELESTIAL_URANUS\n                 CELESTIAL_NEPTUNE\n    :return: ajtot, The total acceleration vector due to the J\n                    perturbations in km/sec^2 [accelx;accely;accelz]\n    \"\"\"\n\n    ajtot = np.zeros(3)\n\n    # default #\n    mu = MU_EARTH\n    req = REQ_EARTH\n    J2 = J2_EARTH\n    J3 = J3_EARTH\n    J4 = J4_EARTH\n    J5 = J5_EARTH\n    J6 = J6_EARTH\n\n    if planet == 'CELESTIAL_MERCURY':\n        mu = MU_MERCURY\n        req = REQ_MERCURY\n        J2 = J2_MERCURY\n        J3 = 0.0\n        J4 = 0.0\n        J5 = 0.0\n        J6 = 0.0\n    elif planet == 'CELESTIAL_VENUS':\n        mu = MU_VENUS\n        req = REQ_VENUS\n        J2 = J2_VENUS\n        J3 = 0.0\n        J4 = 0.0\n        J5 = 0.0\n        J6 = 0.0\n    elif planet == 'CELESTIAL_MOON':\n        mu = MU_MOON\n        req = REQ_MOON\n        J2 = J2_MOON\n        J3 = 0.0\n        J4 = 0.0\n        J5 = 0.0\n        J6 = 0.0\n    elif planet == 'CELESTIAL_MARS':\n        mu = MU_MARS\n        req = REQ_MARS\n        J2 = J2_MARS\n        J3 = 0.0\n        J4 = 0.0\n        J5 = 0.0\n        J6 = 0.0\n    elif planet == 'CELESTIAL_JUPITER':\n        mu = MU_JUPITER\n        req = REQ_JUPITER\n        J2 = J2_JUPITER\n        J3 = 0.0\n        J4 = 0.0\n        J5 = 0.0\n        J6 = 0.0\n    elif planet == 'CELESTIAL_URANUS':\n        mu = MU_URANUS\n        req = REQ_URANUS\n        J2 = J2_URANUS\n        J3 = 0.0\n        J4 = 0.0\n        J5 = 0.0\n        J6 = 0.0\n    elif planet == 'CELESTIAL_NEPTUNE':\n        mu = MU_NEPTUNE\n        req = REQ_NEPTUNE\n        J2 = J2_NEPTUNE\n        J3 = 0.0\n        J4 = 0.0\n        J5 = 0.0\n        J6 = 0.0\n    elif planet == 'CELESTIAL_PLUTO':\n        return\n    elif planet == 'CELESTIAL_SUN':\n        return\n\n    # Calculate the J perturbations #\n    x = rvec[0]\n    y = rvec[1]\n    z = rvec[2]\n    r = la.norm(rvec)\n\n    # Error Checking #\n    if num < 2 or num > 6:\n        raise ValueError(\"ERROR: jPerturb() received num = {}.The value of num should be 2 <= num <= 6.\".format(str(num)))\n\n    # Calculating the total acceleration based on user input #\n    if num >= 2:\n        ajtot = np.array([(1.0 - 5.0 * math.pow(z / r, 2.0)) * (x / r),\n                          (1.0 - 5.0 * math.pow(z / r, 2.0)) * (y / r),\n                          (3.0 - 5.0 * math.pow(z / r, 2.0)) * (z / r)])\n        ajtot = (-3.0 / 2.0 * J2 * (mu / math.pow(r, 2.0)) * math.pow(req / r, 2.0)) * ajtot\n    if num >= 3:\n        temp = np.array([5.0 * (7.0 * math.pow(z / r, 3.0) - 3.0 * (z / r)) * (x / r),\n                         5.0 * (7.0 * math.pow(z / r, 3.0) - 3.0 * (z / r)) * (y / r),\n                         -3.0 * (10.0 * math.pow(z / r, 2.0) - (35.0 / 3.0) * math.pow(z / r, 4.0) - 1.0)])\n        temp2 = (1.0 / 2.0 * J3 * (mu / math.pow(r, 2.0)) * math.pow(req / r, 3.0)) * temp\n        ajtot = ajtot + temp2\n    if num >= 4:\n        temp = np.array([(3.0 - 42.0 * math.pow(z / r, 2.0) + 63.0 * math.pow(z / r, 4.0)) * (x / r),\n                         (3.0 - 42.0 * math.pow(z / r, 2.0) + 63.0 * math.pow(z / r, 4.0)) * (y / r),\n                         (15.0 - 70.0 * math.pow(z / r, 2) + 63.0 * math.pow(z / r, 4.0)) * (z / r)])\n        temp2 = (5.0 / 8.0 * J4 * (mu / math.pow(r, 2.0)) * math.pow(req / r, 4.0)) * temp\n        ajtot = ajtot + temp2\n    if num >= 5:\n        temp = np.array([3.0 * (35.0 * (z / r) - 210.0 * math.pow(z / r, 3.0) + 231.0 * math.pow(z / r, 5.0)) * (x / r),\n                         3.0 * (35.0 * (z / r) - 210.0 * math.pow(z / r, 3.0) + 231.0 * math.pow(z / r, 5.0)) * (y / r),\n                         -(15.0 - 315.0 * math.pow(z / r, 2.0) + 945.0 * math.pow(z / r, 4.0) - 693.0 * math.pow(z / r,\n                                                                                                                 6.0))])\n        temp2 = (1.0 / 8.0 * J5 * (mu / math.pow(r, 2.0)) * math.pow(req / r, 5.0)) * temp\n        ajtot = ajtot + temp2\n    if num >= 6:\n        temp = np.array([(35.0 - 945.0 * math.pow(z / r, 2) + 3465.0 * math.pow(z / r, 4.0) - 3003.0 * math.pow(z / r,\n                                                                                                                6.0)) * (\n                             x / r),\n                         (35.0 - 945.0 * math.pow(z / r, 2.0) + 3465.0 * math.pow(z / r, 4.0) - 3003.0 * math.pow(z / r,\n                                                                                                                  6.0)) * (\n                             y / r),\n                         -(3003.0 * math.pow(z / r, 6.0) - 4851.0 * math.pow(z / r, 4.0) + 2205.0 * math.pow(z / r,\n                                                                                                             2.0) - 245.0) * (\n                             z / r)])\n        temp2 = (-1.0 / 16.0 * J6 * (mu / math.pow(r, 2.0)) * math.pow(req / r, 6.0)) * temp\n        ajtot = ajtot + temp2\n\n    return ajtot",
  "def solarRad(A, m, sunvec):\n    \"\"\"\n    Computes the inertial solar radiation force vectors\n    based on cross-sectional Area and mass of the spacecraft\n    and the position vector of the planet to the sun.\n\n    .. note::\n\n        It is assumed that the solar radiation pressure decreases quadratically with distance from sun (in AU)\n\n    Solar Radiation Equations obtained from\n    Earth Space and Planets Journal Vol. 51, 1999 pp. 979-986\n\n    :param A: Cross-sectional area of the spacecraft that is facing the sun in m^2.\n    :param m: The mass of the spacecraft in kg.\n    :param sunvec: Position vector to the Sun in units of AU. Earth has a distance of 1 AU.\n    :return:   arvec, The inertial acceleration vector due to the effects of Solar Radiation pressure in km/sec^2.  The vector\n               components of the output are the same as the vector\n               components of the sunvec input vector.\n    \"\"\"\n    # Solar Radiation Flux #\n    flux = 1372.5398\n\n    # Speed of light #\n    c = 299792458.\n\n    # Radiation pressure coefficient #\n    Cr = 1.3\n\n    # Magnitude of position vector #\n    sundist = la.norm(sunvec)\n\n    # Computing the acceleration vector #\n    arvec = ((-Cr * A * flux) / (m * c * math.pow(sundist, 3)) / 1000.) * sunvec\n\n    return arvec",
  "def v3Normalize(v):\n    result = np.zeros(3)\n    norm = la.norm(v)\n    if norm > DB0_EPS:\n        result = (1. / norm) * v\n    return result",
  "def clMeanOscMap(req, J2, oe, oep, sign):\n    \"\"\"\n    First-order J2 Mapping Between Mean and Osculating Orbital Elements\n\n    Analytical Mechanics of Space Systems, Hanspeter Schaub, John L. Junkins, 4th edition.\n    [m] or [km] should be the same both for req and elements.a\n\n    :param req: equatorial radius\n    :param J2:\n    :param oe: classical orbit element set\n    :param oep:\n    :param sign: sgn=1:mean to osc, sgn=-1:osc to mean\n\n    \"\"\"\n    a       = oe.a\n    e       = oe.e\n    i       = oe.i\n    Omega   = oe.Omega\n    omega   = oe.omega\n    f       = oe.f\n    E       = f2E(f, e)\n    M       = E2M(E, e)\n    gamma2  = sign*J2/2*((req/oe.a)**2)\n    eta     = math.sqrt(1-oe.e*oe.e)\n    gamma2p = gamma2/(eta**4)\n    a_r     = (1+oe.e*math.cos(oe.f))/(eta**2)\n    # calculate oep.a\n    ap = oe.a + oe.a*gamma2*((3*(math.cos(oe.i))**2-1)*(a_r**3-1/(eta**3)) \\\n       +3*(1-(math.cos(oe.i))**2)*(a_r**3)*math.cos(2*oe.omega+2*oe.f))  # (F.7)\n\n    de1 = gamma2p/8*e*(eta**2)*(1-11*((math.cos(i))**2)-40*((math.cos(i)) **4) \\\n        /(1-5*((math.cos(i))**2)))*math.cos(2*omega)  # (F.8)\n\n    de = de1 + (eta ** 2) / 2 * (gamma2 *((3 * ((math.cos(i)) ** 2) - 1) / (eta ** 6) \\\n       *(e * eta + e / (1 + eta) + 3 * math.cos(f) + 3 * e * ((math.cos(f)) ** 2) + (e ** 2) \\\n       *((math.cos(f)) ** 3)) + 3 * (1 - ((math.cos(i)) ** 2)) / (eta ** 6) \\\n       *(e + 3 * math.cos(f) + 3 * e * ((math.cos(f)) ** 2) + (e ** 2) * ((math.cos(f)) ** 3)) * math.cos(2 * omega + 2 * f)) \\\n       - gamma2p * (1 - ((math.cos(i)) ** 2)) *(3 * math.cos(2 * omega + f) + math.cos(2 * omega + 3 * f)))  # (F.9)\n\n    di = -e*de1/(eta**2)/math.tan(i) + gamma2p/2*math.cos(i)*math.sqrt(1-((math.cos(i))**2)) \\\n       *(3*math.cos(2*omega+2*f) + 3*e*math.cos(2*omega+f)+e*math.cos(2*omega+3*f))  # (F.10)\n\n    MpopOp = M + omega + Omega + gamma2p / 8 * (eta ** 3) * (1 - 11 * ((math.cos(i)) ** 2) \\\n           - 40 *((math.cos(i)) ** 4) / (1 - 5 * ((math.cos(i)) ** 2))) * math.sin(2 * omega) \\\n           - gamma2p / 16 * (2 + (e ** 2) - 11 * (2 + 3 * (e ** 2)) * ((math.cos(i)) ** 2) - 40 * (2 + 5 * (e ** 2)) \\\n           *((math.cos(i)) ** 4) / (1 - 5 * ((math.cos(i)) ** 2)) - 400 * (e ** 2) * ((math.cos(i)) ** 6) \\\n           /((1 - 5 * ((math.cos(i)) ** 2)) ** 2)) * math.sin(2 * omega) \\\n           + gamma2p / 4 * (-6 *(1 - 5 * ((math.cos(i)) ** 2)) * (f - M + e * math.sin(f)) + (3 - 5 * ((math.cos(i)) ** 2)) \\\n           *(3 * math.sin(2 * omega + 2 * f) + 3 * e * math.sin(2 * omega + f) + e * math.sin(2 * omega + 3 * f))) \\\n           - gamma2p / 8 * (e ** 2) * math.cos(i) * (11 + 80 *((math.cos(i)) ** 2) / (1 - 5 * ((math.cos(i)) ** 2)) \\\n           + 200 * ((math.cos(i)) ** 4) / ((1 - 5 * ((math.cos(i)) ** 2)) ** 2)) * math.sin(2 * omega) \\\n           - gamma2p / 2 * math.cos(i) * (6 *(f - M + e * math.sin(f)) - 3 * math.sin(2 * omega + 2 * f) \\\n           - 3 * e * math.sin(2 * omega + f) - e * math.sin(2 * omega + 3 * f))  # (F.11)\n\n    edM = gamma2p / 8 * e * (eta ** 3) * (1 - 11 * ((math.cos(i)) ** 2) - 40 * ((math.cos(i)) ** 4) \\\n        /(1 - 5 * ((math.cos(i)) ** 2))) * math.sin(2 * omega) - gamma2p / 4 * (eta ** 3) * (2 * (3 * ((math.cos(i)) ** 2) - 1) \\\n        * ((a_r * eta) ** 2 + a_r + 1) * math.sin(f) + 3 *(1 - ((math.cos(i)) ** 2)) *((-(a_r * eta) ** 2 - a_r + 1) \\\n        * math.sin(2 * omega + f) + ((a_r * eta) ** 2 + a_r + 1 / 3) * math.sin(2 * omega + 3 * f)))  # (F.12)\n\n    dOmega = -gamma2p / 8 * (e ** 2) * math.cos(i) * (11 + 80 * ((math.cos(i)) ** 2) /(1 - 5 * ((math.cos(i)) ** 2)) \\\n           + 200 * ((math.cos(i)) ** 4) /((1 - 5 * ((math.cos(i)) ** 2)) ** 2)) * math.sin(2 * omega) \\\n           - gamma2p / 2 * math.cos(i) * (6 *(f - M + e * math.sin(f)) - 3 * math.sin(2 * omega + 2 * f) \\\n           - 3 * e * math.sin(2 * omega + f) - e* math.sin(2 * omega + 3 * f))  # (F.13)\n\n    d1 = (e+de)*math.sin(M) + edM*math.cos(M)  # (F.14)\n    d2 = (e+de)*math.cos(M) - edM*math.sin(M)  # (F.15)\n\n    Mp = math.atan2(d1, d2)  # (F.16)\n    ep = math.sqrt(d1**2+d2**2)  # (F.17)\n\n    d3 = (math.sin(i/2)+math.cos(i/2)*di/2)*math.sin(Omega) + math.sin(i/2)*dOmega*math.cos(Omega)  # (F.18)\n    d4 = (math.sin(i/2)+math.cos(i/2)*di/2)*math.cos(Omega) - math.sin(i/2)*dOmega*math.sin(Omega)  # (F.19)\n\n    Omegap = math.atan2(d3, d4)  # (F.20)\n    ip = 2*math.asin(np.clip(math.sqrt(d3**2+d4**2), a_min=-1.0, a_max=1.0))  # (F.21)\n    omegap = MpopOp - Mp - Omegap  # (F.22)\n\n    Ep = M2E(Mp, ep)\n    fp = E2f(Ep, ep)\n\n    oep.a = ap\n    oep.e = ep\n    oep.i = ip\n    oep.Omega = Omegap\n    oep.omega = omegap\n    oep.f = fp\n    return",
  "def clElem2eqElem(elements_cl, elements_eq):\n    \"\"\"\n    conversion\n    from classical orbital elements (a,e,i,Omega,omega,f)\n    to equinoctial orbital elements (a,P1,P2,Q1,Q2,l,L)\n\n    :param elements_cl: classical elements\n    :return: elements_eq, equinoctial elements\n    \"\"\"\n    elements_eq.a  = elements_cl.a\n    elements_eq.P1 = elements_cl.e * math.sin(elements_cl.Omega + elements_cl.omega)\n    elements_eq.P2 = elements_cl.e * math.cos(elements_cl.Omega + elements_cl.omega)\n    elements_eq.Q1 = math.tan(elements_cl.i / 2) * math.sin(elements_cl.Omega)\n    elements_eq.Q2 = math.tan(elements_cl.i / 2) * math.cos(elements_cl.Omega)\n    E              = f2E(elements_cl.f, elements_cl.e)\n    M              = E2M(E, elements_cl.e)\n    elements_eq.l  = elements_cl.Omega + elements_cl.omega + M\n    elements_eq.L  = elements_cl.Omega + elements_cl.omega + elements_cl.f\n    return",
  "def hillFrame(rc_N, vc_N):\n    \"\"\"\n    Compute the Hill frame DCM HN\n    :param rc_N: inertial position vector\n    :param vc_N: inertial velocity vector\n    :return: HN: DCM that maps from the inertial frame N to the Hill (i.e. orbit) frame H\n    \"\"\"\n    ir = rc_N/la.norm(rc_N)\n    h = np.cross(rc_N, vc_N)\n    ih = h / la.norm(h)\n    itheta = np.cross(ih, ir)\n\n    return np.array([ir, itheta, ih])",
  "def rv2hill(rc_N, vc_N, rd_N, vd_N):\n    \"\"\"\n    Express the deputy position and velocity vector as chief by the chief Hill frame.\n\n    :param rc_N: chief inertial position vector\n    :param vc_N: chief inertial velocity vector\n    :param rd_N: chief deputy position vector\n    :param vd_N: chief deputy velocity vector\n    :return: rho_H, rhoPrime_H: Hill frame relative position and velocity vectors\n    \"\"\"\n\n    HN = hillFrame(rc_N, vc_N)\n    fDot = la.norm(np.cross(rc_N, vc_N))/(la.norm(rc_N)**2)\n    omega_HN_H = np.array([0, 0, fDot])\n    rho_H = np.matmul(HN, rd_N - rc_N)\n    rhoPrime_H = np.matmul(HN, vd_N - vc_N) - np.cross(omega_HN_H, rho_H)\n    return rho_H, rhoPrime_H",
  "def hill2rv(rc_N, vc_N, rho_H, rhoPrime_H):\n    \"\"\"\n    Map the deputy position and velocity vector relative to the chief Hill frame to inertial frame.\n\n    :param rc_N: chief inertial position vector\n    :param vc_N: chief inertial velocity vector\n    :param rho_H: deputy Hill relative position vector\n    :param rhoPrime_H: deputy Hill relative velocity vector\n    :return:  rd_N, vd_N: Deputy inertial position and velocity vectors\n    \"\"\"\n\n    NH = hillFrame(rc_N, vc_N).transpose()\n    fDot = la.norm(np.cross(rc_N, vc_N)) / (la.norm(rc_N) ** 2)\n    omega_HN_H = np.array([0, 0, fDot])\n    rd_N = rc_N + np.matmul(NH, rho_H)\n    vd_N = vc_N + np.matmul(NH, rhoPrime_H + np.cross(omega_HN_H, rho_H))\n    return rd_N, vd_N",
  "def spkRead(target, time, ref, observer):\n    \"\"\"Spice spk read method\"\"\"\n    et = pyswice.new_doubleArray(1)\n    pyswice.str2et_c(time, et)\n    state = pyswice.new_doubleArray(6)\n    lt = pyswice.new_doubleArray(1)\n\n    pyswice.spkezr_c(target, pyswice.doubleArray_getitem(et, 0), ref, \"NONE\", observer, state, lt)\n    stateArray = numpy.zeros(6)\n    lightTime = pyswice.doubleArray_getitem(lt, 0)\n    for i in range(6):\n        stateArray[i] = pyswice.doubleArray_getitem(state, i)\n    pyswice.delete_doubleArray(state)\n    pyswice.delete_doubleArray(lt)\n    pyswice.delete_doubleArray(et)\n    return stateArray",
  "class gravBodyFactory(object):\n    \"\"\"Factory cass to create gravitational bodies.\"\"\"\n    def __init__(self, bodyNames=None):\n        self.spicePlanetNames = []\n        self.spicePlanetFrames = []\n        self.gravBodies = OrderedDict()\n        self.spiceObject = None\n        self.spiceKernelFileNames = []\n        self.epochMsg = None\n        if bodyNames:\n            self.createBodies(bodyNames)\n\n    def createBodies(self, bodyNames):\n        \"\"\"\n            A convenience function to create multiple typical solar system bodies.\n\n            Parameters\n            ----------\n            bodyNames : array_like\n                Planet name strings. Each planet name must be a valid SPICE celestial body string.\n\n            Returns\n            -------\n            gravBodies : array_like\n                A list of gravity body objects held by the gravity factory.\n        \"\"\"\n        for name in bodyNames:\n            if name == 'mercury':\n                self.createMercury()\n            elif name == 'venus':\n                self.createVenus()\n            elif name == \"earth\":\n                self.createEarth()\n            elif name == \"moon\":\n                self.createMoon()\n            elif name == \"mars\":\n                self.createMars()\n            elif name == \"mars barycenter\":\n                self.createMarsBarycenter()\n            elif name == \"jupiter barycenter\":\n                self.createJupiter()\n            elif name == \"saturn\":\n                self.createSaturn()\n            elif name == 'uranus':\n                self.createUranus()\n            elif name == 'neptune':\n                self.createNeptune()\n            elif name == \"sun\":\n                self.createSun()\n            else:\n                print(\"gravBody \" + name + \" not found in gravBodyUtilities.py\")\n        return self.gravBodies\n\n    # Note, in the `create` functions below the `isCentralBody` and `useSphericalHarmParams` are\n    # all set to False in the `GravGodyData()` constructor.\n\n    def createSun(self):\n        \"\"\"Create gravity body with sun mass properties.\"\"\"\n        sun = gravityEffector.GravBodyData()\n        sun.planetName = \"sun_planet_data\"\n        sun.displayName = \"sun\"\n        sun.modelDictionaryKey = \"\"\n        sun.mu = 1.32712440018E20  # meters^3/s^2\n        sun.radEquator = 695508000.0  # meters\n        self.gravBodies['sun'] = sun\n        self.spicePlanetFrames.append(\"IAU_sun\")\n        sun.this.disown()\n        return sun\n\n    def createMercury(self):\n        \"\"\"Create gravity body with Mercury mass properties.\"\"\"\n        mercury = gravityEffector.GravBodyData()\n        mercury.planetName = \"mercury_planet_data\"\n        mercury.displayName = \"mercury\"\n        mercury.modelDictionaryKey = \"\"\n        mercury.mu = 4.28283100e13  # meters^3/s^2\n        mercury.radEquator = 2439700.0  # meters\n        self.gravBodies['mercury'] = mercury\n        self.spicePlanetFrames.append(\"IAU_mercury\")\n        mercury.this.disown()\n        return mercury\n\n    def createVenus(self):\n        \"\"\"Create gravity body with Venus mass properties.\"\"\"\n        venus = gravityEffector.GravBodyData()\n        venus.planetName = \"venus_planet_data\"\n        venus.displayName = \"venus\"\n        venus.modelDictionaryKey = \"\"\n        venus.mu = 3.24858599e14  # meters^3/s^2\n        venus.radEquator = 6051800.0  # meters\n        self.gravBodies['venus'] = venus\n        self.spicePlanetFrames.append(\"IAU_venus\")\n        venus.this.disown()\n        return venus\n\n    def createEarth(self):\n        \"\"\"Create gravity body with Earth mass properties.\"\"\"\n        earth = gravityEffector.GravBodyData()\n        earth.planetName = \"earth_planet_data\"\n        earth.displayName = \"earth\"\n        earth.modelDictionaryKey = \"\"\n        earth.mu = 0.3986004415E+15  # meters^3/s^2\n        earth.radEquator = 6378136.6  # meters\n        self.gravBodies['earth'] = earth\n        self.spicePlanetFrames.append(\"IAU_earth\")\n        earth.this.disown()\n        return earth\n\n    def createMoon(self):\n        \"\"\"Create gravity body with Moon mass properties.\"\"\"\n        moon = gravityEffector.GravBodyData()\n        moon.planetName = \"moon_planet_data\"\n        moon.displayName = \"moon\"\n        moon.modelDictionaryKey = \"\"\n        moon.mu = 4.902799E12  # meters^3/s^2\n        moon.radEquator = 1738100.0  # meters\n        self.gravBodies['moon'] = moon\n        self.spicePlanetFrames.append(\"IAU_moon\")\n        moon.this.disown()\n        return moon\n\n    def createMars(self):\n        \"\"\"Create gravity body with Mars mass properties.\"\"\"\n        mars = gravityEffector.GravBodyData()\n        mars.planetName = \"mars_planet_data\"\n        mars.displayName = \"mars\"\n        mars.modelDictionaryKey = \"\"\n        mars.mu = 4.28283100e13  # meters^3/s^2\n        mars.radEquator = 3396190  # meters\n        self.gravBodies['mars'] = mars\n        self.spicePlanetFrames.append(\"IAU_mars\")\n        mars.this.disown()\n        return mars\n\n    def createMarsBarycenter(self):\n        \"\"\"Create gravity body with Mars mass properties.\"\"\"\n        mars_barycenter = gravityEffector.GravBodyData()\n        mars_barycenter.planetName = \"mars barycenter_planet_data\"\n        mars_barycenter.displayName = \"mars\"\n        mars_barycenter.modelDictionaryKey = \"\"\n        mars_barycenter.mu = 4.28283100e13  # meters^3/s^2\n        mars_barycenter.radEquator = 3396190  # meters\n        self.gravBodies['mars barycenter'] = mars_barycenter\n        self.spicePlanetFrames.append(\"IAU_mars\")\n        mars_barycenter.this.disown()\n        return mars_barycenter\n\n    def createJupiter(self):\n        \"\"\"Create gravity body with Jupiter mass properties.\"\"\"\n        jupiter = gravityEffector.GravBodyData()\n        jupiter.planetName = \"jupiter barycenter_planet_data\"\n        jupiter.displayName = \"jupiter\"\n        jupiter.modelDictionaryKey = \"\"\n        jupiter.mu = 1.266865349093058E17  # meters^3/s^2\n        jupiter.radEquator = 71492000.0  # meters\n        self.gravBodies['jupiter barycenter'] = jupiter\n        self.spicePlanetFrames.append(\"IAU_jupiter\")\n        jupiter.this.disown()\n        return jupiter\n\n    def createSaturn(self):\n        \"\"\"Create gravity body with Saturn mass properties.\"\"\"\n        saturn = gravityEffector.GravBodyData()\n        saturn.planetName = \"saturn barycenter_planet_data\"\n        saturn.displayName = \"saturn\"\n        saturn.modelDictionaryKey = \"\"\n        saturn.mu = 3.79395000E16  # meters^3/s^2\n        saturn.radEquator = 60268000.0  # meters\n        self.gravBodies['saturn'] = saturn\n        self.spicePlanetFrames.append(\"IAU_saturn\")\n        saturn.this.disown()\n        return saturn\n\n    def createUranus(self):\n        \"\"\"Create gravity body with Uranus mass properties.\"\"\"\n        uranus = gravityEffector.GravBodyData()\n        uranus.planetName = \"uranus barycenter_planet_data\"\n        uranus.displayName = \"uranus\"\n        uranus.modelDictionaryKey = \"\"\n        uranus.mu = 5.79396566E15  # meters^3/s^2\n        uranus.radEquator = 25559000.0  # meters\n        self.gravBodies['uranus'] = uranus\n        self.spicePlanetFrames.append(\"IAU_uranus\")\n        uranus.this.disown()\n        return uranus\n\n    def createNeptune(self):\n        \"\"\"Create gravity body with Neptune mass properties.\"\"\"\n        neptune = gravityEffector.GravBodyData()\n        neptune.planetName = \"neptune barycenter_planet_data\"\n        neptune.displayName = \"neptune\"\n        neptune.modelDictionaryKey = \"\"\n        neptune.mu = 6.83509920E15  # meters^3/s^2\n        neptune.radEquator = 24764000.0  # meters\n        self.gravBodies['neptune'] = neptune\n        self.spicePlanetFrames.append(\"IAU_neptune\")\n        neptune.this.disown()\n        return neptune\n\n    def createCustomGravObject(self, label, mu, **kwargs):\n        \"\"\"\n            Create a custom gravity body object.\n\n            Parameters\n            ----------\n            label : string\n                Gravity body name\n            mu : double\n                Gravity constant\n\n            Other Parameters\n            ----------------\n            kwargs :\n                radEquator : double\n                    Equatorial radius in meters\n                radiusRatio : double\n                    Ratio of the polar radius to the equatorial radius.\n                planetFrame : string\n                    Name of the spice planet frame\n                displayName: string\n                    Vizard celestial body name, if not provided then planetFrame becomes the Vizard name\n                modelDictionaryKey: string\n                    Vizard model key name.  if not set, then either the displayName or planetName is used to set the model\n\n        \"\"\"\n        unitTestSupport.checkMethodKeyword(\n            ['radEquator', 'radiusRatio', 'planetFrame', 'displayName', 'modelDictionaryKey'],\n            kwargs)\n\n        if not isinstance(label, str):\n            print('ERROR: label must be a string')\n            exit(1)\n\n        gravBody = gravityEffector.GravBodyData()\n        gravBody.planetName = label\n        gravBody.mu = mu\n        if 'radEquator' in kwargs:\n            gravBody.radEquator = kwargs['radEquator']\n        if 'radiusRatio' in kwargs:\n            gravBody.radiusRatio = kwargs['radiusRatio']\n        if 'displayName' in kwargs:\n            gravBody.displayName = kwargs['displayName']\n        gravBody.modelDictionaryKey = \"\"\n        if 'modelDictionaryKey' in kwargs:\n            gravBody.modelDictionaryKey = kwargs['modelDictionaryKey']\n        self.gravBodies[label] = gravBody\n        planetFrame = \"\"\n        if 'planetFrame' in kwargs:\n            planetFrame = kwargs['planetFrame']\n        self.spicePlanetFrames.append(planetFrame)\n        gravBody.this.disown()\n        return gravBody\n\n    def createSpiceInterface(self, path, time, **kwargs):\n        \"\"\"\n            A convenience function to configure a NAIF Spice module for the simulation.\n            It connect the gravBodyData objects to the spice planet state messages.  Thus,\n            it must be run after the gravBodyData objects are created.\n\n            Parameters\n            ----------\n            path : string\n                The absolute path to the Basilisk source directory (default '').\n            time : string\n                The time string.\n\n            Other Parameters\n            ----------------\n            kwargs :\n                spiceKernalFileNames :\n                    A list of spice kernel file names including file extension.\n                spicePlanetNames :\n                    A list of planet names whose Spice data is loaded, overriding the gravBodies list.\n                spicePlanetFrames :\n                    A list of strings for the planet frame names.  If left empty for a planet, then\n                    ``IAU_`` + planetName is assumed for the planet frame.\n                epochInMsg: bool\n                    Flag to set an epoch input message for the spice interface\n\n        \"\"\"\n\n        if 'spiceKernalFileNames' in kwargs:\n            try:\n                for fileName in kwargs['spiceKernalFileNames']:\n                    self.spiceKernelFileNames.append(fileName)\n            except TypeError:\n                raise TypeError('spiceKernalFileNames expects a list')\n        else:\n            self.spiceKernelFileNames.extend(['de430.bsp', 'naif0012.tls', 'de-403-masses.tpc', 'pck00010.tpc'])\n\n        self.spicePlanetNames = []\n        if 'spicePlanetNames' in kwargs:\n            try:\n                for planetName in kwargs['spicePlanetNames']:\n                    self.spicePlanetNames.append(planetName)\n            except TypeError:\n                raise TypeError('spicePlanetNames expects a list')\n        else:\n            self.spicePlanetNames = list(self.gravBodies.keys())\n\n        if 'spicePlanetFrames' in kwargs:\n            try:\n                self.spicePlanetFrames = []\n                for planetFrame in kwargs['spicePlanetFrames']:\n                    self.spicePlanetFrames.append(planetFrame)\n            except TypeError:\n                raise TypeError('spicePlanetFrames expects a list')\n\n        self.spiceObject = spiceInterface.SpiceInterface()\n        self.spiceObject.ModelTag = \"SpiceInterfaceData\"\n        self.spiceObject.SPICEDataPath = path\n        self.spiceObject.addPlanetNames(spiceInterface.StringVector(self.spicePlanetNames))\n        self.spiceObject.UTCCalInit = time\n        if len(self.spicePlanetFrames) > 0:\n            self.spiceObject.planetFrames = spiceInterface.StringVector(self.spicePlanetFrames)\n\n        for fileName in self.spiceKernelFileNames:\n            self.spiceObject.loadSpiceKernel(fileName, path)\n        self.spiceObject.SPICELoaded = True\n\n        # subscribe Grav Body data to the spice state message\n        c = 0\n        for key, gravBodyDataItem in self.gravBodies.items():\n            gravBodyDataItem.planetBodyInMsg.subscribeTo(self.spiceObject.planetStateOutMsgs[c])\n            c += 1\n\n        # create and connect to an epoch input message\n        if 'epochInMsg' in kwargs:\n            if kwargs['epochInMsg']:\n                self.epochMsg = unitTestSupport.timeStringToGregorianUTCMsg(time, dataPath=path)\n                self.spiceObject.epochInMsg.subscribeTo(self.epochMsg)\n\n        return\n\n    def unloadSpiceKernels(self):\n        \"\"\"Method to unload spice kernals at the end of a simulation.\"\"\"\n        for fileName in self.spiceKernelFileNames:\n            self.spiceObject.unloadSpiceKernel(fileName, self.spiceObject.SPICEDataPath)\n        return",
  "def loadGravFromFile(fileName, spherHarm, maxDeg=2):\n    \"\"\"\n            Load the gravitational body spherical harmonics coefficients from a file.\n\n            Parameters\n            ----------\n            fileName : string\n                The full path to the specified data file.\n            spherHarm:\n                The spherical harmonics container of the gravity body.\n            maxDeg : integer\n                maximum degree of spherical harmonics to load\n\n\n            Notes\n            -----\n            This function is a convenience utility for loading in the spherical harmonics\n            coefficients from a data file.  The default harmonic degree is 2 unless specified.\n            Note that this function calls the gravityEffector function loadGravFromFile().\n    \"\"\"\n    loadGravFromFile_python(fileName, spherHarm, maxDeg)",
  "def loadPolyFromFile(fileName, poly):\n    \"\"\"\n            Load the gravitational body spherical harmonics coefficients from a file.\n\n            Parameters\n            ----------\n            fileName : string\n                The full path to the specified data file.\n            spherHarm:\n                The spherical harmonics container of the gravity body.\n            maxDeg : integer\n                maximum degree of spherical harmonics to load\n\n\n            Notes\n            -----\n            This function is a convenience utility for loading in the spherical harmonics\n            coefficients from a data file.  The default harmonic degree is 2 unless specified.\n            Note that this function calls the gravityEffector function loadGravFromFile().\n    \"\"\"\n    loadPolyFromFile_python(fileName, poly)",
  "def __init__(self, bodyNames=None):\n        self.spicePlanetNames = []\n        self.spicePlanetFrames = []\n        self.gravBodies = OrderedDict()\n        self.spiceObject = None\n        self.spiceKernelFileNames = []\n        self.epochMsg = None\n        if bodyNames:\n            self.createBodies(bodyNames)",
  "def createBodies(self, bodyNames):\n        \"\"\"\n            A convenience function to create multiple typical solar system bodies.\n\n            Parameters\n            ----------\n            bodyNames : array_like\n                Planet name strings. Each planet name must be a valid SPICE celestial body string.\n\n            Returns\n            -------\n            gravBodies : array_like\n                A list of gravity body objects held by the gravity factory.\n        \"\"\"\n        for name in bodyNames:\n            if name == 'mercury':\n                self.createMercury()\n            elif name == 'venus':\n                self.createVenus()\n            elif name == \"earth\":\n                self.createEarth()\n            elif name == \"moon\":\n                self.createMoon()\n            elif name == \"mars\":\n                self.createMars()\n            elif name == \"mars barycenter\":\n                self.createMarsBarycenter()\n            elif name == \"jupiter barycenter\":\n                self.createJupiter()\n            elif name == \"saturn\":\n                self.createSaturn()\n            elif name == 'uranus':\n                self.createUranus()\n            elif name == 'neptune':\n                self.createNeptune()\n            elif name == \"sun\":\n                self.createSun()\n            else:\n                print(\"gravBody \" + name + \" not found in gravBodyUtilities.py\")\n        return self.gravBodies",
  "def createSun(self):\n        \"\"\"Create gravity body with sun mass properties.\"\"\"\n        sun = gravityEffector.GravBodyData()\n        sun.planetName = \"sun_planet_data\"\n        sun.displayName = \"sun\"\n        sun.modelDictionaryKey = \"\"\n        sun.mu = 1.32712440018E20  # meters^3/s^2\n        sun.radEquator = 695508000.0  # meters\n        self.gravBodies['sun'] = sun\n        self.spicePlanetFrames.append(\"IAU_sun\")\n        sun.this.disown()\n        return sun",
  "def createMercury(self):\n        \"\"\"Create gravity body with Mercury mass properties.\"\"\"\n        mercury = gravityEffector.GravBodyData()\n        mercury.planetName = \"mercury_planet_data\"\n        mercury.displayName = \"mercury\"\n        mercury.modelDictionaryKey = \"\"\n        mercury.mu = 4.28283100e13  # meters^3/s^2\n        mercury.radEquator = 2439700.0  # meters\n        self.gravBodies['mercury'] = mercury\n        self.spicePlanetFrames.append(\"IAU_mercury\")\n        mercury.this.disown()\n        return mercury",
  "def createVenus(self):\n        \"\"\"Create gravity body with Venus mass properties.\"\"\"\n        venus = gravityEffector.GravBodyData()\n        venus.planetName = \"venus_planet_data\"\n        venus.displayName = \"venus\"\n        venus.modelDictionaryKey = \"\"\n        venus.mu = 3.24858599e14  # meters^3/s^2\n        venus.radEquator = 6051800.0  # meters\n        self.gravBodies['venus'] = venus\n        self.spicePlanetFrames.append(\"IAU_venus\")\n        venus.this.disown()\n        return venus",
  "def createEarth(self):\n        \"\"\"Create gravity body with Earth mass properties.\"\"\"\n        earth = gravityEffector.GravBodyData()\n        earth.planetName = \"earth_planet_data\"\n        earth.displayName = \"earth\"\n        earth.modelDictionaryKey = \"\"\n        earth.mu = 0.3986004415E+15  # meters^3/s^2\n        earth.radEquator = 6378136.6  # meters\n        self.gravBodies['earth'] = earth\n        self.spicePlanetFrames.append(\"IAU_earth\")\n        earth.this.disown()\n        return earth",
  "def createMoon(self):\n        \"\"\"Create gravity body with Moon mass properties.\"\"\"\n        moon = gravityEffector.GravBodyData()\n        moon.planetName = \"moon_planet_data\"\n        moon.displayName = \"moon\"\n        moon.modelDictionaryKey = \"\"\n        moon.mu = 4.902799E12  # meters^3/s^2\n        moon.radEquator = 1738100.0  # meters\n        self.gravBodies['moon'] = moon\n        self.spicePlanetFrames.append(\"IAU_moon\")\n        moon.this.disown()\n        return moon",
  "def createMars(self):\n        \"\"\"Create gravity body with Mars mass properties.\"\"\"\n        mars = gravityEffector.GravBodyData()\n        mars.planetName = \"mars_planet_data\"\n        mars.displayName = \"mars\"\n        mars.modelDictionaryKey = \"\"\n        mars.mu = 4.28283100e13  # meters^3/s^2\n        mars.radEquator = 3396190  # meters\n        self.gravBodies['mars'] = mars\n        self.spicePlanetFrames.append(\"IAU_mars\")\n        mars.this.disown()\n        return mars",
  "def createMarsBarycenter(self):\n        \"\"\"Create gravity body with Mars mass properties.\"\"\"\n        mars_barycenter = gravityEffector.GravBodyData()\n        mars_barycenter.planetName = \"mars barycenter_planet_data\"\n        mars_barycenter.displayName = \"mars\"\n        mars_barycenter.modelDictionaryKey = \"\"\n        mars_barycenter.mu = 4.28283100e13  # meters^3/s^2\n        mars_barycenter.radEquator = 3396190  # meters\n        self.gravBodies['mars barycenter'] = mars_barycenter\n        self.spicePlanetFrames.append(\"IAU_mars\")\n        mars_barycenter.this.disown()\n        return mars_barycenter",
  "def createJupiter(self):\n        \"\"\"Create gravity body with Jupiter mass properties.\"\"\"\n        jupiter = gravityEffector.GravBodyData()\n        jupiter.planetName = \"jupiter barycenter_planet_data\"\n        jupiter.displayName = \"jupiter\"\n        jupiter.modelDictionaryKey = \"\"\n        jupiter.mu = 1.266865349093058E17  # meters^3/s^2\n        jupiter.radEquator = 71492000.0  # meters\n        self.gravBodies['jupiter barycenter'] = jupiter\n        self.spicePlanetFrames.append(\"IAU_jupiter\")\n        jupiter.this.disown()\n        return jupiter",
  "def createSaturn(self):\n        \"\"\"Create gravity body with Saturn mass properties.\"\"\"\n        saturn = gravityEffector.GravBodyData()\n        saturn.planetName = \"saturn barycenter_planet_data\"\n        saturn.displayName = \"saturn\"\n        saturn.modelDictionaryKey = \"\"\n        saturn.mu = 3.79395000E16  # meters^3/s^2\n        saturn.radEquator = 60268000.0  # meters\n        self.gravBodies['saturn'] = saturn\n        self.spicePlanetFrames.append(\"IAU_saturn\")\n        saturn.this.disown()\n        return saturn",
  "def createUranus(self):\n        \"\"\"Create gravity body with Uranus mass properties.\"\"\"\n        uranus = gravityEffector.GravBodyData()\n        uranus.planetName = \"uranus barycenter_planet_data\"\n        uranus.displayName = \"uranus\"\n        uranus.modelDictionaryKey = \"\"\n        uranus.mu = 5.79396566E15  # meters^3/s^2\n        uranus.radEquator = 25559000.0  # meters\n        self.gravBodies['uranus'] = uranus\n        self.spicePlanetFrames.append(\"IAU_uranus\")\n        uranus.this.disown()\n        return uranus",
  "def createNeptune(self):\n        \"\"\"Create gravity body with Neptune mass properties.\"\"\"\n        neptune = gravityEffector.GravBodyData()\n        neptune.planetName = \"neptune barycenter_planet_data\"\n        neptune.displayName = \"neptune\"\n        neptune.modelDictionaryKey = \"\"\n        neptune.mu = 6.83509920E15  # meters^3/s^2\n        neptune.radEquator = 24764000.0  # meters\n        self.gravBodies['neptune'] = neptune\n        self.spicePlanetFrames.append(\"IAU_neptune\")\n        neptune.this.disown()\n        return neptune",
  "def createCustomGravObject(self, label, mu, **kwargs):\n        \"\"\"\n            Create a custom gravity body object.\n\n            Parameters\n            ----------\n            label : string\n                Gravity body name\n            mu : double\n                Gravity constant\n\n            Other Parameters\n            ----------------\n            kwargs :\n                radEquator : double\n                    Equatorial radius in meters\n                radiusRatio : double\n                    Ratio of the polar radius to the equatorial radius.\n                planetFrame : string\n                    Name of the spice planet frame\n                displayName: string\n                    Vizard celestial body name, if not provided then planetFrame becomes the Vizard name\n                modelDictionaryKey: string\n                    Vizard model key name.  if not set, then either the displayName or planetName is used to set the model\n\n        \"\"\"\n        unitTestSupport.checkMethodKeyword(\n            ['radEquator', 'radiusRatio', 'planetFrame', 'displayName', 'modelDictionaryKey'],\n            kwargs)\n\n        if not isinstance(label, str):\n            print('ERROR: label must be a string')\n            exit(1)\n\n        gravBody = gravityEffector.GravBodyData()\n        gravBody.planetName = label\n        gravBody.mu = mu\n        if 'radEquator' in kwargs:\n            gravBody.radEquator = kwargs['radEquator']\n        if 'radiusRatio' in kwargs:\n            gravBody.radiusRatio = kwargs['radiusRatio']\n        if 'displayName' in kwargs:\n            gravBody.displayName = kwargs['displayName']\n        gravBody.modelDictionaryKey = \"\"\n        if 'modelDictionaryKey' in kwargs:\n            gravBody.modelDictionaryKey = kwargs['modelDictionaryKey']\n        self.gravBodies[label] = gravBody\n        planetFrame = \"\"\n        if 'planetFrame' in kwargs:\n            planetFrame = kwargs['planetFrame']\n        self.spicePlanetFrames.append(planetFrame)\n        gravBody.this.disown()\n        return gravBody",
  "def createSpiceInterface(self, path, time, **kwargs):\n        \"\"\"\n            A convenience function to configure a NAIF Spice module for the simulation.\n            It connect the gravBodyData objects to the spice planet state messages.  Thus,\n            it must be run after the gravBodyData objects are created.\n\n            Parameters\n            ----------\n            path : string\n                The absolute path to the Basilisk source directory (default '').\n            time : string\n                The time string.\n\n            Other Parameters\n            ----------------\n            kwargs :\n                spiceKernalFileNames :\n                    A list of spice kernel file names including file extension.\n                spicePlanetNames :\n                    A list of planet names whose Spice data is loaded, overriding the gravBodies list.\n                spicePlanetFrames :\n                    A list of strings for the planet frame names.  If left empty for a planet, then\n                    ``IAU_`` + planetName is assumed for the planet frame.\n                epochInMsg: bool\n                    Flag to set an epoch input message for the spice interface\n\n        \"\"\"\n\n        if 'spiceKernalFileNames' in kwargs:\n            try:\n                for fileName in kwargs['spiceKernalFileNames']:\n                    self.spiceKernelFileNames.append(fileName)\n            except TypeError:\n                raise TypeError('spiceKernalFileNames expects a list')\n        else:\n            self.spiceKernelFileNames.extend(['de430.bsp', 'naif0012.tls', 'de-403-masses.tpc', 'pck00010.tpc'])\n\n        self.spicePlanetNames = []\n        if 'spicePlanetNames' in kwargs:\n            try:\n                for planetName in kwargs['spicePlanetNames']:\n                    self.spicePlanetNames.append(planetName)\n            except TypeError:\n                raise TypeError('spicePlanetNames expects a list')\n        else:\n            self.spicePlanetNames = list(self.gravBodies.keys())\n\n        if 'spicePlanetFrames' in kwargs:\n            try:\n                self.spicePlanetFrames = []\n                for planetFrame in kwargs['spicePlanetFrames']:\n                    self.spicePlanetFrames.append(planetFrame)\n            except TypeError:\n                raise TypeError('spicePlanetFrames expects a list')\n\n        self.spiceObject = spiceInterface.SpiceInterface()\n        self.spiceObject.ModelTag = \"SpiceInterfaceData\"\n        self.spiceObject.SPICEDataPath = path\n        self.spiceObject.addPlanetNames(spiceInterface.StringVector(self.spicePlanetNames))\n        self.spiceObject.UTCCalInit = time\n        if len(self.spicePlanetFrames) > 0:\n            self.spiceObject.planetFrames = spiceInterface.StringVector(self.spicePlanetFrames)\n\n        for fileName in self.spiceKernelFileNames:\n            self.spiceObject.loadSpiceKernel(fileName, path)\n        self.spiceObject.SPICELoaded = True\n\n        # subscribe Grav Body data to the spice state message\n        c = 0\n        for key, gravBodyDataItem in self.gravBodies.items():\n            gravBodyDataItem.planetBodyInMsg.subscribeTo(self.spiceObject.planetStateOutMsgs[c])\n            c += 1\n\n        # create and connect to an epoch input message\n        if 'epochInMsg' in kwargs:\n            if kwargs['epochInMsg']:\n                self.epochMsg = unitTestSupport.timeStringToGregorianUTCMsg(time, dataPath=path)\n                self.spiceObject.epochInMsg.subscribeTo(self.epochMsg)\n\n        return",
  "def unloadSpiceKernels(self):\n        \"\"\"Method to unload spice kernals at the end of a simulation.\"\"\"\n        for fileName in self.spiceKernelFileNames:\n            self.spiceObject.unloadSpiceKernel(fileName, self.spiceObject.SPICEDataPath)\n        return",
  "def pull_and_format_df(path, varIdxLen):\n    df = pd.read_pickle(path)\n    if len(np.unique(df.columns.codes[1])) is not varIdxLen:\n        print(\"Warning: \" + path + \" not formatted correctly!\")\n        newMultIndex = pd.MultiIndex.from_product([df.columns.codes[0], list(range(varIdxLen))], names=['runNum', 'varIdx'])\n        indices = pd.Index([0,1]) # Need multiple rows for curves\n        df = df.reindex(columns=newMultIndex, index=indices)\n    return df",
  "def curve_per_df_component(df):\n    \"\"\"\n    Make a curve per component in the message dataframe (i.e. omega_BR_B[2] across all runs as a single curve)\n\n    :param df:\n    :return:\n    \"\"\"\n    idx = pd.IndexSlice\n    df = df.interpolate(method = \"linear\")\n    df_list = []\n    for i in np.unique(df.columns.codes[1]):\n        # Select all of the component\n        varIdx_df = df.loc[idx[:], idx[:, i]]\n\n        # Inject NaNs at the end of the run so the curves don't wrap from t_f to t_0\n        varIdx_df = varIdx_df.append(pd.Series(name=np.nan, dtype='float'))\n\n        # Flatten values by column order\n        time = np.tile(varIdx_df.index, len(varIdx_df.columns.codes[0]))  # Repeat time by number of runs\n        varIdx_flat = varIdx_df.values.flatten('F')\n\n        # Generate a curve for each component\n        curve_df = pd.DataFrame(np.transpose([time, varIdx_flat]).tolist(), columns=['x', 'y'])\n        df_list.append(curve_df)\n\n    return df_list",
  "def curve_per_df_column(df):\n    \"\"\"\n    Divides the dataframe by column into format friendly for datashaders\n    :return: List of single column dataframes\n    \"\"\"\n    idx = pd.IndexSlice\n    df_list = []\n    for index in range(len(df.columns)):\n        try:\n            i = df.columns.codes[0][index] # Multi-Index level=0 index\n            j = df.columns.codes[1][index] # Multi-Index level=1 index\n\n            # Grab the desired x and y data\n            xData = df.index.values # time [ns]\n            yData = df.loc[idx[:], idx[i, j]].values # variable data\n            runNum = np.repeat(i, len(xData))\n        except:\n            # Grab the desired x and y data\n            xData = df.index.values  # time [ns]\n            yData = df.loc[idx[:], idx[index]].values  # variable data\n            runNum = np.repeat(index, len(xData))\n\n        # Convert to two columns\n        plotData = pd.DataFrame(np.transpose([xData, yData]).tolist(), columns=['x', 'y'])#, runNum]).tolist()\n        df_list.append(plotData)\n    return df_list",
  "class DS_Plot():\n    '''\n    Object which stores data necessary to generate a bokeh image.\n    '''\n\n    def __init__(self, data, title='',\n              yAxisLabel='', xAxisLabel='time [ns]',\n              macro_y=1.0, macro_x=macros.NANO2SEC,\n              cmap=Sets1to3,\n              plotObjType=hv.Curve,\n              labels=[],\n              plotFcn=curve_per_df_component):\n        if type(data) is not list:\n            self.data = [data]\n        else:\n            self.data = data\n        self.title = title\n        self.yAxisLabel = yAxisLabel\n        self.xAxisLabel = xAxisLabel\n        self.macro_x = macro_x\n        self.macro_y = macro_y\n        self.plotObjType = plotObjType\n        self.cmap = cmap\n        #self.backend =\n        self.labels = labels\n        self.plotFcn = plotFcn\n\n\n    def generateCurves(self):\n        '''\n        Generate hv.Curve or hv.Points from the provided dataframe(s)\n        Scales the index and values using macro_x and macro_y\n        Populates a dictionary with a unique identifier for each curve for curve coloring purposes\n        :return: dict of hv.Curve or hv.Point objects\n        '''\n        count = 0\n        curves = []\n        missingData = []\n        self.min = self.data[0].values.min()\n        self.max = self.data[0].values.max()\n\n        for i in range(len(self.data)):\n            if self.min > self.data[0].values.min() : self.min = self.data[0].values.min()\n            if self.max < self.data[0].values.max() : self.max = self.data[0].values.max()\n            self.data[i] = self.data[i] * self.macro_y\n            self.data[i].index = self.data[i].index * 1e-9\n\n            # Seperate dataframe by component\n            curveList = self.plotFcn(self.data[i])  # Only one component so it will be a single curve\n\n            # Customize the individual component curves, points, other\n            for curve_df in curveList:\n                curve = self.plotObjType(curve_df)#.opts(framewise=True)\n                curves.append(curve)\n                count += 1\n\n            if self.data[i].dropna().empty:\n                missingData.append(True)\n        # Label each curve with a unique identifier\n        curves = {i: curves[i] for i in range(len(curves))}\n        return curves, missingData\n\n\n    def generateImage(self):\n        '''\n        Generate the image to be sent to the bokeh server. This includes\n        1) generating curves from the dataframe or list of dataframes,\n        2) overlaying those curves onto a single image, and\n        3) populating various annotations and asethetic configurations\n        :return: hv.DynImage()\n        '''\n        hv.extension('bokeh')\n        # Overlay these curves\n        curves, missingData = self.generateCurves()\n        overlay = hv.NdOverlay(curves, kdims='k')#.opts(framewise=True)\n\n        # Rasterize the plot using datashade()\n        if np.sum(missingData) == len(self.data):\n            image = hv.Text(0.5, 0.5, \"All Data Missing\")\n        else:\n            if self.min == self.max and self.min != np.nan:\n                y_range = (self.min-0.1, self.max+0.1)\n                image = dynspread(datashade(overlay, dynamic=True, streams=[RangeXY],\n                                            aggregator=ds.count_cat('k'), color_key=self.cmap,\n                                            y_range=y_range)).opts(framewise=True)\n            else:\n                image = dynspread(datashade(overlay, dynamic=True, streams=[RangeXY],\n                                            aggregator=ds.count_cat('k'), color_key=self.cmap\n                                           )).opts(framewise=True)\n\n        image.opts(width=960, height=540)\n        image.opts(tools=['hover'])\n        image.opts(padding=0.05)\n        image.opts(title=self.title, xlabel=self.xAxisLabel, ylabel=self.yAxisLabel)\n\n        if not self.labels == []:\n            color_key = [(name, color) for name, color in zip(self.labels, self.cmap)]\n            legend = hv.NdOverlay({n: hv.Points([np.nan, np.nan], label=str(n)).opts(style=dict(color=c)) for n, c in color_key})\n            image = image*legend\n\n        return image, self.title",
  "def __init__(self, data, title='',\n              yAxisLabel='', xAxisLabel='time [ns]',\n              macro_y=1.0, macro_x=macros.NANO2SEC,\n              cmap=Sets1to3,\n              plotObjType=hv.Curve,\n              labels=[],\n              plotFcn=curve_per_df_component):\n        if type(data) is not list:\n            self.data = [data]\n        else:\n            self.data = data\n        self.title = title\n        self.yAxisLabel = yAxisLabel\n        self.xAxisLabel = xAxisLabel\n        self.macro_x = macro_x\n        self.macro_y = macro_y\n        self.plotObjType = plotObjType\n        self.cmap = cmap\n        #self.backend =\n        self.labels = labels\n        self.plotFcn = plotFcn",
  "def generateCurves(self):\n        '''\n        Generate hv.Curve or hv.Points from the provided dataframe(s)\n        Scales the index and values using macro_x and macro_y\n        Populates a dictionary with a unique identifier for each curve for curve coloring purposes\n        :return: dict of hv.Curve or hv.Point objects\n        '''\n        count = 0\n        curves = []\n        missingData = []\n        self.min = self.data[0].values.min()\n        self.max = self.data[0].values.max()\n\n        for i in range(len(self.data)):\n            if self.min > self.data[0].values.min() : self.min = self.data[0].values.min()\n            if self.max < self.data[0].values.max() : self.max = self.data[0].values.max()\n            self.data[i] = self.data[i] * self.macro_y\n            self.data[i].index = self.data[i].index * 1e-9\n\n            # Seperate dataframe by component\n            curveList = self.plotFcn(self.data[i])  # Only one component so it will be a single curve\n\n            # Customize the individual component curves, points, other\n            for curve_df in curveList:\n                curve = self.plotObjType(curve_df)#.opts(framewise=True)\n                curves.append(curve)\n                count += 1\n\n            if self.data[i].dropna().empty:\n                missingData.append(True)\n        # Label each curve with a unique identifier\n        curves = {i: curves[i] for i in range(len(curves))}\n        return curves, missingData",
  "def generateImage(self):\n        '''\n        Generate the image to be sent to the bokeh server. This includes\n        1) generating curves from the dataframe or list of dataframes,\n        2) overlaying those curves onto a single image, and\n        3) populating various annotations and asethetic configurations\n        :return: hv.DynImage()\n        '''\n        hv.extension('bokeh')\n        # Overlay these curves\n        curves, missingData = self.generateCurves()\n        overlay = hv.NdOverlay(curves, kdims='k')#.opts(framewise=True)\n\n        # Rasterize the plot using datashade()\n        if np.sum(missingData) == len(self.data):\n            image = hv.Text(0.5, 0.5, \"All Data Missing\")\n        else:\n            if self.min == self.max and self.min != np.nan:\n                y_range = (self.min-0.1, self.max+0.1)\n                image = dynspread(datashade(overlay, dynamic=True, streams=[RangeXY],\n                                            aggregator=ds.count_cat('k'), color_key=self.cmap,\n                                            y_range=y_range)).opts(framewise=True)\n            else:\n                image = dynspread(datashade(overlay, dynamic=True, streams=[RangeXY],\n                                            aggregator=ds.count_cat('k'), color_key=self.cmap\n                                           )).opts(framewise=True)\n\n        image.opts(width=960, height=540)\n        image.opts(tools=['hover'])\n        image.opts(padding=0.05)\n        image.opts(title=self.title, xlabel=self.xAxisLabel, ylabel=self.yAxisLabel)\n\n        if not self.labels == []:\n            color_key = [(name, color) for name, color in zip(self.labels, self.cmap)]\n            legend = hv.NdOverlay({n: hv.Points([np.nan, np.nan], label=str(n)).opts(style=dict(color=c)) for n, c in color_key})\n            image = image*legend\n\n        return image, self.title",
  "def ckWrite(handle, time, MRPArray, avArray, startSeg, sc = -62, rf = \"J2000\"):\n    \"\"\"\n    Purpose: Creates a CK kernel from a timeArray, MRPArray, and an avArray. Assumes that the SCLK is furnshed\n\n    .. warning::\n\n        time stamps for the timeArray, MRPArray, and avArray must line up exactly!!\n\n    :param handle: What you would like the CK file to be named. Note, it must be in double quotes and end in .bc, ex: \"moikernel.bc\"\n    :param time: numpy array of time stamps in nanoseconds\n    :param MRPArray: array of modified Rodriguez parameters in column order x, y, z\n    :param avArray: array of angular velocities about 3 axis in column order x, y, z\n    :param startSeg: the SCLK time that the file begins at in UTC Gregorian ex: 'FEB 01,2021  12:00:55.9999 (UTC)'\n    :param sc: spacecraft ID ex:-62\n    :param rf: reference frame ex:\"J2000\"\n    :return:\n    \"\"\"\n    try:\n        os.remove(handle)\n    except OSError:\n        pass\n    fileHandle = pyswice.new_intArray(1)\n    pyswice.ckopn_c(handle, \"my-ckernel\", 0, fileHandle)\n    velLen = avArray.shape[0]\n    velArray = pyswice.new_doubleArray(velLen * 3)\n    z = MRPArray.shape[0]\n    shapeMRP = numpy.shape(MRPArray)\n    shapeavArray = numpy.shape(avArray)\n    et = pyswice.new_doubleArray(1)\n    pyswice.str2et_c(startSeg, et)\n    starts = pyswice.new_doubleArray(1)\n    pyswice.sce2c_c(sc, pyswice.doubleArray_getitem(et, 0), starts)\n    zeroTime = 0  # pyswice.doubleArray_getitem(starts, 0)\n    for w in range(velLen):\n        for m in range(3):\n            if shapeavArray[1] == 4:\n                pyswice.doubleArray_setitem(velArray, (3 * w) + m, avArray[w, m + 1])\n            else:\n                pyswice.doubleArray_setitem(velArray, (3 * w) + m, avArray[w, m])\n    quatArray = pyswice.new_doubleArray(z * 4)\n    timeArray = pyswice.new_doubleArray(z)\n    for i in range(z):\n        for j in range(4):\n            if shapeMRP[1] == 4:\n                quat = RigidBodyKinematics.MRP2EP(MRPArray[i, 1:4])\n                quat[1:4] = -quat[1:4]\n            else:\n                quat = RigidBodyKinematics.MRP2EP(MRPArray[i, 0:3])\n                quat[1:4] = -quat[1:4]\n            pyswice.doubleArray_setitem(quatArray, (4 * i) + j, quat[j])\n        sclkdp = pyswice.new_doubleArray(1)\n        pyswice.sce2c_c(-62, time[i] + zeroTime*1.0E-9, sclkdp)\n        pyswice.doubleArray_setitem(timeArray, i, pyswice.doubleArray_getitem(sclkdp, 0))\n    # Getting time into usable format\n    encStartTime = pyswice.doubleArray_getitem(timeArray, 0) - 1.0e-3 #Pad the beginning for roundoff\n    encEndTime = pyswice.doubleArray_getitem(timeArray, z-1) + 1.0e-3 #Pad the end for roundoff\n    pyswice.ckw03_c(pyswice.intArray_getitem(fileHandle, 0), encStartTime, encEndTime, -62000, rf, 1,\n                    \"InertialData\", z, timeArray, quatArray, velArray, 1, starts)\n    pyswice.ckcls_c(pyswice.intArray_getitem(fileHandle, 0))\n    return",
  "def ckRead(time, SCID=-62, rf=\"J2000\"):\n    \"\"\"\n    Purpose: Read information out of a CK Kernel for a single instance and returns a quaternion array\n    and an angular velocity array\n\n    .. warning::\n\n        Assumes that SCLK and CK kernels are already loaded using furnsh because pyswice gets mad when loading the same files over and over again.\n\n    :param time: Should be in UTC Gregorian, and passed in as a string, ex: 'FEB 01,2021  14:00:55.9999 (UTC)'\n    :param SCID: Spacecraft ID -- Default: -62\n    :param rf: is a character string which specifies the, reference frame of the segment. Reference Frame, ex: \"J2000\"\n    :return: None\n    \"\"\"\n    #Getting time into usable format\n    et = pyswice.new_doubleArray(1)\n    pyswice.str2et_c(time, et)\n    tick = pyswice.new_doubleArray(1)\n    pyswice.sce2c_c(SCID, pyswice.doubleArray_getitem(et, 0), tick)\n    cmat = pyswice.new_doubleArray(9)\n    av = pyswice.new_doubleArray(3)\n    clkout = pyswice.new_doubleArray(1)\n    intArray = pyswice.new_intArray(1)\n    cmatConversion = numpy.zeros((3, 3))\n    kernalQuatArray = numpy.zeros((1, 4))\n    kernMRPArray = numpy.zeros((1, 3))\n    kernOmega = numpy.zeros((1, 3))\n    pyswice.ckgpav_c(SCID, pyswice.doubleArray_getitem(tick, 0), 0, rf, cmat, av, clkout, intArray)\n    for q in range(9):\n        if q < 3:\n            cmatConversion[0, q] = pyswice.doubleArray_getitem(cmat, q)\n            kernOmega[0, q] = pyswice.doubleArray_getitem(av, q)\n        elif q >= 6:\n            cmatConversion[2, (q - 6)] = pyswice.doubleArray_getitem(cmat, q)\n        else:\n            cmatConversion[1, (q - 3)] = pyswice.doubleArray_getitem(cmat, q)\n    kernalQuat = RigidBodyKinematics.C2EP(cmatConversion)\n    kernMRP = RigidBodyKinematics.C2MRP(cmatConversion)\n    for s in range(4):\n        if s < 3:\n            kernMRPArray[0, s] = -kernMRP[s]\n        kernalQuatArray[0, s] = -kernalQuat[s]\n        if s == 0:\n            kernalQuatArray[0, s] = -kernalQuatArray[0, s]\n    etout = pyswice.doubleArray_getitem(et, 0)\n    return etout, kernalQuatArray, kernOmega",
  "def ckInitialize(ck_file_in):\n    pyswice.furnsh_c(ck_file_in)",
  "def ckClose(ck_file_in):\n    pyswice.unload_c(ck_file_in)",
  "def spkRead(target, time, ref, observer):\n    et = pyswice.new_doubleArray(1)\n    pyswice.str2et_c(time, et)\n    state = pyswice.new_doubleArray(6)\n    lt = pyswice.new_doubleArray(1)\n\n    pyswice.spkezr_c(target, pyswice.doubleArray_getitem(et, 0), ref, \"NONE\",\n        observer, state, lt)\n    stateArray = numpy.zeros(6)\n    lightTime = pyswice.doubleArray_getitem(lt, 0)\n    for i in range(6):\n        stateArray[i] = pyswice.doubleArray_getitem(state, i)\n    return stateArray",
  "def normalize(v):\n    \"\"\"normalize a vector\"\"\"\n    norm=np.linalg.norm(v)\n    if norm==0:\n       return v\n    return v/norm",
  "def orbitalPeriod(a, mu):\n    \"\"\"Return the orbit period\"\"\"\n    P = 2*PI * np.sqrt(a*a*a / mu)\n    return P",
  "def orbitalSMA(P, mu):\n    \"\"\"Return the semi-major axis\"\"\"\n    a3 = mu * np.power(P / (2 * PI) , 2)\n    exp = 1./3\n    a = np.power(a3, exp)\n    return a",
  "def Earth_RV(JDE):\n    \"\"\"return Earth (r,v)\"\"\"\n    (a, e, i, Omega, w, nu) = ephemeridesMeeus(JDE, 'EARTH')\n    return OE2RV(mu_S, a, e, i, Omega, w, nu)",
  "def Mars_RV(JDE):\n    \"\"\"return Mars (r,v)\"\"\"\n    (a, e, i, Omega, w, nu) = ephemeridesMeeus(JDE, 'MARS')\n    return OE2RV(mu_S, a, e, i, Omega, w, nu)",
  "def Jupiter_RV(JDE):\n    \"\"\"return Jupiter (r,v)\"\"\"\n    (a, e, i, Omega, w, nu) = ephemeridesMeeus(JDE, 'JUPITER')\n    return OE2RV(mu_S, a, e, i, Omega, w, nu)",
  "def Venus_RV(JDE):\n    \"\"\"return Venus (r,v)\"\"\"\n    (a, e, i, Omega, w, nu) = ephemeridesMeeus(JDE, 'VENUS')\n    return OE2RV(mu_S, a, e, i, Omega, w, nu)",
  "def Pluto_RV(JDE):\n    \"\"\"return Pluto (r,v)\"\"\"\n    (a, e, i, Omega, w, nu) = ephemeridesMeeus(JDE, 'PLUTO')\n    return OE2RV(mu_S, a, e, i, Omega, w, nu)",
  "def Uranus_RV(JDE):\n    \"\"\"return Uranus (r,v)\"\"\"\n    (a, e, i, Omega, w, nu) = ephemeridesMeeus(JDE, 'URANUS')\n    return OE2RV(mu_S, a, e, i, Omega, w, nu)",
  "def Neptune_RV(JDE):\n    \"\"\"return Neptune (r,v)\"\"\"\n    (a, e, i, Omega, w, nu) = ephemeridesMeeus(JDE, 'NEPTUNE')\n    return OE2RV(mu_S, a, e, i, Omega, w, nu)",
  "def Saturn_RV(JDE):\n    \"\"\"return Saturn (r,v)\"\"\"\n    (a, e, i, Omega, w, nu) = ephemeridesMeeus(JDE, 'SATURN')\n    return OE2RV(mu_S, a, e, i, Omega, w, nu)",
  "def OE2RV(mu, a, e, i, Omega, w, nu):\n    \"\"\"OE to (r,v) conversion\"\"\"\n    if e!=1:\n        p = a*(1-e*e)\n    else:\n        print('ERROR: parabolic case')\n        return\n    c = np.cos(nu)\n    s = np.sin(nu)\n    r_PQW = np.array([ p*c / (1 + e*c), p*s / (1 + e*c), 0])\n    v_PQW = np.array([ -s * np.sqrt(mu/p), (e + c)*np.sqrt(mu/p), 0])\n    return PQW2IJK(Omega, i, w, r_PQW, v_PQW)",
  "def quadrant4(x):\n    return 2*PI - x",
  "def RV2OE(mu, r_IJK, v_IJK):\n    \"\"\"(r,v) to OE conversion\"\"\"\n    r = r_IJK\n    v = v_IJK\n    K = np.array([0, 0, 1])\n    h = np.cross(r, v)\n    n = np.cross(K, h)\n    hm = np.linalg.norm(h)\n    nm = np.linalg.norm(n)\n    vm = np.linalg.norm(v)\n    rm = np.linalg.norm(r)\n\n    e_vec = 1./mu *((vm*vm - mu/rm)*r - np.dot(r,v)*v)\n    e = np.linalg.norm(e_vec)\n    eta = 0.5*vm*vm - mu/rm\n    if (e!=1.0):\n        a = -0.5*mu/eta\n        p = a*(1-e*e)\n    else:\n        a = 0.\n        p = h*h/mu\n\n    if h[2] == 0:\n        i = 0.0\n    else:\n        i = np.arccos(h[2]/hm)\n    if n[0] == 0:\n        Omega = 0.0\n    else:\n        Omega = np.arccos(n[0]/nm)\n    if n[1] < 0:\n        Omega = quadrant4(Omega)\n\n    dotProd = np.dot(n, e_vec)\n    if dotProd == 0:\n        omega = 0.0\n    else:\n        omega = np.arccos(np.dot(n, e_vec) / (nm * e))\n    if e_vec[2] < 0:\n        omega = quadrant4(omega)\n\n    dotProd = np.dot(e_vec, r)\n    if dotProd == 0:\n        nu = 0.0\n    else:\n        nu = np.arccos(np.dot(e_vec, r)/(e*rm))\n    if np.dot(r, v) < 0:\n        nu = quadrant4(nu)\n    return (a, e, i, Omega, omega, nu)",
  "def PQW2IJK(Omega, i, w, r_PQW, v_PQW):\n    sO = np.sin(Omega)\n    cO = np.cos(Omega)\n    si = np.sin(i)\n    ci = np.cos(i)\n    sw = np.sin(w)\n    cw = np.cos(w)\n\n    C11 = cO*cw - sO*sw*ci\n    C12 = -cO*sw - sO*cw*ci\n    C13 = sO*si\n    C21 = sO*cw + cO*sw*ci\n    C22 = -sO*sw + cO*cw*ci\n    C23 = -cO*si\n    C31 = sw*si\n    C32 = cw*si\n    C33 = ci\n    C =  np.array([ [C11,C12,C13], [C21,C22,C23], [C31,C32,C33] ])\n\n    r_IJK = C.dot(r_PQW)\n    v_IJK = C.dot(v_PQW)\n    return (r_IJK, v_IJK)",
  "def ephemeridesMeeus(JDE, celestialBody):\n        T = (JDE - 2451545.0)/36525\n\n        def ephem(vec, T):\n                val = vec[0] + vec[1]*T + vec[2]*T + vec[3]*T*T*T\n                return val\n\n        if celestialBody == 'EARTH':\n            L = 100.466449 + 35999.3728519 *T + (-0.00000568)*T*T + 0*T*T*T\n            a = 1.000001018\n            e = 0.01670862 + (-0.000042037)*T + (-0.0000001236)*T*T + 0.00000000004*T*T*T\n            i = 0 + 0.0130546*T + (-0.00000931)*T*T + (-0.000000034)*T*T*T\n            Omega = 174.873174 + (-0.2410908)*T + 0.00004067*T*T + (-0.000001327)*T*T*T\n            Pi = 102.937348 + 0.3225557*T + 0.00015026*T*T + 0.000000478*T*T*T\n        elif celestialBody == 'MARS':\n            L = 355.433275 + 19140.2993313 *T + 0.00000261*T*T + (-0.000000003)*T*T*T\n            a = 1.523679342\n            e = 0.09340062 + 0.000090483 *T + (-0.0000000806)*T*T + (-0.00000000035)*T*T*T\n            i = 1.849726 + (-0.0081479) *T + (-0.00002255)*T*T + (-0.000000027)*T*T*T\n            Omega = 49.558093 + (-0.2949846) *T + (-0.00063993)*T*T + (-0.000002143)*T*T*T\n            Pi = 336.060234 + 0.4438898 *T + (- 0.00017321)*T*T + 0.000000300*T*T*T\n        elif celestialBody == 'JUPITER':\n            L = 34.351484 + 3034.9056746*T + (-0.00008501)*T*T + 0.000000004*T*T*T\n            a = 5.202603191 + 0.0000001913*T\n            e = 0.04849485 + 0.000163244*T + -0.0000004719*T*T + (-0.00000000197)*T*T*T\n            i = 1.303270 + (-0.0019872)*T + 0.00003318*T*T + 0.000000092*T*T*T\n            Omega = 100.464441 + 0.1766828*T + 0.00090387*T*T + (-0.000007032)*T*T*T\n            Pi = 14.331309 + 0.2155525*T + 0.00072252*T*T + (-0.000004590)*T*T*T\n        elif celestialBody == 'VENUS':\n            L = 181.979801 + 58517.8156760*T + 0.00000165*T*T + (-0.000000002)*T*T*T\n            a = 0.72332982\n            e = 0.00677188 + (-0.000047766)*T + 0.0000000975*T*T + 0.00000000044*T*T*T\n            i = 3.394662 + (-0.0008568)*T + (-0.00003244)*T*T + 0.000000010*T*T*T\n            Omega = 76.679920 + (-0.2780080)*T + (-0.00014256)*T*T + (-0.000000198)*T*T*T\n            Pi = 131.563707 + 0.0048646*T + (-0.00138232)*T*T + (-0.000005332)*T*T*T\n        elif celestialBody == 'PLUTO':\n            L = 238.92903833 + 145.20780515*T\n            a = 39.48211675 + (-0.00031596)*T\n            e = 0.24882730 + 0.00005170*T\n            i = 17.14001206 + 0.00004818*T\n            Omega = 110.30393684 + (-0.01183482)*T\n            Pi = 224.06891629 + (-0.04062942)*T\n        elif celestialBody == 'SATURN':\n            L_vec = np.array([50.077471, 1222.1137943, 0.00021004, -0.000000019])\n            a_vec = np.array([9.554909596, -0.0000021389, 0.0, 0.0])\n            e_vec = np.array([0.05550862, -0.000346818, -0.0000006456, 0.00000000338])\n            i_vec = np.array([2.488878,\t0.0025515, -0.00004903, 0.000000018])\n            Omega_vec = np.array([113.665524, -0.2566649, -0.00018345, 0.000000357])\n            Pi_vec = np.array([93.056787, 0.5665496, 0.00052809, 0.000004882])\n            L = ephem(L_vec, T)\n            a = ephem(a_vec, T)\n            e = ephem(e_vec, T)\n            i = ephem(i_vec, T)\n            Omega = ephem(Omega_vec, T)\n            Pi = ephem(Pi_vec, T)\n        elif celestialBody == 'URANUS':\n            L_vec = np.array([314.055005, 429.8640561, 0.00030434, 0.000000026])\n            a_vec = np.array([19.218446062, -0.0000000372, 0.00000000098, 0.0])\n            e_vec = np.array([0.04629590, -0.000027337, 0.0000000790, 0.00000000025])\n            i_vec = np.array([0.773196,\t0.0007744, 0.00003749, -0.000000092])\n            Omega_vec = np.array([74.005947, 0.5211258,\t0.00133982,\t0.000018516])\n            Pi_vec = np.array([173.005159, 1.4863784, 0.0021450, 0.000000433])\n            L = ephem(L_vec, T)\n            a = ephem(a_vec, T)\n            e = ephem(e_vec, T)\n            i = ephem(i_vec, T)\n            Omega = ephem(Omega_vec, T)\n            Pi = ephem(Pi_vec, T)\n        elif celestialBody == 'NEPTUNE':\n            L_vec = np.array([304.348665, 219.8833092, 0.00030926, 0.000000018])\n            a_vec = np.array([30.110386869,\t-0.0000001663, 0.00000000069, 0.0])\n            e_vec = np.array([0.00898809, 0.000006408,-0.0000000008, -0.00000000005])\n            i_vec = np.array([1.769952, -0.0093082, -0.00000708, 0.000000028])\n            Omega_vec = np.array([131.784057, 1.1022057, 0.00026006, -0.000000636])\n            Pi_vec = np.array([48.123691, 1.4262677, 0.00037918, -0.000000003])\n            L = ephem(L_vec, T)\n            a = ephem(a_vec, T)\n            e = ephem(e_vec, T)\n            i = ephem(i_vec, T)\n            Omega = ephem(Omega_vec, T)\n            Pi = ephem(Pi_vec, T)\n        else:\n            print(\"Meeus coefficients for \" + celestialBody + \" not defined\")\n            L = 0.\n            a = 0.\n            e = 0.\n            i = 0.\n            Omega = 0.\n            Pi = 0.\n\n        return computeCOE(L,a,e,i,Omega,Pi)",
  "def computeCOE(L,a,e,i,Omega,Pi):\n    # Units:\n    L = L*D2R\n    a = a*AU\n    i = i*D2R\n    Omega = Omega*D2R\n    Pi = Pi*D2R\n\n    w = Pi - Omega\n    M = L - Pi\n    C_cen = (2*e - 1//4 * np.power(e,3) + 5//96 * np.power(e,5)) * np.sin(M) +\\\n            (5//4 * np.power(e,2) - 11//24 * np.power(e,4)) * np.sin(2*M) +\\\n            (13//12 * np.power(e,3) - 43//64 * np.power(e,5)) * np.sin(3*M) +\\\n            103//96 * np.power(e,4) * np.sin(4*M) +\\\n            1097//960 * np.power(e,5) * np.sin(5*M)\n    nu = M + C_cen\n    return (a, e, i, Omega, w, nu)",
  "def JulianDate(GDE):\n    yr = GDE[0]\n    mo = GDE[1]\n    d = GDE[2]\n    JD = 367*yr - int(7*(yr + int((mo+9)/12))/4) + int(275*mo/9) + d + 1721013.5\n    return np.ceil(JD)",
  "def GregorianDate(JDE):\n    LMonth = np.array([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31])\n    T = (JDE - 2415019.5)/ 365.25\n    Yr = 1900 + np.trunc(T)\n    LeapYrs = np.trunc((Yr - 1900 - 1)*0.25)\n    Days = JDE - 2415019.5 - ((Yr-1900)*365.0 + LeapYrs)\n    if Days < 1.0:\n        Yr = Yr - 1\n        LeapYrs = np.trunc((Yr - 1900 - 1)*0.25)\n        Days = JDE - 2415019.5 - ((Yr-1900)*365.0 + LeapYrs)\n    if Yr%4 == 0:\n        LMonth[1] = 29\n    DayOfYr = np.trunc(Days)\n    sum = 0\n    i = 0\n    for month in LMonth:\n        if (sum + month <= DayOfYr):\n            sum += month\n            i += 1\n    Mo = i + 1\n    Day = DayOfYr - sum\n    GD = np.array([ int(Yr), int(Mo), int(Day)])\n    return GD",
  "def exactGregorianDate(JD):\n    L_month = np.array([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31])\n    T_1900 = (JD - 2415019.5)/365.25\n    Year = 1900 + np.trunc(T_1900)\n    LeapYrs = np.trunc(0.25*(Year - 1900 - 1))\n    Days = (JD - 2415019.5) - (365.0*(Year - 1900) + LeapYrs)\n    if Days < 1.0:\n        Year = Year - 1\n        LeapYrs = np.trunc(0.25*(Year - 1900 - 1))\n        Days = (JD - 2415019.5) - (365.0*(Year - 1900) + LeapYrs)\n    if Year%4 == 0:\n        L_month[1] = 29\n    DOY = np.trunc(Days) # Day of the year\n    monthDays = 0 # summation of days in months\n    m = 0 # months counter\n    while True:\n        if monthDays + L_month[m] >= DOY:\n            break\n        else:\n            monthDays += L_month[m]\n            m += 1\n    Month = m\n    Day = DOY - monthDays\n    time = (Days - DOY)*24\n    h = np.trunc(time)\n    min = np.trunc(60*(time - h))\n    s = 3600 * (time - h - min/60.0)\n\n    GD = '['+ str(int(Year)) + ', '+ str(int(Month) + 1) + ', ' + str(int(Day)) +', ' + \\\n         str(int(h)) + ':' + str(int(min)) + ':' + str(int(s)) + ']'\n\n    return GD",
  "def optimalDate(GD0, DaysPastDeparture, TOF):\n    JD0 = JulianDate(GD0) + DaysPastDeparture\n    print('Departure Date: ', GregorianDate(JD0))\n    print('Arrival Date: ', GregorianDate(JD0 + TOF))\n    return (JD0, JD0+TOF)",
  "def B_params_1(r, v, mu):\n    rm = np.linalg.norm(r)\n    vm = np.linalg.norm(v)\n    h = np.cross(r, v)\n    h_hat = normalize(h)\n    e_vec = 1. / mu * ((vm * vm - mu / rm) * r - np.dot(r, v) * v)\n    e = np.linalg.norm(e_vec)\n    Betta = np.arccos(1. / e)\n    a = 1. / (2 / rm - vm * vm / mu)\n    b = np.abs(a) * np.sqrt(e * e - 1)\n\n    k_hat = np.array([0, 0, 1])\n    S_hat = np.cos(Betta)/e * e_vec + np.sin(Betta) * normalize(np.cross(h_hat, e_vec))\n    T_hat = normalize(np.cross(S_hat, k_hat))\n    R_hat = np.cross(S_hat, T_hat)\n    B_hat = np.cross(S_hat, h_hat)\n\n    B = b*B_hat\n    BT = np.dot(B, T_hat)\n    BR = np.dot(B, R_hat)\n    return (BT, BR)",
  "def B_params_2(v_in, v_out, mu):\n    vm_in = np.linalg.norm(v_in)\n    vm_out = np.linalg.norm(v_out)\n\n    S = normalize(v_in)\n    h = normalize(np.cross(v_in, v_out))\n    B_hat = normalize(np.cross(S, h))\n    k = np.array([0, 0, 1])\n    T = normalize(np.cross(S, k))\n    R = normalize(np.cross(S, T))\n    psi = np.arccos(np.dot(v_in, v_out) / (vm_in*vm_out))\n    rp = mu / (vm_in * vm_in) * ( 1.0 / np.cos(0.5*(PI - psi)) - 1)\n    temp = 1 + vm_in * vm_in * rp / mu\n    B = mu / (vm_in * vm_in) * np.sqrt(temp*temp - 1)\n    BT = B * np.dot(B_hat,T)\n    BR = B * np.dot(B_hat,R)\n    theta = np.arctan2(BR, BT)\n    return (rp, psi*R2D, B, theta*R2D, BT, BR)",
  "def EarthResonantOrbit(v_inf_in, V1, R1, v_inf_out, V2, N):\n    # compute P, a, v_scSun\n    P = N * 365.242189 * 86400                      # Earth orbital period\n    n = P / (2.0*PI)\n    exp = 1./3\n    a = np.power(n * n * mu_S, exp)                 # Earth heliocentric orbit SMA\n    rm_1 = la.norm(R1)\n    vm_sc_h = np.sqrt(mu_S * (2./rm_1 - 1./a))      # s/c heliocentric velocity\n\n    # compute theta\n    vm_inf_in = la.norm(v_inf_in)\n    vm_P = la.norm(V1)\n    cosTheta = (vm_inf_in * vm_inf_in + vm_P * vm_P - vm_sc_h * vm_sc_h) / (2 * vm_inf_in * vm_P)\n    theta = np.arccos(cosTheta)\n\n    # Compute T_vnc: DCM from VNC to ecliptic\n    V_hat = normalize(V1)\n    N_hat = normalize(np.cross(R1, V1))\n    C_hat = np.cross(V_hat, N_hat)\n    T_vnc = np.array([V_hat, N_hat, C_hat]).T\n\n    # Arrays to stack successful resonances that don't impact w/ the planet\n    rp_GA1 = np.array([])\n    PHI_GA1 = np.array([])\n    rp_GA2 = np.array([])\n    PHI_GA2 = np.array([])\n\n    # Loop\n    vm_inf_out = la.norm(v_inf_out)\n    c = np.cos(PI - theta)\n    s = np.sin(PI - theta)\n    p = 360     # number of points\n    phi_vec = np.linspace(0., 2*PI, p)\n    for phi in phi_vec:\n        vGA_out_VNC = vm_inf_out * np.array([c, s*np.cos(phi), -s*np.sin(phi)])\n        v_GA1_out_ecl = np.dot(T_vnc, vGA_out_VNC)\n        vm_GA1_out = la.norm(v_GA1_out_ecl)\n        (rp, psi, B, theta, BT, BR) = B_params_2(v_inf_in, v_GA1_out_ecl, mu_E)\n        if rp > E_radius or rp < E_radius:\n            rp_GA1 = np.append(rp_GA1, rp)\n            PHI_GA1 = np.append(PHI_GA1, phi)\n\n        v_GA2_in_ecl = v_GA1_out_ecl + V1 - V2\n        vm_GA2_in = la.norm(v_GA2_in_ecl)\n        (rp, psi, B, theta, BT, BR) = B_params_2(v_GA2_in_ecl, v_inf_out, mu_E)\n        if rp > E_radius or rp < E_radius:\n            rp_GA2 = np.append(rp_GA2, rp)\n            PHI_GA2 = np.append(PHI_GA2, phi)\n\n    plt.plot(PHI_GA1, rp_GA1, 'm', PHI_GA2, rp_GA2, 'b')\n    plt.axhline(E_radius, color='k')\n    plt.legend(['EGA 1', 'EGA 2', 'r$_{P, min}$'], loc='lower right')\n    plt.xlabel(r'$\\phi$ [rad]')\n    plt.ylabel('Perigee Radius [km]')\n    # plt.show()\n    return",
  "def testResonance():\n    R1 = np.array([31161153575.0634, 143995536213.184, 3018421.6823707])\n    R2 = np.array([31194146713.798,\n             143988869052.709,\n             2352102.45497072])\n    V1 = np.array([\n            -29599.9908905588,\n             6189.32095554111,\n           0.0729005972949417])\n    V2 = np.array([ -29598.5134550237,\n             6195.92283490717,\n           0.0568758149973483])\n\n    v_inf_in = np.array([-0.320955575422136,\n            -8.79065711515436,\n             1.70894261814904])\n    v_inf_out = np.array([ -8.95399388012787,\n           -0.346120703226863,\n           -0.350867778719334])\n\n    N = 2\n\n    EarthResonantOrbit(v_inf_in, V1/1000, R1/1000, v_inf_out, V2/1000, N)",
  "def plotPlanetOrbit(JD, planet, color, ax):\n    rx = np.array([])\n    ry = np.array([])\n    rz = np.array([])\n    (a, e, i , Omega, w, nu0) = ephemeridesMeeus(JD, planet)\n    nu_vec = np.linspace(nu0, nu0 + 2*PI, 360)\n    for nu in nu_vec:\n        (r, v) = OE2RV(mu_S, a, e, i, Omega, w, nu)\n        rx = np.append(rx, r[0])\n        ry = np.append(ry, r[1])\n        rz = np.append(rz, r[2])\n    ax.plot(rx, ry, rz, c=color)\n    ax.scatter(rx[0], ry[0], rz[0], c=color)\n\n    max_range = np.array([rx.max()-rx.min(), ry.max()-ry.min(), rz.max()-rz.min()]).max()\n    Xb = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][0].flatten() + 0.5*(rx.max()+rx.min())\n    Yb = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][1].flatten() + 0.5*(ry.max()+ry.min())\n    Zb = 0.5*max_range*np.mgrid[-1:2:2,-1:2:2,-1:2:2][2].flatten() + 0.5*(rz.max()+rz.min())\n    # Comment or uncomment following both lines to test the fake bounding box:\n    for xb, yb, zb in zip(Xb, Yb, Zb):\n        ax.plot([xb], [yb], [zb], 'w')",
  "def plotSolarSystem(JD, JD_ref):\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n    plotPlanetOrbit(JD, 'EARTH', 'dodgerblue', ax)\n    plotPlanetOrbit(JD, 'SATURN', 'orchid', ax)\n    plotPlanetOrbit(JD, 'URANUS', 'lightgreen', ax)\n    plt.title('Days Past JD_ref = ' + str(JD - JD_ref))\n    plt.show()",
  "def V_circular(r, mu):\n    return np.sqrt(mu / r)",
  "def rotationMatrix(alpha):\n    M = np.identity(3)\n    M[0, 0] = np.cos(alpha)\n    M[0, 1] = -np.sin(alpha)\n    M[1, 0] = np.sin(alpha)\n    M[0, 1] = np.cos(alpha)\n    return M",
  "def TisserandPlot(R_P, v_inf, color):\n    RP = np.array([])\n    RA = np.array([])\n    R_P_vec = np.array([0., - R_P, 0.])\n    V_P = V_circular(R_P, mu_S)\n    V_P_vec = np.array([V_P, 0., 0.])\n    points = 360\n    alpha_vec = np.linspace(0., PI, points)\n    for alpha in alpha_vec:\n        M = rotationMatrix(alpha)\n        V_P_hat = normalize(V_P_vec)\n        v_inf_vec = v_inf * np.dot(M, V_P_hat)\n        V_inf_vec = V_P_vec + v_inf_vec\n        (a, e, i, Omega, omega, nu) = RV2OE(mu_S, R_P_vec, V_inf_vec)\n        rp = a * (1. - e)\n        ra = a * (1. + e)\n        RP = np.append(RP, rp/AU)\n        RA = np.append(RA, ra/AU)\n    plt.loglog(RP, RA, color)",
  "def Tisserand_P1_2_P2(r_planet_vec, v_inf_P1_vec, v_inf_P2_vec):\n    for r_planet in r_planet_vec:\n            plt.loglog(r_planet/AU, r_planet/AU, 'ko')\n\n    color_vec = np.array(['dodgerblue', 'lightgreen', 'magenta', 'lightsalmon', 'indigo'])\n    color_vec = np.array(['k', 'k', 'k', 'k', 'k'])\n    i = 0\n    for v_inf in v_inf_P1_vec:\n        TisserandPlot(r_planet_vec[0], v_inf, color_vec[i])\n        i += 1\n    j = 0\n    for v_inf in v_inf_P2_vec:\n        TisserandPlot(r_planet_vec[1], v_inf, color_vec[j])\n        j += 1\n    # x-axis plot limits\n    l = len(r_planet_vec) - 1\n    rp_min = r_planet_vec[0] / AU * 0.2\n    rp_max = r_planet_vec[l] / AU * 1.8\n    # y-axis plot limits\n    ra_min = r_planet_vec[0] / AU * 0.2\n    ra_max = r_planet_vec[l] / AU * 1.8\n    plt.xlim([rp_min, rp_max])\n    plt.ylim([ra_min, ra_max])\n    plt.xlabel('Radius of Periapse [AU]')\n    plt.ylabel('Radius of Apoapse [AU]')\n    plt.title(r'$v_{\\infty}^{Earth} $ = '+ str(v_inf_P1_vec) +r' km/s \\n'\n              r'$v_{\\infty}^{Saturn} $ = '+ str(v_inf_P2_vec) +' km/s')",
  "def Tisserand_ESU():\n    r_planet_vec = np.array([a_E, a_Saturn, a_U])\n    v_inf_E_vec = np.array([9, 11, 13, 15, 17])\n    v_inf_S_vec = np.array([6, 7, 8, 9, 10])\n    Tisserand_P1_2_P2(r_planet_vec, v_inf_E_vec, v_inf_S_vec)\n    TisserandPlot(a_E, v_inf_E_vec[2], 'cyan')\n    TisserandPlot(a_Saturn, v_inf_S_vec[3], 'cyan')\n\n    plt.show()",
  "def main():\n    Mars_RV(JulianDate([2018, 10, 16]))",
  "def ephem(vec, T):\n                val = vec[0] + vec[1]*T + vec[2]*T + vec[3]*T*T*T\n                return val",
  "def isVectorEqual(result, truth, accuracy):\n    \"\"\"function to check if a 3D vector is the same as the truth values\"\"\"\n    if foundNAN(result): return 0\n\n    if np.linalg.norm(result - truth) > accuracy:\n        return 0  # return 0 to indicate the array's are not equal\n    return 1",
  "def isArrayEqual(result, truth, dim, accuracy):\n    \"\"\"function to check if an array of values is the same as the truth values\"\"\"\n    # the result array is of dimension dim, no time stamp\n    # the truth array is of dimesion dim, no time stamp\n    if dim < 1:\n        print(\"Incorrect array dimension \" + dim + \" sent to isArrayEqual\")\n        return 0\n\n    if len(result) == 0:\n        print(\"Result array was empty\")\n        return 0\n\n    if len(truth) == 0:\n        print(\"Truth array was empty\")\n        return 0\n\n    if foundNAN(result): return 0\n\n    for i in range(0, dim):\n        if math.fabs(result[i] - truth[i]) > accuracy:\n            return 0  # return 0 to indicate the array's are not equal\n    return 1",
  "def isArrayEqualRelative(result, truth, dim, accuracy):\n    \"\"\"Compare relative accuracy of two arrays\"\"\"\n    # the result array is of dimension dim, no time stamp\n    # the truth array is of dimesion dim, no time stamp\n    if dim < 1:\n        print(\"Incorrect array dimension \" + dim + \" sent to isArrayEqual\")\n        return 0\n\n    if len(result) == 0:\n        print(\"Result array was empty\")\n        return 0\n\n    if len(truth) == 0:\n        print(\"Truth array was empty\")\n        return 0\n\n    if foundNAN(result): return 0\n\n    for i in range(0, dim):\n        if truth[i] == 0:\n            if result[i] == 0:\n                continue\n            else:\n                print(\"Truth array contains zero\")\n                return 0\n        if math.fabs((result[i] - truth[i]) / truth[i]) > accuracy:\n            return 0  # return 0 to indicate the array's are not equal\n    return 1",
  "def isArrayZero(result, dim, accuracy):\n    \"\"\"function to check if an array of values are zero\"\"\"\n    # the result array is of dimension dim\n    if dim < 1:\n        print(\"Incorrect array dimension \" + dim + \" sent to isArrayEqual\")\n        return 0\n\n    if len(result) == 0:\n        print(\"Result array was empty\")\n        return 0\n\n    if foundNAN(result): return 0\n\n    for i in range(0, dim):\n        if (math.fabs(result[i]) > accuracy):\n            return 0  # return 0 to indicate the array's are not equal\n\n    return 1",
  "def compareVector(trueStates, dataStates, accuracy, msg, testFailCount, testMessages, ExpectedResult=1):\n    \"\"\"Compare two vector size and values and check absolute accuracy\"\"\"\n    if (len(trueStates) != len(dataStates)):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" unequal data array sizes\\n\")\n    else:\n        if isVectorEqual(dataStates, trueStates, accuracy) != ExpectedResult:\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + msg + r\"\\n\")\n    return testFailCount, testMessages",
  "def compareArray(trueStates, dataStates, accuracy, msg, testFailCount, testMessages):\n    \"\"\"Compare two arrays size and values and check absolute accuracy\"\"\"\n    if len(trueStates) != len(dataStates):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" unequal data array sizes\\n\")\n    elif len(trueStates) == 0 or len(dataStates) == 0:\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" data had empty arrays\\n\")\n    else:\n        for i in range(0, len(trueStates)):\n            # check a vector values\n            if not isArrayEqual(dataStates[i], trueStates[i], 3, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + msg + \"\\n\")\n    return testFailCount, testMessages",
  "def compareArrayND(trueStates, dataStates, accuracy, msg, size, testFailCount, testMessages):\n    \"\"\"Compare two arrays of size N for size and values and check absolute accuracy\"\"\"\n    if len(trueStates) != len(dataStates):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" unequal data array sizes\\n\")\n    elif len(trueStates) == 0 or len(dataStates) == 0:\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" data had empty arrays\\n\")\n    else:\n        for i in range(0, len(trueStates)):\n            # check a vector values\n            try:\n                data = dataStates[i].flatten()\n            except:\n                data = dataStates[i]\n            try:\n                trueValue = trueStates[i].flatten()\n            except:\n                trueValue = trueStates[i]\n            if not isArrayEqual(data, trueValue, size, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + msg)\n    return testFailCount, testMessages",
  "def compareArrayRelative(trueStates, dataStates, accuracy, msg, testFailCount, testMessages):\n    \"\"\"\n    Checks whether the relative distance between elements of a pullMessageLogData-derived array and a\n    truth array is below a provided accuracy, and return an error if not.\n\n    Args:\n        trueStates: iterable of size (m,n);\n        dataStates: iterable of size (m,n)\n        accuracy: Relative accuracy boundary\n        msg:\n        testFailCount:\n        testMessages:\n\n    \"\"\"\n    if (len(trueStates) != len(dataStates)):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" unequal data array sizes\\n\")\n    elif len(trueStates) == 0 or len(dataStates) == 0:\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" data had empty arrays\\n\")\n    else:\n        for i in range(0, len(trueStates)):\n            # check a vector values\n            if not isArrayEqualRelative(dataStates[i], trueStates[i], 3, accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + msg + \" at t=\" + str(dataStates[i, 0] * macros.NANO2SEC) + r\"sec\\n\")\n    return testFailCount, testMessages",
  "def isDoubleEqual(result, truth, accuracy):\n    \"\"\"function to check if a double equals a truth value\"\"\"\n    if foundNAN(result): return 0\n\n    if math.fabs(result - truth) > accuracy:\n        return 0  # return 0 to indicate the doubles are not equal\n\n    return 1",
  "def isDoubleEqualRelative(result, truth, accuracy):\n    \"\"\"function to check if a double equals a truth value with relative tolerance\"\"\"\n    if foundNAN(result): return 0\n    if foundNAN(truth): return 0\n    if foundNAN(accuracy): return 0\n    if truth == 0:\n        print(\"truth is zero, cannot compare\")\n        return 0\n\n    if math.fabs((truth - result) / truth) > accuracy:\n        return 0  # return 0 to indicate the doubles are not equal\n\n    return 1",
  "def compareDoubleArrayRelative(trueStates, dataStates, accuracy, msg, testFailCount, testMessages):\n    \"\"\"Compare two arrays of doubles for size and values and check relative accuracy\"\"\"\n    if len(trueStates) != len(dataStates):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" unequal data array sizes\\n\")\n    elif len(trueStates) == 0 or len(dataStates) == 0:\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" data had empty arrays\\n\")\n    else:\n        for i in range(0, len(trueStates)):\n            # check a vector values\n            if not isDoubleEqualRelative(dataStates[i], trueStates[i], accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + msg + \"\\n\")\n    return testFailCount, testMessages",
  "def compareDoubleArray(trueStates, dataStates, accuracy, msg, testFailCount, testMessages):\n    \"\"\"Compare two arrays of doubles for size and values and check absolute accuracy\"\"\"\n    if len(trueStates) != len(dataStates):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" unequal data array sizes\\n\")\n    elif len(trueStates) == 0 or len(dataStates) == 0:\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" data had empty arrays\\n\")\n    else:\n        for i in range(0, len(trueStates)):\n            # check a vector values\n            if not isDoubleEqual(dataStates[i], trueStates[i], accuracy):\n                testFailCount += 1\n                testMessages.append(\"FAILED: \" + msg + \"\\n\")\n    return testFailCount, testMessages",
  "def compareListRelative(trueStates, dataStates, accuracy, msg, testFailCount, testMessages):\n    \"\"\"Compare two row lists of values and check relative accuracy\"\"\"\n    if len(trueStates) != len(dataStates):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" unequal data array sizes\\n\")\n    elif len(trueStates) == 0 or len(dataStates) == 0:\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" data had empty arrays\\n\")\n    else:\n        if not trueStates == pytest.approx(dataStates, rel=accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + msg + \"\\n\")\n    return testFailCount, testMessages",
  "def compareList(trueStates, dataStates, accuracy, msg, testFailCount, testMessages):\n    \"\"\"Compare two row lists of values and check relative accuracy\"\"\"\n    if len(trueStates) != len(dataStates):\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" unequal data array sizes\\n\")\n    elif len(trueStates) == 0 or len(dataStates) == 0:\n        testFailCount += 1\n        testMessages.append(\"FAILED: \" + msg + r\" data had empty arrays\\n\")\n    else:\n        if not trueStates == pytest.approx(dataStates, abs=accuracy):\n            testFailCount += 1\n            testMessages.append(\"FAILED: \" + msg + \"\\n\")\n    return testFailCount, testMessages",
  "def writeTableLaTeX(tableName, tableHeaders, caption, array, path):\n    \"\"\"Take a list and return equivalent LaTeX table code\"\"\"\n\n    texFileName = path + \"/../_Documentation/AutoTeX/\" + tableName + \".tex\"\n\n    if not os.path.exists(os.path.dirname(texFileName)):\n        try:\n            os.makedirs(os.path.dirname(texFileName))\n        except OSError as exc:  # Guard against race condition\n            if exc.errno != errno.EEXIST:\n                raise\n    with open(texFileName, \"w\") as texTable:\n        table = tabulate(array,\n                         tableHeaders,\n                         tablefmt=\"latex\",\n                         numalign=\"center\"\n                         )\n\n        texTable.write(r'\\begin{table}[htbp]')\n        texTable.write(r'\\caption{' + caption + '}')\n        texTable.write(r'\\label{tbl:' + tableName + '}')\n        texTable.write(r'\\centering')\n        texTable.write(table)\n        texTable.write(r'\\end{table}')\n        texTable.close()\n\n    return",
  "def writeTeXSnippet(snippetName, texSnippet, path):\n    \"\"\"Write a LaTeX snippet to a file\"\"\"\n\n    texFileName = path + \"/../_Documentation/AutoTeX/\" + snippetName + \".tex\"\n\n    if not os.path.exists(os.path.dirname(texFileName)):\n        try:\n            os.makedirs(os.path.dirname(texFileName))\n        except OSError as exc:  # Guard against race condition\n            if exc.errno != errno.EEXIST:\n                raise\n    with open(texFileName, \"w\") as fileHandler:\n        fileHandler.write(texSnippet)\n        fileHandler.close()\n\n    return",
  "def saveScenarioFigure(figureName, plt, path, extension=\".svg\"):\n    \"\"\"save a python scenario result into the documentation image folder\"\"\"\n    imgFileName = os.path.join(path, \"..\", \"..\", \"docs\", \"source\", \"_images\", \"Scenarios\", figureName + extension)\n    if not os.path.exists(os.path.dirname(imgFileName)):\n        try:\n            os.makedirs(os.path.dirname(imgFileName))\n        except OSError as exc:  # Guard against race condition\n            if exc.errno != errno.EEXIST:\n                raise\n    plt.savefig(imgFileName, transparent=True)",
  "def saveFigurePDF(figureName, plt, path):\n    \"\"\"Save a Figure as a PDF\"\"\"\n    figFileName = os.path.join(path, figureName + \".pdf\")\n    if not os.path.exists(os.path.dirname(figFileName)):\n        try:\n            os.makedirs(os.path.dirname(figFileName))\n        except OSError as exc:  # Guard against race condition\n            if exc.errno != errno.EEXIST:\n                raise\n    plt.savefig(figFileName, transparent=True, pad_inches=0.05)",
  "def writeFigureLaTeX(figureName, caption, plt, format, path):\n    \"\"\"Save a figure and associated TeX code snippet\"\"\"\n    texFileName = os.path.join(path, \"..\", \"_Documentation\", \"AutoTeX\", figureName + \".tex\")\n    if not os.path.exists(os.path.dirname(texFileName)):\n        try:\n            os.makedirs(os.path.dirname(texFileName))\n        except OSError as exc:  # Guard against race condition\n            if exc.errno != errno.EEXIST:\n                raise\n    with open(texFileName, \"w\") as texFigure:\n        texFigure.write(r'\\begin{figure}[htbp]')\n        texFigure.write(r'\\centerline{')\n        texFigure.write(r'\\includegraphics[' + format + ']{AutoTeX/' + figureName + r'}}')\n        texFigure.write(r'\\caption{' + caption + r'}')\n        texFigure.write(r'\\label{fig:' + figureName + r'}')\n        texFigure.write(r'\\end{figure}')\n        texFigure.close()\n\n        texFileName = path + \"/../_Documentation/AutoTeX/\" + figureName + \".pdf\"\n        plt.savefig(texFileName, transparent=True)\n\n    return",
  "def foundNAN(array):\n    \"\"\"check if an array contains NAN values\"\"\"\n    if (np.isnan(np.sum(array))):\n        print(\"Warning: found NaN value.\")\n        return 1  # return 1 to indicate a NaN value was found\n    return 0",
  "def getLineColor(idx, maxNum):\n    \"\"\"pick a nicer color pattern to plot 3 vector components\"\"\"\n    values = list(range(0, maxNum + 2))\n    colorMap = mpl.pyplot.get_cmap('gist_earth')\n    cNorm = colors.Normalize(vmin=0, vmax=values[-1])\n    scalarMap = cmx.ScalarMappable(norm=cNorm, cmap=colorMap)\n    return scalarMap.to_rgba(values[idx + 1])",
  "def np2EigenMatrix3d(mat):\n    \"\"\"convert 3D numpy matrix to Eigen matrix\"\"\"\n    return [\n        [mat[0], mat[1], mat[2]]\n        , [mat[3], mat[4], mat[5]]\n        , [mat[6], mat[7], mat[8]]\n    ]",
  "def np2EigenVectorXd(vec):\n    \"\"\"Convert numpy to Eigen vector\"\"\"\n    npVec = []\n    for item in vec:\n        npVec.extend([[item]])\n\n    return npVec",
  "def npList2EigenXdVector(list):\n    \"\"\"Conver a list of arrays to a list of eigen values\"\"\"\n    eigenList = bskUtilities.Eigen3dVector()\n    for pos in list:\n        eigenList.push_back(pos)\n    return eigenList",
  "def EigenVector3d2np(eig):\n    \"\"\"convert Eigen vector3d to numpy\"\"\"\n    return np.array([eig[0][0], eig[1][0], eig[2][0]])",
  "def pullVectorSetFromData(inpMat):\n    \"\"\"extract the vector data set from a data matrix where the 1st column is the time information\"\"\"\n    outMat = np.array(inpMat).transpose()\n    return outMat[1:].transpose()",
  "def addTimeColumn(time, data):\n    \"\"\"Add a time column to the data set\"\"\"\n    return np.transpose(np.vstack([[time], np.transpose(data)]))",
  "def decimalYearToDateTime(start):\n    \"\"\"convert a decimal Year format to a regular dataTime object\"\"\"\n    year = int(start)\n    rem = start - year\n\n    base = datetime(year, 1, 1)\n    return base + timedelta(seconds=(base.replace(year=base.year + 1) - base).total_seconds() * rem)",
  "def timeStringToGregorianUTCMsg(DateSpice, **kwargs):\n    \"\"\"convert a general time/date string to a gregoarian UTC msg object\"\"\"\n    # set the data path\n    if 'dataPath' in kwargs:\n        dataPath = kwargs['dataPath']\n        if not isinstance(dataPath, str):\n            print('ERROR: dataPath must be a string argument')\n            exit(1)\n    else:\n        dataPath = bskPath + '/supportData/EphemerisData/'  # default value\n\n    # load spice kernel and convert the string into a UTC date/time string\n    pyswice.furnsh_c(dataPath + 'naif0012.tls')\n    et = pyswice.new_doubleArray(1)\n    pyswice.str2et_c(DateSpice, et)\n    etEpoch = pyswice.doubleArray_getitem(et, 0)\n    ep1 = pyswice.et2utc_c(etEpoch, 'C', 6, 255, \"Yo\")\n    pyswice.unload_c(dataPath + 'naif0012.tls')  # leap second file\n\n    # convert UTC string to datetime object\n    datetime_object = datetime.strptime(ep1, '%Y %b %d %H:%M:%S.%f')\n\n    # populate the epochMsg with the gregorian UTC date/time information\n    epochMsgStructure = messaging.EpochMsgPayload()\n    epochMsgStructure.year = datetime_object.year\n    epochMsgStructure.month = datetime_object.month\n    epochMsgStructure.day = datetime_object.day\n    epochMsgStructure.hours = datetime_object.hour\n    epochMsgStructure.minutes = datetime_object.minute\n    epochMsgStructure.seconds = datetime_object.second + datetime_object.microsecond / 1e6\n\n    epochMsg = messaging.EpochMsg().write(epochMsgStructure)\n    epochMsg.this.disown()\n\n    return epochMsg",
  "def columnToRowList(set):\n    \"\"\"Loop through a column list and return a row list\"\"\"\n    ans = []\n    for item in set:\n        ans.append(item[0])\n    return ans",
  "def checkMethodKeyword(karglist, kwargs):\n    \"\"\"loop through list of method keyword arguments and make sure that an approved keyword is used.\"\"\"\n    for key in kwargs:\n        if key not in karglist:\n            print('ERROR: you tried to use an incorrect keyword ' + key + '. Options include:')\n            print(karglist)\n            exit(1)",
  "def removeTimeFromData(dataList):\n    \"\"\"pull out the time column out of a 4xN data list\"\"\"\n    return (dataList.transpose()[1:len(dataList[0])]).transpose()",
  "def samplingTime(simTime, baseTimeStep, numDataPoints):\n    \"\"\"\n    Given a simulation duration, this routine returns\n    a sampling time that yields the closest integer match to a desired number of sampling points\n\n    Args:\n        simTime: [ns] total simulation duration\n        baseTimeStep: [ns] baseline sampling period\n        numDataPoints: nominal desired number of data points over the simulation duration\n\n    \"\"\"\n    deltaTime = math.floor(simTime / baseTimeStep / (numDataPoints - 1)) * baseTimeStep\n    if deltaTime < 1:\n        deltaTime = 1\n    return deltaTime",
  "class SimulationProgressBar:\n    \"\"\"\n    Class to generate a BSK progress bar in the terminal window\n    \"\"\"\n    def __init__(self, max_value, enable=False):\n        self.max_value = max_value\n        self.last_update = 0\n        self.enable = enable\n        self.p = self.pbar()\n\n    def pbar(self):\n        return tqdm(\n            total=self.max_value,\n            desc='Progress: ',\n            disable=not self.enable,\n            bar_format=\"%s{l_bar}{bar}|%s\" % (Fore.YELLOW, Fore.RESET))\n\n    def update(self, update_value):\n        if update_value < self.max_value:\n            self.p.update(update_value-self.last_update)\n            self.last_update = update_value\n        else:\n            self.p.update(self.max_value - self.last_update)\n            self.last_update = self.max_value\n\n    def markComplete(self):\n        if self.update == self.max_value:\n            return\n        self.p.update(self.max_value-self.last_update)\n\n    def close(self):\n        self.p.close()",
  "def __init__(self, max_value, enable=False):\n        self.max_value = max_value\n        self.last_update = 0\n        self.enable = enable\n        self.p = self.pbar()",
  "def pbar(self):\n        return tqdm(\n            total=self.max_value,\n            desc='Progress: ',\n            disable=not self.enable,\n            bar_format=\"%s{l_bar}{bar}|%s\" % (Fore.YELLOW, Fore.RESET))",
  "def update(self, update_value):\n        if update_value < self.max_value:\n            self.p.update(update_value-self.last_update)\n            self.last_update = update_value\n        else:\n            self.p.update(self.max_value - self.last_update)\n            self.last_update = self.max_value",
  "def markComplete(self):\n        if self.update == self.max_value:\n            return\n        self.p.update(self.max_value-self.last_update)",
  "def close(self):\n        self.p.close()",
  "class ProcessBaseClass(object):\n    \"\"\"Class for a BSK process\"\"\"\n    def __init__(self, procName, procPriority=-1):\n        self.Name = procName\n        self.processData = sim_model.SysProcess(procName)\n        self.processData.processPriority = procPriority\n\n    def addTask(self, newTask, taskPriority=-1):\n        self.processData.addNewTask(newTask.TaskData, taskPriority)\n\n    def addInterfaceRef(self, newInt):\n        self.processData.addInterfaceRef(newInt)\n\n    def discoverAllMessages(self):\n        self.processData.discoverAllMessages()\n\n    def disableAllTasks(self):\n        self.processData.disableAllTasks()\n\n    def enableAllTasks(self):\n        self.processData.enableAllTasks()\n\n    def selectProcess(self):\n        pass\n\n    def updateTaskPeriod(self, TaskName, newPeriod):\n        self.processData.changeTaskPeriod(TaskName, newPeriod)",
  "class TaskBaseClass(object):\n    def __init__(self, TaskName, TaskRate, InputDelay=0, FirstStart=0):\n        self.Name = TaskName\n        self.TaskData = sys_model_task.SysModelTask(TaskRate, InputDelay,\n                                                    FirstStart)\n        self.TaskData.TaskName = TaskName\n        self.TaskModels = []\n\n    def disable(self):\n        self.TaskData.disableTask()\n\n    def enable(self):\n        self.TaskData.enableTask()\n\n    def resetTask(self, callTime):\n        self.TaskData.ResetTaskList(callTime)",
  "class PythonModelClass(object):\n    idCounter = 1\n    def __init__(self, modelName, modelActive=True, modelPriority=-1):\n        # The modelName is a unique identifier (unique to simulation) passed\n        # in to a class.\n        self.modelName = modelName\n        # The modelActive flag indicates if the model should be run or not\n        self.modelActive = modelActive\n        # The moduleID is a numeric identifier used to track message usage in\n        # a given simulation.\n        # Note: python modules get negative ID numbers\n        self.moduleID = -PythonModelClass.idCounter\n        PythonModelClass.idCounter = PythonModelClass.idCounter + 1\n        # The modelPriority variable is the setting for which models get run\n        # first.  Higher priority indicates that a model will get run sooner.\n        self.modelPriority = modelPriority\n\n    # The selfInit method is used to initialize all of the output messages of a class.\n    def selfInit(self):\n        return\n\n    # The reset method is used to clear out any persistent variables that need to get changed\n    #  when a task is restarted.  This method is typically only called once after selfInit,\n    #  but it should be written to allow the user to call it multiple times if necessary.\n    def reset(self, currentTime):\n        return\n\n    # The updateState method is the cyclical worker method for a given Basilisk class.  It\n    # will get called periodically at the rate specified in the Python task that the model is\n    # attached to.  It persists and anything can be done inside of it.  If you have realtime\n    # requirements though, be careful about how much processing you put into a Python updateState\n    # method.  You could easily detonate your sim's ability to run in realtime.\n    def updateState(self, currentTime):\n        return",
  "class PythonTaskClass(object):\n    def __init__(self, taskName, taskRate, taskActive=True, taskPriority=-1, parentProc=None):\n        self.name = taskName\n        self.rate = taskRate\n        self.priority = taskPriority\n        self.modelList = []\n        self.nextTaskTime = 0\n        self.taskActive = taskActive\n        self.parentProc = parentProc\n\n    def updateParentProc(self, newParentProc):\n        self.parentProc = newParentProc\n\n    def selfInitTask(self):\n        for model in self.modelList:\n            model.selfInit()\n\n    def resetTask(self, currentTime):\n        for model in self.modelList:\n            model.reset(currentTime)\n\n    def addModelToTask(self, newModel, priority=None):\n        if priority is not None:\n            newModel.modelPriority = priority\n        i = 0\n        for model in self.modelList:\n            if newModel.modelPriority > model.modelPriority:\n                self.modelList.insert(i, newModel)\n                return\n            i += 1\n        self.modelList.append(newModel)\n\n    def executeModelList(self, currentTime):\n        self.nextTaskTime = currentTime + self.rate\n        if not self.taskActive:\n            return\n        for model in self.modelList:\n            model.updateState(currentTime)",
  "class PythonProcessClass(ProcessBaseClass):\n    def __init__(self, procName, priority=-1):\n        super(PythonProcessClass, self).__init__(procName)\n        self.taskList = []\n        self.executionOrder = []\n        self.nextTaskTime = 0\n        self.pyProcPriority = priority\n        self.intRefs = []\n\n    def nextCallTime(self):\n        return self.nextTaskTime\n\n    def scheduleTask(self, newTask):\n        for i in range(len(self.executionOrder)):\n            tmpTask = self.executionOrder[i]\n            if (newTask.nextTaskTime < tmpTask.nextTaskTime or\n                    newTask.nextTaskTime == tmpTask.nextTaskTime and\n                    newTask.priority > tmpTask.priority):\n                self.executionOrder.insert(i, newTask)\n                return\n        self.executionOrder.append(newTask)\n\n    def createPythonTask(self, newTaskName, taskRate, taskActive=True, taskPriority=-1):\n        self.taskList.append(PythonTaskClass(newTaskName, taskRate, taskActive, taskPriority, self.processData))\n\n    def addPythonTask(self, newPyTask):\n        self.taskList.append(newPyTask)\n\n    def addModelToTask(self, taskName, newModel, priority=None):\n        for task in self.taskList:\n            if task.name == taskName:\n                task.addModelToTask(newModel, priority)\n                return\n        print(\"Attempted to add model: \" + newModel.modelName)\n        print(\"to non-existent task: \" + taskName)\n\n    def selfInitProcess(self):\n\n        if not self.taskList:\n            return\n\n        for task in self.taskList:\n            task.selfInitTask()\n        self.nextTaskTime = 0\n        self.scheduleTask(self.taskList[-1])\n\n    def resetProcess(self, currentTime):\n        self.executionOrder = []\n        for task in self.taskList:\n            task.resetTask(currentTime)\n            self.scheduleTask(task)\n\n    def executeTaskList(self, currentTime):\n        if len(self.executionOrder) == 0:\n            return\n        taskNext = self.executionOrder[0]\n        for intCurr in self.intRefs:\n            intCurr.routeInputs(self.processData.messageBuffer)\n        while taskNext.nextTaskTime <= currentTime:\n            taskNext.executeModelList(currentTime)\n            self.executionOrder.pop(0)\n            self.scheduleTask(taskNext)\n            taskNext = self.executionOrder[0]\n        self.nextTaskTime = taskNext.nextTaskTime\n\n    def addInterfaceRef(self, newInt):\n        self.intRefs.append(newInt)",
  "def __init__(self, procName, procPriority=-1):\n        self.Name = procName\n        self.processData = sim_model.SysProcess(procName)\n        self.processData.processPriority = procPriority",
  "def addTask(self, newTask, taskPriority=-1):\n        self.processData.addNewTask(newTask.TaskData, taskPriority)",
  "def addInterfaceRef(self, newInt):\n        self.processData.addInterfaceRef(newInt)",
  "def discoverAllMessages(self):\n        self.processData.discoverAllMessages()",
  "def disableAllTasks(self):\n        self.processData.disableAllTasks()",
  "def enableAllTasks(self):\n        self.processData.enableAllTasks()",
  "def selectProcess(self):\n        pass",
  "def updateTaskPeriod(self, TaskName, newPeriod):\n        self.processData.changeTaskPeriod(TaskName, newPeriod)",
  "def __init__(self, TaskName, TaskRate, InputDelay=0, FirstStart=0):\n        self.Name = TaskName\n        self.TaskData = sys_model_task.SysModelTask(TaskRate, InputDelay,\n                                                    FirstStart)\n        self.TaskData.TaskName = TaskName\n        self.TaskModels = []",
  "def disable(self):\n        self.TaskData.disableTask()",
  "def enable(self):\n        self.TaskData.enableTask()",
  "def resetTask(self, callTime):\n        self.TaskData.ResetTaskList(callTime)",
  "def __init__(self, modelName, modelActive=True, modelPriority=-1):\n        # The modelName is a unique identifier (unique to simulation) passed\n        # in to a class.\n        self.modelName = modelName\n        # The modelActive flag indicates if the model should be run or not\n        self.modelActive = modelActive\n        # The moduleID is a numeric identifier used to track message usage in\n        # a given simulation.\n        # Note: python modules get negative ID numbers\n        self.moduleID = -PythonModelClass.idCounter\n        PythonModelClass.idCounter = PythonModelClass.idCounter + 1\n        # The modelPriority variable is the setting for which models get run\n        # first.  Higher priority indicates that a model will get run sooner.\n        self.modelPriority = modelPriority",
  "def selfInit(self):\n        return",
  "def reset(self, currentTime):\n        return",
  "def updateState(self, currentTime):\n        return",
  "def __init__(self, taskName, taskRate, taskActive=True, taskPriority=-1, parentProc=None):\n        self.name = taskName\n        self.rate = taskRate\n        self.priority = taskPriority\n        self.modelList = []\n        self.nextTaskTime = 0\n        self.taskActive = taskActive\n        self.parentProc = parentProc",
  "def updateParentProc(self, newParentProc):\n        self.parentProc = newParentProc",
  "def selfInitTask(self):\n        for model in self.modelList:\n            model.selfInit()",
  "def resetTask(self, currentTime):\n        for model in self.modelList:\n            model.reset(currentTime)",
  "def addModelToTask(self, newModel, priority=None):\n        if priority is not None:\n            newModel.modelPriority = priority\n        i = 0\n        for model in self.modelList:\n            if newModel.modelPriority > model.modelPriority:\n                self.modelList.insert(i, newModel)\n                return\n            i += 1\n        self.modelList.append(newModel)",
  "def executeModelList(self, currentTime):\n        self.nextTaskTime = currentTime + self.rate\n        if not self.taskActive:\n            return\n        for model in self.modelList:\n            model.updateState(currentTime)",
  "def __init__(self, procName, priority=-1):\n        super(PythonProcessClass, self).__init__(procName)\n        self.taskList = []\n        self.executionOrder = []\n        self.nextTaskTime = 0\n        self.pyProcPriority = priority\n        self.intRefs = []",
  "def nextCallTime(self):\n        return self.nextTaskTime",
  "def scheduleTask(self, newTask):\n        for i in range(len(self.executionOrder)):\n            tmpTask = self.executionOrder[i]\n            if (newTask.nextTaskTime < tmpTask.nextTaskTime or\n                    newTask.nextTaskTime == tmpTask.nextTaskTime and\n                    newTask.priority > tmpTask.priority):\n                self.executionOrder.insert(i, newTask)\n                return\n        self.executionOrder.append(newTask)",
  "def createPythonTask(self, newTaskName, taskRate, taskActive=True, taskPriority=-1):\n        self.taskList.append(PythonTaskClass(newTaskName, taskRate, taskActive, taskPriority, self.processData))",
  "def addPythonTask(self, newPyTask):\n        self.taskList.append(newPyTask)",
  "def addModelToTask(self, taskName, newModel, priority=None):\n        for task in self.taskList:\n            if task.name == taskName:\n                task.addModelToTask(newModel, priority)\n                return\n        print(\"Attempted to add model: \" + newModel.modelName)\n        print(\"to non-existent task: \" + taskName)",
  "def selfInitProcess(self):\n\n        if not self.taskList:\n            return\n\n        for task in self.taskList:\n            task.selfInitTask()\n        self.nextTaskTime = 0\n        self.scheduleTask(self.taskList[-1])",
  "def resetProcess(self, currentTime):\n        self.executionOrder = []\n        for task in self.taskList:\n            task.resetTask(currentTime)\n            self.scheduleTask(task)",
  "def executeTaskList(self, currentTime):\n        if len(self.executionOrder) == 0:\n            return\n        taskNext = self.executionOrder[0]\n        for intCurr in self.intRefs:\n            intCurr.routeInputs(self.processData.messageBuffer)\n        while taskNext.nextTaskTime <= currentTime:\n            taskNext.executeModelList(currentTime)\n            self.executionOrder.pop(0)\n            self.scheduleTask(taskNext)\n            taskNext = self.executionOrder[0]\n        self.nextTaskTime = taskNext.nextTaskTime",
  "def addInterfaceRef(self, newInt):\n        self.intRefs.append(newInt)",
  "class rwFactory(object):\n    \"\"\"\n    Reaction Wheel Factory Class\n    \"\"\"\n    def __init__(self):\n        self.rwList = OrderedDict()\n        self.maxMomentum = 0.0\n\n    def create(self, rwType, gsHat_B, **kwargs):\n        \"\"\"\n        This function is called to setup a RW device in python, and adds it to the RW factory\n        list rwList{}.  The function returns a copy of the device that can be changed if needed.\n        The first 2 arguments are required, the remaining arguments are optional with:\n\n        Parameters\n        ----------\n        rwType : string\n            RW manufacturing name.\n        gsHat_B : list\n            Spin axis unit vector gsHat in B-frame components\n        kwargs:\n            Omega: float\n                initial RW speed in RPM\n            Omega_max: float\n                maximum RW speed in RPM\n            rWB_B: list\n                3x1 list of RW center of mass position coordinates\n            RWModel: integer\n                RW model type such as BalancedWheels, JitterSimple and JitterFullyCoupled\n            useRWfriction: BOOL\n                conditional to turn on RW internal wheel friction\n            useMinTorque: BOOL\n                conditional to clip any torque below a minimum torque value\n            useMaxTorque: BOOL\n                conditional to clip any torque value above a maximum torque value\n            u_max: float\n                the maximum RW motor torque\n            maxMomentum: float\n                maximum RW wheel momentum in Nms.  This is a required variable for some wheels.\n            P_max: float\n                the maximum allowed wheel power for changing wheel speed (does not include a base power requirement)\n            label: string\n                with the unique device name, must be 5 characters or less\n            fCoulomb: float\n                Coulomb friction torque model coefficient\n            fStatic: float\n                Static friction torque magnitude\n            betaStatic: float\n                Stribeck friction coefficient, positive turns Stribeck friction on, negative turns this friction off\n            cViscous: float\n                Viscous friction coefficient\n            Js: float\n                RW inertia about spin axis\n        \n        Returns\n        -------\n        RWConfigSimMsg : message structure\n            A handle to the RW configuration message\n        \"\"\"\n\n        # create the blank RW object\n        RW = messaging.RWConfigMsgPayload()\n\n        # process optional input arguments\n        if 'RWModel' in kwargs:\n            varRWModel =  kwargs['RWModel']\n            if not isinstance(varRWModel, int):\n                print('ERROR: RWModel must be a INT argument')\n                exit(1)\n        else:\n            varRWModel = messaging.BalancedWheels    # default value\n\n        if 'useRWfriction' in kwargs:\n            varUseRWfriction = kwargs['useRWfriction']\n            if not isinstance(varUseRWfriction, bool):\n                print('ERROR: useRWfriction must be a BOOL argument')\n                exit(1)\n        else:\n            varUseRWfriction = False            # default value\n\n        if 'useMinTorque' in kwargs:\n            varUseMinTorque =  kwargs['useMinTorque']\n            if not isinstance(varUseMinTorque, bool):\n                print('ERROR: useMinTorque must be a BOOL argument')\n                exit(1)\n        else:\n            varUseMinTorque = False             # default value\n\n        if 'useMaxTorque' in kwargs:\n            varUseMaxTorque = kwargs['useMaxTorque']\n            if not isinstance(varUseMaxTorque, bool):\n                print('ERROR: useMaxTorque must be a BOOL argument')\n                exit(1)\n        else:\n            varUseMaxTorque = True              # default value\n\n        if 'maxMomentum' in kwargs:\n            varMaxMomentum = kwargs['maxMomentum']\n            if not isinstance(varMaxMomentum, float):\n                print('ERROR: maxMomentum must be a FLOAT argument')\n                exit(1)\n        else:\n            varMaxMomentum = 0.0              # default value\n        self.maxMomentum = varMaxMomentum\n\n        if 'P_max' in kwargs:\n            varMaxPower = kwargs['P_max']\n            if not isinstance(varMaxPower, float):\n                print('ERROR: P_max must be a FLOAT argument')\n                exit(1)\n        else:\n            varMaxPower = -1.0              # default value turns off max power limit\n        RW.P_max = varMaxPower\n\n        if 'fCoulomb' in kwargs:\n            varfCoulomb = kwargs['fCoulomb']\n            if not isinstance(varfCoulomb, float):\n                print('ERROR: fCoulomb must be a FLOAT argument')\n                exit(1)\n        else:\n            varfCoulomb = 0.0       # default value\n        RW.fCoulomb = varfCoulomb\n\n        if 'fStatic' in kwargs:\n            varfStatic = kwargs['fStatic']\n            if not isinstance(varfStatic, float):\n                print('ERROR: fStatic must be a FLOAT argument')\n                exit(1)\n        else:\n            varfStatic = 0.0       # default value\n        RW.fStatic = varfStatic\n\n        if 'betaStatic' in kwargs:\n            varbetaStatic = kwargs['betaStatic']\n            if not isinstance(varbetaStatic, float):\n                print('ERROR: betaStatic must be a FLOAT argument')\n                exit(1)\n            if varbetaStatic == 0:\n                print('ERROR: betaStatic cannot be set to zero.  Positive turns it on, negative turns it off')\n                exit(1)\n        else:\n            varbetaStatic = -1.0       # default value turns off Stribeck friction model\n        RW.betaStatic = varbetaStatic\n\n        if 'cViscous' in kwargs:\n            varcViscous =  kwargs['cViscous']\n            if not isinstance(varcViscous, float):\n                print('ERROR: cViscous must be a FLOAT argument')\n                exit(1)\n        else:\n            varcViscous = 0.0       # default value\n        RW.cViscous = varcViscous\n\n        # set device label name\n        if 'label' in kwargs:\n            varLabel = kwargs['label']\n            if not isinstance(varLabel, str):\n                print('ERROR: label must be a string')\n                exit(1)\n            if len(varLabel) > 5:\n                print('ERROR: RW label string is longer than 5 characters')\n                exit(1)\n        else:\n            varLabel = 'RW' + str(len(self.rwList)+1)        # default device labeling\n        RW.label = varLabel\n\n        # populate the RW object with the type specific parameters\n        try:\n            eval('self.' + rwType + '(RW)')\n        except:\n            print('ERROR: RW type ' + rwType + ' is not implemented')\n            exit(1)\n\n        if 'u_min' in kwargs:\n            varu_min = kwargs['u_min']\n            if not isinstance(varu_min, float):\n                print('ERROR: u_min must be a FLOAT argument')\n                exit(1)\n            RW.u_min = varu_min\n        if RW.u_min <= 0.0 and varUseMinTorque:\n            print('ERROR: RW is being setup with non-positive u_min value with varUseMinTorque set to True')\n            exit(1)\n\n        if 'u_max' in kwargs:\n            varu_max = kwargs['u_max']\n            if not isinstance(varu_max, float):\n                print('ERROR: u_max must be a FLOAT argument')\n                exit(1)\n            RW.u_max = varu_max\n        if RW.u_max <= 0.0 and varUseMaxTorque:\n            print('ERROR: RW is being setup with non-positive u_max value with varUseMaxTorque set to True')\n            exit(1)\n\n        # set initial RW states\n        if 'Omega_max' in kwargs:\n            varOmega_max = kwargs['Omega_max']\n            if not isinstance(varOmega_max, float):\n                print('ERROR: Omega_max must be a FLOAT argument')\n                exit(1)\n            RW.Omega_max = varOmega_max * macros.RPM\n\n        # set RW spin axis inertia\n        RW.Js = -1.0\n        if 'Js' in kwargs:\n            varJs = kwargs['Js']\n            if not isinstance(varJs, float):\n                print('ERROR: Js must be a FLOAT argument')\n                exit(1)\n            if varJs > 0.0:\n                RW.Js = varJs * macros.RPM\n                RW.Jt = 0.5 * RW.Js\n                RW.Jg = RW.Jt\n            else:\n                print('ERROR: Js must be a positive value')\n                exit(1)\n\n        if RW.Omega_max > 0.0 and self.maxMomentum > 0.0:\n            if RW.Js <= 0.0:  # no inertia specified\n                # spin axis gs inertia [kg*m^2]\n                RW.Js = self.maxMomentum / RW.Omega_max\n                RW.Jt = 0.5 * RW.Js\n                RW.Jg = RW.Jt\n            else:\n                print('ERROR: rwFactory tried to set Js both directly and through maxMomentum and Omega_max')\n                exit(1)\n        if RW.Js < 0.0:\n            print('ERROR: RW Js value not specified direct, nor indirectly using maxMomentum and Omega_max')\n\n        # set RW axes\n        self.setGsHat(RW, gsHat_B)\n\n        # set RW position vector\n        if 'rWB_B' in kwargs:\n            varrWB_B =  kwargs['rWB_B']\n            if not isinstance(varrWB_B, list):\n                print('ERROR: rWB_B must be a 3x1 list argument')\n                exit(1)\n            if not len(varrWB_B) == 3:\n                print('ERROR: rWB_B has dimension ' + str(len(varrWB_B)) + ', must be a 3x1 list argument')\n                exit(1)\n        else:\n            varrWB_B = [0., 0., 0.]             # default value\n        RW.rWB_B = varrWB_B\n\n        # set initial RW states\n        if 'Omega' in kwargs:\n            varOmega =  kwargs['Omega']\n            if not isinstance(varOmega, (float)):\n                print('ERROR: Omega must be a FLOAT argument')\n                exit(1)\n        else:\n            varOmega = 0.0                      # default value\n        RW.Omega = varOmega * macros.RPM\n        RW.theta = 0.0 * macros.D2R\n\n        # enforce some RW options\n        RW.RWModel = varRWModel\n        if not varUseRWfriction:\n            RW.fCoulomb = 0.0\n        if not varUseMaxTorque:\n            RW.u_max = -1  # a negative value turns off RW torque saturation\n        if not varUseMinTorque:\n            RW.u_min = 0.0\n\n        # add RW to the list of RW devices\n        RW.this.disown()\n        self.rwList[varLabel] = RW\n        return RW\n\n    def setGsHat(self, RW, gsHat_B):\n        \"\"\"\n            Function to set the gsHat_B RW spin axis vector.  This function\n            automatically computes to companion transfer axes to complete a\n            wheel reference frame.\n\n        :param RW:\n        :param gsHat_B:\n        \"\"\"\n        # set RW spin axis gsHat\n        norm = numpy.linalg.norm(gsHat_B)\n        if norm > 1e-10:\n            gsHat_B = gsHat_B / norm\n        else:\n            print('Error: RW gsHat input must be non-zero 3x1 vector')\n            exit(1)\n        RW.gsHat_B = [[gsHat_B[0]], [gsHat_B[1]], [gsHat_B[2]]]\n\n        # set RW t and g unit axes\n        w2Hat0_B = numpy.cross(gsHat_B, [1, 0, 0])\n        norm = numpy.linalg.norm(w2Hat0_B)\n        if norm < 0.01:\n            w2Hat0_B = numpy.cross(gsHat_B, [0, 1, 0])\n            norm = numpy.linalg.norm(w2Hat0_B)\n        w2Hat0_B = w2Hat0_B / norm\n        w3Hat0_B = numpy.cross(gsHat_B, w2Hat0_B)\n        RW.w2Hat0_B = [[w2Hat0_B[0]], [w2Hat0_B[1]], [w2Hat0_B[2]]]\n        RW.w3Hat0_B = [[w3Hat0_B[0]], [w3Hat0_B[1]], [w3Hat0_B[2]]]\n\n        return\n\n    def addToSpacecraft(self, modelTag, rwStateEffector, sc):\n        \"\"\"\n            This function should be called after all RW devices are created with createRW()\n            It creates the C-class container for the array of RW devices, and attaches\n            this container to the spacecraft object\n\n            Parameters\n            ----------\n            :param modelTag:  string with the model tag\n            :param rwStateEffector:\n            :param sc: spacecraft object\n        \"\"\"\n\n        rwStateEffector.ModelTag = modelTag\n\n        for key, rw in list(self.rwList.items()):\n            rwStateEffector.addReactionWheel(rw)\n\n        sc.addStateEffector(rwStateEffector)\n\n        return\n\n    def getNumOfDevices(self):\n        \"\"\"\n            Returns the number of RW devices setup.\n\n            Returns\n            -------\n            :return: int\n        \"\"\"\n        return len(self.rwList)\n\n    def getConfigMessage(self):\n        \"\"\"\n        Returns a FSW reaction wheel configuration message based on the current setup.\n\n        :return: RWArrayConfigMsg\n        \"\"\"\n\n        GsMatrix_B = []\n        JsList = []\n        uMaxList = []\n        for rw in self.rwList.values():\n            \n            flatGsHat = [element for sublist in rw.gsHat_B for element in sublist]\n            \n            GsMatrix_B.extend(flatGsHat)\n            JsList.extend([rw.Js])\n            uMaxList.extend([rw.u_max])\n\n        rwConfigParams = messaging.RWArrayConfigMsgPayload()\n        rwConfigParams.GsMatrix_B = GsMatrix_B\n        rwConfigParams.JsList = JsList\n        rwConfigParams.uMax = uMaxList\n        rwConfigParams.numRW = len(self.rwList)\n\n        rwConfigMsg = messaging.RWArrayConfigMsg().write(rwConfigParams)\n        rwConfigMsg.this.disown()\n\n        return rwConfigMsg\n\n    #\n    #   Honeywell HR16 (100Nm, 75Nm, 50Nm)\n    #\n    #   RW Information Source:\n    #   http://www51.honeywell.com/aero/common/documents/Constellation_Series_Reaction_Wheels.pdf\n    #\n    #   There are 3 momentum capacity options for this RW type.  The maximum momentum\n    #   capacity must be set prior to creating the HR16 RW type using\n    #       maxMomentum = 100, 75 or 50\n    #\n    def Honeywell_HR16(self, RW):\n\n        # maximum allowable wheel speed\n        RW.Omega_max = 6000.0*macros.RPM\n        # maximum RW torque [Nm]\n        RW.u_max = 0.200\n        # minimum RW torque [Nm]\n        RW.u_min = 0.00001\n        # static friction torque [Nm]\n        RW.fCoulomb = 0.0005\n        # RW rotor mass [kg]\n        # Note: the rotor mass here is set equal to the RW mass of the above spec sheet.\n        # static RW imbalance [kg*m]\n        # dynamic RW imbalance [kg*m^2]\n        large = 100\n        medium = 75\n        small = 50\n\n        if self.maxMomentum == large:\n            RW.mass = 12.0\n            RW.U_s = 4.8E-6\n            RW.U_d = 15.4E-7\n        elif self.maxMomentum == medium:\n            RW.mass = 10.4\n            RW.U_s = 3.8E-6\n            RW.U_d = 11.5E-7\n        elif self.maxMomentum == small:\n            RW.mass = 9.0\n            RW.U_s = 2.8E-6\n            RW.U_d = 7.7E-7\n        else:\n            if self.maxMomentum > 0:\n                print('ERROR: ' + sys._getframe().f_code.co_name + '() does not have a correct wheel momentum of '\\\n                      +str(large)+', '+str(medium)+' or '+str(small)+' Nm. Provided ' + str(self.maxMomentum) + ' Nm')\n            else:\n                print('ERROR: ' + sys._getframe().f_code.co_name \\\n                      + '() maxMomentum option must be set prior to calling createRW()')\n            exit(1)\n\n        return\n\n\n    #\n    #   Honeywell HR14 (25Nm, 50Nm, 75Nm)\n    #\n    #   RW Information Source:\n    #   http://www51.honeywell.com/aero/common/documents/Constellation_Series_Reaction_Wheels.pdf\n    #\n    #   There are 3 momentum capacity options for this RW type.  The maximum momentum\n    #   capacity must be set prior to creating the HR14 RW type using\n    #       options.maxMomentum = 75, 50 or 25\n    #\n    def Honeywell_HR14(self, RW):\n        # maximum allowable wheel speed\n        RW.Omega_max = 6000.0*macros.RPM\n        # maximum RW torque [Nm]\n        RW.u_max = 0.200\n        # minimum RW torque [Nm]\n        RW.u_min = 0.00001\n        # static friction torque [Nm]\n        RW.fCoulomb = 0.0005\n        # RW rotor mass [kg]\n        # Note: the rotor mass here is set equal to the RW mass of the above spec sheet.\n        # static RW imbalance [kg*m]\n        # dynamic RW imbalance [kg*m^2]\n        large = 75\n        medium = 50\n        small = 25\n        if self.maxMomentum == large:\n            RW.mass = 10.6\n            RW.U_s = 4.8E-6\n            RW.U_d = 13.7E-7\n        elif self.maxMomentum == medium:\n            RW.mass = 8.5\n            RW.U_s = 3.5E-6\n            RW.U_d = 9.1E-7\n        elif self.maxMomentum == small:\n            RW.mass = 7.5\n            RW.U_s = 2.2E-6\n            RW.U_d = 4.6E-7\n        else:\n            if self.maxMomentum > 0:\n                print('ERROR: ' + sys._getframe().f_code.co_name + '() does not have a correct wheel momentum of '\\\n                      +str(large)+', '+str(medium)+' or '+str(small)+' Nm. Provided ' + str(self.maxMomentum) + ' Nm')\n            else:\n                print('ERROR: ' + sys._getframe().f_code.co_name \\\n                      + '() maxMomentum option must be set prior to calling createRW()')\n            exit(1)\n\n        return\n\n\n    #\n    #   Honeywell HR12 (12Nm, 25Nm, 50Nm)\n    #\n    #   RW Information Source:\n    #   http://www51.honeywell.com/aero/common/documents/Constellation_Series_Reaction_Wheels.pdf\n    #\n    #   There are 3 momentum capacity self for this RW type.  The maximum momentum\n    #   capacity must be set prior to creating the HR12 RW type using\n    #       maxMomentum = 12, 25 or 50\n    #\n    def Honeywell_HR12(self, RW):\n\n        # maximum allowable wheel speed\n        RW.Omega_max = 6000.0*macros.RPM\n        # maximum RW torque [Nm]\n        RW.u_max = 0.200\n        # minimum RW torque [Nm]\n        RW.u_min = 0.00001\n        # static friction torque [Nm]\n        RW.fCoulomb = 0.0005\n        # RW rotor mass [kg]\n        # Note: the rotor mass here is set equal to the RW mass of the above spec sheet.\n        # static RW imbalance [kg*m]\n        # dynamic RW imbalance [kg*m^2]\n        large = 50\n        medium = 25\n        small = 12\n        if self.maxMomentum == large:\n            RW.mass = 9.5\n            RW.U_s = 4.4E-6\n            RW.U_d = 9.1E-7\n        elif self.maxMomentum == medium:\n            RW.mass = 7.0\n            RW.U_s = 2.4E-6\n            RW.U_d = 4.6E-7\n        elif self.maxMomentum == small:\n            RW.mass = 6.0\n            RW.U_s = 1.5E-6\n            RW.U_d = 2.2E-7\n        else:\n            if self.maxMomentum > 0:\n                print('ERROR: ' + sys._getframe().f_code.co_name + '() does not have a correct wheel momentum of '\\\n                      +str(large)+', '+str(medium)+' or '+str(small)+' Nm. Provided ' + str(self.maxMomentum) + ' Nm')\n            else:\n                print('ERROR: ' + sys._getframe().f_code.co_name \\\n                      + '() maxMomentum option must be set prior to calling createRW()')\n            exit(1)\n\n        return\n\n\n    def BCT_RWP015(self, RW):\n        \"\"\"\n        BCT RWP015\n\n        RW Information Source:\n        https://storage.googleapis.com/blue-canyon-tech-news/1/2019/10/BCT_DataSheet_Components_ReactionWheels_F2.pdf\n\n        Not complete; fields not listed are estimates.\n\n        :param RW: reaction wheel configuration message\n        :return:\n        \"\"\"\n\n        # maximum allowable wheel speed\n        RW.Omega_max = 6000.0*macros.RPM\n        # maximum RW torque [Nm]\n        RW.u_max = 0.004\n        # minimum RW torque [Nm]\n        RW.u_min = 0.00001\n        # static friction torque [Nm]\n        RW.fCoulomb = 0.00005\n        # RW rotor mass [kg]\n        # Note: the rotor mass here is set equal to the RW mass of the above spec sheet.\n        # static RW imbalance [kg*m]\n        # dynamic RW imbalance [kg*m^2]\n\n        if self.maxMomentum > 0.0:\n            print(\"WARNING: BCT_RWP015 has a fixed maxMomentum value.  Custom value being replaced.\")\n        self.maxMomentum = 0.015     # Nms\n\n        RW.mass = 0.130\n        RW.U_s = 1E-7 # Guestimate\n        RW.U_d = 1E-8 # Guestimate\n\n        return\n\n    def custom(self, RW):\n        \"\"\"\n        Creates an empty reaction wheel configuration message.  This assumes the user provided the\n        RW maximum speed and maximum angular momentum information so that Js can be computed,\n        or the user provides the Js inertia value directly.\n\n        :param RW: reaction wheel configuration message\n        :return:\n        \"\"\"\n\n        return",
  "def __init__(self):\n        self.rwList = OrderedDict()\n        self.maxMomentum = 0.0",
  "def create(self, rwType, gsHat_B, **kwargs):\n        \"\"\"\n        This function is called to setup a RW device in python, and adds it to the RW factory\n        list rwList{}.  The function returns a copy of the device that can be changed if needed.\n        The first 2 arguments are required, the remaining arguments are optional with:\n\n        Parameters\n        ----------\n        rwType : string\n            RW manufacturing name.\n        gsHat_B : list\n            Spin axis unit vector gsHat in B-frame components\n        kwargs:\n            Omega: float\n                initial RW speed in RPM\n            Omega_max: float\n                maximum RW speed in RPM\n            rWB_B: list\n                3x1 list of RW center of mass position coordinates\n            RWModel: integer\n                RW model type such as BalancedWheels, JitterSimple and JitterFullyCoupled\n            useRWfriction: BOOL\n                conditional to turn on RW internal wheel friction\n            useMinTorque: BOOL\n                conditional to clip any torque below a minimum torque value\n            useMaxTorque: BOOL\n                conditional to clip any torque value above a maximum torque value\n            u_max: float\n                the maximum RW motor torque\n            maxMomentum: float\n                maximum RW wheel momentum in Nms.  This is a required variable for some wheels.\n            P_max: float\n                the maximum allowed wheel power for changing wheel speed (does not include a base power requirement)\n            label: string\n                with the unique device name, must be 5 characters or less\n            fCoulomb: float\n                Coulomb friction torque model coefficient\n            fStatic: float\n                Static friction torque magnitude\n            betaStatic: float\n                Stribeck friction coefficient, positive turns Stribeck friction on, negative turns this friction off\n            cViscous: float\n                Viscous friction coefficient\n            Js: float\n                RW inertia about spin axis\n        \n        Returns\n        -------\n        RWConfigSimMsg : message structure\n            A handle to the RW configuration message\n        \"\"\"\n\n        # create the blank RW object\n        RW = messaging.RWConfigMsgPayload()\n\n        # process optional input arguments\n        if 'RWModel' in kwargs:\n            varRWModel =  kwargs['RWModel']\n            if not isinstance(varRWModel, int):\n                print('ERROR: RWModel must be a INT argument')\n                exit(1)\n        else:\n            varRWModel = messaging.BalancedWheels    # default value\n\n        if 'useRWfriction' in kwargs:\n            varUseRWfriction = kwargs['useRWfriction']\n            if not isinstance(varUseRWfriction, bool):\n                print('ERROR: useRWfriction must be a BOOL argument')\n                exit(1)\n        else:\n            varUseRWfriction = False            # default value\n\n        if 'useMinTorque' in kwargs:\n            varUseMinTorque =  kwargs['useMinTorque']\n            if not isinstance(varUseMinTorque, bool):\n                print('ERROR: useMinTorque must be a BOOL argument')\n                exit(1)\n        else:\n            varUseMinTorque = False             # default value\n\n        if 'useMaxTorque' in kwargs:\n            varUseMaxTorque = kwargs['useMaxTorque']\n            if not isinstance(varUseMaxTorque, bool):\n                print('ERROR: useMaxTorque must be a BOOL argument')\n                exit(1)\n        else:\n            varUseMaxTorque = True              # default value\n\n        if 'maxMomentum' in kwargs:\n            varMaxMomentum = kwargs['maxMomentum']\n            if not isinstance(varMaxMomentum, float):\n                print('ERROR: maxMomentum must be a FLOAT argument')\n                exit(1)\n        else:\n            varMaxMomentum = 0.0              # default value\n        self.maxMomentum = varMaxMomentum\n\n        if 'P_max' in kwargs:\n            varMaxPower = kwargs['P_max']\n            if not isinstance(varMaxPower, float):\n                print('ERROR: P_max must be a FLOAT argument')\n                exit(1)\n        else:\n            varMaxPower = -1.0              # default value turns off max power limit\n        RW.P_max = varMaxPower\n\n        if 'fCoulomb' in kwargs:\n            varfCoulomb = kwargs['fCoulomb']\n            if not isinstance(varfCoulomb, float):\n                print('ERROR: fCoulomb must be a FLOAT argument')\n                exit(1)\n        else:\n            varfCoulomb = 0.0       # default value\n        RW.fCoulomb = varfCoulomb\n\n        if 'fStatic' in kwargs:\n            varfStatic = kwargs['fStatic']\n            if not isinstance(varfStatic, float):\n                print('ERROR: fStatic must be a FLOAT argument')\n                exit(1)\n        else:\n            varfStatic = 0.0       # default value\n        RW.fStatic = varfStatic\n\n        if 'betaStatic' in kwargs:\n            varbetaStatic = kwargs['betaStatic']\n            if not isinstance(varbetaStatic, float):\n                print('ERROR: betaStatic must be a FLOAT argument')\n                exit(1)\n            if varbetaStatic == 0:\n                print('ERROR: betaStatic cannot be set to zero.  Positive turns it on, negative turns it off')\n                exit(1)\n        else:\n            varbetaStatic = -1.0       # default value turns off Stribeck friction model\n        RW.betaStatic = varbetaStatic\n\n        if 'cViscous' in kwargs:\n            varcViscous =  kwargs['cViscous']\n            if not isinstance(varcViscous, float):\n                print('ERROR: cViscous must be a FLOAT argument')\n                exit(1)\n        else:\n            varcViscous = 0.0       # default value\n        RW.cViscous = varcViscous\n\n        # set device label name\n        if 'label' in kwargs:\n            varLabel = kwargs['label']\n            if not isinstance(varLabel, str):\n                print('ERROR: label must be a string')\n                exit(1)\n            if len(varLabel) > 5:\n                print('ERROR: RW label string is longer than 5 characters')\n                exit(1)\n        else:\n            varLabel = 'RW' + str(len(self.rwList)+1)        # default device labeling\n        RW.label = varLabel\n\n        # populate the RW object with the type specific parameters\n        try:\n            eval('self.' + rwType + '(RW)')\n        except:\n            print('ERROR: RW type ' + rwType + ' is not implemented')\n            exit(1)\n\n        if 'u_min' in kwargs:\n            varu_min = kwargs['u_min']\n            if not isinstance(varu_min, float):\n                print('ERROR: u_min must be a FLOAT argument')\n                exit(1)\n            RW.u_min = varu_min\n        if RW.u_min <= 0.0 and varUseMinTorque:\n            print('ERROR: RW is being setup with non-positive u_min value with varUseMinTorque set to True')\n            exit(1)\n\n        if 'u_max' in kwargs:\n            varu_max = kwargs['u_max']\n            if not isinstance(varu_max, float):\n                print('ERROR: u_max must be a FLOAT argument')\n                exit(1)\n            RW.u_max = varu_max\n        if RW.u_max <= 0.0 and varUseMaxTorque:\n            print('ERROR: RW is being setup with non-positive u_max value with varUseMaxTorque set to True')\n            exit(1)\n\n        # set initial RW states\n        if 'Omega_max' in kwargs:\n            varOmega_max = kwargs['Omega_max']\n            if not isinstance(varOmega_max, float):\n                print('ERROR: Omega_max must be a FLOAT argument')\n                exit(1)\n            RW.Omega_max = varOmega_max * macros.RPM\n\n        # set RW spin axis inertia\n        RW.Js = -1.0\n        if 'Js' in kwargs:\n            varJs = kwargs['Js']\n            if not isinstance(varJs, float):\n                print('ERROR: Js must be a FLOAT argument')\n                exit(1)\n            if varJs > 0.0:\n                RW.Js = varJs * macros.RPM\n                RW.Jt = 0.5 * RW.Js\n                RW.Jg = RW.Jt\n            else:\n                print('ERROR: Js must be a positive value')\n                exit(1)\n\n        if RW.Omega_max > 0.0 and self.maxMomentum > 0.0:\n            if RW.Js <= 0.0:  # no inertia specified\n                # spin axis gs inertia [kg*m^2]\n                RW.Js = self.maxMomentum / RW.Omega_max\n                RW.Jt = 0.5 * RW.Js\n                RW.Jg = RW.Jt\n            else:\n                print('ERROR: rwFactory tried to set Js both directly and through maxMomentum and Omega_max')\n                exit(1)\n        if RW.Js < 0.0:\n            print('ERROR: RW Js value not specified direct, nor indirectly using maxMomentum and Omega_max')\n\n        # set RW axes\n        self.setGsHat(RW, gsHat_B)\n\n        # set RW position vector\n        if 'rWB_B' in kwargs:\n            varrWB_B =  kwargs['rWB_B']\n            if not isinstance(varrWB_B, list):\n                print('ERROR: rWB_B must be a 3x1 list argument')\n                exit(1)\n            if not len(varrWB_B) == 3:\n                print('ERROR: rWB_B has dimension ' + str(len(varrWB_B)) + ', must be a 3x1 list argument')\n                exit(1)\n        else:\n            varrWB_B = [0., 0., 0.]             # default value\n        RW.rWB_B = varrWB_B\n\n        # set initial RW states\n        if 'Omega' in kwargs:\n            varOmega =  kwargs['Omega']\n            if not isinstance(varOmega, (float)):\n                print('ERROR: Omega must be a FLOAT argument')\n                exit(1)\n        else:\n            varOmega = 0.0                      # default value\n        RW.Omega = varOmega * macros.RPM\n        RW.theta = 0.0 * macros.D2R\n\n        # enforce some RW options\n        RW.RWModel = varRWModel\n        if not varUseRWfriction:\n            RW.fCoulomb = 0.0\n        if not varUseMaxTorque:\n            RW.u_max = -1  # a negative value turns off RW torque saturation\n        if not varUseMinTorque:\n            RW.u_min = 0.0\n\n        # add RW to the list of RW devices\n        RW.this.disown()\n        self.rwList[varLabel] = RW\n        return RW",
  "def setGsHat(self, RW, gsHat_B):\n        \"\"\"\n            Function to set the gsHat_B RW spin axis vector.  This function\n            automatically computes to companion transfer axes to complete a\n            wheel reference frame.\n\n        :param RW:\n        :param gsHat_B:\n        \"\"\"\n        # set RW spin axis gsHat\n        norm = numpy.linalg.norm(gsHat_B)\n        if norm > 1e-10:\n            gsHat_B = gsHat_B / norm\n        else:\n            print('Error: RW gsHat input must be non-zero 3x1 vector')\n            exit(1)\n        RW.gsHat_B = [[gsHat_B[0]], [gsHat_B[1]], [gsHat_B[2]]]\n\n        # set RW t and g unit axes\n        w2Hat0_B = numpy.cross(gsHat_B, [1, 0, 0])\n        norm = numpy.linalg.norm(w2Hat0_B)\n        if norm < 0.01:\n            w2Hat0_B = numpy.cross(gsHat_B, [0, 1, 0])\n            norm = numpy.linalg.norm(w2Hat0_B)\n        w2Hat0_B = w2Hat0_B / norm\n        w3Hat0_B = numpy.cross(gsHat_B, w2Hat0_B)\n        RW.w2Hat0_B = [[w2Hat0_B[0]], [w2Hat0_B[1]], [w2Hat0_B[2]]]\n        RW.w3Hat0_B = [[w3Hat0_B[0]], [w3Hat0_B[1]], [w3Hat0_B[2]]]\n\n        return",
  "def addToSpacecraft(self, modelTag, rwStateEffector, sc):\n        \"\"\"\n            This function should be called after all RW devices are created with createRW()\n            It creates the C-class container for the array of RW devices, and attaches\n            this container to the spacecraft object\n\n            Parameters\n            ----------\n            :param modelTag:  string with the model tag\n            :param rwStateEffector:\n            :param sc: spacecraft object\n        \"\"\"\n\n        rwStateEffector.ModelTag = modelTag\n\n        for key, rw in list(self.rwList.items()):\n            rwStateEffector.addReactionWheel(rw)\n\n        sc.addStateEffector(rwStateEffector)\n\n        return",
  "def getNumOfDevices(self):\n        \"\"\"\n            Returns the number of RW devices setup.\n\n            Returns\n            -------\n            :return: int\n        \"\"\"\n        return len(self.rwList)",
  "def getConfigMessage(self):\n        \"\"\"\n        Returns a FSW reaction wheel configuration message based on the current setup.\n\n        :return: RWArrayConfigMsg\n        \"\"\"\n\n        GsMatrix_B = []\n        JsList = []\n        uMaxList = []\n        for rw in self.rwList.values():\n            \n            flatGsHat = [element for sublist in rw.gsHat_B for element in sublist]\n            \n            GsMatrix_B.extend(flatGsHat)\n            JsList.extend([rw.Js])\n            uMaxList.extend([rw.u_max])\n\n        rwConfigParams = messaging.RWArrayConfigMsgPayload()\n        rwConfigParams.GsMatrix_B = GsMatrix_B\n        rwConfigParams.JsList = JsList\n        rwConfigParams.uMax = uMaxList\n        rwConfigParams.numRW = len(self.rwList)\n\n        rwConfigMsg = messaging.RWArrayConfigMsg().write(rwConfigParams)\n        rwConfigMsg.this.disown()\n\n        return rwConfigMsg",
  "def Honeywell_HR16(self, RW):\n\n        # maximum allowable wheel speed\n        RW.Omega_max = 6000.0*macros.RPM\n        # maximum RW torque [Nm]\n        RW.u_max = 0.200\n        # minimum RW torque [Nm]\n        RW.u_min = 0.00001\n        # static friction torque [Nm]\n        RW.fCoulomb = 0.0005\n        # RW rotor mass [kg]\n        # Note: the rotor mass here is set equal to the RW mass of the above spec sheet.\n        # static RW imbalance [kg*m]\n        # dynamic RW imbalance [kg*m^2]\n        large = 100\n        medium = 75\n        small = 50\n\n        if self.maxMomentum == large:\n            RW.mass = 12.0\n            RW.U_s = 4.8E-6\n            RW.U_d = 15.4E-7\n        elif self.maxMomentum == medium:\n            RW.mass = 10.4\n            RW.U_s = 3.8E-6\n            RW.U_d = 11.5E-7\n        elif self.maxMomentum == small:\n            RW.mass = 9.0\n            RW.U_s = 2.8E-6\n            RW.U_d = 7.7E-7\n        else:\n            if self.maxMomentum > 0:\n                print('ERROR: ' + sys._getframe().f_code.co_name + '() does not have a correct wheel momentum of '\\\n                      +str(large)+', '+str(medium)+' or '+str(small)+' Nm. Provided ' + str(self.maxMomentum) + ' Nm')\n            else:\n                print('ERROR: ' + sys._getframe().f_code.co_name \\\n                      + '() maxMomentum option must be set prior to calling createRW()')\n            exit(1)\n\n        return",
  "def Honeywell_HR14(self, RW):\n        # maximum allowable wheel speed\n        RW.Omega_max = 6000.0*macros.RPM\n        # maximum RW torque [Nm]\n        RW.u_max = 0.200\n        # minimum RW torque [Nm]\n        RW.u_min = 0.00001\n        # static friction torque [Nm]\n        RW.fCoulomb = 0.0005\n        # RW rotor mass [kg]\n        # Note: the rotor mass here is set equal to the RW mass of the above spec sheet.\n        # static RW imbalance [kg*m]\n        # dynamic RW imbalance [kg*m^2]\n        large = 75\n        medium = 50\n        small = 25\n        if self.maxMomentum == large:\n            RW.mass = 10.6\n            RW.U_s = 4.8E-6\n            RW.U_d = 13.7E-7\n        elif self.maxMomentum == medium:\n            RW.mass = 8.5\n            RW.U_s = 3.5E-6\n            RW.U_d = 9.1E-7\n        elif self.maxMomentum == small:\n            RW.mass = 7.5\n            RW.U_s = 2.2E-6\n            RW.U_d = 4.6E-7\n        else:\n            if self.maxMomentum > 0:\n                print('ERROR: ' + sys._getframe().f_code.co_name + '() does not have a correct wheel momentum of '\\\n                      +str(large)+', '+str(medium)+' or '+str(small)+' Nm. Provided ' + str(self.maxMomentum) + ' Nm')\n            else:\n                print('ERROR: ' + sys._getframe().f_code.co_name \\\n                      + '() maxMomentum option must be set prior to calling createRW()')\n            exit(1)\n\n        return",
  "def Honeywell_HR12(self, RW):\n\n        # maximum allowable wheel speed\n        RW.Omega_max = 6000.0*macros.RPM\n        # maximum RW torque [Nm]\n        RW.u_max = 0.200\n        # minimum RW torque [Nm]\n        RW.u_min = 0.00001\n        # static friction torque [Nm]\n        RW.fCoulomb = 0.0005\n        # RW rotor mass [kg]\n        # Note: the rotor mass here is set equal to the RW mass of the above spec sheet.\n        # static RW imbalance [kg*m]\n        # dynamic RW imbalance [kg*m^2]\n        large = 50\n        medium = 25\n        small = 12\n        if self.maxMomentum == large:\n            RW.mass = 9.5\n            RW.U_s = 4.4E-6\n            RW.U_d = 9.1E-7\n        elif self.maxMomentum == medium:\n            RW.mass = 7.0\n            RW.U_s = 2.4E-6\n            RW.U_d = 4.6E-7\n        elif self.maxMomentum == small:\n            RW.mass = 6.0\n            RW.U_s = 1.5E-6\n            RW.U_d = 2.2E-7\n        else:\n            if self.maxMomentum > 0:\n                print('ERROR: ' + sys._getframe().f_code.co_name + '() does not have a correct wheel momentum of '\\\n                      +str(large)+', '+str(medium)+' or '+str(small)+' Nm. Provided ' + str(self.maxMomentum) + ' Nm')\n            else:\n                print('ERROR: ' + sys._getframe().f_code.co_name \\\n                      + '() maxMomentum option must be set prior to calling createRW()')\n            exit(1)\n\n        return",
  "def BCT_RWP015(self, RW):\n        \"\"\"\n        BCT RWP015\n\n        RW Information Source:\n        https://storage.googleapis.com/blue-canyon-tech-news/1/2019/10/BCT_DataSheet_Components_ReactionWheels_F2.pdf\n\n        Not complete; fields not listed are estimates.\n\n        :param RW: reaction wheel configuration message\n        :return:\n        \"\"\"\n\n        # maximum allowable wheel speed\n        RW.Omega_max = 6000.0*macros.RPM\n        # maximum RW torque [Nm]\n        RW.u_max = 0.004\n        # minimum RW torque [Nm]\n        RW.u_min = 0.00001\n        # static friction torque [Nm]\n        RW.fCoulomb = 0.00005\n        # RW rotor mass [kg]\n        # Note: the rotor mass here is set equal to the RW mass of the above spec sheet.\n        # static RW imbalance [kg*m]\n        # dynamic RW imbalance [kg*m^2]\n\n        if self.maxMomentum > 0.0:\n            print(\"WARNING: BCT_RWP015 has a fixed maxMomentum value.  Custom value being replaced.\")\n        self.maxMomentum = 0.015     # Nms\n\n        RW.mass = 0.130\n        RW.U_s = 1E-7 # Guestimate\n        RW.U_d = 1E-8 # Guestimate\n\n        return",
  "def custom(self, RW):\n        \"\"\"\n        Creates an empty reaction wheel configuration message.  This assumes the user provided the\n        RW maximum speed and maximum angular momentum information so that Js can be computed,\n        or the user provides the Js inertia value directly.\n\n        :param RW: reaction wheel configuration message\n        :return:\n        \"\"\"\n\n        return",
  "class SingleVariableDispersion(object):\n    __metaclass__ = abc.ABCMeta\n\n    def __init__(self, varName, bounds):\n        self.varName = varName\n        self.bounds = bounds\n        self.magnitude = []\n\n    @abc.abstractmethod\n    def generate(self, sim):\n        pass\n\n    def getDispersionMag(self):\n        return self.magnitude\n\n    def checkBounds(self, value):\n        if self.bounds is None:\n            return value\n\n        if value <= self.bounds[0]:\n            value = self.bounds[0]\n        if value >= self.bounds[1]:\n            value = self.bounds[1]\n        return value\n\n    def getName(self):\n        return self.varName\n\n    def generateString(self, sim):\n        return str(self.generate(sim))\n\n    def generateMagString(self):\n        return str(self.getDispersionMag())",
  "class UniformDispersion(SingleVariableDispersion):\n    def __init__(self, varName, bounds=None):\n        SingleVariableDispersion.__init__(self, varName, bounds)\n        if self.bounds is None:\n            self.bounds = ([-1.0, 1.0])  # defines a hard floor/ceiling\n\n    def generate(self, sim):\n        dispValue = random.uniform(self.bounds[0], self.bounds[1])\n\n        mid = (self.bounds[1] + self.bounds[0])/2.\n        scale = self.bounds[1] - mid\n        self.magnitude.append(str(round((dispValue - mid)/scale*100,2)) + \" %\")\n        return dispValue",
  "class NormalDispersion(SingleVariableDispersion):\n    def __init__(self, varName, mean=0.0, stdDeviation=0.5, bounds=None):\n        SingleVariableDispersion.__init__(self, varName, bounds)\n        self.mean = mean\n        self.stdDeviation = stdDeviation\n\n    def generate(self, sim):\n        dispValue = random.gauss(self.mean, self.stdDeviation)\n        if self.bounds is not None:\n            dispValue = self.checkBounds(dispValue)\n        if self.stdDeviation !=0 :\n            self.magnitude.append(str(round((dispValue - self.mean)/self.stdDeviation,2)) + \" sigma\")\n        return dispValue",
  "class VectorVariableDispersion(object):\n    __metaclass__ = abc.ABCMeta\n    \n    def __init__(self, varName, bounds):\n        self.varName = varName\n        self.bounds = bounds\n        self.magnitude = []\n        return\n\n    @abc.abstractmethod\n    def generate(self, sim=None):\n        pass\n\n    def getDispersionMag(self):\n        return self.magnitude\n\n    def perturbVectorByAngle(self, vector, angle):\n        rndVec = np.random.random(3)\n        if np.dot(rndVec, vector) > 0.95:\n            rndVec[0] *= -1\n        eigenAxis = np.cross(vector, rndVec)\n        thrusterMisalignDCM = self.eigAxisAndAngleToDCM(eigenAxis, angle)\n        self.magnitude.append(str(round(np.arccos(np.dot(rndVec, vector)/np.linalg.norm(rndVec)/np.linalg.norm(vector))*180./np.pi,2)) + \" deg\")\n        return np.dot(thrusterMisalignDCM, vector)\n\n    def perturbCartesianVectorUniform(self, vector):\n        dispValues = np.zeros(3)\n        for i in range(len(vector)):\n            dispValues[i] = random.uniform(self.bounds[0], self.bounds[1])\n            mid = (self.bounds[1] + self.bounds[0])\n            scale = self.bounds[1] - mid\n            self.magnitude.append(str(round((dispValues[i] - mid)/scale*100,2)) + \" %\")\n        return dispValues\n\n    def perturbCartesianVectorNormal(self, vector):\n        dispValues = np.zeros(3)\n        for i in range(len(vector)):\n            dispValues[i] = random.gauss(self.mean, self.stdDeviation)\n            if self.stdDeviation != 0 :\n                self.magnitude.append(str(round((dispValues[i] - self.mean)/self.stdDeviation,2)) + r\" $\\sigma$\")\n        return dispValues\n\n    def cart2Spherical(self, cartVector):\n        # Spherical Coordinate Set: [rho, theta, phi]\n        x = cartVector[0]\n        y = cartVector[1]\n        z = cartVector[2]\n\n        rho = np.linalg.norm(cartVector)\n        phi = np.arctan2(y, x)[0]\n        theta = np.arccos(z)[0]\n\n        return [rho, phi, theta]\n\n    def spherical2Cart(self, spherVec):\n        rho = spherVec[0]\n        phi = spherVec[1]\n        theta = spherVec[2]\n\n        x = rho * np.sin(theta) * np.cos(phi)\n        y = rho * np.sin(theta) * np.sin(phi)\n        z = rho * np.cos(theta)\n\n        return [x,y,z]\n\n    @staticmethod\n    def eigAxisAndAngleToDCM(axis, angle):\n        axis = axis / np.linalg.norm(axis)\n        sigma = 1 - np.cos(angle)\n        dcm = np.zeros((3, 3))\n        dcm[0, 0] = axis[0] ** 2 * sigma + np.cos(angle)\n        dcm[0, 1] = axis[0] * axis[1] * sigma + axis[2] * np.sin(angle)\n        dcm[0, 2] = axis[0] * axis[2] * sigma - axis[1] * np.sin(angle)\n        dcm[1, 0] = axis[1] * axis[0] * sigma - axis[2] * np.sin(angle)\n        dcm[1, 1] = axis[1] ** 2 * sigma + np.cos(angle)\n        dcm[1, 2] = axis[1] * axis[2] * sigma + axis[0] * np.sin(angle)\n        dcm[2, 0] = axis[2] * axis[0] * sigma + axis[1] * np.sin(angle)\n        dcm[2, 1] = axis[2] * axis[1] * sigma - axis[0] * np.sin(angle)\n        dcm[2, 2] = axis[2] ** 2 * sigma + np.cos(angle)\n        return dcm\n\n    # @TODO This should be a @classmethod.\n    @staticmethod\n    def checkBounds(value, bounds):\n        if value < bounds[0]:\n            value = bounds[0]\n        if value > bounds[1]:\n            value = bounds[1]\n        return value\n\n    def generateString(self, sim):\n        # TODO does this actually behave differently then str(nextValue)?\n        nextValue = self.generate(sim)\n        val = '['\n        for i in range(3):\n            val += str(nextValue[i]) + ','\n        val = val[0:-1] + ']'\n        return val\n\n    def generateMagString(self):\n        nextValue = self.getDispersionMag()\n        val = '['\n        for i in range(len(self.magnitude)):\n            val += str(nextValue[i]) + ','\n        val = val[0:-1] + ']'\n        return val\n\n    def getName(self):\n        return self.varName",
  "class UniformVectorDispersion(VectorVariableDispersion):\n    def __init__(self, varName, bounds=None):\n        VectorVariableDispersion.__init__(self, varName, bounds)\n        if self.bounds is None:\n            self.bounds = ([-1.0, 1.0])  # defines a hard floor/ceiling\n\n    def generate(self, sim):\n        vector = eval('sim.' + self.varName)\n        dispValue = self.perturbCartesianVectorUniform(vector)\n        return dispValue",
  "class NormalVectorDispersion(VectorVariableDispersion):\n    def __init__(self, varName, mean=0.0, stdDeviation=0.5, bounds=None):\n        VectorVariableDispersion.__init__(self, varName, bounds)\n        if self.bounds is None:\n            self.bounds = ([-1.0, 1.0])  # defines a hard floor/ceiling\n\n    def generate(self, sim):\n        vector = eval('sim.' + self.varName)\n        dispValue = self.perturbCartesianVectorNormal(vector, self.mean, self.stdDeviation)\n        return dispValue",
  "class UniformVectorAngleDispersion(VectorVariableDispersion):\n    def __init__(self, varName, phiBoundsOffNom=None, thetaBoundsOffNom=None):\n        super(UniformVectorAngleDispersion, self).__init__(varName, None)\n        # @TODO these bounds are not currently being applied to the generated values\n\n        self.phiBoundsOffNom = phiBoundsOffNom\n        self.thetaBoundsOffNom = thetaBoundsOffNom\n\n        if phiBoundsOffNom is None:\n            self.phiBoundsOffNom = [-np.pi / 2, np.pi / 2]\n        if thetaBoundsOffNom is None:\n            self.thetaBoundsOffNom = [-np.pi, np.pi]\n\n        self.magnitude = []\n\n    def generate(self, sim=None):\n        # Note this dispersion is applied off of the nominal\n        vectorCart = eval('sim.' + self.varName)\n        vectorCart = vectorCart/np.linalg.norm(vectorCart)\n        vectorSphere = self.cart2Spherical(vectorCart)\n\n        meanPhi = vectorSphere[1] # Nominal phi\n        meanTheta = vectorSphere[2] #Nominal theta\n\n        self.phiBounds = [meanPhi + self.phiBoundsOffNom[0], meanPhi + self.phiBoundsOffNom[1]]\n        self.thetaBounds = [meanTheta + self.thetaBoundsOffNom[0],  meanTheta + self.thetaBoundsOffNom[1]]\n\n        phiRnd = np.random.uniform(meanPhi+self.phiBounds[0], meanPhi+self.phiBounds[1])\n        thetaRnd = np.random.uniform(meanTheta+self.thetaBounds[0], meanTheta+self.thetaBounds[1])\n\n        phiRnd = self.checkBounds(phiRnd, self.phiBounds)\n        thetaRnd = self.checkBounds(thetaRnd, self.thetaBounds)\n\n        newVec = self.spherical2Cart([1.0, phiRnd, thetaRnd])\n        dispVec = newVec/np.linalg.norm(newVec) # Shouldn't technically need the normalization but doing it for completeness\n\n        midPhi = (self.phiBounds[1] + self.phiBounds[0])/2.\n        scalePhi = self.phiBounds[1] - midPhi\n        midTheta = (self.thetaBounds[1] + self.thetaBounds[0])/2.\n        scaleTheta = self.thetaBounds[1] - midTheta\n        self.magnitude.append(str(round((phiRnd - midPhi)/scalePhi*100,2)) + \" %\")\n        self.magnitude.append(str(round((thetaRnd - midTheta)/scaleTheta*100,2)) + \" %\")\n\n        return dispVec",
  "class NormalVectorAngleDispersion(VectorVariableDispersion):\n    def __init__(self, varName, thetaStd = np.pi/3.0, phiStd=np.pi/3.0, thetaBoundsOffNom=None, phiBoundsOffNom=None):\n        super(NormalVectorAngleDispersion, self).__init__(varName, None)\n        # @TODO these bounds are not currently being applied to the generated values\n\n        self.thetaStd = thetaStd\n        self.phiStd = phiStd\n\n        self.phiBoundsOffNom = phiBoundsOffNom\n        self.thetaBoundsOffNom = thetaBoundsOffNom\n\n        if phiBoundsOffNom is None:\n            self.phiBoundsOffNom = [-np.pi/2, np.pi/2]\n        if thetaBoundsOffNom is None:\n            self.thetaBoundsOffNom = [-np.pi, np.pi]\n\n        self.magnitude = []\n\n    def generate(self, sim=None):\n        vectorCart = eval('sim.' + self.varName)\n        vectorCart = vectorCart/np.linalg.norm(vectorCart)\n        vectorSphere = self.cart2Spherical(vectorCart)\n\n        meanPhi = vectorSphere[1] # Nominal phi\n        meanTheta = vectorSphere[2] # Nominal theta\n\n        phiRnd = np.random.normal(meanPhi, self.phiStd, 1)\n        thetaRnd = np.random.normal(meanTheta, self.thetaStd, 1)\n\n        self.phiBounds = [meanPhi + self.phiBoundsOffNom[0], meanPhi + self.phiBoundsOffNom[1]]\n        self.thetaBounds = [meanTheta + self.thetaBoundsOffNom[0],  meanTheta + self.thetaBoundsOffNom[1]]\n\n        phiRnd = self.checkBounds(phiRnd, self.phiBounds)\n        thetaRnd = self.checkBounds(thetaRnd, self.thetaBounds)\n\n        newVec = self.spherical2Cart([1.0, phiRnd, thetaRnd])\n        dispVec = newVec/np.linalg.norm(newVec) # Shouldn't technically need the normalization but doing it for completeness\n\n        self.magnitude.append(str(round((phiRnd - meanPhi) / self.phiStd, 2)) + r\" $\\sigma$\")\n        self.magnitude.append(str(round((thetaRnd - meanTheta) / self.thetaStd, 2)) + r\" $\\sigma$\")\n\n        return dispVec",
  "class UniformEulerAngleMRPDispersion(VectorVariableDispersion):\n    def __init__(self, varName, bounds=None):\n        \"\"\"\n        Args:\n            varName (str): A string representation of the variable to be dispersed\n                e.g. 'VehDynObject.AttitudeInit'.\n            bounds (Array[float, float]): defines lower and upper cut offs for generated dispersion values radians.\n        \"\"\"\n        super(UniformEulerAngleMRPDispersion, self).__init__(varName, bounds)\n        if self.bounds is None:\n            self.bounds = ([0, 2 * np.pi])\n        self.magnitude = []\n\n    def generate(self, sim=None):\n        rndAngles = np.zeros((3, 1))\n        for i in range(3):\n            rndAngles[i] = (self.bounds[1] - self.bounds[0]) * np.random.random() + self.bounds[0]\n        dispMRP = rbk.euler3232MRP(rndAngles)\n        dispMRP = dispMRP.reshape(3)\n        for i in range(3):\n            self.magnitude.append(str(round((dispMRP[i] - np.pi)/np.pi*100,2))+ \" %\")\n        return dispMRP",
  "class NormalThrusterUnitDirectionVectorDispersion(VectorVariableDispersion):\n    def __init__(self, varName, thrusterIndex=0, phiStd=0.1745, bounds=None):\n        \"\"\"\n        Args:\n            varName (str): A string representation of the variable to be dispersed\n                e.g. 'ACSThrusterDynObject.ThrusterData[0].thrusterDirectionDisp'.\n            thrusterIndex (int): The index of the thruster to be used in array references.\n            phiStd (float): The 1 sigma standard deviation of the dispersion angle in radians.\n            bounds (Array[float, float]): defines lower and upper cut offs for generated dispersion values.\n        \"\"\"\n        super(NormalThrusterUnitDirectionVectorDispersion, self).__init__(varName, bounds)\n        self.varNameComponents = self.varName.split(\".\")\n        self.phiStd = phiStd  # (rad) angular standard deviation\n        # Limit dispersion to a hemisphere around the vector being dispersed\n        # if self.bounds is None:\n        #     self.bounds = ([-np.pi/2, np.pi/2])\n        self.thrusterIndex = thrusterIndex\n        self.magnitude = []\n\n    def getName(self):\n        return '.'.join(self.varNameComponents[0:-1]) + '.thrDir_B'\n\n    def generateString(self, sim):\n        # TODO does this actually behave differently then str(nextValue)?\n        nextValue = self.generate(sim)\n\n        val = '['\n        for i in range(3):\n            val += str(nextValue[i])\n            if (i < 2):\n                val += ', '\n        val += ']'\n\n        return val\n\n    def generateMagString(self):\n        nextValue = self.getDispersionMag()\n\n        val = '['\n        for i in range(len(self.magnitude)):\n            val += str(nextValue[i])\n            val += ', '\n        val += ']'\n\n        return val\n\n    def generate(self, sim=None):\n        if sim is None:\n            print((\"No simulation object parameter set in '\" + self.generate.__name__\n                  + \"()' dispersions will not be set for variable \" + self.varName))\n            return\n        else:\n            separator = '.'\n            thrusterObject = getattr(sim, self.varNameComponents[0])\n            totalVar = separator.join(self.varNameComponents[0:-1])\n            dirVec = eval('sim.' + totalVar + '.thrDir_B')\n            angle = np.random.normal(0, self.phiStd, 1)\n            dirVec = np.array(dirVec).reshape(3).tolist()\n            dispVec = self.perturbVectorByAngle(dirVec, angle)\n            angleDisp = np.arccos(np.dot(dirVec, dispVec)/np.linalg.norm(dirVec)/np.linalg.norm(dispVec))\n            self.magnitude.append(str(round(angleDisp / self.phiStd,2)) + \" sigma\")\n        return dispVec",
  "class UniformVectorCartDispersion(VectorVariableDispersion):\n    def __init__(self, varName, bounds=None):\n        super(UniformVectorCartDispersion, self).__init__(varName, bounds)\n        if self.bounds is None:\n            self.bounds = ([-1.0, 1.0])\n        self.magnitude = []\n\n    def generate(self, sim=None):\n        dispVec = []\n        for i in range(3):\n            rnd = random.uniform(self.bounds[0], self.bounds[1])\n            rnd = self.checkBounds(rnd, self.bounds)\n            for i in range(3):\n                mid = (self.bounds[1] + self.bounds[0])/2.\n                scale = self.bounds[1] - mid\n                self.magnitude.append(str(round((rnd - mid) / scale * 100,2))+ \" %\")\n            dispVec.append(rnd)\n        return dispVec",
  "class NormalVectorCartDispersion(VectorVariableDispersion):\n    def __init__(self, varName, mean=0.0, stdDeviation=0.0, bounds=None):\n        super(NormalVectorCartDispersion, self).__init__(varName, bounds)\n        self.mean = mean\n        self.stdDeviation = stdDeviation\n        self.magnitude = []\n\n    def generate(self, sim=None):\n        dispVec = []\n        for i in range(3):\n            if isinstance(self.stdDeviation, collections.abc.Sequence):\n                rnd = random.gauss(self.mean[i], self.stdDeviation[i])\n                if self.stdDeviation[i] != 0:\n                    self.magnitude.append(str(round((rnd - self.mean[i])/self.stdDeviation[i],2)) + \" sigma\")\n            else:\n                rnd = random.gauss(self.mean, self.stdDeviation)\n                if self.stdDeviation != 0:\n                    self.magnitude.append(str(round((rnd - self.mean) / self.stdDeviation,2)) + \" sigma\")\n            if self.bounds is not None:\n                rnd = self.checkBounds(rnd, self.bounds)\n            dispVec.append(rnd)\n\n        return dispVec",
  "class InertiaTensorDispersion:\n    def __init__(self, varName, stdDiag=None, boundsDiag=None, stdAngle=None):\n        \"\"\"\n        Args:\n            varName (str): A string representation of the variable to be dispersed\n                e.g. 'LocalConfigData.I'.\n            stdDeviation (float): The 1 sigma standard deviation of the diagonal element dispersions in kg*m^2.\n            bounds (Array[float, float]): defines lower and upper cut offs for generated dispersion values kg*m^2.\n        \"\"\"\n        self.varName = varName\n        self.varNameComponents = self.varName.split(\".\")\n        self.stdDiag = stdDiag\n        self.stdAngle = stdAngle\n        self.bounds = boundsDiag\n        self.magnitude = []\n        if self.stdDiag is None:\n            self.stdDiag = 1.0\n        if self.bounds is None:\n            self.bounds = ([-1.0, 1.0])\n        if self.stdAngle is None:\n            self.stdAngle = 0.0\n\n    def generate(self, sim=None):\n        if sim is None:\n            print((\"No simulation object parameter set in '\" + self.generate.__name__\n                  + \"()' dispersions will not be set for variable \" + self.varName))\n            return\n        else:\n            vehDynObject = getattr(sim, self.varNameComponents[0])\n            I = np.array(eval('sim.' + self.varName)).reshape(3, 3)\n\n            # generate random values for the diagonals\n            temp = []\n            for i in range(3):\n                rnd = random.gauss(0, self.stdDiag)\n                rnd = self.checkBounds(rnd)\n                temp.append(rnd)\n                if self.stdDiag != 0:\n                    self.magnitude.append(str(round(rnd/self.stdDiag,2)) + \" sigma\")\n            dispIdentityMatrix = np.identity(3) * temp\n            # generate random values for the similarity transform to produce off-diagonal terms\n            angles = np.random.normal(0, self.stdAngle, 3)\n            for i in range(3):\n                if self.stdAngle != 0:\n                    self.magnitude.append(str(round(angles[i] / self.stdAngle,2)) + \" sigma\")\n            disp321Matrix = rbk.euler3212C(angles)\n\n            # disperse the diagonal elements\n            dispI = I + dispIdentityMatrix\n            # disperse the off diagonals with a slight similarity transform of the inertia tensor\n            dispI = np.dot(np.dot(disp321Matrix, dispI), disp321Matrix.T)\n\n        return dispI\n\n    def getDispersionMag(self):\n        return self.magnitude\n\n    def checkBounds(self, value):\n        if value < self.bounds[0]:\n            value = self.bounds[0]\n        if value > self.bounds[1]:\n            value = self.bounds[1]\n        return value\n\n    def generateString(self, sim):\n        nextValue = self.generate(sim)\n        # TODO does this actually behave differently then str(nextValue)?\n        val = '['\n        for i in range(3):\n            val += '[' + str(nextValue[i][0]) + ', ' \\\n                + str(nextValue[i][1]) + ', ' \\\n                + str(nextValue[i][2]) + ']'\n            if i != 2:\n                val += ','\n        val = val[0:] + ']'\n        return val\n\n    def generateMagString(self):\n        nextValue = self.getDispersionMag()\n        val = '['\n        for i in range(len(self.magnitude)):\n            val += str(nextValue[i]) + ','\n        val = val[0:-1] + ']'\n        return val\n\n    def getName(self):\n        return self.varName",
  "class OrbitalElementDispersion:\n    def __init__(self, varName1, varName2, dispDict):\n        \"\"\"\n        A function that disperses position and velocity of the spacecraft using orbital elements as a dispersion metric.\n        Args:\n            varName1 (str): A string representation of the position variable to be dispersed\n            varName2 (str): A string representation of the velocity variable to be dispersed\n            dispDict (dict): A dictionnary containing the dispersions for each of the orbital elements. The values are lists\n            with first element 'normal' or 'uniform' followed by mean, std or lower bound, upper bound respectively. If no dispersion\n            is added for a specific orbital elemenet, None should be the values for the corresponding key\n        \"\"\"\n        self.numberOfSubDisps = 2\n        self.varName1 = varName1\n        self.varName1Components = self.varName1.split(\".\")\n        self.varName2 = varName2\n        self.varName2Components = self.varName2.split(\".\")\n        self.oeDict = dispDict\n\n\n    def generate(self, sim=None):\n        elems = orbitalMotion.ClassicElements\n        for key in self.oeDict.keys():\n            if self.oeDict[key] is not None and key != \"mu\":\n                exec(\"elems.\"+ key + \" = np.random.\" + self.oeDict[key][0] + \"(\" +  str(self.oeDict[key][1]) + ', ' +  str(self.oeDict[key][2]) + \")\")\n            else:\n                if key != \"mu\":\n                    exec(\"elems.\" + key + \" = 0.\")\n        if elems.e < 0:\n            elems.e = 0\n        r, v =orbitalMotion.elem2rv_parab( self.oeDict[\"mu\"], elems)\n\n        self.dispR = r\n        self.dispV = v\n\n\n    def generateString(self, index, sim=None):\n        if index == 1:\n            nextValue = self.dispR\n        if index == 2:\n            nextValue = self.dispV\n        val = '['\n        for i in range(3):\n            val += str(nextValue[i]) + ','\n        val = val[0:-1] + ']'\n        return val\n\n    def getName(self, index):\n        if index == 1:\n            return self.varName1\n        if index == 2:\n            return self.varName2",
  "class MRPDispersionPerAxis(VectorVariableDispersion):\n    def __init__(self, varName, bounds=None):\n        \"\"\"\n        A function that disperses MRPs with specfic bounds per axis.\n        Args:\n            varName (str): A string representation of the variable to be dispersed\n                e.g. 'VehDynObject.AttitudeInit'.\n            bounds (list(Array[float, float],Array[float, float],Array[float, float])): defines lower and upper cut offs for generated dispersion values radians.\n        \"\"\"\n        super(MRPDispersionPerAxis, self).__init__(varName, bounds)\n        if self.bounds is None:\n            self.bounds = [[0, 2 * np.pi], [0, 2 * np.pi], [0, 2 * np.pi]]\n\n    def generate(self, sim=None):\n        rndAngles = np.zeros((3, 1))\n        for i in range(3):\n            rndAngles[i] = (self.bounds[i][1] - self.bounds[i][0]) * np.random.random() + self.bounds[i][0]\n        dispMRP = rndAngles.reshape(3)\n        return dispMRP",
  "def __init__(self, varName, bounds):\n        self.varName = varName\n        self.bounds = bounds\n        self.magnitude = []",
  "def generate(self, sim):\n        pass",
  "def getDispersionMag(self):\n        return self.magnitude",
  "def checkBounds(self, value):\n        if self.bounds is None:\n            return value\n\n        if value <= self.bounds[0]:\n            value = self.bounds[0]\n        if value >= self.bounds[1]:\n            value = self.bounds[1]\n        return value",
  "def getName(self):\n        return self.varName",
  "def generateString(self, sim):\n        return str(self.generate(sim))",
  "def generateMagString(self):\n        return str(self.getDispersionMag())",
  "def __init__(self, varName, bounds=None):\n        SingleVariableDispersion.__init__(self, varName, bounds)\n        if self.bounds is None:\n            self.bounds = ([-1.0, 1.0])",
  "def generate(self, sim):\n        dispValue = random.uniform(self.bounds[0], self.bounds[1])\n\n        mid = (self.bounds[1] + self.bounds[0])/2.\n        scale = self.bounds[1] - mid\n        self.magnitude.append(str(round((dispValue - mid)/scale*100,2)) + \" %\")\n        return dispValue",
  "def __init__(self, varName, mean=0.0, stdDeviation=0.5, bounds=None):\n        SingleVariableDispersion.__init__(self, varName, bounds)\n        self.mean = mean\n        self.stdDeviation = stdDeviation",
  "def generate(self, sim):\n        dispValue = random.gauss(self.mean, self.stdDeviation)\n        if self.bounds is not None:\n            dispValue = self.checkBounds(dispValue)\n        if self.stdDeviation !=0 :\n            self.magnitude.append(str(round((dispValue - self.mean)/self.stdDeviation,2)) + \" sigma\")\n        return dispValue",
  "def __init__(self, varName, bounds):\n        self.varName = varName\n        self.bounds = bounds\n        self.magnitude = []\n        return",
  "def generate(self, sim=None):\n        pass",
  "def getDispersionMag(self):\n        return self.magnitude",
  "def perturbVectorByAngle(self, vector, angle):\n        rndVec = np.random.random(3)\n        if np.dot(rndVec, vector) > 0.95:\n            rndVec[0] *= -1\n        eigenAxis = np.cross(vector, rndVec)\n        thrusterMisalignDCM = self.eigAxisAndAngleToDCM(eigenAxis, angle)\n        self.magnitude.append(str(round(np.arccos(np.dot(rndVec, vector)/np.linalg.norm(rndVec)/np.linalg.norm(vector))*180./np.pi,2)) + \" deg\")\n        return np.dot(thrusterMisalignDCM, vector)",
  "def perturbCartesianVectorUniform(self, vector):\n        dispValues = np.zeros(3)\n        for i in range(len(vector)):\n            dispValues[i] = random.uniform(self.bounds[0], self.bounds[1])\n            mid = (self.bounds[1] + self.bounds[0])\n            scale = self.bounds[1] - mid\n            self.magnitude.append(str(round((dispValues[i] - mid)/scale*100,2)) + \" %\")\n        return dispValues",
  "def perturbCartesianVectorNormal(self, vector):\n        dispValues = np.zeros(3)\n        for i in range(len(vector)):\n            dispValues[i] = random.gauss(self.mean, self.stdDeviation)\n            if self.stdDeviation != 0 :\n                self.magnitude.append(str(round((dispValues[i] - self.mean)/self.stdDeviation,2)) + r\" $\\sigma$\")\n        return dispValues",
  "def cart2Spherical(self, cartVector):\n        # Spherical Coordinate Set: [rho, theta, phi]\n        x = cartVector[0]\n        y = cartVector[1]\n        z = cartVector[2]\n\n        rho = np.linalg.norm(cartVector)\n        phi = np.arctan2(y, x)[0]\n        theta = np.arccos(z)[0]\n\n        return [rho, phi, theta]",
  "def spherical2Cart(self, spherVec):\n        rho = spherVec[0]\n        phi = spherVec[1]\n        theta = spherVec[2]\n\n        x = rho * np.sin(theta) * np.cos(phi)\n        y = rho * np.sin(theta) * np.sin(phi)\n        z = rho * np.cos(theta)\n\n        return [x,y,z]",
  "def eigAxisAndAngleToDCM(axis, angle):\n        axis = axis / np.linalg.norm(axis)\n        sigma = 1 - np.cos(angle)\n        dcm = np.zeros((3, 3))\n        dcm[0, 0] = axis[0] ** 2 * sigma + np.cos(angle)\n        dcm[0, 1] = axis[0] * axis[1] * sigma + axis[2] * np.sin(angle)\n        dcm[0, 2] = axis[0] * axis[2] * sigma - axis[1] * np.sin(angle)\n        dcm[1, 0] = axis[1] * axis[0] * sigma - axis[2] * np.sin(angle)\n        dcm[1, 1] = axis[1] ** 2 * sigma + np.cos(angle)\n        dcm[1, 2] = axis[1] * axis[2] * sigma + axis[0] * np.sin(angle)\n        dcm[2, 0] = axis[2] * axis[0] * sigma + axis[1] * np.sin(angle)\n        dcm[2, 1] = axis[2] * axis[1] * sigma - axis[0] * np.sin(angle)\n        dcm[2, 2] = axis[2] ** 2 * sigma + np.cos(angle)\n        return dcm",
  "def checkBounds(value, bounds):\n        if value < bounds[0]:\n            value = bounds[0]\n        if value > bounds[1]:\n            value = bounds[1]\n        return value",
  "def generateString(self, sim):\n        # TODO does this actually behave differently then str(nextValue)?\n        nextValue = self.generate(sim)\n        val = '['\n        for i in range(3):\n            val += str(nextValue[i]) + ','\n        val = val[0:-1] + ']'\n        return val",
  "def generateMagString(self):\n        nextValue = self.getDispersionMag()\n        val = '['\n        for i in range(len(self.magnitude)):\n            val += str(nextValue[i]) + ','\n        val = val[0:-1] + ']'\n        return val",
  "def getName(self):\n        return self.varName",
  "def __init__(self, varName, bounds=None):\n        VectorVariableDispersion.__init__(self, varName, bounds)\n        if self.bounds is None:\n            self.bounds = ([-1.0, 1.0])",
  "def generate(self, sim):\n        vector = eval('sim.' + self.varName)\n        dispValue = self.perturbCartesianVectorUniform(vector)\n        return dispValue",
  "def __init__(self, varName, mean=0.0, stdDeviation=0.5, bounds=None):\n        VectorVariableDispersion.__init__(self, varName, bounds)\n        if self.bounds is None:\n            self.bounds = ([-1.0, 1.0])",
  "def generate(self, sim):\n        vector = eval('sim.' + self.varName)\n        dispValue = self.perturbCartesianVectorNormal(vector, self.mean, self.stdDeviation)\n        return dispValue",
  "def __init__(self, varName, phiBoundsOffNom=None, thetaBoundsOffNom=None):\n        super(UniformVectorAngleDispersion, self).__init__(varName, None)\n        # @TODO these bounds are not currently being applied to the generated values\n\n        self.phiBoundsOffNom = phiBoundsOffNom\n        self.thetaBoundsOffNom = thetaBoundsOffNom\n\n        if phiBoundsOffNom is None:\n            self.phiBoundsOffNom = [-np.pi / 2, np.pi / 2]\n        if thetaBoundsOffNom is None:\n            self.thetaBoundsOffNom = [-np.pi, np.pi]\n\n        self.magnitude = []",
  "def generate(self, sim=None):\n        # Note this dispersion is applied off of the nominal\n        vectorCart = eval('sim.' + self.varName)\n        vectorCart = vectorCart/np.linalg.norm(vectorCart)\n        vectorSphere = self.cart2Spherical(vectorCart)\n\n        meanPhi = vectorSphere[1] # Nominal phi\n        meanTheta = vectorSphere[2] #Nominal theta\n\n        self.phiBounds = [meanPhi + self.phiBoundsOffNom[0], meanPhi + self.phiBoundsOffNom[1]]\n        self.thetaBounds = [meanTheta + self.thetaBoundsOffNom[0],  meanTheta + self.thetaBoundsOffNom[1]]\n\n        phiRnd = np.random.uniform(meanPhi+self.phiBounds[0], meanPhi+self.phiBounds[1])\n        thetaRnd = np.random.uniform(meanTheta+self.thetaBounds[0], meanTheta+self.thetaBounds[1])\n\n        phiRnd = self.checkBounds(phiRnd, self.phiBounds)\n        thetaRnd = self.checkBounds(thetaRnd, self.thetaBounds)\n\n        newVec = self.spherical2Cart([1.0, phiRnd, thetaRnd])\n        dispVec = newVec/np.linalg.norm(newVec) # Shouldn't technically need the normalization but doing it for completeness\n\n        midPhi = (self.phiBounds[1] + self.phiBounds[0])/2.\n        scalePhi = self.phiBounds[1] - midPhi\n        midTheta = (self.thetaBounds[1] + self.thetaBounds[0])/2.\n        scaleTheta = self.thetaBounds[1] - midTheta\n        self.magnitude.append(str(round((phiRnd - midPhi)/scalePhi*100,2)) + \" %\")\n        self.magnitude.append(str(round((thetaRnd - midTheta)/scaleTheta*100,2)) + \" %\")\n\n        return dispVec",
  "def __init__(self, varName, thetaStd = np.pi/3.0, phiStd=np.pi/3.0, thetaBoundsOffNom=None, phiBoundsOffNom=None):\n        super(NormalVectorAngleDispersion, self).__init__(varName, None)\n        # @TODO these bounds are not currently being applied to the generated values\n\n        self.thetaStd = thetaStd\n        self.phiStd = phiStd\n\n        self.phiBoundsOffNom = phiBoundsOffNom\n        self.thetaBoundsOffNom = thetaBoundsOffNom\n\n        if phiBoundsOffNom is None:\n            self.phiBoundsOffNom = [-np.pi/2, np.pi/2]\n        if thetaBoundsOffNom is None:\n            self.thetaBoundsOffNom = [-np.pi, np.pi]\n\n        self.magnitude = []",
  "def generate(self, sim=None):\n        vectorCart = eval('sim.' + self.varName)\n        vectorCart = vectorCart/np.linalg.norm(vectorCart)\n        vectorSphere = self.cart2Spherical(vectorCart)\n\n        meanPhi = vectorSphere[1] # Nominal phi\n        meanTheta = vectorSphere[2] # Nominal theta\n\n        phiRnd = np.random.normal(meanPhi, self.phiStd, 1)\n        thetaRnd = np.random.normal(meanTheta, self.thetaStd, 1)\n\n        self.phiBounds = [meanPhi + self.phiBoundsOffNom[0], meanPhi + self.phiBoundsOffNom[1]]\n        self.thetaBounds = [meanTheta + self.thetaBoundsOffNom[0],  meanTheta + self.thetaBoundsOffNom[1]]\n\n        phiRnd = self.checkBounds(phiRnd, self.phiBounds)\n        thetaRnd = self.checkBounds(thetaRnd, self.thetaBounds)\n\n        newVec = self.spherical2Cart([1.0, phiRnd, thetaRnd])\n        dispVec = newVec/np.linalg.norm(newVec) # Shouldn't technically need the normalization but doing it for completeness\n\n        self.magnitude.append(str(round((phiRnd - meanPhi) / self.phiStd, 2)) + r\" $\\sigma$\")\n        self.magnitude.append(str(round((thetaRnd - meanTheta) / self.thetaStd, 2)) + r\" $\\sigma$\")\n\n        return dispVec",
  "def __init__(self, varName, bounds=None):\n        \"\"\"\n        Args:\n            varName (str): A string representation of the variable to be dispersed\n                e.g. 'VehDynObject.AttitudeInit'.\n            bounds (Array[float, float]): defines lower and upper cut offs for generated dispersion values radians.\n        \"\"\"\n        super(UniformEulerAngleMRPDispersion, self).__init__(varName, bounds)\n        if self.bounds is None:\n            self.bounds = ([0, 2 * np.pi])\n        self.magnitude = []",
  "def generate(self, sim=None):\n        rndAngles = np.zeros((3, 1))\n        for i in range(3):\n            rndAngles[i] = (self.bounds[1] - self.bounds[0]) * np.random.random() + self.bounds[0]\n        dispMRP = rbk.euler3232MRP(rndAngles)\n        dispMRP = dispMRP.reshape(3)\n        for i in range(3):\n            self.magnitude.append(str(round((dispMRP[i] - np.pi)/np.pi*100,2))+ \" %\")\n        return dispMRP",
  "def __init__(self, varName, thrusterIndex=0, phiStd=0.1745, bounds=None):\n        \"\"\"\n        Args:\n            varName (str): A string representation of the variable to be dispersed\n                e.g. 'ACSThrusterDynObject.ThrusterData[0].thrusterDirectionDisp'.\n            thrusterIndex (int): The index of the thruster to be used in array references.\n            phiStd (float): The 1 sigma standard deviation of the dispersion angle in radians.\n            bounds (Array[float, float]): defines lower and upper cut offs for generated dispersion values.\n        \"\"\"\n        super(NormalThrusterUnitDirectionVectorDispersion, self).__init__(varName, bounds)\n        self.varNameComponents = self.varName.split(\".\")\n        self.phiStd = phiStd  # (rad) angular standard deviation\n        # Limit dispersion to a hemisphere around the vector being dispersed\n        # if self.bounds is None:\n        #     self.bounds = ([-np.pi/2, np.pi/2])\n        self.thrusterIndex = thrusterIndex\n        self.magnitude = []",
  "def getName(self):\n        return '.'.join(self.varNameComponents[0:-1]) + '.thrDir_B'",
  "def generateString(self, sim):\n        # TODO does this actually behave differently then str(nextValue)?\n        nextValue = self.generate(sim)\n\n        val = '['\n        for i in range(3):\n            val += str(nextValue[i])\n            if (i < 2):\n                val += ', '\n        val += ']'\n\n        return val",
  "def generateMagString(self):\n        nextValue = self.getDispersionMag()\n\n        val = '['\n        for i in range(len(self.magnitude)):\n            val += str(nextValue[i])\n            val += ', '\n        val += ']'\n\n        return val",
  "def generate(self, sim=None):\n        if sim is None:\n            print((\"No simulation object parameter set in '\" + self.generate.__name__\n                  + \"()' dispersions will not be set for variable \" + self.varName))\n            return\n        else:\n            separator = '.'\n            thrusterObject = getattr(sim, self.varNameComponents[0])\n            totalVar = separator.join(self.varNameComponents[0:-1])\n            dirVec = eval('sim.' + totalVar + '.thrDir_B')\n            angle = np.random.normal(0, self.phiStd, 1)\n            dirVec = np.array(dirVec).reshape(3).tolist()\n            dispVec = self.perturbVectorByAngle(dirVec, angle)\n            angleDisp = np.arccos(np.dot(dirVec, dispVec)/np.linalg.norm(dirVec)/np.linalg.norm(dispVec))\n            self.magnitude.append(str(round(angleDisp / self.phiStd,2)) + \" sigma\")\n        return dispVec",
  "def __init__(self, varName, bounds=None):\n        super(UniformVectorCartDispersion, self).__init__(varName, bounds)\n        if self.bounds is None:\n            self.bounds = ([-1.0, 1.0])\n        self.magnitude = []",
  "def generate(self, sim=None):\n        dispVec = []\n        for i in range(3):\n            rnd = random.uniform(self.bounds[0], self.bounds[1])\n            rnd = self.checkBounds(rnd, self.bounds)\n            for i in range(3):\n                mid = (self.bounds[1] + self.bounds[0])/2.\n                scale = self.bounds[1] - mid\n                self.magnitude.append(str(round((rnd - mid) / scale * 100,2))+ \" %\")\n            dispVec.append(rnd)\n        return dispVec",
  "def __init__(self, varName, mean=0.0, stdDeviation=0.0, bounds=None):\n        super(NormalVectorCartDispersion, self).__init__(varName, bounds)\n        self.mean = mean\n        self.stdDeviation = stdDeviation\n        self.magnitude = []",
  "def generate(self, sim=None):\n        dispVec = []\n        for i in range(3):\n            if isinstance(self.stdDeviation, collections.abc.Sequence):\n                rnd = random.gauss(self.mean[i], self.stdDeviation[i])\n                if self.stdDeviation[i] != 0:\n                    self.magnitude.append(str(round((rnd - self.mean[i])/self.stdDeviation[i],2)) + \" sigma\")\n            else:\n                rnd = random.gauss(self.mean, self.stdDeviation)\n                if self.stdDeviation != 0:\n                    self.magnitude.append(str(round((rnd - self.mean) / self.stdDeviation,2)) + \" sigma\")\n            if self.bounds is not None:\n                rnd = self.checkBounds(rnd, self.bounds)\n            dispVec.append(rnd)\n\n        return dispVec",
  "def __init__(self, varName, stdDiag=None, boundsDiag=None, stdAngle=None):\n        \"\"\"\n        Args:\n            varName (str): A string representation of the variable to be dispersed\n                e.g. 'LocalConfigData.I'.\n            stdDeviation (float): The 1 sigma standard deviation of the diagonal element dispersions in kg*m^2.\n            bounds (Array[float, float]): defines lower and upper cut offs for generated dispersion values kg*m^2.\n        \"\"\"\n        self.varName = varName\n        self.varNameComponents = self.varName.split(\".\")\n        self.stdDiag = stdDiag\n        self.stdAngle = stdAngle\n        self.bounds = boundsDiag\n        self.magnitude = []\n        if self.stdDiag is None:\n            self.stdDiag = 1.0\n        if self.bounds is None:\n            self.bounds = ([-1.0, 1.0])\n        if self.stdAngle is None:\n            self.stdAngle = 0.0",
  "def generate(self, sim=None):\n        if sim is None:\n            print((\"No simulation object parameter set in '\" + self.generate.__name__\n                  + \"()' dispersions will not be set for variable \" + self.varName))\n            return\n        else:\n            vehDynObject = getattr(sim, self.varNameComponents[0])\n            I = np.array(eval('sim.' + self.varName)).reshape(3, 3)\n\n            # generate random values for the diagonals\n            temp = []\n            for i in range(3):\n                rnd = random.gauss(0, self.stdDiag)\n                rnd = self.checkBounds(rnd)\n                temp.append(rnd)\n                if self.stdDiag != 0:\n                    self.magnitude.append(str(round(rnd/self.stdDiag,2)) + \" sigma\")\n            dispIdentityMatrix = np.identity(3) * temp\n            # generate random values for the similarity transform to produce off-diagonal terms\n            angles = np.random.normal(0, self.stdAngle, 3)\n            for i in range(3):\n                if self.stdAngle != 0:\n                    self.magnitude.append(str(round(angles[i] / self.stdAngle,2)) + \" sigma\")\n            disp321Matrix = rbk.euler3212C(angles)\n\n            # disperse the diagonal elements\n            dispI = I + dispIdentityMatrix\n            # disperse the off diagonals with a slight similarity transform of the inertia tensor\n            dispI = np.dot(np.dot(disp321Matrix, dispI), disp321Matrix.T)\n\n        return dispI",
  "def getDispersionMag(self):\n        return self.magnitude",
  "def checkBounds(self, value):\n        if value < self.bounds[0]:\n            value = self.bounds[0]\n        if value > self.bounds[1]:\n            value = self.bounds[1]\n        return value",
  "def generateString(self, sim):\n        nextValue = self.generate(sim)\n        # TODO does this actually behave differently then str(nextValue)?\n        val = '['\n        for i in range(3):\n            val += '[' + str(nextValue[i][0]) + ', ' \\\n                + str(nextValue[i][1]) + ', ' \\\n                + str(nextValue[i][2]) + ']'\n            if i != 2:\n                val += ','\n        val = val[0:] + ']'\n        return val",
  "def generateMagString(self):\n        nextValue = self.getDispersionMag()\n        val = '['\n        for i in range(len(self.magnitude)):\n            val += str(nextValue[i]) + ','\n        val = val[0:-1] + ']'\n        return val",
  "def getName(self):\n        return self.varName",
  "def __init__(self, varName1, varName2, dispDict):\n        \"\"\"\n        A function that disperses position and velocity of the spacecraft using orbital elements as a dispersion metric.\n        Args:\n            varName1 (str): A string representation of the position variable to be dispersed\n            varName2 (str): A string representation of the velocity variable to be dispersed\n            dispDict (dict): A dictionnary containing the dispersions for each of the orbital elements. The values are lists\n            with first element 'normal' or 'uniform' followed by mean, std or lower bound, upper bound respectively. If no dispersion\n            is added for a specific orbital elemenet, None should be the values for the corresponding key\n        \"\"\"\n        self.numberOfSubDisps = 2\n        self.varName1 = varName1\n        self.varName1Components = self.varName1.split(\".\")\n        self.varName2 = varName2\n        self.varName2Components = self.varName2.split(\".\")\n        self.oeDict = dispDict",
  "def generate(self, sim=None):\n        elems = orbitalMotion.ClassicElements\n        for key in self.oeDict.keys():\n            if self.oeDict[key] is not None and key != \"mu\":\n                exec(\"elems.\"+ key + \" = np.random.\" + self.oeDict[key][0] + \"(\" +  str(self.oeDict[key][1]) + ', ' +  str(self.oeDict[key][2]) + \")\")\n            else:\n                if key != \"mu\":\n                    exec(\"elems.\" + key + \" = 0.\")\n        if elems.e < 0:\n            elems.e = 0\n        r, v =orbitalMotion.elem2rv_parab( self.oeDict[\"mu\"], elems)\n\n        self.dispR = r\n        self.dispV = v",
  "def generateString(self, index, sim=None):\n        if index == 1:\n            nextValue = self.dispR\n        if index == 2:\n            nextValue = self.dispV\n        val = '['\n        for i in range(3):\n            val += str(nextValue[i]) + ','\n        val = val[0:-1] + ']'\n        return val",
  "def getName(self, index):\n        if index == 1:\n            return self.varName1\n        if index == 2:\n            return self.varName2",
  "def __init__(self, varName, bounds=None):\n        \"\"\"\n        A function that disperses MRPs with specfic bounds per axis.\n        Args:\n            varName (str): A string representation of the variable to be dispersed\n                e.g. 'VehDynObject.AttitudeInit'.\n            bounds (list(Array[float, float],Array[float, float],Array[float, float])): defines lower and upper cut offs for generated dispersion values radians.\n        \"\"\"\n        super(MRPDispersionPerAxis, self).__init__(varName, bounds)\n        if self.bounds is None:\n            self.bounds = [[0, 2 * np.pi], [0, 2 * np.pi], [0, 2 * np.pi]]",
  "def generate(self, sim=None):\n        rndAngles = np.zeros((3, 1))\n        for i in range(3):\n            rndAngles[i] = (self.bounds[i][1] - self.bounds[i][0]) * np.random.random() + self.bounds[i][0]\n        dispMRP = rndAngles.reshape(3)\n        return dispMRP",
  "class mcAnalysisBaseClass:\n    def __init__(self):\n        self.variableName = \"\"\n        self.variableDim = 0\n        self.dataDir = \"\"\n        self.numExtrema = 0\n        self.extremaRuns = []\n        self.timeWindow = []\n        self.data = None\n\n    def pull_and_format_df(path, varIdxLen):\n        df = pd.read_pickle(path)\n        if len(np.unique(df.columns.codes[1])) is not varIdxLen:\n            print(\"Warning: \" + path + \" not formatted correctly!\")\n            newMultIndex = pd.MultiIndex.from_product([df.columns.codes[0], range(varIdxLen)],\n                                                      names=['runNum', 'varIdx'])\n            indices = pd.Index([0, 1])  # Need multiple rows for curves\n            df = df.reindex(columns=newMultIndex, index=indices)\n        return df\n\n    def getNominalRunIndices(self, maxNumber=50):\n        \"\"\"\n        Find the specific MC run indices of the most nominal cases (by iteratively widdling away runs which\n        have the largest std)\n\n        :param maxNumber: the number of nominal runs to widdle down to.\n        :return: list of run indices\n        \"\"\"\n        if self.data is None:\n            self.data = pd.read_pickle(self.dataDir + \"/\" + self.variableName + \".data\")\n\n        dataBar = self.data[np.abs(self.data - self.data.mean()) < 0.5 * self.data.std()]\n        i = 5\n        while len(dataBar.columns.codes[0]) > maxNumber * self.variableDim:\n            i += 1\n            cols_to_delete = dataBar.columns[dataBar.isnull().sum() / len(dataBar) > 1. / np.sqrt(i)]\n            dataBar.drop(cols_to_delete, axis=1, inplace=True)\n\n        print(\"Nominal runs are \", list(dict.fromkeys(dataBar.columns.codes[0].tolist())))\n        return dataBar.columns.codes[0]\n\n    def getExtremaRunIndices(self, numExtrema, window):\n        \"\"\"\n        Determine the MC run indices of the most deviant values within a particular time window\n\n        :param numExtrema: number of extreme runs to collect\n        :param window: window of time to search for the extremes in\n        :return: list of run indices\n        \"\"\"\n        if self.data is None:\n            self.data = pd.read_pickle(self.dataDir + \"/\" + self.variableName + \".data\")\n        times = self.data.index.tolist()\n\n        # Find the closest indices to the time window requested\n        indStart = min(range(len(times)), key=lambda i: abs(times[i] - window[0]))\n        indEnd = min(range(len(times)), key=lambda i: abs(times[i] - window[1]))\n        self.timeWindow = [indStart, indEnd]\n\n        # Find outliers based on largest deviation off of the mean\n        self.mean = self.data.mean(axis=1, level=1)\n        self.diff = self.data.subtract(self.mean)\n        self.diff = self.diff.abs()\n        self.diff = self.diff.iloc[indStart:indEnd].max(axis=0)\n        self.extremaRuns = self.diff.nlargest(numExtrema).index._codes[0]\n        print(\"Extreme runs are \", list(dict.fromkeys(self.extremaRuns.tolist())))\n        return self.extremaRuns\n\n    def generateStatCurves(self):\n        \"\"\"\n        Generate curves that represent the mean, median, and standard deviation of a particular variable.\n        Not Tested.\n        \"\"\"\n        if self.data is None:\n            self.data = pd.read_pickle(self.dataDir + \"/\" + self.variableName + \".data\")\n\n        idx = pd.IndexSlice\n        self.runs, self.varNum = self.data.columns.values[-1]\n        self.runs += 1\n        self.varNum += 1\n        axesMean = []\n        axesMedian = []\n        axesStd = []\n        for j in range(self.varNum):\n            axisMean = self.data.loc[idx[:], idx[:, j]].mean(axis=1)\n            axisMedian = self.data.loc[idx[:], idx[:, j]].median(axis=1)\n            axisStd = self.data.loc[idx[:], idx[:, j]].std(axis=1)\n            axesMean.append(axisMean)\n            axesMedian.append(axisMedian)\n            axesStd.append(axisStd)\n\n        meanRun = pd.concat(axesMean, axis=1)\n        medianRun = pd.concat(axesMedian, axis=1)\n        stdRun = pd.concat(axesStd, axis=1)\n\n        return [meanRun, medianRun, stdRun]\n\n    def generateStatPlots(self):\n        \"\"\"\n        Generate plots for the mean, median, and mode.\n        Not Tested.\n        :return: list of stats plots\n        \"\"\"\n        if self.data is None:\n            self.data = self.pull_and_format_df(self.dataDir + \"/\" + self.variableName + \".data\", self.variableDim)\n\n        meanRun, medianRun, stdRun = self.generateStatCurves()\n        varIdxList = range(self.variableDim)\n        varIdxListStr = str(varIdxList)\n\n        meanRun.columns = pd.MultiIndex.from_product([['mean'], [0,1,2]], names=[\"stats\", \"varIdx\"])\n        medianRun.columns = pd.MultiIndex.from_product([['median'], [0,1,2]], names=[\"stats\", \"varIdx\"])\n        stdRun.columns = pd.MultiIndex.from_product([['std'], [0,1,2]], names=[\"stats\", \"varIdx\"])\n\n        meanRun_plot = DS_Plot(meanRun, title=\"Mean Plot: \" + self.variableName,\n                                            xAxisLabel='time[s]', yAxisLabel= self.variableName.split('.')[-1],\n                                            macro_x=macros.NANO2SEC,\n                                            labels=['1', '2', '3'],\n                                            plotFcn=curve_per_df_component)\n\n        medRun_plot = DS_Plot(medianRun, title=\"Median Plot: \" + self.variableName,\n                                            xAxisLabel='time[s]', yAxisLabel= self.variableName.split('.')[-1],\n                                            macro_x=macros.NANO2SEC,\n                                            labels=['1', '2', '3'],\n                                            plotFcn=curve_per_df_component)\n\n        stdRun_plot = DS_Plot(stdRun, title=\"Standard Dev Plot: \" + self.variableName,\n                                            xAxisLabel='time[s]', yAxisLabel= self.variableName.split('.')[-1],\n                                            macro_x=macros.NANO2SEC,\n                                            labels=['1', '2', '3'],\n                                            plotFcn=curve_per_df_component)\n\n        statRun_plots = []\n        statRun_plots.append(meanRun_plot)\n        statRun_plots.append(medRun_plot)\n        statRun_plots.append(stdRun_plot)\n\n        return statRun_plots\n\n    def extractSubsetOfRuns(self, runIdx):\n        \"\"\"\n        Create a separate folder in the data directory that contains the subset of data the user is looking to plot.\n        If the ``/subset/`` directory already exists, check if it contains the data for the runs requested, if so skip.\n\n        :param runIdx: list of run indices to extract\n        :return: nothing\n        \"\"\"\n        idx = pd.IndexSlice\n        baseDir = self.dataDir\n\n        # check if a subset directory exists, and if it already contains all runIdx requested\n        if not os.path.exists(baseDir + \"/subset/\"):\n            os.mkdir(baseDir + \"/subset/\")\n        else:\n            filePaths = glob.glob(baseDir + \"/subset\" + \"/*.data\")\n            for filePath in filePaths:\n                if \"MonteCarlo.data\" in filePath:\n                    continue\n                if \"run\" in filePath and \"overrun\" not in filePath:\n                    continue\n                df = pd.read_pickle(filePath)\n                singleton = list(dict.fromkeys(np.array(df.columns.codes[0]).tolist()))\n                singletonRuns = list(dict.fromkeys(np.sort(np.array(runIdx)).tolist()))\n                if len(singleton) == len(singletonRuns):\n                    if singletonRuns == singleton:\n                        print(\"Subset directory already contains runIdx values. Skipping extraction\")\n                        return\n                    else:\n                        break\n\n        # If no data in subset (or the wrong data), extract and save the right data.\n        print(\"Populating Subset Directory with Dataframes for runs: \" + str(runIdx))\n        # shutil.rmtree(dataDir + \"/subset/\")\n        filePaths = glob.glob(baseDir + \"/*.data\")\n        for filePath in filePaths:\n            if \"MonteCarlo.data\" in filePath:\n                continue\n            if \"run\" in filePath and \"overrun\" not in filePath:\n                continue\n            df = pd.read_pickle(filePath)\n            dfSubSet = df.loc[idx[:], idx[runIdx, :]]\n            varName = filePath.rsplit(\"/\")\n            pd.to_pickle(dfSubSet, baseDir + \"/subset/\" + varName[-1])\n        print(\"Finished Populating Subset Directory\")\n\n    def renderPlots(self, plotList):\n        \"\"\"\n        Render all plots in plotList and print information about time taken, percent complete, which plot, etc.\n\n        :param plotList: List of plots to render\n        :return: nothing.\n        \"\"\"\n        hv.extension('bokeh')\n        renderer = hv.renderer('bokeh').instance(mode='server')\n\n        if self.save_as_static:\n            print(\"Note: You requested to save static plots. This means no interactive python session will be generated.\")\n        print(\"Beginning the plotting\")\n\n        if not os.path.exists(self.dataDir + self.staticDir):\n            os.mkdir(self.dataDir + self.staticDir)\n\n        for i in range(len(plotList)):\n            startTime = time.time()\n            image, title = plotList[i].generateImage()\n            try:\n                if self.save_as_static:\n                    # Save .html files of each of the plots into the static directory\n                    hv.save(image, self.dataDir + self.staticDir + \"/\" + title + \".html\")\n                else:\n                    renderer.server_doc(image)\n                # Print information about the rendering process\n                print(\"LOADED: \" + title +\"\\t\\t\\t\" +\n                      \"Percent Complete: \" + str(round((i + 1) / len(plotList) * 100, 2)) + \"% \\t\\t\\t\"\n                      \"Time Elapsed: \" + str( round(time.time() - startTime)) + \" [s]\")\n            except Exception as e:\n                print(\"Couldn't Plot \" + title)\n                print(e)",
  "def __init__(self):\n        self.variableName = \"\"\n        self.variableDim = 0\n        self.dataDir = \"\"\n        self.numExtrema = 0\n        self.extremaRuns = []\n        self.timeWindow = []\n        self.data = None",
  "def pull_and_format_df(path, varIdxLen):\n        df = pd.read_pickle(path)\n        if len(np.unique(df.columns.codes[1])) is not varIdxLen:\n            print(\"Warning: \" + path + \" not formatted correctly!\")\n            newMultIndex = pd.MultiIndex.from_product([df.columns.codes[0], range(varIdxLen)],\n                                                      names=['runNum', 'varIdx'])\n            indices = pd.Index([0, 1])  # Need multiple rows for curves\n            df = df.reindex(columns=newMultIndex, index=indices)\n        return df",
  "def getNominalRunIndices(self, maxNumber=50):\n        \"\"\"\n        Find the specific MC run indices of the most nominal cases (by iteratively widdling away runs which\n        have the largest std)\n\n        :param maxNumber: the number of nominal runs to widdle down to.\n        :return: list of run indices\n        \"\"\"\n        if self.data is None:\n            self.data = pd.read_pickle(self.dataDir + \"/\" + self.variableName + \".data\")\n\n        dataBar = self.data[np.abs(self.data - self.data.mean()) < 0.5 * self.data.std()]\n        i = 5\n        while len(dataBar.columns.codes[0]) > maxNumber * self.variableDim:\n            i += 1\n            cols_to_delete = dataBar.columns[dataBar.isnull().sum() / len(dataBar) > 1. / np.sqrt(i)]\n            dataBar.drop(cols_to_delete, axis=1, inplace=True)\n\n        print(\"Nominal runs are \", list(dict.fromkeys(dataBar.columns.codes[0].tolist())))\n        return dataBar.columns.codes[0]",
  "def getExtremaRunIndices(self, numExtrema, window):\n        \"\"\"\n        Determine the MC run indices of the most deviant values within a particular time window\n\n        :param numExtrema: number of extreme runs to collect\n        :param window: window of time to search for the extremes in\n        :return: list of run indices\n        \"\"\"\n        if self.data is None:\n            self.data = pd.read_pickle(self.dataDir + \"/\" + self.variableName + \".data\")\n        times = self.data.index.tolist()\n\n        # Find the closest indices to the time window requested\n        indStart = min(range(len(times)), key=lambda i: abs(times[i] - window[0]))\n        indEnd = min(range(len(times)), key=lambda i: abs(times[i] - window[1]))\n        self.timeWindow = [indStart, indEnd]\n\n        # Find outliers based on largest deviation off of the mean\n        self.mean = self.data.mean(axis=1, level=1)\n        self.diff = self.data.subtract(self.mean)\n        self.diff = self.diff.abs()\n        self.diff = self.diff.iloc[indStart:indEnd].max(axis=0)\n        self.extremaRuns = self.diff.nlargest(numExtrema).index._codes[0]\n        print(\"Extreme runs are \", list(dict.fromkeys(self.extremaRuns.tolist())))\n        return self.extremaRuns",
  "def generateStatCurves(self):\n        \"\"\"\n        Generate curves that represent the mean, median, and standard deviation of a particular variable.\n        Not Tested.\n        \"\"\"\n        if self.data is None:\n            self.data = pd.read_pickle(self.dataDir + \"/\" + self.variableName + \".data\")\n\n        idx = pd.IndexSlice\n        self.runs, self.varNum = self.data.columns.values[-1]\n        self.runs += 1\n        self.varNum += 1\n        axesMean = []\n        axesMedian = []\n        axesStd = []\n        for j in range(self.varNum):\n            axisMean = self.data.loc[idx[:], idx[:, j]].mean(axis=1)\n            axisMedian = self.data.loc[idx[:], idx[:, j]].median(axis=1)\n            axisStd = self.data.loc[idx[:], idx[:, j]].std(axis=1)\n            axesMean.append(axisMean)\n            axesMedian.append(axisMedian)\n            axesStd.append(axisStd)\n\n        meanRun = pd.concat(axesMean, axis=1)\n        medianRun = pd.concat(axesMedian, axis=1)\n        stdRun = pd.concat(axesStd, axis=1)\n\n        return [meanRun, medianRun, stdRun]",
  "def generateStatPlots(self):\n        \"\"\"\n        Generate plots for the mean, median, and mode.\n        Not Tested.\n        :return: list of stats plots\n        \"\"\"\n        if self.data is None:\n            self.data = self.pull_and_format_df(self.dataDir + \"/\" + self.variableName + \".data\", self.variableDim)\n\n        meanRun, medianRun, stdRun = self.generateStatCurves()\n        varIdxList = range(self.variableDim)\n        varIdxListStr = str(varIdxList)\n\n        meanRun.columns = pd.MultiIndex.from_product([['mean'], [0,1,2]], names=[\"stats\", \"varIdx\"])\n        medianRun.columns = pd.MultiIndex.from_product([['median'], [0,1,2]], names=[\"stats\", \"varIdx\"])\n        stdRun.columns = pd.MultiIndex.from_product([['std'], [0,1,2]], names=[\"stats\", \"varIdx\"])\n\n        meanRun_plot = DS_Plot(meanRun, title=\"Mean Plot: \" + self.variableName,\n                                            xAxisLabel='time[s]', yAxisLabel= self.variableName.split('.')[-1],\n                                            macro_x=macros.NANO2SEC,\n                                            labels=['1', '2', '3'],\n                                            plotFcn=curve_per_df_component)\n\n        medRun_plot = DS_Plot(medianRun, title=\"Median Plot: \" + self.variableName,\n                                            xAxisLabel='time[s]', yAxisLabel= self.variableName.split('.')[-1],\n                                            macro_x=macros.NANO2SEC,\n                                            labels=['1', '2', '3'],\n                                            plotFcn=curve_per_df_component)\n\n        stdRun_plot = DS_Plot(stdRun, title=\"Standard Dev Plot: \" + self.variableName,\n                                            xAxisLabel='time[s]', yAxisLabel= self.variableName.split('.')[-1],\n                                            macro_x=macros.NANO2SEC,\n                                            labels=['1', '2', '3'],\n                                            plotFcn=curve_per_df_component)\n\n        statRun_plots = []\n        statRun_plots.append(meanRun_plot)\n        statRun_plots.append(medRun_plot)\n        statRun_plots.append(stdRun_plot)\n\n        return statRun_plots",
  "def extractSubsetOfRuns(self, runIdx):\n        \"\"\"\n        Create a separate folder in the data directory that contains the subset of data the user is looking to plot.\n        If the ``/subset/`` directory already exists, check if it contains the data for the runs requested, if so skip.\n\n        :param runIdx: list of run indices to extract\n        :return: nothing\n        \"\"\"\n        idx = pd.IndexSlice\n        baseDir = self.dataDir\n\n        # check if a subset directory exists, and if it already contains all runIdx requested\n        if not os.path.exists(baseDir + \"/subset/\"):\n            os.mkdir(baseDir + \"/subset/\")\n        else:\n            filePaths = glob.glob(baseDir + \"/subset\" + \"/*.data\")\n            for filePath in filePaths:\n                if \"MonteCarlo.data\" in filePath:\n                    continue\n                if \"run\" in filePath and \"overrun\" not in filePath:\n                    continue\n                df = pd.read_pickle(filePath)\n                singleton = list(dict.fromkeys(np.array(df.columns.codes[0]).tolist()))\n                singletonRuns = list(dict.fromkeys(np.sort(np.array(runIdx)).tolist()))\n                if len(singleton) == len(singletonRuns):\n                    if singletonRuns == singleton:\n                        print(\"Subset directory already contains runIdx values. Skipping extraction\")\n                        return\n                    else:\n                        break\n\n        # If no data in subset (or the wrong data), extract and save the right data.\n        print(\"Populating Subset Directory with Dataframes for runs: \" + str(runIdx))\n        # shutil.rmtree(dataDir + \"/subset/\")\n        filePaths = glob.glob(baseDir + \"/*.data\")\n        for filePath in filePaths:\n            if \"MonteCarlo.data\" in filePath:\n                continue\n            if \"run\" in filePath and \"overrun\" not in filePath:\n                continue\n            df = pd.read_pickle(filePath)\n            dfSubSet = df.loc[idx[:], idx[runIdx, :]]\n            varName = filePath.rsplit(\"/\")\n            pd.to_pickle(dfSubSet, baseDir + \"/subset/\" + varName[-1])\n        print(\"Finished Populating Subset Directory\")",
  "def renderPlots(self, plotList):\n        \"\"\"\n        Render all plots in plotList and print information about time taken, percent complete, which plot, etc.\n\n        :param plotList: List of plots to render\n        :return: nothing.\n        \"\"\"\n        hv.extension('bokeh')\n        renderer = hv.renderer('bokeh').instance(mode='server')\n\n        if self.save_as_static:\n            print(\"Note: You requested to save static plots. This means no interactive python session will be generated.\")\n        print(\"Beginning the plotting\")\n\n        if not os.path.exists(self.dataDir + self.staticDir):\n            os.mkdir(self.dataDir + self.staticDir)\n\n        for i in range(len(plotList)):\n            startTime = time.time()\n            image, title = plotList[i].generateImage()\n            try:\n                if self.save_as_static:\n                    # Save .html files of each of the plots into the static directory\n                    hv.save(image, self.dataDir + self.staticDir + \"/\" + title + \".html\")\n                else:\n                    renderer.server_doc(image)\n                # Print information about the rendering process\n                print(\"LOADED: \" + title +\"\\t\\t\\t\" +\n                      \"Percent Complete: \" + str(round((i + 1) / len(plotList) * 100, 2)) + \"% \\t\\t\\t\"\n                      \"Time Elapsed: \" + str( round(time.time() - startTime)) + \" [s]\")\n            except Exception as e:\n                print(\"Couldn't Plot \" + title)\n                print(e)",
  "class VariableRetentionParameters:\n    \"\"\"\n    Represents a variable's logging parameters.\n    \"\"\"\n\n    def __init__(self, varName, varRate, startIndex=0, stopIndex=0, varType='double'):\n        self.varName = varName\n        self.varRate = varRate\n        self.startIndex = startIndex\n        self.stopIndex = stopIndex\n        self.varType = varType",
  "class MessageRetentionParameters:\n    \"\"\"\n    Represents a message's logging parameters.\n    Args:\n        name: name of the message recorder\n        retainedVars: the message variable to record\n    \"\"\"\n\n    def __init__(self, name, retainedVars):\n        self.msgRecName = name\n        self.retainedVars = retainedVars",
  "class RetentionPolicy:\n    \"\"\"\n    This policy controls what simulation data is saved and how it is stored.  Note that the simulation data\n    array will have the message time prepended as the first column.\n    \"\"\"\n\n    def __init__(self, rate=int(1E10)):\n        self.logRate = rate\n        self.messageLogList = []\n        self.varLogList = []\n        self.dataCallback = None\n        self.retentionFunctions = []\n\n    def addMessageLog(self, name, retainedVars):\n        self.messageLogList.append(MessageRetentionParameters(name, retainedVars))\n\n    def addVariableLog(self, variableName, startIndex=0, stopIndex=0, varType='double', logRate=None):\n        if logRate is None:\n            logRate = self.logRate\n        varContainer = VariableRetentionParameters(variableName, logRate, startIndex, stopIndex, varType)\n        self.varLogList.append(varContainer)\n\n    def addLogsToSim(self, simInstance):\n        for variable in self.varLogList:\n            simInstance.AddVariableForLogging(variable.varName, variable.varRate,\n                                              variable.startIndex, variable.stopIndex, variable.varType)\n\n    def addRetentionFunction(self, function):\n        self.retentionFunctions.append(function)\n\n    def setDataCallback(self, dataCallback):\n        self.dataCallback = dataCallback\n\n    def executeCallback(self, data):\n        if self.dataCallback is not None:\n            self.dataCallback(data, self)\n\n    @staticmethod\n    def addRetentionPoliciesToSim(simInstance, retentionPolicies):\n        \"\"\" Adds logs for variables and messages to a simInstance\n        Args:\n            simInstance: The simulation instance to add logs to.\n            retentionPolicies: RetentionPolicy[] list that defines the data to log.\n        \"\"\"\n\n        for retentionPolicy in retentionPolicies:\n            retentionPolicy.addLogsToSim(simInstance)\n\n        # TODO handle duplicates somehow?\n\n    @staticmethod\n    def getDataForRetention(simInstance, retentionPolicies):\n        \"\"\" Returns the data that should be retained given a simInstance and the retentionPolicies\n\n        Args:\n            simInstance: The simulation instance to retrieve data from\n            retentionPolicies: A list of RetentionPolicy objects defining the data to retain\n\n        Returns:\n            Retained Data in the form of a dictionary with two sub-dictionaries for messages and variables::\n\n                {\n                    \"messages\": {\n                        \"messageName\": [value1,value2,value3]\n                    },\n                    \"variables\": {\n                        \"variableName\": [value1,value2,value3]\n                    }\n                }\n        \"\"\"\n        data = {\"messages\": {}, \"variables\": {}, \"custom\": {}}\n        df = pd.DataFrame()\n        dataFrames = []\n        for retentionPolicy in retentionPolicies:\n            for msgParam in retentionPolicy.messageLogList:\n\n                # record the message recording times\n                msgTimes = simInstance.msgRecList[msgParam.msgRecName].times()\n\n                # record the message variables\n                for varName in msgParam.retainedVars:\n                    # To ensure the current datashaders utilities continue to work, the\n                    # retained data is combined with the time information as it was in\n                    # BSK1.x releases.\n                    msgData = getattr(simInstance.msgRecList[msgParam.msgRecName], varName)\n                    msgData = unitTestSupport.addTimeColumn(msgTimes, msgData)\n                    data[\"messages\"][msgParam.msgRecName + \".\" + varName] = msgData\n\n            for variable in retentionPolicy.varLogList:\n                data[\"variables\"][variable.varName] = simInstance.GetLogVariableData(variable.varName)\n\n            for func in retentionPolicy.retentionFunctions:\n                tmpModuleData = func(simInstance)\n                for (key, value) in tmpModuleData.items():\n                    data[\"custom\"][key] = value\n        return data",
  "def __init__(self, varName, varRate, startIndex=0, stopIndex=0, varType='double'):\n        self.varName = varName\n        self.varRate = varRate\n        self.startIndex = startIndex\n        self.stopIndex = stopIndex\n        self.varType = varType",
  "def __init__(self, name, retainedVars):\n        self.msgRecName = name\n        self.retainedVars = retainedVars",
  "def __init__(self, rate=int(1E10)):\n        self.logRate = rate\n        self.messageLogList = []\n        self.varLogList = []\n        self.dataCallback = None\n        self.retentionFunctions = []",
  "def addMessageLog(self, name, retainedVars):\n        self.messageLogList.append(MessageRetentionParameters(name, retainedVars))",
  "def addVariableLog(self, variableName, startIndex=0, stopIndex=0, varType='double', logRate=None):\n        if logRate is None:\n            logRate = self.logRate\n        varContainer = VariableRetentionParameters(variableName, logRate, startIndex, stopIndex, varType)\n        self.varLogList.append(varContainer)",
  "def addLogsToSim(self, simInstance):\n        for variable in self.varLogList:\n            simInstance.AddVariableForLogging(variable.varName, variable.varRate,\n                                              variable.startIndex, variable.stopIndex, variable.varType)",
  "def addRetentionFunction(self, function):\n        self.retentionFunctions.append(function)",
  "def setDataCallback(self, dataCallback):\n        self.dataCallback = dataCallback",
  "def executeCallback(self, data):\n        if self.dataCallback is not None:\n            self.dataCallback(data, self)",
  "def addRetentionPoliciesToSim(simInstance, retentionPolicies):\n        \"\"\" Adds logs for variables and messages to a simInstance\n        Args:\n            simInstance: The simulation instance to add logs to.\n            retentionPolicies: RetentionPolicy[] list that defines the data to log.\n        \"\"\"\n\n        for retentionPolicy in retentionPolicies:\n            retentionPolicy.addLogsToSim(simInstance)",
  "def getDataForRetention(simInstance, retentionPolicies):\n        \"\"\" Returns the data that should be retained given a simInstance and the retentionPolicies\n\n        Args:\n            simInstance: The simulation instance to retrieve data from\n            retentionPolicies: A list of RetentionPolicy objects defining the data to retain\n\n        Returns:\n            Retained Data in the form of a dictionary with two sub-dictionaries for messages and variables::\n\n                {\n                    \"messages\": {\n                        \"messageName\": [value1,value2,value3]\n                    },\n                    \"variables\": {\n                        \"variableName\": [value1,value2,value3]\n                    }\n                }\n        \"\"\"\n        data = {\"messages\": {}, \"variables\": {}, \"custom\": {}}\n        df = pd.DataFrame()\n        dataFrames = []\n        for retentionPolicy in retentionPolicies:\n            for msgParam in retentionPolicy.messageLogList:\n\n                # record the message recording times\n                msgTimes = simInstance.msgRecList[msgParam.msgRecName].times()\n\n                # record the message variables\n                for varName in msgParam.retainedVars:\n                    # To ensure the current datashaders utilities continue to work, the\n                    # retained data is combined with the time information as it was in\n                    # BSK1.x releases.\n                    msgData = getattr(simInstance.msgRecList[msgParam.msgRecName], varName)\n                    msgData = unitTestSupport.addTimeColumn(msgTimes, msgData)\n                    data[\"messages\"][msgParam.msgRecName + \".\" + varName] = msgData\n\n            for variable in retentionPolicy.varLogList:\n                data[\"variables\"][variable.varName] = simInstance.GetLogVariableData(variable.varName)\n\n            for func in retentionPolicy.retentionFunctions:\n                tmpModuleData = func(simInstance)\n                for (key, value) in tmpModuleData.items():\n                    data[\"custom\"][key] = value\n        return data",
  "class DataWriter(mp.Process):\n    \"\"\" Class to be launched as separate process to pull data from queue and write out to .csv dataFrames\n        Args:\n            q: queue object from multiprocessing.Manager.queue\n        Returns:\n            Nil\n    \"\"\"\n    def __init__(self, q):\n        super(DataWriter, self).__init__()\n        self._queue = q\n        self._endToken = None\n        self._varCast = None\n        self._logDir = \"\"\n        self._dataFiles = set()\n\n    def run(self):\n        \"\"\" The process run loop. Gets data from a queue and writes it out to per message csv files\n            Args:\n                Nil\n            Returns:\n                Nil\n        \"\"\"\n        while self._endToken is None:\n            data, mcSimIndex, self._endToken = self._queue.get()\n            print(\"Starting to log: \" + str(mcSimIndex))\n            if self._endToken:\n                continue\n            print(\"Logging Dataframes from run \" + str(mcSimIndex))\n            for dictName, dictData in data.items(): # Loops through Messages, Variables, Custom dictionaries in the retention policy\n                for itemName, itemData in dictData.items(): # Loop through all items and their data\n\n                    if itemName == \"OrbitalElements.Omega\": # Protects from OS that aren't case sensitive.\n                        itemName = \"OrbitalElements.Omega_Capital\"\n\n                    filePath = self._logDir + itemName + \".data\"\n                    self._dataFiles.add(filePath)\n\n                    # Is the data a vector, scalar, or non-existant?\n                    try:\n                        variLen = itemData[:,1:].shape[1]\n                    except:\n                        variLen = 0\n\n                    # Generate the MultiLabel\n                    outerLabel = [mcSimIndex]\n                    innerLabel = []\n\n                    for i in range(variLen):\n                        innerLabel.append(i)\n                    if variLen == 0:\n                        innerLabel.append(0) # May not be necessary, might be able to leave blank and get a None\n                    labels = pd.MultiIndex.from_product([outerLabel, innerLabel], names=[\"runNum\", \"varIdx\"])\n\n                    # Generate the individual run's dataframe\n                    if variLen >= 2:\n                        df = pd.DataFrame(itemData[:, 1:].tolist(), index=itemData[:,0], columns=labels)\n                    elif variLen == 1:\n                        df = pd.DataFrame(itemData[:, 1].tolist(), index=itemData[:,0], columns=labels)\n                    else:\n                        df = pd.DataFrame([np.nan], columns=labels)\n\n                    for i in range(0, variLen):\n                        try: # if the data is numeric reduce it to float32 rather than float64 to reduce storage footprint\n                            # Note: You might think you can simplify these three lines into a single:\n                            # df.iloc[:,i] = df.iloc[:,i].apply(pandas.to_numeric, downcast=\"float\")\n                            # but you'd be wrong.\n                            varComp = df.iloc[:,i]\n                            if self._varCast != None:\n                                varComp = pd.to_numeric(varComp, downcast='float')\n                            df.iloc[:,i] = varComp\n                        except:\n                            pass\n\n                    # If the .data file doesn't exist save the dataframe to create the file\n                    # and skip the remainder of the loop\n                    if not os.path.exists(filePath):\n                        pickle.dump([df], open(filePath, \"wb\"))\n                        continue\n\n                    # If the .data file does exists, append the message's pickle.\n                    with open(filePath, \"a+b\") as pkl:\n                        pickle.dump([df], pkl)\n\n            print(\"Finished logging dataframes from run\" + str(mcSimIndex))\n\n        # Sort by the MultiIndex (first by run number then by variable component)\n        print(\"Starting to concatenate dataframes\")\n        for filePath in self._dataFiles:\n            # We create a new index so that we populate any missing run data (in the case that a run breaks) with NaNs.\n            allData = []\n            with open(filePath, 'rb') as pkl:\n                try:\n                    while True:\n                        allData.extend(pickle.load(pkl))\n                except EOFError:\n                    pass\n            allData = pd.concat(allData, axis=1)\n            newMultInd = pd.MultiIndex.from_product([list(range(allData.columns.min()[0], allData.columns.max()[0]+1)),\n                                                         list(range(allData.columns.min()[1], allData.columns.max()[1]+1))],\n                                                         names=[\"runNum\", \"varIdx\"])\n            #allData = allData.sort_index(axis=1, level=[0,1]) #TODO: When we dont lose MCs anymore, we should just use this call\n            allData = allData.reindex(columns=newMultInd)\n            allData.index.name = 'time[ns]'\n            allData.to_pickle(filePath)\n        print(\"Finished concatenating dataframes\")\n\n    def setLogDir(self, logDir):\n        self._logDir = logDir\n\n    def setVarCast(self, varCast):\n        self._varCast = varCast",
  "def __init__(self, q):\n        super(DataWriter, self).__init__()\n        self._queue = q\n        self._endToken = None\n        self._varCast = None\n        self._logDir = \"\"\n        self._dataFiles = set()",
  "def run(self):\n        \"\"\" The process run loop. Gets data from a queue and writes it out to per message csv files\n            Args:\n                Nil\n            Returns:\n                Nil\n        \"\"\"\n        while self._endToken is None:\n            data, mcSimIndex, self._endToken = self._queue.get()\n            print(\"Starting to log: \" + str(mcSimIndex))\n            if self._endToken:\n                continue\n            print(\"Logging Dataframes from run \" + str(mcSimIndex))\n            for dictName, dictData in data.items(): # Loops through Messages, Variables, Custom dictionaries in the retention policy\n                for itemName, itemData in dictData.items(): # Loop through all items and their data\n\n                    if itemName == \"OrbitalElements.Omega\": # Protects from OS that aren't case sensitive.\n                        itemName = \"OrbitalElements.Omega_Capital\"\n\n                    filePath = self._logDir + itemName + \".data\"\n                    self._dataFiles.add(filePath)\n\n                    # Is the data a vector, scalar, or non-existant?\n                    try:\n                        variLen = itemData[:,1:].shape[1]\n                    except:\n                        variLen = 0\n\n                    # Generate the MultiLabel\n                    outerLabel = [mcSimIndex]\n                    innerLabel = []\n\n                    for i in range(variLen):\n                        innerLabel.append(i)\n                    if variLen == 0:\n                        innerLabel.append(0) # May not be necessary, might be able to leave blank and get a None\n                    labels = pd.MultiIndex.from_product([outerLabel, innerLabel], names=[\"runNum\", \"varIdx\"])\n\n                    # Generate the individual run's dataframe\n                    if variLen >= 2:\n                        df = pd.DataFrame(itemData[:, 1:].tolist(), index=itemData[:,0], columns=labels)\n                    elif variLen == 1:\n                        df = pd.DataFrame(itemData[:, 1].tolist(), index=itemData[:,0], columns=labels)\n                    else:\n                        df = pd.DataFrame([np.nan], columns=labels)\n\n                    for i in range(0, variLen):\n                        try: # if the data is numeric reduce it to float32 rather than float64 to reduce storage footprint\n                            # Note: You might think you can simplify these three lines into a single:\n                            # df.iloc[:,i] = df.iloc[:,i].apply(pandas.to_numeric, downcast=\"float\")\n                            # but you'd be wrong.\n                            varComp = df.iloc[:,i]\n                            if self._varCast != None:\n                                varComp = pd.to_numeric(varComp, downcast='float')\n                            df.iloc[:,i] = varComp\n                        except:\n                            pass\n\n                    # If the .data file doesn't exist save the dataframe to create the file\n                    # and skip the remainder of the loop\n                    if not os.path.exists(filePath):\n                        pickle.dump([df], open(filePath, \"wb\"))\n                        continue\n\n                    # If the .data file does exists, append the message's pickle.\n                    with open(filePath, \"a+b\") as pkl:\n                        pickle.dump([df], pkl)\n\n            print(\"Finished logging dataframes from run\" + str(mcSimIndex))\n\n        # Sort by the MultiIndex (first by run number then by variable component)\n        print(\"Starting to concatenate dataframes\")\n        for filePath in self._dataFiles:\n            # We create a new index so that we populate any missing run data (in the case that a run breaks) with NaNs.\n            allData = []\n            with open(filePath, 'rb') as pkl:\n                try:\n                    while True:\n                        allData.extend(pickle.load(pkl))\n                except EOFError:\n                    pass\n            allData = pd.concat(allData, axis=1)\n            newMultInd = pd.MultiIndex.from_product([list(range(allData.columns.min()[0], allData.columns.max()[0]+1)),\n                                                         list(range(allData.columns.min()[1], allData.columns.max()[1]+1))],\n                                                         names=[\"runNum\", \"varIdx\"])\n            #allData = allData.sort_index(axis=1, level=[0,1]) #TODO: When we dont lose MCs anymore, we should just use this call\n            allData = allData.reindex(columns=newMultInd)\n            allData.index.name = 'time[ns]'\n            allData.to_pickle(filePath)\n        print(\"Finished concatenating dataframes\")",
  "def setLogDir(self, logDir):\n        self._logDir = logDir",
  "def setVarCast(self, varCast):\n        self._varCast = varCast",
  "class Controller:\n    \"\"\"\n    The MonteCarloController class is used to run a monte carlo simulation.\n    It is used to execute multiple runs of a simulation with varying initial parameters. Data from each run is retained\n    in order to analyze differences in the simulation runs and the parameters used.\n    \"\"\"\n\n    def __init__(self):\n        self.executionCount = 0\n        self.ICrunFlag = False\n        self.icDirectory = \"\"\n        self.archiveDir = None\n        self.varCast = None\n        self.numProcess = mp.cpu_count()\n\n        self.simParams = SimulationParameters(\n            creationFunction=None,\n            executionFunction=None,\n            configureFunction=None,\n            retentionPolicies=[],\n            shouldArchiveParameters=False,\n            shouldDisperseSeeds=False,\n            dispersions=[],\n            filename=\"\",\n            icfilename=\"\"\n        )\n\n    def setShowProgressBar(self, value):\n        \"\"\"\n        To enable or disable progress bar to show simulation progress\n        Args:\n            value: boolean value, decide to show/hide progress bar\n        \"\"\"\n        self.simParams.showProgressBar = value\n\n    @staticmethod\n    def load(runDirectory):\n        \"\"\"\n        Load a previously completed MonteCarlo simulation\n        Args:\n            The path to the MonteCarlo.data file that contains the archived MonteCarlo run\n        \"\"\"\n        filename = os.path.abspath(runDirectory) + \"/MonteCarlo.data\"\n\n        with gzip.open(filename) as pickledData:\n            data = pickle.load(pickledData)\n            if data.simParams.verbose:\n                print(\"Loading montecarlo at\", filename)\n            data.multiProcManager = mp.Manager()\n            data.dataOutQueue = data.multiProcManager.Queue()\n            data.dataWriter = DataWriter(data.dataOutQueue)\n            data.dataWriter.daemon = False\n            return data\n\n    def setExecutionFunction(self, newModule):\n        \"\"\"\n        Set an execution function that executes a simulation instance.\n\n        Args:\n            executionFunction: (sim: SimulationBaseClass) => None\n                A function with one parameter, a simulation instance.\n                The function will be called after the creationFunction and configurationFunction in each simulation run.\n                It must execute the simulation.\n                Its return value is not used.\n        \"\"\"\n        self.simParams.executionFunction = newModule\n\n    def setConfigureFunction(self, newModule):\n        \"\"\"\n        Set an execution function that executes a simulation instance.\n\n        Args:\n            executionFunction: (sim: SimulationBaseClass) => None\n                A function with one parameter, a simulation instance.\n                The function will be called after the creationFunction and configurationFunction in each simulation run.\n                It must execute the simulation.\n                Its return value is not used.\n        \"\"\"\n        self.simParams.configureFunction = newModule\n\n    def setSimulationFunction(self, newObject):\n        \"\"\"\n        Set the function that creates the simulation instance.\n\n        Args:\n            creationFunction: () => SimulationBaseClass\n                A function with no parameters, that returns a simulation instance.\n        \"\"\"\n        self.simParams.creationFunction = newObject\n\n    def setShouldDisperseSeeds(self, seedDisp):\n        \"\"\"\n        Disperse the RNG seeds of each run in the MonteCarlo\n\n        Args:\n            seedDisp: bool\n                Whether to disperse the RNG seeds in each run of the simulation\n        \"\"\"\n        self.simParams.shouldDisperseSeeds = seedDisp\n\n    def setExecutionCount(self, newCount):\n        \"\"\"\n        Set the number of runs for the MonteCarlo simulation\n\n        Args:\n            newCount: int\n                The number of runs to use for the simulation\n        \"\"\"\n        self.executionCount = newCount\n\n    def addDispersion(self, disp):\n        \"\"\"\n        Add a dispersion to the simulation.\n\n        Args:\n            disp: Dispersion\n                The dispersion to add to the simulation.\n        \"\"\"\n        self.simParams.dispersions.append(disp)\n\n    def addRetentionPolicy(self, policy):\n        \"\"\"\n        Add a retention policy to the simulation.\n\n        Args:\n            disp: RetentionPolicy\n                The retention policy to add to the simulation.\n                This defines variables to be logged and saved\n        \"\"\"\n        self.simParams.retentionPolicies.append(policy)\n\n    def setThreadCount(self, threads):\n        \"\"\"\n        Set the number of threads to use for the monte carlo simulation\n\n        Args:\n            threads: int\n                Number of threads to execute the montecarlo run on.\n        \"\"\"\n        self.numProcess = threads\n\n    def setVerbose(self, verbose):\n        \"\"\"\n        Use verbose output for this MonteCarlo run\n\n        Args:\n            verbose: bool\n                Whether to print verbose information during this MonteCarlo sim.\n        \"\"\"\n        self.simParams.verbose = verbose\n\n    def setDispMagnitudeFile(self, magnitudes):\n        \"\"\"\n        Save .txt with the magnitude of each dispersion in % or sigma away from mean\n\n        Args:\n            magnitudes: bool\n                Whether to save extra files for analysis.\n        \"\"\"\n        self.simParams.saveDispMag = magnitudes\n\n    def setShouldArchiveParameters(self, shouldArchiveParameters):\n        self.simParams.shouldArchiveParameters = shouldArchiveParameters\n\n    def setArchiveDir(self, dirName):\n        \"\"\"\n        Set-up archives for this MonteCarlo run\n\n        Args:\n            dirName: string\n                The name of the directory to archive runs in.\n                None, if no archive desired.\n        \"\"\"\n        self.archiveDir = os.path.abspath(dirName) + \"/\"\n        self.simParams.shouldArchiveParameters = dirName is not None\n        self.simParams.filename = self.archiveDir\n\n    def setVarCast(self, varCast):\n        \"\"\"\n        Set the variable type to downcast the data to\n\n        :param varCast: 'float', 'integer', 'signed', 'unsigned' (see pandas.to_numeric documentation)\n        :return:\n        \"\"\"\n        self.varCast = varCast\n\n    def setICDir(self, dirName):\n        \"\"\"\n        Set-up archives containing IC data\n\n        Args:\n            dirName: string\n                The name of the directory to archive runs in.\n                None, if no archive desired.\n        \"\"\"\n        self.icDirectory = os.path.abspath(dirName) + \"/\"\n        self.simParams.shouldArchiveParameters = True\n        self.simParams.icfilename = self.icDirectory\n\n    def setICRunFlag(self, bool):\n        \"\"\"\n        Set the number of threads to use for the monte carlo simulation\n\n        Args:\n            threads: int\n                Number of threads to execute the montecarlo run on.\n        \"\"\"\n        self.ICrunFlag = bool\n\n    def getRetainedData(self, case):\n        \"\"\"\n        Get the data that was retained for a run, or list of runs.\n\n        Args:\n            cases: int The desired case to get data from.\n        Returns:\n            The retained data for that run is returned.\n        \"\"\"\n        if self.ICrunFlag:\n            oldRunDataFile = self.icDirectory + \"run\" + str(case) + \".data\"\n        else:\n            oldRunDataFile = self.archiveDir + \"run\" + str(case) + \".data\"\n\n        with gzip.open(oldRunDataFile) as pickledData:\n            data = pickle.load(pickledData)\n            return data\n\n    def getRetainedDatas(self, cases):\n        \"\"\"\n        Get the data that was retained for a list of runs.\n\n        Args:\n            cases: int[] The desired cases to get data from.\n        Returns:\n            A generator is returned, which will yield, in-order, the retained data for each of these cases\n        \"\"\"\n\n        for case in cases:\n            yield self.getRetainedData(case)  # call this method recursively, yielding the result\n\n    def getParameters(self, caseNumber):\n        \"\"\"\n        Get the parameters used for a particular run of the montecarlo\n\n        :param caseNumber: The number of the run to get the parameters used for.\n        :type caseNumber: int\n\n        :return: A dictionary of the parameters of the simulation\n                 For example:\n                 {\"keyForSim\": parameterValue, 'TaskList[0].TaskModels[0].RNGSeed': 1674764759}\n        \"\"\"\n        if self.ICrunFlag:\n            filename = self.icDirectory + \"run\" + str(caseNumber) + \".json\"\n        else:\n            filename = self.archiveDir + \"run\" + str(caseNumber) + \".json\"\n        with open(filename, \"r\") as dispersionFile:\n            dispersions = json.load(dispersionFile)\n            return dispersions\n\n    def reRunCases(self, caseList):\n        \"\"\"\n        Rerun some cases from a MonteCarlo run. Does not run in parallel\n\n        Args:\n            caseList: int[]\n                The list of runs to repeat, a list of numbers.\n        Returns:\n            failures: int[]\n                The list of failed runs.\n        \"\"\"\n        # the list of failures\n        failed = []\n\n        for caseNumber in caseList:\n            if self.simParams.verbose:\n                print(\"Rerunning\", caseNumber)\n\n            oldRunFile = self.archiveDir + \"run\" + str(caseNumber) + \".json\"\n            if not os.path.exists(oldRunFile):\n                print(\"ERROR re-running case: \" + oldRunFile)\n                continue\n\n            # use old simulation parameters, modified slightly.\n            simParams = copy.deepcopy(self.simParams)\n            simParams.index = caseNumber\n            # don't redisperse seeds, we want to use the ones saved in the oldRunFile\n            simParams.shouldDisperseSeeds = False\n            # don't retain any data so remove all retention policies\n            simParams.retentionPolicies = []\n\n            with open(oldRunFile, \"r\") as runParameters:\n                simParams.modifications = json.load(runParameters)\n\n            # execute simulation with dispersion\n            executor = SimulationExecutor()\n            success = executor([simParams, self.dataOutQueue])\n\n            if not success:\n                print(\"Error re-executing run\", caseNumber)\n                failed.append(caseNumber)\n\n        if len(failed) > 0:\n            failed.sort()\n            print(\"Failed rerunning cases:\", failed)\n\n        return failed\n\n    def runInitialConditions(self, caseList):\n        \"\"\"\n        Run initial conditions given in a file\n\n        Args:\n            caseList: int[]\n                The list of runs to repeat, a list of numbers.\n        Returns:\n            failures: int[]\n                The list of failed runs.\n        \"\"\"\n        # the list of failures\n        failed = []\n\n        assert self.icDirectory != \"\", \"No initial condition directory was given\"\n        assert self.ICrunFlag is not False, \"IC run flag was not set\"\n\n        if self.simParams.verbose:\n            print(\"Beginning simulation with {0} runs on {1} threads\".format(self.executionCount, self.numProcess))\n\n        if self.simParams.shouldArchiveParameters:\n            if not os.path.exists(self.icDirectory):\n                print(\"Cannot run initial conditions: the directory given does not exist\")\n\n            if self.simParams.verbose:\n                print(\"Archiving a copy of this simulation before running it in 'MonteCarlo.data'\")\n            try:\n                with gzip.open(self.icDirectory + \"MonteCarlo.data\", \"w\") as pickleFile:\n                    pickle.dump(self, pickleFile)  # dump this controller object into a file.\n            except Exception as e:\n                print(\"Unknown exception while trying to pickle monte-carlo-controller... \\ncontinuing...\\n\\n\", e)\n\n        # Create Queue, but don't ever start it.\n        self.multiProcManager = mp.Manager()\n        self.dataOutQueue = self.multiProcManager.Queue()\n        self.dataWriter = DataWriter(self.dataOutQueue)\n        self.dataWriter.daemon = False\n\n        # If archiving the rerun data -- make sure not to delete the original data!\n        if self.archiveDir is not None:\n            if self.archiveDir != self.icDirectory:\n                if os.path.exists(self.archiveDir):\n                    shutil.rmtree(self.archiveDir)\n                os.mkdir(self.archiveDir)\n                self.dataWriter.setLogDir(self.archiveDir)\n                self.dataWriter.start()\n            else:\n                print(\"ERROR: The archive directory is set as the icDirectory. Proceeding would have overwriten all data \" \\\n                      \"within: \" + self.archiveDir + \" with the select rerun cases! Exiting.\\n\")\n                sys.exit(\"Change the archive directory to a new location when rerunning cases.\")\n        else:\n            print(\"No archive data specified; no data will be logged to dataframes\")\n\n        jobsFinished = 0  # keep track of what simulations have finished\n\n        # The simulation executor is responsible for executing simulation given a simulation's parameters\n        # It is called within worker threads with each worker's simulation parameters\n        simulationExecutor = SimulationExecutor()\n        #\n        progressBar = SimulationProgressBar(len(caseList), self.simParams.showProgressBar)\n        if self.numProcess == 1:  # don't make child thread\n            if self.simParams.verbose:\n                print(\"Executing sequentially...\")\n            i = 0\n            for i in range(len(caseList)):\n                simGenerator = self.generateICSims(caseList[i:i+1])\n                for sim in simGenerator:\n                    try:\n                        simulationExecutor([sim,  self.dataOutQueue])\n                    except:\n                        failed.append(i)\n                i += 1\n                progressBar.update(i)\n        else:\n            numSims = len(caseList)\n            if self.numProcess > numSims:\n                print(\"Fewer MCs spawned than processes assigned (%d < %d). Changing processes count to %d.\" % (numSims, self.numProcess, numSims))\n                self.numProcess = numSims\n            for i in range(numSims//self.numProcess):\n                # If number of sims doesn't factor evenly into the number of processes:\n                if numSims % self.numProcess != 0 and i == len(list(range(numSims//self.numProcess)))-1:\n                    offset = numSims % self.numProcess\n                else:\n                    offset = 0\n\n                simGenerator = self.generateICSims(caseList[self.numProcess*i:self.numProcess*(i+1)+offset])\n                pool = mp.Pool(self.numProcess)\n                try:\n                    # yields results *as* the workers finish jobs\n                    for result in pool.imap_unordered(simulationExecutor, [(x, self.dataOutQueue) for x in simGenerator]):\n                        if result[0] is not True:  # workers return True on success\n                            failed.append(result[1])  # add failed jobs to the list of failures\n                            print(\"Job\", result[1], \"failed...\")\n\n                        jobsFinished += 1\n                        progressBar.update(jobsFinished)\n                    pool.close()\n                except KeyboardInterrupt as e:\n                    print(\"Ctrl-C was hit, closing pool\")\n                    # failed.extend(range(jobsFinished, numSims))  # fail all potentially running jobs...\n                    pool.terminate()\n                    raise e\n                except Exception as e:\n                    print(\"Unknown exception while running simulations:\", e)\n                    # failed.extend(range(jobsFinished, numSims))  # fail all potentially running jobs...\n                    traceback.print_exc()\n                    pool.terminate()\n                finally:\n                    pool.join()\n\n        progressBar.markComplete()\n        progressBar.close()\n        # If the data was archiving, close the queue.\n        if self.archiveDir is not None and self.archiveDir != self.icDirectory:\n            while not self.dataOutQueue.empty():\n               time.sleep(1)\n            self.dataOutQueue.put((None, None, True))\n            time.sleep(5)\n\n        # if there are failures\n        if len(failed) > 0:\n            failed.sort()\n\n            if self.simParams.verbose:\n                print(\"Failed\", failed, \"saving to 'failures.txt'\")\n\n            if self.simParams.shouldArchiveParameters:\n                # write a file that contains log of failed runs\n                with open(self.icDirectory + \"failures.txt\", \"w\") as failFile:\n                    failFile.write(str(failed))\n\n        return failed\n\n    def generateICSims(self, caseList):\n        \"\"\"\n        Generator function to clone a baseSimulation for IC run\n\n        Args:\n            baseSimulation: SimulationParams\n                A base simulation to clone.\n            numSims: int[]\n                The desired runs to generate.\n        Returns:\n            generator<SimulationParams>\n                A generator that yields that number of cloned simulations\n        \"\"\"\n\n        # make a list of simulations to execute by cloning the base-simulation and\n        # changing each clone's index and filename to make a list of\n        # simulations to execute\n        for caseNumber in caseList:\n            if self.simParams.verbose:\n                print(\"Running IC \", caseNumber)\n\n            oldRunFile = self.icDirectory + \"run\" + str(caseNumber) + \".json\"\n            if not os.path.exists(oldRunFile):\n                print(\"ERROR running IC case: \" + oldRunFile)\n                continue\n\n            # use old simulation parameters, modified slightly.\n            simParams = copy.deepcopy(self.simParams)\n            simParams.index = caseNumber\n            # don't redisperse seeds, we want to use the ones saved in the oldRunFile\n            simParams.shouldDisperseSeeds = False\n\n            simParams.icfilename = self.icDirectory + \"run\" + str(caseNumber)\n            with open(oldRunFile, \"r\") as runParameters:\n                simParams.modifications = json.load(runParameters)\n\n            yield simParams\n\n    def generateSims(self, simNumList):\n        \"\"\"\n        Generator function to clone a baseSimulation\n\n        Args:\n            baseSimulation: SimulationParams\n                A base simulation to clone.\n            numSims: int[]\n                The desired runs to generate.\n        Returns:\n            generator<SimulationParams>\n                A generator that yields that number of cloned simulations\n        \"\"\"\n\n        # make a list of simulations to execute by cloning the base-simulation and\n        # changing each clone's index and filename to make a list of\n        # simulations to execute\n        for i in simNumList:\n            simClone = copy.deepcopy(self.simParams)\n            simClone.index = i\n            simClone.filename += \"run\" + str(i)\n\n            yield simClone\n\n    def executeCallbacks(self, rng=None, retentionPolicies=[]):\n        \"\"\"\n        Execute retention policy callbacks after running a monteCarlo sim.\n\n        Args:\n            rng: A list of simulations to execute callbacks on\n            retentionPolicies: the retention policies to execute\n        \"\"\"\n\n        if rng is None:\n            rng = list(range(self.executionCount))\n\n        if retentionPolicies == []:\n            retentionPolicies = self.simParams.retentionPolicies\n\n        for simIndex in rng:\n            data = self.getRetainedData(simIndex)\n            for retentionPolicy in retentionPolicies:\n                retentionPolicy.executeCallback(data)\n\n    def executeSimulations(self):\n        \"\"\"\n        Execute simulations in parallel\n\n        :return: failed: int[]\n                 A list of the indices of all failed simulation runs.\n        \"\"\"\n\n        if self.simParams.verbose:\n            print(\"Beginning simulation with {0} runs on {1} threads\".format(self.executionCount, self.numProcess))\n\n        if self.simParams.shouldArchiveParameters:\n            if os.path.exists(self.archiveDir):\n                shutil.rmtree(self.archiveDir, ignore_errors=True)\n            os.mkdir(self.archiveDir)\n            if self.simParams.verbose:\n                print(\"Archiving a copy of this simulation before running it in 'MonteCarlo.data'\")\n            try:\n                with gzip.open(self.archiveDir + \"MonteCarlo.data\", \"wb\") as pickleFile:\n                    pickle.dump(self, pickleFile)  # dump this controller object into a file.\n            except Exception as e:\n                print(\"Unknown exception while trying to pickle monte-carlo-controller... \\ncontinuing...\\n\\n\", e)\n\n        self.multiProcManager = mp.Manager()\n        self.dataOutQueue = self.multiProcManager.Queue()\n        self.dataWriter = DataWriter(self.dataOutQueue)\n        self.dataWriter.daemon = False\n\n        numSims = self.executionCount\n\n        # start data writer process\n        self.dataWriter.setLogDir(self.archiveDir)\n        self.dataWriter.setVarCast(self.varCast)\n        self.dataWriter.start()\n\n        # Avoid building a full list of all simulations to run in memory,\n        # instead only generating simulations right before they are needed by a waiting worker\n        # This is accomplished using a generator and pool.imap, -- simulations are only built\n        # when they are about to be passed to a worker, avoiding memory overhead of first building simulations\n        # There is a system-dependent chunking behavior, sometimes 10-20 are generated at a time.\n        # simGenerator = self.generateSims(range(numSims))\n        failed = []  # keep track of the indices of failed simulations\n        jobsFinished = 0  # keep track of what simulations have finished\n\n        # The simulation executor is responsible for executing simulation given a simulation's parameters\n        # It is called within worker threads with each worker's simulation parameters\n        simulationExecutor = SimulationExecutor()\n\n        progressBar = SimulationProgressBar(numSims, self.simParams.showProgressBar)\n\n        # The outermost for-loop for both the serial and multiprocessed sim generator is not necessary. It\n        # is a temporary fix to a memory leak which is assumed to be a result of the simGenerator not collecting\n        # garbage properly. # TODO: Find a more permenant solution to the leak.\n\n        if self.numProcess == 1:  # don't make child thread\n            if self.simParams.verbose:\n                print(\"Executing sequentially...\")\n            i = 0\n            for i in range(numSims):\n                simGenerator = self.generateSims(list(range(i,i+1)))\n                for sim in simGenerator:\n                    try:\n                        run_ok = simulationExecutor([sim, self.dataOutQueue])[0]\n                    except:\n                        failed.append(i)\n                    else:\n                        if not run_ok:\n                            failed.append(i)\n                    i += 1\n                    progressBar.update(i)\n        else:\n            if self.numProcess > numSims:\n                print(\"Fewer MCs spawned than processes assigned (%d < %d). Changing processes count to %d.\" % (numSims, self.numProcess, numSims))\n                self.numProcess = numSims\n            for i in range(numSims//self.numProcess):\n                # If number of sims doesn't factor evenly into the number of processes:\n                if numSims % self.numProcess != 0 and i == len(list(range(numSims//self.numProcess)))-1:\n                    offset = numSims % self.numProcess\n                else:\n                    offset = 0\n                simGenerator = self.generateSims(list(range(self.numProcess*i, self.numProcess*(i+1)+offset)))\n                pool = mp.Pool(self.numProcess)\n                try:\n                    # yields results *as* the workers finish jobs\n                    for result in pool.imap_unordered(simulationExecutor, [(x, self.dataOutQueue) for x in simGenerator]):\n                        if result[0] is not True:  # workers return True on success\n                            failed.append(result[1])  # add failed jobs to the list of failures\n                            print(\"Job\", result[1], \"failed...\")\n\n                        jobsFinished += 1\n                        progressBar.update(jobsFinished)\n                    pool.close()\n                except KeyboardInterrupt as e:\n                    print(\"Ctrl-C was hit, closing pool\")\n                    failed.extend(list(range(jobsFinished, numSims)))  # fail all potentially running jobs...\n                    pool.terminate()\n                    raise e\n                except Exception as e:\n                    print(\"Unknown exception while running simulations:\", e)\n                    failed.extend(list(range(jobsFinished, numSims)))  # fail all potentially running jobs...\n                    traceback.print_exc()\n                    pool.terminate()\n                finally:\n                    # Wait until all data is logged from the spawned runs before proceeding with the next set.\n                    pool.join()\n\n        progressBar.markComplete()\n        progressBar.close()\n        # Wait until all data logging is finished before concatenation dataframes and shutting down the pool\n        while not self.dataOutQueue.empty():\n           time.sleep(1)\n        self.dataOutQueue.put((None, None, True))\n        time.sleep(5)\n\n        # if there are failures\n        if len(failed) > 0:\n            failed.sort()\n\n            if self.simParams.verbose:\n                print(\"Failed\", failed, \"saving to 'failures.txt'\")\n\n            if self.simParams.shouldArchiveParameters:\n                # write a file that contains log of failed runs\n                with open(self.archiveDir + \"failures.txt\", \"w\") as failFile:\n                    failFile.write(str(failed))\n\n        return failed",
  "class SimulationParameters():\n    \"\"\"\n    This class represents the run parameters for a simulation, with information including\n\n     - a function that creates the simulation\n     - a function that executes the simulation\n     - the dispersions to use on that simulation\n     - parameters describing the data to be retained for a simulation\n     - whether randomized seeds should be applied to the simulation\n     - whether data should be archived\n    \"\"\"\n\n    def __init__(self, creationFunction, executionFunction, configureFunction,\n                 retentionPolicies, dispersions, shouldDisperseSeeds,\n                 shouldArchiveParameters, filename, icfilename, index=None, verbose=False, modifications={},\n                 showProgressBar=False):\n        self.index = index\n        self.creationFunction = creationFunction\n        self.executionFunction = executionFunction\n        self.configureFunction = configureFunction\n        self.retentionPolicies = retentionPolicies\n        self.dispersions = dispersions\n        self.shouldDisperseSeeds = shouldDisperseSeeds\n        self.shouldArchiveParameters = shouldArchiveParameters\n        self.filename = filename\n        self.icfilename = icfilename\n        self.verbose = verbose\n        self.modifications = modifications\n        self.dispersionMag = {}\n        self.saveDispMag = False\n        self.showProgressBar = showProgressBar",
  "class SimulationExecutor:\n    \"\"\"\n    This class is used to execute a simulation in a worker thread.\n    To use, create an instance of this class, and then call the instance with the simulation parameters to run them in::\n\n        executor = SimulationExecutor()\n        simParams = SimulationParameters()\n        successFlag = executor(simParams)\n\n    This class can be used to execute a simulation on a different thread, by using this class as the processes target.\n    \"\"\"\n    #\n\n    @classmethod\n    def __call__(cls, params):\n        \"\"\"\n        In each worker process, we execute this function (by calling this object)\n\n        Args:\n            params [simParams, data out queue]:\n                A SimulationParameters object for the simulation to be executed and the output data queue\n                for the data writer.\n        Returns:\n            success: bool\n                (True, simParams.index) if simulation run was successful\n                (False, simParams.index) if simulation run was unsuccessful\n        \"\"\"\n        simParams = params[0]\n        dataOutQueue = params[1]\n\n        try:\n            signal.signal(signal.SIGINT, signal.SIG_IGN)  # On ctrl-c ignore the signal... let the parent deal with it.\n\n            # must make new random seed on each new thread.\n            np.random.seed(simParams.index * 10)\n            random.seed(simParams.index * 10)\n\n            # create the users sim by calling their supplied creationFunction\n            simInstance = simParams.creationFunction()\n\n            # build a list of the parameter and random seed modifications to make\n            modifications = simParams.modifications\n            magnitudes = simParams.dispersionMag\n\n            # we may want to disperse random seeds\n            if simParams.shouldDisperseSeeds:\n                # generate the random seeds for the model (but don't apply them yet)\n                # Note: This sets the RNGSeeds before all other modifications\n                randomSeedDispersions = cls.disperseSeeds(simInstance)\n                for name, value in randomSeedDispersions.items():\n                    modifications[name] = value\n\n            # used if rerunning ICs from a .json file, modifications will contain the\n            # RNGSeeds that need to be set before selfInit()\n            cls.populateSeeds(simInstance, modifications)\n\n            # we may want to disperse parameters\n            for disp in simParams.dispersions:\n                try:\n                    name = disp.getName()\n                    if name not in modifications:  # could be using a saved parameter.\n                        modifications[name] = disp.generateString(simInstance)\n                        if simParams.saveDispMag:\n                            magnitudes[name] = disp.generateMagString()\n                except TypeError:\n                    # This accomodates dispersion variables that are co-dependent\n                    disp.generate()\n                    for i in range(1, disp.numberOfSubDisps+1):\n                        name = disp.getName(i)\n                        if name not in modifications:  # could be using a saved parameter.\n                            modifications[name] = disp.generateString(i, simInstance)\n                            if simParams.saveDispMag:\n                                magnitudes[name] = disp.generateMagString()\n\n            # if archiving, this run's parameters and random seeds are saved in its own json file\n            if simParams.shouldArchiveParameters:\n                # save the dispersions and random seeds for this run\n                if simParams.icfilename != \"\":\n                    with open(simParams.icfilename + \".json\", 'w') as outfile:\n                        json.dump(modifications, outfile)\n                else:\n                    with open(simParams.filename + \".json\", 'w') as outfile:\n                        json.dump(modifications, outfile)\n                    if simParams.saveDispMag:\n                        with open(simParams.filename + \"mag.txt\", 'w') as outfileMag:\n                            for k in sorted(magnitudes.keys()):\n                                outfileMag.write(\"'%s':'%s', \\n\" % (k, magnitudes[k]))\n\n            if simParams.configureFunction is not None:\n                if simParams.verbose:\n                    print(\"Configuring sim\")\n                simParams.configureFunction(simInstance)\n\n            # apply the dispersions and the random seeds\n            for variable, value in list(modifications.items()):\n                disperseStatement = \"simInstance.\" + variable + \"=\" + value\n                if simParams.verbose:\n                    print(\"Executing parameter modification -> \", disperseStatement)\n                exec(disperseStatement)\n\n            # setup data logging\n            if len(simParams.retentionPolicies) > 0:\n                if simParams.verbose:\n                    print(\"Adding retained data\")\n                RetentionPolicy.addRetentionPoliciesToSim(simInstance, simParams.retentionPolicies)\n\n            if simParams.verbose:\n                print(\"Executing simulation\")\n            # execute the simulation, with the user-supplied executionFunction\n            try:\n                simParams.executionFunction(simInstance)\n            except TypeError:\n                simParams.executionFunction(simInstance, simParams.filename)\n\n            if len(simParams.retentionPolicies) > 0:\n                if simParams.icfilename != \"\":\n                    retentionFile = simParams.icfilename + \".data\"\n                else:\n                    retentionFile = simParams.filename + \".data\"\n\n                if simParams.verbose:\n                    print(\"Retaining data for run in\", retentionFile)\n\n                retainedData = RetentionPolicy.getDataForRetention(simInstance, simParams.retentionPolicies)\n                dataOutQueue.put((retainedData, simParams.index, None))\n                time.sleep(1)\n\n                with gzip.open(retentionFile, \"w\") as archive:\n                    retainedData[\"index\"] = simParams.index # add run index\n                    pickle.dump(retainedData, archive)\n\n            if simParams.verbose:\n                print(\"Terminating simulation\")\n\n            if simParams.verbose:\n                print(\"Thread\", os.getpid(), \"Job\", simParams.index, \"finished successfully\")\n\n            return (True, simParams.index)  # this function returns true only if the simulation was successful\n\n        except Exception as e:\n            print(\"Error in worker thread\", e)\n            traceback.print_exc()\n            return (False, simParams.index)  # there was an error\n\n    @staticmethod\n    def disperseSeeds(simInstance):\n        \"\"\"\n        Disperses the RNG seeds of all the tasks in the sim, and returns a statement that contains the seeds.\n        Example return dictionary::\n\n             {\n                '.TaskList[0].TaskModels[1]': 1934586,\n                '.TaskList[0].TaskModels[2]': 3450093,\n                '.TaskList[1].TaskModels[0]': 2221934,\n                '.TaskList[2].TaskModels[0]': 1123244\n             }\n\n        :param simInstance: A basilisk simulation to set random seeds on\n        :type simInstance: SimulationBaseClass\n        :return: A dictionary with the random seeds that should be applied to the sim\n                        \"\"\"\n\n        randomSeeds = {}\n        for i, task in enumerate(simInstance.TaskList):\n            for j, model in enumerate(task.TaskModels):\n                taskVar = 'TaskList[' + str(i) + '].TaskModels' + '[' + str(j) + '].RNGSeed'\n                rand = str(random.randint(0, 1 << 32 - 1))\n                try:\n                    execStatement = \"simInstance.\" + taskVar + \"=\" + str(rand)\n                    exec(execStatement)  # if this fails don't add to the list of modification\n                    randomSeeds[taskVar] = rand\n                except:\n                    pass\n        return randomSeeds\n\n    @staticmethod\n    def populateSeeds(simInstance, modifications):\n        \"\"\"\n        only populate the RNG seeds of all the tasks in the sim\n\n        Args:\n            simInstance: SimulationBaseClass\n                A basilisk simulation to set random seeds on\n            modifications:\n                A dictionary containing RNGSeeds to be populate for the sim, among other sim modifications.\n        \"\"\"\n        for variable, value in modifications.items():\n            if \".RNGSeed\" in variable:\n                rngStatement = \"simInstance.\" + variable + \"=\" + value\n                exec(rngStatement)",
  "def __init__(self):\n        self.executionCount = 0\n        self.ICrunFlag = False\n        self.icDirectory = \"\"\n        self.archiveDir = None\n        self.varCast = None\n        self.numProcess = mp.cpu_count()\n\n        self.simParams = SimulationParameters(\n            creationFunction=None,\n            executionFunction=None,\n            configureFunction=None,\n            retentionPolicies=[],\n            shouldArchiveParameters=False,\n            shouldDisperseSeeds=False,\n            dispersions=[],\n            filename=\"\",\n            icfilename=\"\"\n        )",
  "def setShowProgressBar(self, value):\n        \"\"\"\n        To enable or disable progress bar to show simulation progress\n        Args:\n            value: boolean value, decide to show/hide progress bar\n        \"\"\"\n        self.simParams.showProgressBar = value",
  "def load(runDirectory):\n        \"\"\"\n        Load a previously completed MonteCarlo simulation\n        Args:\n            The path to the MonteCarlo.data file that contains the archived MonteCarlo run\n        \"\"\"\n        filename = os.path.abspath(runDirectory) + \"/MonteCarlo.data\"\n\n        with gzip.open(filename) as pickledData:\n            data = pickle.load(pickledData)\n            if data.simParams.verbose:\n                print(\"Loading montecarlo at\", filename)\n            data.multiProcManager = mp.Manager()\n            data.dataOutQueue = data.multiProcManager.Queue()\n            data.dataWriter = DataWriter(data.dataOutQueue)\n            data.dataWriter.daemon = False\n            return data",
  "def setExecutionFunction(self, newModule):\n        \"\"\"\n        Set an execution function that executes a simulation instance.\n\n        Args:\n            executionFunction: (sim: SimulationBaseClass) => None\n                A function with one parameter, a simulation instance.\n                The function will be called after the creationFunction and configurationFunction in each simulation run.\n                It must execute the simulation.\n                Its return value is not used.\n        \"\"\"\n        self.simParams.executionFunction = newModule",
  "def setConfigureFunction(self, newModule):\n        \"\"\"\n        Set an execution function that executes a simulation instance.\n\n        Args:\n            executionFunction: (sim: SimulationBaseClass) => None\n                A function with one parameter, a simulation instance.\n                The function will be called after the creationFunction and configurationFunction in each simulation run.\n                It must execute the simulation.\n                Its return value is not used.\n        \"\"\"\n        self.simParams.configureFunction = newModule",
  "def setSimulationFunction(self, newObject):\n        \"\"\"\n        Set the function that creates the simulation instance.\n\n        Args:\n            creationFunction: () => SimulationBaseClass\n                A function with no parameters, that returns a simulation instance.\n        \"\"\"\n        self.simParams.creationFunction = newObject",
  "def setShouldDisperseSeeds(self, seedDisp):\n        \"\"\"\n        Disperse the RNG seeds of each run in the MonteCarlo\n\n        Args:\n            seedDisp: bool\n                Whether to disperse the RNG seeds in each run of the simulation\n        \"\"\"\n        self.simParams.shouldDisperseSeeds = seedDisp",
  "def setExecutionCount(self, newCount):\n        \"\"\"\n        Set the number of runs for the MonteCarlo simulation\n\n        Args:\n            newCount: int\n                The number of runs to use for the simulation\n        \"\"\"\n        self.executionCount = newCount",
  "def addDispersion(self, disp):\n        \"\"\"\n        Add a dispersion to the simulation.\n\n        Args:\n            disp: Dispersion\n                The dispersion to add to the simulation.\n        \"\"\"\n        self.simParams.dispersions.append(disp)",
  "def addRetentionPolicy(self, policy):\n        \"\"\"\n        Add a retention policy to the simulation.\n\n        Args:\n            disp: RetentionPolicy\n                The retention policy to add to the simulation.\n                This defines variables to be logged and saved\n        \"\"\"\n        self.simParams.retentionPolicies.append(policy)",
  "def setThreadCount(self, threads):\n        \"\"\"\n        Set the number of threads to use for the monte carlo simulation\n\n        Args:\n            threads: int\n                Number of threads to execute the montecarlo run on.\n        \"\"\"\n        self.numProcess = threads",
  "def setVerbose(self, verbose):\n        \"\"\"\n        Use verbose output for this MonteCarlo run\n\n        Args:\n            verbose: bool\n                Whether to print verbose information during this MonteCarlo sim.\n        \"\"\"\n        self.simParams.verbose = verbose",
  "def setDispMagnitudeFile(self, magnitudes):\n        \"\"\"\n        Save .txt with the magnitude of each dispersion in % or sigma away from mean\n\n        Args:\n            magnitudes: bool\n                Whether to save extra files for analysis.\n        \"\"\"\n        self.simParams.saveDispMag = magnitudes",
  "def setShouldArchiveParameters(self, shouldArchiveParameters):\n        self.simParams.shouldArchiveParameters = shouldArchiveParameters",
  "def setArchiveDir(self, dirName):\n        \"\"\"\n        Set-up archives for this MonteCarlo run\n\n        Args:\n            dirName: string\n                The name of the directory to archive runs in.\n                None, if no archive desired.\n        \"\"\"\n        self.archiveDir = os.path.abspath(dirName) + \"/\"\n        self.simParams.shouldArchiveParameters = dirName is not None\n        self.simParams.filename = self.archiveDir",
  "def setVarCast(self, varCast):\n        \"\"\"\n        Set the variable type to downcast the data to\n\n        :param varCast: 'float', 'integer', 'signed', 'unsigned' (see pandas.to_numeric documentation)\n        :return:\n        \"\"\"\n        self.varCast = varCast",
  "def setICDir(self, dirName):\n        \"\"\"\n        Set-up archives containing IC data\n\n        Args:\n            dirName: string\n                The name of the directory to archive runs in.\n                None, if no archive desired.\n        \"\"\"\n        self.icDirectory = os.path.abspath(dirName) + \"/\"\n        self.simParams.shouldArchiveParameters = True\n        self.simParams.icfilename = self.icDirectory",
  "def setICRunFlag(self, bool):\n        \"\"\"\n        Set the number of threads to use for the monte carlo simulation\n\n        Args:\n            threads: int\n                Number of threads to execute the montecarlo run on.\n        \"\"\"\n        self.ICrunFlag = bool",
  "def getRetainedData(self, case):\n        \"\"\"\n        Get the data that was retained for a run, or list of runs.\n\n        Args:\n            cases: int The desired case to get data from.\n        Returns:\n            The retained data for that run is returned.\n        \"\"\"\n        if self.ICrunFlag:\n            oldRunDataFile = self.icDirectory + \"run\" + str(case) + \".data\"\n        else:\n            oldRunDataFile = self.archiveDir + \"run\" + str(case) + \".data\"\n\n        with gzip.open(oldRunDataFile) as pickledData:\n            data = pickle.load(pickledData)\n            return data",
  "def getRetainedDatas(self, cases):\n        \"\"\"\n        Get the data that was retained for a list of runs.\n\n        Args:\n            cases: int[] The desired cases to get data from.\n        Returns:\n            A generator is returned, which will yield, in-order, the retained data for each of these cases\n        \"\"\"\n\n        for case in cases:\n            yield self.getRetainedData(case)",
  "def getParameters(self, caseNumber):\n        \"\"\"\n        Get the parameters used for a particular run of the montecarlo\n\n        :param caseNumber: The number of the run to get the parameters used for.\n        :type caseNumber: int\n\n        :return: A dictionary of the parameters of the simulation\n                 For example:\n                 {\"keyForSim\": parameterValue, 'TaskList[0].TaskModels[0].RNGSeed': 1674764759}\n        \"\"\"\n        if self.ICrunFlag:\n            filename = self.icDirectory + \"run\" + str(caseNumber) + \".json\"\n        else:\n            filename = self.archiveDir + \"run\" + str(caseNumber) + \".json\"\n        with open(filename, \"r\") as dispersionFile:\n            dispersions = json.load(dispersionFile)\n            return dispersions",
  "def reRunCases(self, caseList):\n        \"\"\"\n        Rerun some cases from a MonteCarlo run. Does not run in parallel\n\n        Args:\n            caseList: int[]\n                The list of runs to repeat, a list of numbers.\n        Returns:\n            failures: int[]\n                The list of failed runs.\n        \"\"\"\n        # the list of failures\n        failed = []\n\n        for caseNumber in caseList:\n            if self.simParams.verbose:\n                print(\"Rerunning\", caseNumber)\n\n            oldRunFile = self.archiveDir + \"run\" + str(caseNumber) + \".json\"\n            if not os.path.exists(oldRunFile):\n                print(\"ERROR re-running case: \" + oldRunFile)\n                continue\n\n            # use old simulation parameters, modified slightly.\n            simParams = copy.deepcopy(self.simParams)\n            simParams.index = caseNumber\n            # don't redisperse seeds, we want to use the ones saved in the oldRunFile\n            simParams.shouldDisperseSeeds = False\n            # don't retain any data so remove all retention policies\n            simParams.retentionPolicies = []\n\n            with open(oldRunFile, \"r\") as runParameters:\n                simParams.modifications = json.load(runParameters)\n\n            # execute simulation with dispersion\n            executor = SimulationExecutor()\n            success = executor([simParams, self.dataOutQueue])\n\n            if not success:\n                print(\"Error re-executing run\", caseNumber)\n                failed.append(caseNumber)\n\n        if len(failed) > 0:\n            failed.sort()\n            print(\"Failed rerunning cases:\", failed)\n\n        return failed",
  "def runInitialConditions(self, caseList):\n        \"\"\"\n        Run initial conditions given in a file\n\n        Args:\n            caseList: int[]\n                The list of runs to repeat, a list of numbers.\n        Returns:\n            failures: int[]\n                The list of failed runs.\n        \"\"\"\n        # the list of failures\n        failed = []\n\n        assert self.icDirectory != \"\", \"No initial condition directory was given\"\n        assert self.ICrunFlag is not False, \"IC run flag was not set\"\n\n        if self.simParams.verbose:\n            print(\"Beginning simulation with {0} runs on {1} threads\".format(self.executionCount, self.numProcess))\n\n        if self.simParams.shouldArchiveParameters:\n            if not os.path.exists(self.icDirectory):\n                print(\"Cannot run initial conditions: the directory given does not exist\")\n\n            if self.simParams.verbose:\n                print(\"Archiving a copy of this simulation before running it in 'MonteCarlo.data'\")\n            try:\n                with gzip.open(self.icDirectory + \"MonteCarlo.data\", \"w\") as pickleFile:\n                    pickle.dump(self, pickleFile)  # dump this controller object into a file.\n            except Exception as e:\n                print(\"Unknown exception while trying to pickle monte-carlo-controller... \\ncontinuing...\\n\\n\", e)\n\n        # Create Queue, but don't ever start it.\n        self.multiProcManager = mp.Manager()\n        self.dataOutQueue = self.multiProcManager.Queue()\n        self.dataWriter = DataWriter(self.dataOutQueue)\n        self.dataWriter.daemon = False\n\n        # If archiving the rerun data -- make sure not to delete the original data!\n        if self.archiveDir is not None:\n            if self.archiveDir != self.icDirectory:\n                if os.path.exists(self.archiveDir):\n                    shutil.rmtree(self.archiveDir)\n                os.mkdir(self.archiveDir)\n                self.dataWriter.setLogDir(self.archiveDir)\n                self.dataWriter.start()\n            else:\n                print(\"ERROR: The archive directory is set as the icDirectory. Proceeding would have overwriten all data \" \\\n                      \"within: \" + self.archiveDir + \" with the select rerun cases! Exiting.\\n\")\n                sys.exit(\"Change the archive directory to a new location when rerunning cases.\")\n        else:\n            print(\"No archive data specified; no data will be logged to dataframes\")\n\n        jobsFinished = 0  # keep track of what simulations have finished\n\n        # The simulation executor is responsible for executing simulation given a simulation's parameters\n        # It is called within worker threads with each worker's simulation parameters\n        simulationExecutor = SimulationExecutor()\n        #\n        progressBar = SimulationProgressBar(len(caseList), self.simParams.showProgressBar)\n        if self.numProcess == 1:  # don't make child thread\n            if self.simParams.verbose:\n                print(\"Executing sequentially...\")\n            i = 0\n            for i in range(len(caseList)):\n                simGenerator = self.generateICSims(caseList[i:i+1])\n                for sim in simGenerator:\n                    try:\n                        simulationExecutor([sim,  self.dataOutQueue])\n                    except:\n                        failed.append(i)\n                i += 1\n                progressBar.update(i)\n        else:\n            numSims = len(caseList)\n            if self.numProcess > numSims:\n                print(\"Fewer MCs spawned than processes assigned (%d < %d). Changing processes count to %d.\" % (numSims, self.numProcess, numSims))\n                self.numProcess = numSims\n            for i in range(numSims//self.numProcess):\n                # If number of sims doesn't factor evenly into the number of processes:\n                if numSims % self.numProcess != 0 and i == len(list(range(numSims//self.numProcess)))-1:\n                    offset = numSims % self.numProcess\n                else:\n                    offset = 0\n\n                simGenerator = self.generateICSims(caseList[self.numProcess*i:self.numProcess*(i+1)+offset])\n                pool = mp.Pool(self.numProcess)\n                try:\n                    # yields results *as* the workers finish jobs\n                    for result in pool.imap_unordered(simulationExecutor, [(x, self.dataOutQueue) for x in simGenerator]):\n                        if result[0] is not True:  # workers return True on success\n                            failed.append(result[1])  # add failed jobs to the list of failures\n                            print(\"Job\", result[1], \"failed...\")\n\n                        jobsFinished += 1\n                        progressBar.update(jobsFinished)\n                    pool.close()\n                except KeyboardInterrupt as e:\n                    print(\"Ctrl-C was hit, closing pool\")\n                    # failed.extend(range(jobsFinished, numSims))  # fail all potentially running jobs...\n                    pool.terminate()\n                    raise e\n                except Exception as e:\n                    print(\"Unknown exception while running simulations:\", e)\n                    # failed.extend(range(jobsFinished, numSims))  # fail all potentially running jobs...\n                    traceback.print_exc()\n                    pool.terminate()\n                finally:\n                    pool.join()\n\n        progressBar.markComplete()\n        progressBar.close()\n        # If the data was archiving, close the queue.\n        if self.archiveDir is not None and self.archiveDir != self.icDirectory:\n            while not self.dataOutQueue.empty():\n               time.sleep(1)\n            self.dataOutQueue.put((None, None, True))\n            time.sleep(5)\n\n        # if there are failures\n        if len(failed) > 0:\n            failed.sort()\n\n            if self.simParams.verbose:\n                print(\"Failed\", failed, \"saving to 'failures.txt'\")\n\n            if self.simParams.shouldArchiveParameters:\n                # write a file that contains log of failed runs\n                with open(self.icDirectory + \"failures.txt\", \"w\") as failFile:\n                    failFile.write(str(failed))\n\n        return failed",
  "def generateICSims(self, caseList):\n        \"\"\"\n        Generator function to clone a baseSimulation for IC run\n\n        Args:\n            baseSimulation: SimulationParams\n                A base simulation to clone.\n            numSims: int[]\n                The desired runs to generate.\n        Returns:\n            generator<SimulationParams>\n                A generator that yields that number of cloned simulations\n        \"\"\"\n\n        # make a list of simulations to execute by cloning the base-simulation and\n        # changing each clone's index and filename to make a list of\n        # simulations to execute\n        for caseNumber in caseList:\n            if self.simParams.verbose:\n                print(\"Running IC \", caseNumber)\n\n            oldRunFile = self.icDirectory + \"run\" + str(caseNumber) + \".json\"\n            if not os.path.exists(oldRunFile):\n                print(\"ERROR running IC case: \" + oldRunFile)\n                continue\n\n            # use old simulation parameters, modified slightly.\n            simParams = copy.deepcopy(self.simParams)\n            simParams.index = caseNumber\n            # don't redisperse seeds, we want to use the ones saved in the oldRunFile\n            simParams.shouldDisperseSeeds = False\n\n            simParams.icfilename = self.icDirectory + \"run\" + str(caseNumber)\n            with open(oldRunFile, \"r\") as runParameters:\n                simParams.modifications = json.load(runParameters)\n\n            yield simParams",
  "def generateSims(self, simNumList):\n        \"\"\"\n        Generator function to clone a baseSimulation\n\n        Args:\n            baseSimulation: SimulationParams\n                A base simulation to clone.\n            numSims: int[]\n                The desired runs to generate.\n        Returns:\n            generator<SimulationParams>\n                A generator that yields that number of cloned simulations\n        \"\"\"\n\n        # make a list of simulations to execute by cloning the base-simulation and\n        # changing each clone's index and filename to make a list of\n        # simulations to execute\n        for i in simNumList:\n            simClone = copy.deepcopy(self.simParams)\n            simClone.index = i\n            simClone.filename += \"run\" + str(i)\n\n            yield simClone",
  "def executeCallbacks(self, rng=None, retentionPolicies=[]):\n        \"\"\"\n        Execute retention policy callbacks after running a monteCarlo sim.\n\n        Args:\n            rng: A list of simulations to execute callbacks on\n            retentionPolicies: the retention policies to execute\n        \"\"\"\n\n        if rng is None:\n            rng = list(range(self.executionCount))\n\n        if retentionPolicies == []:\n            retentionPolicies = self.simParams.retentionPolicies\n\n        for simIndex in rng:\n            data = self.getRetainedData(simIndex)\n            for retentionPolicy in retentionPolicies:\n                retentionPolicy.executeCallback(data)",
  "def executeSimulations(self):\n        \"\"\"\n        Execute simulations in parallel\n\n        :return: failed: int[]\n                 A list of the indices of all failed simulation runs.\n        \"\"\"\n\n        if self.simParams.verbose:\n            print(\"Beginning simulation with {0} runs on {1} threads\".format(self.executionCount, self.numProcess))\n\n        if self.simParams.shouldArchiveParameters:\n            if os.path.exists(self.archiveDir):\n                shutil.rmtree(self.archiveDir, ignore_errors=True)\n            os.mkdir(self.archiveDir)\n            if self.simParams.verbose:\n                print(\"Archiving a copy of this simulation before running it in 'MonteCarlo.data'\")\n            try:\n                with gzip.open(self.archiveDir + \"MonteCarlo.data\", \"wb\") as pickleFile:\n                    pickle.dump(self, pickleFile)  # dump this controller object into a file.\n            except Exception as e:\n                print(\"Unknown exception while trying to pickle monte-carlo-controller... \\ncontinuing...\\n\\n\", e)\n\n        self.multiProcManager = mp.Manager()\n        self.dataOutQueue = self.multiProcManager.Queue()\n        self.dataWriter = DataWriter(self.dataOutQueue)\n        self.dataWriter.daemon = False\n\n        numSims = self.executionCount\n\n        # start data writer process\n        self.dataWriter.setLogDir(self.archiveDir)\n        self.dataWriter.setVarCast(self.varCast)\n        self.dataWriter.start()\n\n        # Avoid building a full list of all simulations to run in memory,\n        # instead only generating simulations right before they are needed by a waiting worker\n        # This is accomplished using a generator and pool.imap, -- simulations are only built\n        # when they are about to be passed to a worker, avoiding memory overhead of first building simulations\n        # There is a system-dependent chunking behavior, sometimes 10-20 are generated at a time.\n        # simGenerator = self.generateSims(range(numSims))\n        failed = []  # keep track of the indices of failed simulations\n        jobsFinished = 0  # keep track of what simulations have finished\n\n        # The simulation executor is responsible for executing simulation given a simulation's parameters\n        # It is called within worker threads with each worker's simulation parameters\n        simulationExecutor = SimulationExecutor()\n\n        progressBar = SimulationProgressBar(numSims, self.simParams.showProgressBar)\n\n        # The outermost for-loop for both the serial and multiprocessed sim generator is not necessary. It\n        # is a temporary fix to a memory leak which is assumed to be a result of the simGenerator not collecting\n        # garbage properly. # TODO: Find a more permenant solution to the leak.\n\n        if self.numProcess == 1:  # don't make child thread\n            if self.simParams.verbose:\n                print(\"Executing sequentially...\")\n            i = 0\n            for i in range(numSims):\n                simGenerator = self.generateSims(list(range(i,i+1)))\n                for sim in simGenerator:\n                    try:\n                        run_ok = simulationExecutor([sim, self.dataOutQueue])[0]\n                    except:\n                        failed.append(i)\n                    else:\n                        if not run_ok:\n                            failed.append(i)\n                    i += 1\n                    progressBar.update(i)\n        else:\n            if self.numProcess > numSims:\n                print(\"Fewer MCs spawned than processes assigned (%d < %d). Changing processes count to %d.\" % (numSims, self.numProcess, numSims))\n                self.numProcess = numSims\n            for i in range(numSims//self.numProcess):\n                # If number of sims doesn't factor evenly into the number of processes:\n                if numSims % self.numProcess != 0 and i == len(list(range(numSims//self.numProcess)))-1:\n                    offset = numSims % self.numProcess\n                else:\n                    offset = 0\n                simGenerator = self.generateSims(list(range(self.numProcess*i, self.numProcess*(i+1)+offset)))\n                pool = mp.Pool(self.numProcess)\n                try:\n                    # yields results *as* the workers finish jobs\n                    for result in pool.imap_unordered(simulationExecutor, [(x, self.dataOutQueue) for x in simGenerator]):\n                        if result[0] is not True:  # workers return True on success\n                            failed.append(result[1])  # add failed jobs to the list of failures\n                            print(\"Job\", result[1], \"failed...\")\n\n                        jobsFinished += 1\n                        progressBar.update(jobsFinished)\n                    pool.close()\n                except KeyboardInterrupt as e:\n                    print(\"Ctrl-C was hit, closing pool\")\n                    failed.extend(list(range(jobsFinished, numSims)))  # fail all potentially running jobs...\n                    pool.terminate()\n                    raise e\n                except Exception as e:\n                    print(\"Unknown exception while running simulations:\", e)\n                    failed.extend(list(range(jobsFinished, numSims)))  # fail all potentially running jobs...\n                    traceback.print_exc()\n                    pool.terminate()\n                finally:\n                    # Wait until all data is logged from the spawned runs before proceeding with the next set.\n                    pool.join()\n\n        progressBar.markComplete()\n        progressBar.close()\n        # Wait until all data logging is finished before concatenation dataframes and shutting down the pool\n        while not self.dataOutQueue.empty():\n           time.sleep(1)\n        self.dataOutQueue.put((None, None, True))\n        time.sleep(5)\n\n        # if there are failures\n        if len(failed) > 0:\n            failed.sort()\n\n            if self.simParams.verbose:\n                print(\"Failed\", failed, \"saving to 'failures.txt'\")\n\n            if self.simParams.shouldArchiveParameters:\n                # write a file that contains log of failed runs\n                with open(self.archiveDir + \"failures.txt\", \"w\") as failFile:\n                    failFile.write(str(failed))\n\n        return failed",
  "def __init__(self, creationFunction, executionFunction, configureFunction,\n                 retentionPolicies, dispersions, shouldDisperseSeeds,\n                 shouldArchiveParameters, filename, icfilename, index=None, verbose=False, modifications={},\n                 showProgressBar=False):\n        self.index = index\n        self.creationFunction = creationFunction\n        self.executionFunction = executionFunction\n        self.configureFunction = configureFunction\n        self.retentionPolicies = retentionPolicies\n        self.dispersions = dispersions\n        self.shouldDisperseSeeds = shouldDisperseSeeds\n        self.shouldArchiveParameters = shouldArchiveParameters\n        self.filename = filename\n        self.icfilename = icfilename\n        self.verbose = verbose\n        self.modifications = modifications\n        self.dispersionMag = {}\n        self.saveDispMag = False\n        self.showProgressBar = showProgressBar",
  "def __call__(cls, params):\n        \"\"\"\n        In each worker process, we execute this function (by calling this object)\n\n        Args:\n            params [simParams, data out queue]:\n                A SimulationParameters object for the simulation to be executed and the output data queue\n                for the data writer.\n        Returns:\n            success: bool\n                (True, simParams.index) if simulation run was successful\n                (False, simParams.index) if simulation run was unsuccessful\n        \"\"\"\n        simParams = params[0]\n        dataOutQueue = params[1]\n\n        try:\n            signal.signal(signal.SIGINT, signal.SIG_IGN)  # On ctrl-c ignore the signal... let the parent deal with it.\n\n            # must make new random seed on each new thread.\n            np.random.seed(simParams.index * 10)\n            random.seed(simParams.index * 10)\n\n            # create the users sim by calling their supplied creationFunction\n            simInstance = simParams.creationFunction()\n\n            # build a list of the parameter and random seed modifications to make\n            modifications = simParams.modifications\n            magnitudes = simParams.dispersionMag\n\n            # we may want to disperse random seeds\n            if simParams.shouldDisperseSeeds:\n                # generate the random seeds for the model (but don't apply them yet)\n                # Note: This sets the RNGSeeds before all other modifications\n                randomSeedDispersions = cls.disperseSeeds(simInstance)\n                for name, value in randomSeedDispersions.items():\n                    modifications[name] = value\n\n            # used if rerunning ICs from a .json file, modifications will contain the\n            # RNGSeeds that need to be set before selfInit()\n            cls.populateSeeds(simInstance, modifications)\n\n            # we may want to disperse parameters\n            for disp in simParams.dispersions:\n                try:\n                    name = disp.getName()\n                    if name not in modifications:  # could be using a saved parameter.\n                        modifications[name] = disp.generateString(simInstance)\n                        if simParams.saveDispMag:\n                            magnitudes[name] = disp.generateMagString()\n                except TypeError:\n                    # This accomodates dispersion variables that are co-dependent\n                    disp.generate()\n                    for i in range(1, disp.numberOfSubDisps+1):\n                        name = disp.getName(i)\n                        if name not in modifications:  # could be using a saved parameter.\n                            modifications[name] = disp.generateString(i, simInstance)\n                            if simParams.saveDispMag:\n                                magnitudes[name] = disp.generateMagString()\n\n            # if archiving, this run's parameters and random seeds are saved in its own json file\n            if simParams.shouldArchiveParameters:\n                # save the dispersions and random seeds for this run\n                if simParams.icfilename != \"\":\n                    with open(simParams.icfilename + \".json\", 'w') as outfile:\n                        json.dump(modifications, outfile)\n                else:\n                    with open(simParams.filename + \".json\", 'w') as outfile:\n                        json.dump(modifications, outfile)\n                    if simParams.saveDispMag:\n                        with open(simParams.filename + \"mag.txt\", 'w') as outfileMag:\n                            for k in sorted(magnitudes.keys()):\n                                outfileMag.write(\"'%s':'%s', \\n\" % (k, magnitudes[k]))\n\n            if simParams.configureFunction is not None:\n                if simParams.verbose:\n                    print(\"Configuring sim\")\n                simParams.configureFunction(simInstance)\n\n            # apply the dispersions and the random seeds\n            for variable, value in list(modifications.items()):\n                disperseStatement = \"simInstance.\" + variable + \"=\" + value\n                if simParams.verbose:\n                    print(\"Executing parameter modification -> \", disperseStatement)\n                exec(disperseStatement)\n\n            # setup data logging\n            if len(simParams.retentionPolicies) > 0:\n                if simParams.verbose:\n                    print(\"Adding retained data\")\n                RetentionPolicy.addRetentionPoliciesToSim(simInstance, simParams.retentionPolicies)\n\n            if simParams.verbose:\n                print(\"Executing simulation\")\n            # execute the simulation, with the user-supplied executionFunction\n            try:\n                simParams.executionFunction(simInstance)\n            except TypeError:\n                simParams.executionFunction(simInstance, simParams.filename)\n\n            if len(simParams.retentionPolicies) > 0:\n                if simParams.icfilename != \"\":\n                    retentionFile = simParams.icfilename + \".data\"\n                else:\n                    retentionFile = simParams.filename + \".data\"\n\n                if simParams.verbose:\n                    print(\"Retaining data for run in\", retentionFile)\n\n                retainedData = RetentionPolicy.getDataForRetention(simInstance, simParams.retentionPolicies)\n                dataOutQueue.put((retainedData, simParams.index, None))\n                time.sleep(1)\n\n                with gzip.open(retentionFile, \"w\") as archive:\n                    retainedData[\"index\"] = simParams.index # add run index\n                    pickle.dump(retainedData, archive)\n\n            if simParams.verbose:\n                print(\"Terminating simulation\")\n\n            if simParams.verbose:\n                print(\"Thread\", os.getpid(), \"Job\", simParams.index, \"finished successfully\")\n\n            return (True, simParams.index)  # this function returns true only if the simulation was successful\n\n        except Exception as e:\n            print(\"Error in worker thread\", e)\n            traceback.print_exc()\n            return (False, simParams.index)",
  "def disperseSeeds(simInstance):\n        \"\"\"\n        Disperses the RNG seeds of all the tasks in the sim, and returns a statement that contains the seeds.\n        Example return dictionary::\n\n             {\n                '.TaskList[0].TaskModels[1]': 1934586,\n                '.TaskList[0].TaskModels[2]': 3450093,\n                '.TaskList[1].TaskModels[0]': 2221934,\n                '.TaskList[2].TaskModels[0]': 1123244\n             }\n\n        :param simInstance: A basilisk simulation to set random seeds on\n        :type simInstance: SimulationBaseClass\n        :return: A dictionary with the random seeds that should be applied to the sim\n                        \"\"\"\n\n        randomSeeds = {}\n        for i, task in enumerate(simInstance.TaskList):\n            for j, model in enumerate(task.TaskModels):\n                taskVar = 'TaskList[' + str(i) + '].TaskModels' + '[' + str(j) + '].RNGSeed'\n                rand = str(random.randint(0, 1 << 32 - 1))\n                try:\n                    execStatement = \"simInstance.\" + taskVar + \"=\" + str(rand)\n                    exec(execStatement)  # if this fails don't add to the list of modification\n                    randomSeeds[taskVar] = rand\n                except:\n                    pass\n        return randomSeeds",
  "def populateSeeds(simInstance, modifications):\n        \"\"\"\n        only populate the RNG seeds of all the tasks in the sim\n\n        Args:\n            simInstance: SimulationBaseClass\n                A basilisk simulation to set random seeds on\n            modifications:\n                A dictionary containing RNGSeeds to be populate for the sim, among other sim modifications.\n        \"\"\"\n        for variable, value in modifications.items():\n            if \".RNGSeed\" in variable:\n                rngStatement = \"simInstance.\" + variable + \"=\" + value\n                exec(rngStatement)",
  "def myCreationFunction():\n    \"\"\" function that returns a simulation \"\"\"\n    #  Create a sim module as an empty container\n    sim = SimulationBaseClass.SimBaseClass()\n\n    # Create simulation variable names\n    simTaskName = \"simTask\"\n    simProcessName = \"simProcess\"\n\n    # Create the simulation process\n    dynProcess = sim.CreateNewProcess(simProcessName)\n\n    # Create the dynamics task and specify the integration update time\n    simulationTimeStep = macros.sec2nano(10.)\n    dynProcess.addTask(sim.CreateNewTask(simTaskName, simulationTimeStep))\n\n    # Setup the simulation modules\n    # Initialize spacecraft object and set properties\n    scObject = spacecraft.Spacecraft()\n    scObject.ModelTag = \"bsk-Sat\"\n    # Add spacecraft object to the simulation process\n    sim.AddModelToTask(simTaskName, scObject)\n\n    # Setup Earth gravity body and attach gravity model to spacecraft\n    gravFactory = simIncludeGravBody.gravBodyFactory()\n    planet = gravFactory.createEarth()\n    planet.isCentralBody = True\n    planet.useSphericalHarmParams = True\n    simIncludeGravBody.loadGravFromFile(bskPath + '/supportData/LocalGravData/GGM03S-J2-only.txt'\n                                        , planet.spherHarm\n                                        , 2\n                                        )\n    scObject.gravField.gravBodies = spacecraft.GravBodyVector([planet])\n\n    # Setup the orbit using classical orbit elements\n    oe = orbitalMotion.ClassicElements()\n    rGEO = 42000. * 1000  # meters\n    oe.a = rGEO\n    oe.e = 0.00001\n    oe.i = 0.0 * macros.D2R\n    oe.Omega = 48.2 * macros.D2R\n    oe.omega = 347.8 * macros.D2R\n    oe.f = 85.3 * macros.D2R\n    rN, vN = orbitalMotion.elem2rv(planet.mu, oe)  # this stores consistent initial orbit elements\n    oe = orbitalMotion.rv2elem(planet.mu, rN, vN)  # with circular or equatorial orbit, some angles are arbitrary\n\n    #   initialize Spacecraft States with the initialization variables\n    scObject.hub.r_CN_NInit = rN  # m   - r_BN_N\n    scObject.hub.v_CN_NInit = vN  # m/s - v_BN_N\n\n    # set the simulation time\n    mean_motion = np.sqrt(planet.mu / oe.a / oe.a / oe.a)\n    period = 2. * np.pi / mean_motion\n    simulationTime = macros.sec2nano(period / 4)\n\n    sim.msgRecList = {}\n    sim.msgRecList[retainedMessageName] = scObject.scStateOutMsg.recorder(retainedRate)\n    sim.AddModelToTask(simTaskName, sim.msgRecList[retainedMessageName])\n\n    #   configure a simulation stop time and execute the simulation run\n    sim.ConfigureStopTime(simulationTime)\n\n    return sim",
  "def myExecutionFunction(sim):\n    \"\"\" function that executes a simulation \"\"\"\n    sim.InitializeSimulation()\n    sim.ExecuteSimulation()",
  "def myDataCallback(monteCarloData, retentionPolicy):\n    data = np.array(monteCarloData[\"messages\"][retainedMessageName + \".r_BN_N\"])\n    plt.plot(data[:, 1], data[:, 2], colorList[monteCarloData[\"index\"]], label=\"run \" + str(monteCarloData[\"index\"]))\n    plt.xlabel('X-coordinate')\n    plt.ylabel('Y-coordinate')\n    plt.legend()",
  "def test_MonteCarloSimulation(show_plots):\n    # Test a montecarlo simulation\n    dirName = os.path.abspath(os.path.dirname(__file__)) + \"/tmp_montecarlo_test\"\n    monteCarlo = Controller()\n    monteCarlo.setShouldDisperseSeeds(True)\n    monteCarlo.setExecutionFunction(myExecutionFunction)\n    monteCarlo.setSimulationFunction(myCreationFunction)\n    monteCarlo.setExecutionCount(NUMBER_OF_RUNS)\n    monteCarlo.setThreadCount(PROCESSES)\n    monteCarlo.setVerbose(True)\n    monteCarlo.setArchiveDir(dirName)\n\n    # Add some dispersions\n    disp1Name = 'TaskList[0].TaskModels[0].hub.sigma_BNInit'\n    disp2Name = 'TaskList[0].TaskModels[0].hub.omega_BN_BInit'\n    disp3Name = 'TaskList[0].TaskModels[0].hub.mHub'\n    disp4Name = 'TaskList[0].TaskModels[0].hub.r_BcB_B'\n    disp5Name = 'TaskList[0].TaskModels[0].hub.r_CN_NInit'\n    disp6Name = 'TaskList[0].TaskModels[0].hub.v_CN_NInit'\n    dispDict = {}\n    dispDict[\"mu\"] = 0.3986004415E+15\n    dispDict[\"a\"] = [\"normal\", 42000 * 1E3, 2000 * 1E3]\n    dispDict[\"e\"] = [\"uniform\", 0, 0.5]\n    dispDict[\"i\"] = [\"uniform\", -80, 80]\n    dispDict[\"Omega\"] = None\n    dispDict[\"omega\"] = [\"uniform\", 80, 90]\n    dispDict[\"f\"] = [\"uniform\", 0, 359]\n    monteCarlo.addDispersion(OrbitalElementDispersion(disp5Name, disp6Name, dispDict))\n    monteCarlo.addDispersion(UniformEulerAngleMRPDispersion(disp1Name))\n    monteCarlo.addDispersion(NormalVectorCartDispersion(disp2Name, 0.0, 0.75 / 3.0 * np.pi / 180))\n    monteCarlo.addDispersion(UniformDispersion(disp3Name, ([1300.0 - 812.3, 1500.0 - 812.3])))\n    monteCarlo.addDispersion(\n        NormalVectorCartDispersion(disp4Name, [0.0, 0.0, 1.0], [0.05 / 3.0, 0.05 / 3.0, 0.1 / 3.0]))\n\n    # Add retention policy\n    retentionPolicy = RetentionPolicy()\n    retentionPolicy.addMessageLog(retainedMessageName, [var1, var2])\n    retentionPolicy.setDataCallback(myDataCallback)\n    monteCarlo.addRetentionPolicy(retentionPolicy)\n\n    failures = monteCarlo.executeSimulations()\n\n    assert len(failures) == 0, \"No runs should fail\"\n\n    # Test loading data from runs from disk\n    monteCarloLoaded = Controller.load(dirName)\n\n    retainedData = monteCarloLoaded.getRetainedData(NUMBER_OF_RUNS-1)\n    assert retainedData is not None, \"Retained data should be available after execution\"\n    assert \"messages\" in retainedData, \"Retained data should retain messages\"\n    assert retainedMessageName + \".r_BN_N\" in retainedData[\"messages\"], \"Retained messages should exist\"\n    assert retainedMessageName + \".v_BN_N\" in retainedData[\"messages\"], \"Retained messages should exist\"\n\n    # rerun the case and it should be the same, because we dispersed random seeds\n    oldOutput = retainedData[\"messages\"][retainedMessageName + \".r_BN_N\"]\n\n    failed = monteCarloLoaded.reRunCases([NUMBER_OF_RUNS-1])\n    assert len(failed) == 0, \"Should rerun case successfully\"\n\n    retainedData = monteCarloLoaded.getRetainedData(NUMBER_OF_RUNS-1)\n    newOutput = retainedData[\"messages\"][retainedMessageName + \".r_BN_N\"]\n    for k1, v1 in enumerate(oldOutput):\n        for k2, v2 in enumerate(v1):\n            assert np.fabs(oldOutput[k1][k2] - newOutput[k1][k2]) < .001, \\\n            \"Outputs shouldn't change on runs if random seeds are same\"\n\n    # test the initial parameters were saved from runs, and they differ between runs\n    params1 = monteCarloLoaded.getParameters(NUMBER_OF_RUNS-1)\n    params2 = monteCarloLoaded.getParameters(NUMBER_OF_RUNS-2)\n    assert \"TaskList[0].TaskModels[0].RNGSeed\" in params1, \"random number seed should be applied\"\n    for dispName in [disp1Name, disp2Name, disp3Name, disp4Name]:\n        assert dispName in params1, \"dispersion should be applied\"\n        # assert two different runs had different parameters.\n        assert params1[dispName] != params2[dispName], \"dispersion should be different in each run\"\n\n    monteCarloLoaded.executeCallbacks()\n    if show_plots:\n        plt.show()\n\n    shutil.rmtree(dirName)\n    assert not os.path.exists(dirName), \"No leftover data should exist after the test\""
]