[
  "def loadDDDigi():\n  global logger\n  import ROOT\n  import dd4hep_base\n  from ROOT import gSystem\n\n  logger = dd4hep_base.dd4hep_logger('dddigi')\n\n  # Try to load libglapi to avoid issues with TLS Static\n  # Turn off all errors from ROOT about the library missing\n  if 'libglapi' not in gSystem.GetLibraries():\n    orgLevel = ROOT.gErrorIgnoreLevel\n    ROOT.gErrorIgnoreLevel = 6000\n    gSystem.Load(\"libglapi\")\n    ROOT.gErrorIgnoreLevel = orgLevel\n\n  import os\n  import platform\n  if platform.system() == \"Darwin\":\n    gSystem.SetDynamicPath(os.environ['DD4HEP_LIBRARY_PATH'])\n  #\n  # load with ROOT the DDDigi plugin library, which in turn loads the DDigi module\n  result = gSystem.Load(\"libDDDigiPlugins\")\n  if result < 0:\n    raise Exception('DDDigi.py: Failed to load the DDDigi library libDDDigiPlugins: ' + gSystem.GetErrorStr())\n  logger.info('DDDigi.py: Successfully loaded DDDigi plugin library libDDDigiPlugins!')\n  #\n  # import with ROOT the I/O module to read DDG4 output\n  result = gSystem.Load(\"libDDDigi_IO\")\n  if result < 0:\n    raise Exception('DDDigi.py: Failed to load the DDDigi IO library libDDDigi_IO: ' + gSystem.GetErrorStr())\n  logger.info('DDDigi.py: Successfully loaded DDDigi IO plugin library libDDDigi_IO!')\n  #\n  # import the main dd4hep module from ROOT\n  from ROOT import dd4hep as module\n  return module",
  "def _import_class(ns, nam):\n  scope = getattr(current, ns)\n  setattr(current, nam, getattr(scope, nam))",
  "def _constant(self, name):\n  return self.constantAsString(name)",
  "def importConstants(description, namespace=None, debug=False):\n  \"\"\"\n  Import the Detector constants into the dddigi namespace\n  \"\"\"\n  ns = current\n  if namespace is not None and not hasattr(current, namespace):\n    import imp\n    m = imp.new_module('dddigi.' + namespace)\n    setattr(current, namespace, m)\n    ns = m\n  evaluator = dd4hep.g4Evaluator()\n  cnt = 0\n  num = 0\n  todo = {}\n  strings = {}\n  for c in description.constants():\n    if c.second.dataType == 'string':\n      strings[c.first] = c.second.GetTitle()\n    else:\n      todo[c.first] = c.second.GetTitle().replace('(int)', '')\n  while len(todo) and cnt < 100:\n    cnt = cnt + 1\n    if cnt == 100:\n      logger.info('%s %d out of %d %s \"%s\": [%s]\\n+++ %s' %\n                  ('+++ FAILED to import',\n                   len(todo), len(todo) + num,\n                   'global values into namespace',\n                   ns.__name__, 'Try to continue anyway', 100 * '=',))\n      for k, v in todo.items():\n        if not hasattr(ns, k):\n          logger.info('+++ FAILED to import: \"' + k + '\" = \"' + str(v) + '\"')\n      logger.info('+++ %s' % (100 * '=',))\n\n    for k, v in todo.items():\n      if not hasattr(ns, k):\n        val = evaluator.evaluate(v)\n        status = evaluator.status()\n        if status == 0:\n          evaluator.setVariable(k, val)\n          setattr(ns, k, val)\n          if debug:\n            logger.info('Imported global value: \"' + k + '\" = \"' + str(val) + '\" into namespace' + ns.__name__)\n          del todo[k]\n          num = num + 1\n  if cnt < 100:\n    logger.info('+++ Imported %d global values to namespace:%s' % (num, ns.__name__),)",
  "def TestAction(kernel, nam, sleep=0):\n  obj = Interface.createAction(kernel, str('DigiTestAction/' + nam))\n  if sleep != 0:\n    obj.sleep = sleep\n  return obj",
  "def Action(kernel, nam, **options):\n  action = Interface.createAction(kernel, str(nam))\n  for option in options.items():\n    setattr(action, option[0], option[1])\n  return action",
  "def _get_action(self):\n  \" Convert handles to action references to access underlying properties provided a dictionary exists. \"\n  return Interface.toAction(self)",
  "def _adopt_property(self, action, foreign_name, local_name=None):\n  proc = _get_action(action)\n  if not local_name:\n    local_name = foreign_name\n  _get_action(self).adopt_property(proc, str(foreign_name), str(local_name))",
  "def _add_new_property(self, name, value):\n  Interface.addProperty(_get_action(self), str(name), value)",
  "def _add_new_position_property(self, name, value):\n  Interface.addPositionProperty(_get_action(self), str(name), str(value))",
  "def _add_new_set_property(self, name, value):\n  Interface.addSetProperty(_get_action(self), str(name), value)",
  "def _add_new_list_property(self, name, value):\n  Interface.addListProperty(_get_action(self), str(name), value)",
  "def _add_new_vector_property(self, name, value):\n  Interface.addVectorProperty(_get_action(self), str(name), value)",
  "def _add_new_mapped_property(self, name, value):\n  Interface.addMappedProperty(_get_action(self), str(name), value)",
  "def _kernel_terminate(self):\n  return self.get().terminate()",
  "def _default_adopt(self, action):\n  getattr(self, '__adopt')(action.get())",
  "def _adopt_event_action(self, action):\n  \" Helper to convert DigiActions objects to DigiEventAction \"\n  proc = Interface.toEventAction(_get_action(action))\n  attr = getattr(self, '__adopt')\n  attr(proc)",
  "def _adopt_container_processor(self, action, processor_argument):\n  \" Helper to convert DigiActions objects to DigiEventAction \"\n  parent = Interface.toContainerSequenceAction(_get_action(self))\n  attr = getattr(parent, 'adopt_processor')\n  proc = Interface.toContainerProcessor(_get_action(action))\n  attr(proc, processor_argument)",
  "def _adopt_segment_processor(self, action, processor_argument):\n  \" Helper to convert DigiActions objects to DigiEventAction \"\n  attr = getattr(_get_action(self), '__adopt_segment_processor')\n  proc = Interface.toContainerProcessor(_get_action(action))\n  attr(proc, processor_argument)",
  "def _adopt_sequence_action(self, name, **options):\n  \" Helper to adopt DigiAction objects for DigiSynchronize \"\n  kernel = Interface.createKernel(_get_action(self))\n  action = Action(kernel, name)\n  for option in options.items():\n    setattr(action, option[0], option[1])\n  self.adopt(action)\n  return action",
  "def _adopt_processor(self, action, containers):\n  proc = Interface.toContainerProcessor(_get_action(action))\n  attr = getattr(_get_action(self), '__adopt_processor')\n  attr(proc, containers)",
  "def _get(self, name):\n  a = Interface.toAction(self)\n  ret = Interface.getProperty(a, name)\n  if ret.status > 0:\n    # print('Property: %s = %s [%s]' % (name, str(ret.data), str(ret.data.__class__),))\n    v = ret.data\n    try:\n      v = eval(v)\n    except TypeError:\n      pass\n    finally:\n      pass\n    return v\n  elif hasattr(a, name):\n    return getattr(a, name)\n  # elif a.__class__ != self.__class__ and hasattr(a, name):\n  #   return getattr(a, name)\n  msg = 'DigiAction::GetProperty [Unhandled]: Cannot access property ' + a.name() + '.' + str(name)\n  raise KeyError(msg)",
  "def _set(self, name, value):\n  \"\"\"This function is called when properties are passed to the c++ objects.\"\"\"\n  import dd4hep as dd4hep\n  act = _get_action(self)\n  nam = dd4hep.unicode_2_string(name)\n  if isinstance(value, str):\n    val = dd4hep.unicode_2_string(value)\n  else:\n    val = str(value)\n  if Interface.setProperty(act, nam, val):\n    return\n  msg = 'DigiAction::SetProperty [Unhandled]: Cannot set ' + act.name() + '.' + str(name) + ' = ' + str(value)\n  raise KeyError(msg)",
  "def _props(obj, **extensions):\n  from dd4hep_base import debug as dd4hep_debug\n  _import_class('digi', obj)\n  cls = getattr(current, obj)\n  for extension in extensions.items():\n    call = extension[0]\n    # print('TRY: Overloading: ' + str(cls) + ' ' + call + ' to __' + call + ' ' + str(hasattr(cls, call)))\n    if hasattr(cls, call):\n      # print('Overloading: ' + str(cls) + ' ' + call + ' to __' + call)\n      setattr(cls, '__' + call, getattr(cls, call))\n    else:\n      dd4hep_debug('FAILED', 'Overloading: ' + str(cls) + ' ' + call + ' to __' + call + ' ' + str(hasattr(cls, call)))\n    setattr(cls, call, extension[1])\n  cls.__getattr__ = _get\n  cls.__setattr__ = _set\n  return cls",
  "class Digitize(dd4hep.Logger, dd4hep.CommandLine):\n  \"\"\"\n   Helper object to perform stuff, which occurs very often.\n   I am sick of typing the same over and over again.\n   Hence, I grouped often used python fragments to this small\n   class to re-usage.\n\n   Long live laziness!\n\n\n   \\author  M.Frank\n   \\version 1.0\n\n    #import pdb\n    #pdb.set_trace()\n\n  \"\"\"\n  def __init__(self, kernel=None):\n    dd4hep.Logger.__init__(self, 'dddigi')\n    dd4hep.CommandLine.__init__(self)\n    self._kernel = kernel\n    self._main_processor = None\n    self._input_processor = None\n    self._event_processor = None\n    self._parallel = True\n    self._dddigi = dddigi\n    self.description = self._kernel.detectorDescription()\n    if self.output_level:\n      lvl = int(self.output_level)\n      self.setPrintLevel(lvl)\n      self._kernel.OutputLevel = lvl\n\n  \"\"\"\n     Access the worker kernel object.\n\n     \\author  M.Frank\n  \"\"\"\n\n  def kernel(self):\n    return self._kernel\n\n  def create_action(self, name, **options):\n    action = dddigi.Action(self._kernel, name)\n    for option in options.items():\n      setattr(action, option[0], option[1])\n    return action\n\n  def main_sequencer(self):\n    \"\"\"\n    Create main digitization sequencer\n    \"\"\"\n    if not self._main_processor:\n      self._main_processor = self.create_action('DigiSynchronize/MainDigitizer', parallel=self._parallel)\n      self._main_processor.parallel = self._parallel\n    return self._main_processor\n\n  def input_action(self, name=None, **options):\n    \"\"\"\n    Append a new action to the kernel's main input action sequence\n    \"\"\"\n    if not self._input_processor:\n      self._input_processor = self._kernel.inputAction()\n      self._input_processor.parallel = self._parallel\n\n    if not name:\n      return self._input_processor\n\n    act = self.create_action(name, **options)\n    self._input_processor.adopt(act)\n    return act\n\n  def event_action(self, name=None, register=True, **options):\n    \"\"\"\n    Append a new action to the kernel's main event action sequence\n    \"\"\"\n    if not self._event_processor:\n      self._event_processor = self._kernel.eventAction()\n      self._event_processor.parallel = self._parallel\n\n    if not name:\n      return self._event_processor\n\n    action = self.create_action(name, **options)\n    if register:\n      self._event_processor.adopt(action)\n    return action\n\n  def output_action(self, name=None, **options):\n    \"\"\"\n    Append a new action to the kernel's main output action sequence\n    \"\"\"\n    if not self._output_processor:\n      self._output_processor = self._kernel.outputAction()\n      self._output_processor.parallel = self._parallel\n\n    if not name:\n      return self._output_processor\n\n    act = self.create_action(name, **options)\n    self._output_processor.adopt(act)\n    return act\n\n  def events_done(self):\n    \"\"\"\n    Access the number of events which finished processing\n    \"\"\"\n    return self.kernel().events_done()\n\n  def events_submitted(self):\n    \"\"\"\n    Access the number of submitted events\n    \"\"\"\n    return self.kernel().events_submitted()\n\n  def events_processing(self):\n    \"\"\"\n    Access the currently number of processing events (events in-flight)\n    \"\"\"\n    return self.kernel().events_processing()\n\n  \"\"\"\n     Execute the Geant 4 program with all steps.\n\n     \\author  M.Frank\n  \"\"\"\n  def execute(self):\n    self.kernel().configure()\n    self.kernel().initialize()\n    self.kernel().run()\n    done = self.kernel().events_done()\n    self.kernel().terminate()\n    return done\n\n  def activeDetectors(self):\n    detectors = []\n    for i in self.description.detectors():\n      o = dd4hep.DetElement(i.second.ptr())  # noqa: F405\n      sd = self.description.sensitiveDetector(o.name())\n      if sd.isValid():\n        d = {'name': o.name(), 'type': sd.type(), 'detector': o, 'sensitive': sd}\n        detectors.append(d)\n    return detectors\n\n  def printDetectors(self):\n    self.info('+++  List of sensitive detectors:')\n    dets = self.activeDetectors()\n    for d in dets:\n      self.always('+++  %-32s ---> type:%-12s' % (d['name'], d['type'],))\n\n  \"\"\"\n     Configure ROOT output for the event digitization\n\n     \\author  M.Frank\n  \"\"\"\n  def setupROOTOutput(self, name, output, mc_truth=True):\n    evt_root = dddigi.EventAction(self.kernel(), 'DigiOutput2ROOT/' + name, True)  # noqa: F405\n    evt_root.HandleMCTruth = mc_truth\n    evt_root.Control = True\n    if not output.endswith('.root'):\n      output = output + '.root'\n    evt_root.Output = output\n    evt_root.enableUI()\n    self.kernel().eventAction().add(evt_root)\n    return evt_root\n\n  \"\"\"\n     Execute the main Digi action\n     \\author  M.Frank\n  \"\"\"\n  def run(self, num_events, num_threads, parallel):\n    krnl = self.kernel()\n    krnl.numEvents = num_events\n    krnl.numThreads = num_threads   # = number of concurrent threads\n    krnl.maxEventsParallel = parallel\n    krnl.configure()\n    krnl.initialize()\n    krnl.run()\n    return krnl.events_done()",
  "def __init__(self, kernel=None):\n    dd4hep.Logger.__init__(self, 'dddigi')\n    dd4hep.CommandLine.__init__(self)\n    self._kernel = kernel\n    self._main_processor = None\n    self._input_processor = None\n    self._event_processor = None\n    self._parallel = True\n    self._dddigi = dddigi\n    self.description = self._kernel.detectorDescription()\n    if self.output_level:\n      lvl = int(self.output_level)\n      self.setPrintLevel(lvl)\n      self._kernel.OutputLevel = lvl",
  "def kernel(self):\n    return self._kernel",
  "def create_action(self, name, **options):\n    action = dddigi.Action(self._kernel, name)\n    for option in options.items():\n      setattr(action, option[0], option[1])\n    return action",
  "def main_sequencer(self):\n    \"\"\"\n    Create main digitization sequencer\n    \"\"\"\n    if not self._main_processor:\n      self._main_processor = self.create_action('DigiSynchronize/MainDigitizer', parallel=self._parallel)\n      self._main_processor.parallel = self._parallel\n    return self._main_processor",
  "def input_action(self, name=None, **options):\n    \"\"\"\n    Append a new action to the kernel's main input action sequence\n    \"\"\"\n    if not self._input_processor:\n      self._input_processor = self._kernel.inputAction()\n      self._input_processor.parallel = self._parallel\n\n    if not name:\n      return self._input_processor\n\n    act = self.create_action(name, **options)\n    self._input_processor.adopt(act)\n    return act",
  "def event_action(self, name=None, register=True, **options):\n    \"\"\"\n    Append a new action to the kernel's main event action sequence\n    \"\"\"\n    if not self._event_processor:\n      self._event_processor = self._kernel.eventAction()\n      self._event_processor.parallel = self._parallel\n\n    if not name:\n      return self._event_processor\n\n    action = self.create_action(name, **options)\n    if register:\n      self._event_processor.adopt(action)\n    return action",
  "def output_action(self, name=None, **options):\n    \"\"\"\n    Append a new action to the kernel's main output action sequence\n    \"\"\"\n    if not self._output_processor:\n      self._output_processor = self._kernel.outputAction()\n      self._output_processor.parallel = self._parallel\n\n    if not name:\n      return self._output_processor\n\n    act = self.create_action(name, **options)\n    self._output_processor.adopt(act)\n    return act",
  "def events_done(self):\n    \"\"\"\n    Access the number of events which finished processing\n    \"\"\"\n    return self.kernel().events_done()",
  "def events_submitted(self):\n    \"\"\"\n    Access the number of submitted events\n    \"\"\"\n    return self.kernel().events_submitted()",
  "def events_processing(self):\n    \"\"\"\n    Access the currently number of processing events (events in-flight)\n    \"\"\"\n    return self.kernel().events_processing()",
  "def execute(self):\n    self.kernel().configure()\n    self.kernel().initialize()\n    self.kernel().run()\n    done = self.kernel().events_done()\n    self.kernel().terminate()\n    return done",
  "def activeDetectors(self):\n    detectors = []\n    for i in self.description.detectors():\n      o = dd4hep.DetElement(i.second.ptr())  # noqa: F405\n      sd = self.description.sensitiveDetector(o.name())\n      if sd.isValid():\n        d = {'name': o.name(), 'type': sd.type(), 'detector': o, 'sensitive': sd}\n        detectors.append(d)\n    return detectors",
  "def printDetectors(self):\n    self.info('+++  List of sensitive detectors:')\n    dets = self.activeDetectors()\n    for d in dets:\n      self.always('+++  %-32s ---> type:%-12s' % (d['name'], d['type'],))",
  "def setupROOTOutput(self, name, output, mc_truth=True):\n    evt_root = dddigi.EventAction(self.kernel(), 'DigiOutput2ROOT/' + name, True)  # noqa: F405\n    evt_root.HandleMCTruth = mc_truth\n    evt_root.Control = True\n    if not output.endswith('.root'):\n      output = output + '.root'\n    evt_root.Output = output\n    evt_root.enableUI()\n    self.kernel().eventAction().add(evt_root)\n    return evt_root",
  "def run(self, num_events, num_threads, parallel):\n    krnl = self.kernel()\n    krnl.numEvents = num_events\n    krnl.numThreads = num_threads   # = number of concurrent threads\n    krnl.maxEventsParallel = parallel\n    krnl.configure()\n    krnl.initialize()\n    krnl.run()\n    return krnl.events_done()",
  "def loadDDRec():\n  from ROOT import gSystem\n  result = gSystem.Load(\"libDDRec\")\n  if result < 0:\n    raise Exception('DDG4.py: Failed to load the DDG4 library libDDRec: ' + gSystem.GetErrorStr())\n  from ROOT import dd4hep as module\n  core.rec = module.rec\n  return module.rec",
  "def import_namespace_item(ns, nam):\n  scope = getattr(name_space, ns)\n  attr = getattr(scope, nam)\n  setattr(name_space, nam, attr)\n  return attr",
  "def import_rec():\n  import_namespace_item('rec', 'CellIDPositionConverter')\n\n  import_namespace_item('rec', 'FixedPadSizeTPCStruct')\n\n  import_namespace_item('rec', 'ZPlanarStruct')\n  import_namespace_item('rec', 'ZPlanarStruct::LayerLayout')\n\n  import_namespace_item('rec', 'ZDiskPetalsStruct')\n  import_namespace_item('rec', 'ZDiskPetalsStruct::LayerLayout')\n\n  import_namespace_item('rec', 'ConicalSupportStruct')\n\n  import_namespace_item('rec', 'LayeredCalorimeterStruct')\n  import_namespace_item('rec', 'LayeredCalorimeterStruct::Layer')\n\n  import_namespace_item('rec', 'NeighbourSurfacesStruct')\n  import_namespace_item('rec', 'DetectorSurfaces')\n\n  import_namespace_item('rec', 'IMaterial')\n  import_namespace_item('rec', 'ISurface')\n  import_namespace_item('rec', 'ICylinder')\n  import_namespace_item('rec', 'ICone')\n  import_namespace_item('rec', 'SurfaceType')\n  import_namespace_item('rec', 'MaterialData')\n  import_namespace_item('rec', 'MaterialManager')\n  import_namespace_item('rec', 'VolSurfaceBase')\n  import_namespace_item('rec', 'VolSurface')\n  import_namespace_item('rec', 'VolSurfaceList')\n  import_namespace_item('rec', 'VolPlaneImpl')\n  import_namespace_item('rec', 'VolCylinderImpl')\n  import_namespace_item('rec', 'VolConeImpl')\n  import_namespace_item('rec', 'Surface')\n  import_namespace_item('rec', 'CylinderSurface')\n  import_namespace_item('rec', 'ConeSurface')\n  import_namespace_item('rec', 'SurfaceList')\n  import_namespace_item('rec', 'Vector2D')\n  import_namespace_item('rec', 'Vector3D')\n  import_namespace_item('rec', 'SurfaceManager')\n\n  import_namespace_item('rec', 'FixedPadSizeTPCData')\n  import_namespace_item('rec', 'ZPlanarData')\n  import_namespace_item('rec', 'ZDiskPetalsData')\n  import_namespace_item('rec', 'ConicalSupportData')\n  import_namespace_item('rec', 'LayeredCalorimeterData')\n  import_namespace_item('rec', 'NeighbourSurfacesData')",
  "def dumpData(det):\n  try:\n    dat = DDRec.FixedPadSizeTPCData(det)\n    logger.info(dat.toString())\n  except Exception:\n    pass\n  try:\n    dat = DDRec.ZPlanarData(det)\n    logger.info(dat.toString())\n  except Exception:\n    pass\n  try:\n    dat = DDRec.ZDiskPetalsData(det)\n    logger.info(dat.toString())\n  except Exception:\n    pass\n  try:\n    dat = DDRec.ConicalSupportData(det)\n    logger.info(dat.toString())\n  except Exception:\n    pass\n  try:\n    dat = DDRec.LayeredCalorimeterData(det)\n    logger.info(dat.toString())\n  except Exception:\n    pass\n  try:\n    dat = DDRec.NeighbourSurfacesStruct(det)\n    logger.info(dat.toString())\n  except Exception:\n    pass",
  "def loadDDG4():\n  import ROOT\n  from ROOT import gSystem\n\n  # Try to load libglapi to avoid issues with TLS Static\n  # Turn off all errors from ROOT about the library missing\n  if 'libglapi' not in gSystem.GetLibraries():\n    orgLevel = ROOT.gErrorIgnoreLevel\n    ROOT.gErrorIgnoreLevel = 6000\n    gSystem.Load(\"libglapi\")\n    ROOT.gErrorIgnoreLevel = orgLevel\n\n  import platform\n  import os\n  if platform.system() == \"Darwin\":\n    gSystem.SetDynamicPath(os.environ['DD4HEP_LIBRARY_PATH'])\n    os.environ['DYLD_LIBRARY_PATH'] = os.pathsep.join([os.environ['DD4HEP_LIBRARY_PATH'],\n                                                       os.environ.get('DYLD_LIBRARY_PATH', '')]).strip(os.pathsep)\n\n  result = gSystem.Load(\"libDDG4Plugins\")\n  if result < 0:\n    raise Exception('DDG4.py: Failed to load the DDG4 library libDDG4Plugins: ' + gSystem.GetErrorStr())\n  from ROOT import dd4hep as module\n  return module",
  "def _import_class(ns, nam):\n  scope = getattr(current, ns)\n  setattr(current, nam, getattr(scope, nam))",
  "def _constant(self, name):\n  return self.constantAsString(name)",
  "def importConstants(description, namespace=None, debug=False):\n  \"\"\"\n  Import the Detector constants into the DDG4 namespace\n  \"\"\"\n  ns = current\n  if namespace is not None and not hasattr(current, namespace):\n    import imp\n    m = imp.new_module('DDG4.' + namespace)\n    setattr(current, namespace, m)\n    ns = m\n  evaluator = dd4hep.g4Evaluator()\n  cnt = 0\n  num = 0\n  todo = {}\n  strings = {}\n  for c in description.constants():\n    if c.second.dataType == 'string':\n      strings[c.first] = c.second.GetTitle()\n    else:\n      todo[c.first] = c.second.GetTitle().replace('(int)', '')\n  while len(todo) and cnt < 100:\n    cnt = cnt + 1\n    if cnt == 100:\n      logger.error('%s %d out of %d %s \"%s\": [%s]\\n+++ %s',\n                   '+++ FAILED to import',\n                   len(todo), len(todo) + num,\n                   'global values into namespace',\n                   ns.__name__, 'Try to continue anyway', 100 * '=')\n      for k, v in todo.items():\n        if not hasattr(ns, k):\n          logger.error('+++ FAILED to import: \"' + k + '\" = \"' + str(v) + '\"')\n      logger.info('+++ %s', 100 * '=')\n\n    for k, v in list(todo.items()):\n      if not hasattr(ns, k):\n        val = evaluator.evaluate(str(v))\n        if val.first == 0:\n          evaluator.setVariable(str(k), val.second)\n          setattr(ns, k, val.second)\n          if debug:\n            logger.info('Imported global value: \"' + k + '\" = \"' + str(val.second) + '\" into namespace' + ns.__name__)\n          del todo[k]\n          num = num + 1\n  if cnt < 100:\n    logger.info('+++ Imported %d global values to namespace:%s', num, ns.__name__,)",
  "def _registerGlobalAction(self, action):\n  self.get().registerGlobalAction(Interface.toAction(action))",
  "def _registerGlobalFilter(self, filter):  # noqa: A002\n  self.get().registerGlobalFilter(Interface.toAction(filter))",
  "def _evalProperty(data):\n  \"\"\"\n    Function necessary to extract real strings from the property value.\n    Strings may be embraced by quotes: '<value>'\n  \"\"\"\n  try:\n    if isinstance(data, str):\n      import ast\n      return ast.literal_eval(data)\n  except ValueError:\n    pass\n  except TypeError:\n    pass\n  finally:\n    pass\n  return data",
  "def _getKernelProperty(self, name):\n  ret = Interface.getPropertyKernel(self.get(), name)\n  if ret.status > 0:\n    return _evalProperty(ret.data)\n  elif hasattr(self.get(), name):\n    return _evalProperty(getattr(self.get(), name))\n  elif hasattr(self, name):\n    return _evalProperty(getattr(self, name))\n  msg = 'Geant4Kernel::GetProperty [Unhandled]: Cannot access Kernel.' + name\n  raise KeyError(msg)",
  "def _setKernelProperty(self, name, value):\n  if Interface.setPropertyKernel(self.get(), str(name), str(value)):\n    return\n  msg = 'Geant4Kernel::SetProperty [Unhandled]: Cannot set Kernel.' + name + ' = ' + str(value)\n  raise KeyError(msg)",
  "def _kernel_phase(self, name):\n  return self.addSimplePhase(str(name), False)",
  "def _kernel_worker(self):\n  return Kernel(self.get().createWorker())",
  "def _kernel_terminate(self):\n  return self.get().terminate()",
  "def SensitiveAction(kernel, nam, det, shared=False):\n  return Interface.createSensitive(kernel, str(nam), str(det), shared)",
  "def Action(kernel, nam, shared=False):\n  return Interface.createAction(kernel, str(nam), shared)",
  "def Filter(kernel, nam, shared=False):\n  return Interface.createFilter(kernel, str(nam), shared)",
  "def PhaseAction(kernel, nam, shared=False):\n  return Interface.createPhaseAction(kernel, str(nam), shared)",
  "def RunAction(kernel, nam, shared=False):\n  return Interface.createRunAction(kernel, str(nam), shared)",
  "def EventAction(kernel, nam, shared=False):\n  return Interface.createEventAction(kernel, str(nam), shared)",
  "def GeneratorAction(kernel, nam, shared=False):\n  return Interface.createGeneratorAction(kernel, str(nam), shared)",
  "def TrackingAction(kernel, nam, shared=False):\n  return Interface.createTrackingAction(kernel, str(nam), shared)",
  "def SteppingAction(kernel, nam, shared=False):\n  return Interface.createSteppingAction(kernel, str(nam), shared)",
  "def StackingAction(kernel, nam, shared=False):\n  return Interface.createStackingAction(kernel, str(nam), shared)",
  "def DetectorConstruction(kernel, nam):\n  return Interface.createDetectorConstruction(kernel, str(nam))",
  "def PhysicsList(kernel, nam):\n  return Interface.createPhysicsList(kernel, str(nam))",
  "def UserInitialization(kernel, nam):\n  return Interface.createUserInitialization(kernel, str(nam))",
  "def SensitiveSequence(kernel, nam):\n  return Interface.createSensDetSequence(kernel, str(nam))",
  "def _setup(obj):\n  def _adopt(self, action):\n    self.__adopt(action.get())\n  _import_class('Sim', obj)\n  o = getattr(current, obj)\n  setattr(o, '__adopt', getattr(o, 'adopt'))\n  setattr(o, 'adopt', _adopt)\n  setattr(o, 'add', _adopt)",
  "def _setup_callback(obj):\n  def _adopt(self, action):\n    self.__adopt(action.get(), action.callback())\n  _import_class('Sim', obj)\n  o = getattr(current, obj)\n  setattr(o, '__adopt', getattr(o, 'add'))\n  setattr(o, 'add', _adopt)",
  "def _get(self, name):\n  a = Interface.toAction(self)\n  ret = Interface.getProperty(a, name)\n  if ret.status > 0:\n    return ret.data\n  elif hasattr(self.action, name):\n    return getattr(self.action, name)\n  elif hasattr(a, name):\n    return getattr(a, name)\n  msg = 'Geant4Action::GetProperty [Unhandled]: Cannot access property ' + a.name() + '.' + name\n  raise KeyError(msg)",
  "def _set(self, name, value):\n  \"\"\"This function is called when properties are passed to the c++ objects.\"\"\"\n  from dd4hep_base import unicode_2_string\n  a = Interface.toAction(self)\n  name = unicode_2_string(name)\n  value = unicode_2_string(value)\n  if Interface.setProperty(a, name, value):\n    return\n  msg = 'Geant4Action::SetProperty [Unhandled]: Cannot set ' + a.name() + '.' + name + ' = ' + value\n  raise KeyError(msg)",
  "def _props(obj):\n  _import_class('Sim', obj)\n  cl = getattr(current, obj)\n  cl.__getattr__ = _get\n  cl.__setattr__ = _set",
  "class Geant4:\n  \"\"\"\n  Helper object to perform stuff, which occurs very often.\n  I am sick of typing the same over and over again.\n  Hence, I grouped often used python fragments to this small\n  class to re-usage.\n\n  \\author  M.Frank\n  \\version 1.0\n  \"\"\"\n\n  def __init__(self, kernel=None,\n               calo='Geant4CalorimeterAction',\n               tracker='Geant4SimpleTrackerAction'):\n    kernel.UI = \"UI\"\n    kernel.printProperties()\n    self._kernel = kernel\n    if kernel is None:\n      self._kernel = Kernel()\n    self.description = self._kernel.detectorDescription()\n    self.sensitive_types = {}\n    self.sensitive_types['tracker'] = tracker\n    self.sensitive_types['calorimeter'] = calo\n    self.sensitive_types['escape_counter'] = 'Geant4EscapeCounter'\n\n  def kernel(self):\n    \"\"\"\n    Access the worker kernel object.\n\n    \\author  M.Frank\n    \"\"\"\n    return self._kernel.worker()\n\n  def master(self):\n    \"\"\"\n    Access the master kernel object.\n\n    \\author  M.Frank\n    \"\"\"\n    return self._kernel\n\n  def setupUI(self, typ='csh', vis=False, ui=True, macro=None):\n    \"\"\"\n    Configure the Geant4 command executive\n\n    \\author  M.Frank\n    \"\"\"\n    ui_action = Action(self.master(), \"Geant4UIManager/UI\")\n    if vis:\n      ui_action.HaveVIS = True\n    else:\n      ui_action.HaveVIS = False\n    if ui:\n      ui_action.HaveUI = True\n    else:\n      ui_action.HaveUI = False\n    ui_action.SessionType = typ\n    if macro:\n      ui_action.SetupUI = macro\n    self.master().registerGlobalAction(ui_action)\n    return ui_action\n\n  def setupCshUI(self, typ='csh', vis=False, ui=True, macro=None):\n    \"\"\"\n    Configure the Geant4 command executive with a csh like command prompt\n\n    \\author  M.Frank\n    \"\"\"\n    return self.setupUI(typ='csh', vis=vis, ui=ui, macro=macro)\n\n  def ui(self):\n    \"\"\"\n    Access UI manager action from the kernel object\n\n    \\author  M.Frank\n    \"\"\"\n    ui_name = getattr(self.master(), 'UI')\n    return self.master().globalAction(ui_name)\n\n  def addUserInitialization(self, worker, worker_args=None, master=None, master_args=None):\n    \"\"\"\n    Configure Geant4 user initialization for optionasl multi-threading mode\n\n    \\author  M.Frank\n    \"\"\"\n    init_seq = self.master().userInitialization(True)\n    init_action = UserInitialization(self.master(), 'Geant4PythonInitialization/PyG4Init')\n    #\n    if worker:\n      init_action.setWorkerSetup(worker, worker_args)\n    else:\n      raise RuntimeError('Invalid argument for Geant4 worker initialization')\n    #\n    if master:\n      init_action.setMasterSetup(master, master_args)\n    #\n    init_seq.adopt(init_action)\n    return init_seq, init_action\n\n  def detectorConstruction(self):\n    seq = self.master().detectorConstruction(True)\n    return seq\n\n  def addDetectorConstruction(self, name_type,\n                              field=None, field_args=None,\n                              geometry=None, geometry_args=None,\n                              sensitives=None, sensitives_args=None,\n                              allow_threads=False):\n    \"\"\"\n    Configure Geant4 user initialization for optional multi-threading mode\n\n    \\author  M.Frank\n    \"\"\"\n    init_seq = self.master().detectorConstruction(True)\n    init_action = DetectorConstruction(self.master(), name_type)\n    #\n    if geometry:\n      init_action.setConstructGeo(geometry, geometry_args)\n    #\n    if field:\n      init_action.setConstructField(field, field_args)\n    #\n    if sensitives:\n      init_action.setConstructSensitives(sensitives, sensitives_args)\n    #\n    init_seq.adopt(init_action)\n    if allow_threads:\n      last_action = DetectorConstruction(self.master(), \"Geant4PythonDetectorConstructionLast/LastDetectorAction\")\n      init_seq.adopt(last_action)\n\n    return init_seq, init_action\n\n  def addPhaseAction(self, phase_name, factory_specification, ui=True, instance=None):\n    \"\"\"\n    Add a new phase action to an arbitrary step.\n\n    \\author  M.Frank\n    \"\"\"\n    if instance is None:\n      instance = self.kernel()\n    action = PhaseAction(instance, factory_specification)\n    instance.phase(phase_name).add(action)\n    if ui:\n      action.enableUI()\n    return action\n\n  def addConfig(self, factory_specification):\n    \"\"\"\n    Add a new phase action to the 'configure' step.\n    Called at the beginning of Geant4Exec::configure.\n    The factory specification is the typical string \"<factory_name>/<instance name>\".\n    If no instance name is specified it defaults to the factory name.\n\n    \\author  M.Frank\n    \"\"\"\n    return self.addPhaseAction('configure', factory_specification, instance=self.master())\n\n  def addInit(self, factory_specification):\n    \"\"\"\n    Add a new phase action to the 'initialize' step.\n    Called at the beginning of Geant4Exec::initialize.\n    The factory specification is the typical string \"<factory_name>/<instance name>\".\n    If no instance name is specified it defaults to the factory name.\n\n    \\author  M.Frank\n    \"\"\"\n    return self.addPhaseAction('initialize', factory_specification)\n\n  def addStart(self, factory_specification):\n    \"\"\"\n    Add a new phase action to the 'start' step.\n    Called at the beginning of Geant4Exec::run.\n    The factory specification is the typical string \"<factory_name>/<instance name>\".\n    If no instance name is specified it defaults to the factory name.\n\n    \\author  M.Frank\n    \"\"\"\n    return self.addPhaseAction('start', factory_specification)\n\n  def addStop(self, factory_specification):\n    \"\"\"\n    Add a new phase action to the 'stop' step.\n    Called at the end of Geant4Exec::run.\n    The factory specification is the typical string \"<factory_name>/<instance name>\".\n    If no instance name is specified it defaults to the factory name.\n\n    \\author  M.Frank\n    \"\"\"\n    return self.addPhaseAction('stop', factory_specification)\n\n  def execute(self, num_events=None):\n    \"\"\"\n    Execute the Geant 4 program with all steps.\n\n    \\author  M.Frank\n    \"\"\"\n    self.kernel().configure()\n    self.kernel().initialize()\n    if num_events:\n      self.kernel().NumEvents = num_events\n    self.kernel().run()\n    self.kernel().terminate()\n    return self\n\n  def printDetectors(self):\n    \"\"\"\n    Scan the list of detectors and print detector name and sensitive type\n\n    \\author  M.Frank\n    \"\"\"\n    logger.info('+++  List of sensitive detectors:')\n    for i in self.description.detectors():\n      o = DetElement(i.second.ptr())  # noqa: F405\n      sd = self.description.sensitiveDetector(str(o.name()))\n      if sd.isValid():\n        typ = sd.type()\n        sdtyp = 'Unknown'\n        if typ in self.sensitive_types:\n          sdtyp = self.sensitive_types[typ]\n        logger.info('+++  %-32s type:%-12s  --> Sensitive type: %s', o.name(), typ, sdtyp)\n\n  def setupDetectors(self):\n    \"\"\"\n    Scan the list of detectors and assign the proper sensitive actions\n\n    \\author  M.Frank\n    \"\"\"\n    seq = None\n    actions = []\n    logger.info('+++  Setting up sensitive detectors:')\n    for i in self.description.detectors():\n      o = DetElement(i.second.ptr())  # noqa: F405\n      sd = self.description.sensitiveDetector(str(o.name()))\n      if sd.isValid():\n        typ = sd.type()\n        sdtyp = 'Unknown'\n        if typ in self.sensitive_types:\n          sdtyp = self.sensitive_types[typ]\n          seq, act = self.setupDetector(o.name(), sdtyp, collections=None)\n          logger.info('+++  %-32s type:%-12s  --> Sensitive type: %s', o.name(), typ, sdtyp)\n          actions.append(act)\n          continue\n        logger.info('+++  %-32s --> UNKNOWN Sensitive type: %s', o.name(), typ)\n    return (seq, actions)\n\n  def setupDetector(self, name, action, collections=None):\n    \"\"\"\n    Setup single subdetector and assign the proper sensitive action\n\n    \\author  M.Frank\n    \"\"\"\n    # fg: allow the action to be a tuple with parameter dictionary\n    sensitive_type = \"\"\n    parameterDict = {}\n    if isinstance(action, tuple) or isinstance(action, list):\n      sensitive_type = action[0]\n      parameterDict = action[1]\n    else:\n      sensitive_type = action\n\n    seq = SensitiveSequence(self.kernel(), 'Geant4SensDetActionSequence/' + name)\n    seq.enableUI()\n    acts = []\n    if collections is None:\n      sd = self.description.sensitiveDetector(str(name))\n      ro = sd.readout()\n      collections = ro.collectionNames()\n      if len(collections) == 0:\n        act = SensitiveAction(self.kernel(), sensitive_type + '/' + name + 'Handler', name)\n        for parameter, value in six.iteritems(parameterDict):\n          setattr(act, parameter, value)\n        acts.append(act)\n\n    # Work down the collections if present\n    if collections is not None:\n      for coll in collections:\n        params = {}\n        if isinstance(coll, tuple) or isinstance(coll, list):\n          if len(coll) > 2:\n            coll_nam = str(coll[0])\n            sensitive_type = coll[1]\n            params = str(coll[2])\n          elif len(coll) > 1:\n            coll_nam = str(coll[0])\n            sensitive_type = coll[1]\n          else:\n            coll_nam = str(coll[0])\n        else:\n          coll_nam = str(coll)\n        act = SensitiveAction(self.kernel(), sensitive_type + '/' + coll_nam + 'Handler', name)\n        act.CollectionName = coll_nam\n        for parameter, value in six.iteritems(params):\n          setattr(act, parameter, value)\n        acts.append(act)\n\n    for act in acts:\n      act.enableUI()\n      seq.add(act)\n    if len(acts) > 1:\n      return (seq, acts)\n    return (seq, acts[0])\n\n  def setupCalorimeter(self, name, type=None, collections=None):  # noqa: A002\n    \"\"\"\n    Setup subdetector of type 'calorimeter' and assign the proper sensitive action\n\n    \\author  M.Frank\n    \"\"\"\n    typ = type    # noqa: A002\n    self.description.sensitiveDetector(str(name))\n    # sd.setType('calorimeter')\n    if typ is None:\n      typ = self.sensitive_types['calorimeter']\n    return self.setupDetector(name, typ, collections)\n\n  def setupTracker(self, name, type=None, collections=None):  # noqa: A002\n    \"\"\"\n    Setup subdetector of type 'tracker' and assign the proper sensitive action\n\n    \\author  M.Frank\n    \"\"\"\n    typ = type\n    self.description.sensitiveDetector(str(name))\n    # sd.setType('tracker')\n    if typ is None:\n      typ = self.sensitive_types['tracker']\n    return self.setupDetector(name, typ, collections)\n\n  def _private_setupField(self, field, stepper, equation, prt):\n    import g4units\n    field.stepper = stepper\n    field.equation = equation\n    field.eps_min = 5e-05 * g4units.mm\n    field.eps_max = 0.001 * g4units.mm\n    field.min_chord_step = 0.01 * g4units.mm\n    field.delta_chord = 0.25 * g4units.mm\n    field.delta_intersection = 0.001 * g4units.mm\n    field.delta_one_step = 0.01 * g4units.mm\n    field.largest_step = 1000 * g4units.m\n    if prt:\n      logger.info('+++++> %s %s %s %s ', field.name, '-> stepper  = ', str(field.stepper), '')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> equation = ', str(field.equation), '')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> eps_min  = ', str(field.eps_min), '[mm]')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> eps_max  = ', str(field.eps_max), '[mm]')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> delta_chord        = ', str(field.delta_chord), '[mm]')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> min_chord_step     = ', str(field.min_chord_step), '[mm]')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> delta_one_step     = ', str(field.delta_one_step), '[mm]')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> delta_intersection = ', str(field.delta_intersection), '[mm]')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> largest_step       = ', str(field.largest_step), '[mm]')\n    return field\n\n  def setupTrackingFieldMT(self, name='MagFieldTrackingSetup',\n                           stepper='ClassicalRK4', equation='Mag_UsualEqRhs', prt=False):\n    seq, fld = self.addDetectorConstruction(\"Geant4FieldTrackingConstruction/\" + name)\n    self._private_setupField(fld, stepper, equation, prt)\n    return (seq, fld)\n\n  def setupTrackingField(self, name='MagFieldTrackingSetup',\n                         stepper='ClassicalRK4', equation='Mag_UsualEqRhs', prt=False):\n    field = self.addConfig('Geant4FieldTrackingSetupAction/' + name)\n    self._private_setupField(field, stepper, equation, prt)\n    return field\n\n  def setupPhysics(self, name):\n    phys = self.master().physicsList()\n    phys.extends = name\n    phys.decays = True\n    phys.enableUI()\n    phys.dump()\n    return phys\n\n  def addPhysics(self, name):\n    phys = self.master().physicsList()\n    opt = PhysicsList(self.master(), name)\n    opt.enableUI()\n    phys.adopt(opt)\n    return opt\n\n  def setupGun(self, name, particle, energy, typ=\"Geant4ParticleGun\", isotrop=True,\n               multiplicity=1, position=(0.0, 0.0, 0.0), register=True, **args):\n    gun = GeneratorAction(self.kernel(), typ + \"/\" + name, True)\n    for i in args.items():\n      setattr(gun, i[0], i[1])\n    gun.Energy = energy\n    gun.particle = particle\n    gun.multiplicity = multiplicity\n    gun.position = position\n    gun.isotrop = isotrop\n    gun.enableUI()\n    if register:\n      self.kernel().generatorAction().add(gun)\n    return gun\n\n  def setupROOTOutput(self, name, output, mc_truth=True):\n    \"\"\"\n    Configure ROOT output for the simulated events\n\n    \\author  M.Frank\n    \"\"\"\n    evt_root = EventAction(self.kernel(), 'Geant4Output2ROOT/' + name, True)\n    evt_root.HandleMCTruth = mc_truth\n    evt_root.Control = True\n    if not output.endswith('.root'):\n      output = output + '.root'\n    evt_root.Output = output\n    evt_root.enableUI()\n    self.kernel().eventAction().add(evt_root)\n    return evt_root\n\n  def setupLCIOOutput(self, name, output):\n    \"\"\"\n    Configure LCIO output for the simulated events\n\n    \\author  M.Frank\n    \"\"\"\n    evt_lcio = EventAction(self.kernel(), 'Geant4Output2LCIO/' + name, True)\n    evt_lcio.Control = True\n    evt_lcio.Output = output\n    evt_lcio.enableUI()\n    self.kernel().eventAction().add(evt_lcio)\n    return evt_lcio\n\n  def setupEDM4hepOutput(self, name, output):\n    \"\"\"Configure EDM4hep root output for the simulated events.\"\"\"\n    evt_edm4hep = EventAction(self.kernel(), 'Geant4Output2EDM4hep/' + name, True)\n    evt_edm4hep.Control = True\n    evt_edm4hep.Output = output\n    evt_edm4hep.enableUI()\n    self.kernel().eventAction().add(evt_edm4hep)\n    return evt_edm4hep\n\n  def buildInputStage(self, generator_input_modules, output_level=None, have_mctruth=True):\n    \"\"\"\n    Generic build of the input stage with multiple input modules.\n\n    Actions executed are:\n    1) Register Generation initialization action\n    2) Append all modules to build the complete input record\n    These modules are readers/particle sources, boosters and/or smearing actions.\n    3) Merge all existing interaction records\n    4) Add the MC truth handler\n\n    \\author  M.Frank\n    \"\"\"\n    ga = self.kernel().generatorAction()\n    # Register Generation initialization action\n    gen = GeneratorAction(self.kernel(), \"Geant4GeneratorActionInit/GenerationInit\")\n    if output_level is not None:\n      gen.OutputLevel = output_level\n    ga.adopt(gen)\n\n    # Now append all modules to build the complete input record\n    # These modules are readers/particle sources, boosters and/or smearing actions\n    for gen in generator_input_modules:\n      gen.enableUI()\n      if output_level is not None:\n        gen.OutputLevel = output_level\n      ga.adopt(gen)\n\n    # Merge all existing interaction records\n    gen = GeneratorAction(self.kernel(), \"Geant4InteractionMerger/InteractionMerger\")\n    gen.enableUI()\n    if output_level is not None:\n      gen.OutputLevel = output_level\n    ga.adopt(gen)\n\n    # Finally generate Geant4 primaries\n    if have_mctruth:\n      gen = GeneratorAction(self.kernel(), \"Geant4PrimaryHandler/PrimaryHandler\")\n      gen.RejectPDGs = \"{1,2,3,4,5,6,21,23,24}\"\n      gen.enableUI()\n      if output_level is not None:\n        gen.OutputLevel = output_level\n      ga.adopt(gen)\n    # Puuuhh! All done.\n    return self\n\n  def run(self):\n    \"\"\"\n    Execute the main Geant4 action\n    \\author  M.Frank\n    \"\"\"\n    from ROOT import PyDDG4\n    PyDDG4.run(self.master().get())\n    return self",
  "def _adopt(self, action):\n    self.__adopt(action.get())",
  "def _adopt(self, action):\n    self.__adopt(action.get(), action.callback())",
  "def __init__(self, kernel=None,\n               calo='Geant4CalorimeterAction',\n               tracker='Geant4SimpleTrackerAction'):\n    kernel.UI = \"UI\"\n    kernel.printProperties()\n    self._kernel = kernel\n    if kernel is None:\n      self._kernel = Kernel()\n    self.description = self._kernel.detectorDescription()\n    self.sensitive_types = {}\n    self.sensitive_types['tracker'] = tracker\n    self.sensitive_types['calorimeter'] = calo\n    self.sensitive_types['escape_counter'] = 'Geant4EscapeCounter'",
  "def kernel(self):\n    \"\"\"\n    Access the worker kernel object.\n\n    \\author  M.Frank\n    \"\"\"\n    return self._kernel.worker()",
  "def master(self):\n    \"\"\"\n    Access the master kernel object.\n\n    \\author  M.Frank\n    \"\"\"\n    return self._kernel",
  "def setupUI(self, typ='csh', vis=False, ui=True, macro=None):\n    \"\"\"\n    Configure the Geant4 command executive\n\n    \\author  M.Frank\n    \"\"\"\n    ui_action = Action(self.master(), \"Geant4UIManager/UI\")\n    if vis:\n      ui_action.HaveVIS = True\n    else:\n      ui_action.HaveVIS = False\n    if ui:\n      ui_action.HaveUI = True\n    else:\n      ui_action.HaveUI = False\n    ui_action.SessionType = typ\n    if macro:\n      ui_action.SetupUI = macro\n    self.master().registerGlobalAction(ui_action)\n    return ui_action",
  "def setupCshUI(self, typ='csh', vis=False, ui=True, macro=None):\n    \"\"\"\n    Configure the Geant4 command executive with a csh like command prompt\n\n    \\author  M.Frank\n    \"\"\"\n    return self.setupUI(typ='csh', vis=vis, ui=ui, macro=macro)",
  "def ui(self):\n    \"\"\"\n    Access UI manager action from the kernel object\n\n    \\author  M.Frank\n    \"\"\"\n    ui_name = getattr(self.master(), 'UI')\n    return self.master().globalAction(ui_name)",
  "def addUserInitialization(self, worker, worker_args=None, master=None, master_args=None):\n    \"\"\"\n    Configure Geant4 user initialization for optionasl multi-threading mode\n\n    \\author  M.Frank\n    \"\"\"\n    init_seq = self.master().userInitialization(True)\n    init_action = UserInitialization(self.master(), 'Geant4PythonInitialization/PyG4Init')\n    #\n    if worker:\n      init_action.setWorkerSetup(worker, worker_args)\n    else:\n      raise RuntimeError('Invalid argument for Geant4 worker initialization')\n    #\n    if master:\n      init_action.setMasterSetup(master, master_args)\n    #\n    init_seq.adopt(init_action)\n    return init_seq, init_action",
  "def detectorConstruction(self):\n    seq = self.master().detectorConstruction(True)\n    return seq",
  "def addDetectorConstruction(self, name_type,\n                              field=None, field_args=None,\n                              geometry=None, geometry_args=None,\n                              sensitives=None, sensitives_args=None,\n                              allow_threads=False):\n    \"\"\"\n    Configure Geant4 user initialization for optional multi-threading mode\n\n    \\author  M.Frank\n    \"\"\"\n    init_seq = self.master().detectorConstruction(True)\n    init_action = DetectorConstruction(self.master(), name_type)\n    #\n    if geometry:\n      init_action.setConstructGeo(geometry, geometry_args)\n    #\n    if field:\n      init_action.setConstructField(field, field_args)\n    #\n    if sensitives:\n      init_action.setConstructSensitives(sensitives, sensitives_args)\n    #\n    init_seq.adopt(init_action)\n    if allow_threads:\n      last_action = DetectorConstruction(self.master(), \"Geant4PythonDetectorConstructionLast/LastDetectorAction\")\n      init_seq.adopt(last_action)\n\n    return init_seq, init_action",
  "def addPhaseAction(self, phase_name, factory_specification, ui=True, instance=None):\n    \"\"\"\n    Add a new phase action to an arbitrary step.\n\n    \\author  M.Frank\n    \"\"\"\n    if instance is None:\n      instance = self.kernel()\n    action = PhaseAction(instance, factory_specification)\n    instance.phase(phase_name).add(action)\n    if ui:\n      action.enableUI()\n    return action",
  "def addConfig(self, factory_specification):\n    \"\"\"\n    Add a new phase action to the 'configure' step.\n    Called at the beginning of Geant4Exec::configure.\n    The factory specification is the typical string \"<factory_name>/<instance name>\".\n    If no instance name is specified it defaults to the factory name.\n\n    \\author  M.Frank\n    \"\"\"\n    return self.addPhaseAction('configure', factory_specification, instance=self.master())",
  "def addInit(self, factory_specification):\n    \"\"\"\n    Add a new phase action to the 'initialize' step.\n    Called at the beginning of Geant4Exec::initialize.\n    The factory specification is the typical string \"<factory_name>/<instance name>\".\n    If no instance name is specified it defaults to the factory name.\n\n    \\author  M.Frank\n    \"\"\"\n    return self.addPhaseAction('initialize', factory_specification)",
  "def addStart(self, factory_specification):\n    \"\"\"\n    Add a new phase action to the 'start' step.\n    Called at the beginning of Geant4Exec::run.\n    The factory specification is the typical string \"<factory_name>/<instance name>\".\n    If no instance name is specified it defaults to the factory name.\n\n    \\author  M.Frank\n    \"\"\"\n    return self.addPhaseAction('start', factory_specification)",
  "def addStop(self, factory_specification):\n    \"\"\"\n    Add a new phase action to the 'stop' step.\n    Called at the end of Geant4Exec::run.\n    The factory specification is the typical string \"<factory_name>/<instance name>\".\n    If no instance name is specified it defaults to the factory name.\n\n    \\author  M.Frank\n    \"\"\"\n    return self.addPhaseAction('stop', factory_specification)",
  "def execute(self, num_events=None):\n    \"\"\"\n    Execute the Geant 4 program with all steps.\n\n    \\author  M.Frank\n    \"\"\"\n    self.kernel().configure()\n    self.kernel().initialize()\n    if num_events:\n      self.kernel().NumEvents = num_events\n    self.kernel().run()\n    self.kernel().terminate()\n    return self",
  "def printDetectors(self):\n    \"\"\"\n    Scan the list of detectors and print detector name and sensitive type\n\n    \\author  M.Frank\n    \"\"\"\n    logger.info('+++  List of sensitive detectors:')\n    for i in self.description.detectors():\n      o = DetElement(i.second.ptr())  # noqa: F405\n      sd = self.description.sensitiveDetector(str(o.name()))\n      if sd.isValid():\n        typ = sd.type()\n        sdtyp = 'Unknown'\n        if typ in self.sensitive_types:\n          sdtyp = self.sensitive_types[typ]\n        logger.info('+++  %-32s type:%-12s  --> Sensitive type: %s', o.name(), typ, sdtyp)",
  "def setupDetectors(self):\n    \"\"\"\n    Scan the list of detectors and assign the proper sensitive actions\n\n    \\author  M.Frank\n    \"\"\"\n    seq = None\n    actions = []\n    logger.info('+++  Setting up sensitive detectors:')\n    for i in self.description.detectors():\n      o = DetElement(i.second.ptr())  # noqa: F405\n      sd = self.description.sensitiveDetector(str(o.name()))\n      if sd.isValid():\n        typ = sd.type()\n        sdtyp = 'Unknown'\n        if typ in self.sensitive_types:\n          sdtyp = self.sensitive_types[typ]\n          seq, act = self.setupDetector(o.name(), sdtyp, collections=None)\n          logger.info('+++  %-32s type:%-12s  --> Sensitive type: %s', o.name(), typ, sdtyp)\n          actions.append(act)\n          continue\n        logger.info('+++  %-32s --> UNKNOWN Sensitive type: %s', o.name(), typ)\n    return (seq, actions)",
  "def setupDetector(self, name, action, collections=None):\n    \"\"\"\n    Setup single subdetector and assign the proper sensitive action\n\n    \\author  M.Frank\n    \"\"\"\n    # fg: allow the action to be a tuple with parameter dictionary\n    sensitive_type = \"\"\n    parameterDict = {}\n    if isinstance(action, tuple) or isinstance(action, list):\n      sensitive_type = action[0]\n      parameterDict = action[1]\n    else:\n      sensitive_type = action\n\n    seq = SensitiveSequence(self.kernel(), 'Geant4SensDetActionSequence/' + name)\n    seq.enableUI()\n    acts = []\n    if collections is None:\n      sd = self.description.sensitiveDetector(str(name))\n      ro = sd.readout()\n      collections = ro.collectionNames()\n      if len(collections) == 0:\n        act = SensitiveAction(self.kernel(), sensitive_type + '/' + name + 'Handler', name)\n        for parameter, value in six.iteritems(parameterDict):\n          setattr(act, parameter, value)\n        acts.append(act)\n\n    # Work down the collections if present\n    if collections is not None:\n      for coll in collections:\n        params = {}\n        if isinstance(coll, tuple) or isinstance(coll, list):\n          if len(coll) > 2:\n            coll_nam = str(coll[0])\n            sensitive_type = coll[1]\n            params = str(coll[2])\n          elif len(coll) > 1:\n            coll_nam = str(coll[0])\n            sensitive_type = coll[1]\n          else:\n            coll_nam = str(coll[0])\n        else:\n          coll_nam = str(coll)\n        act = SensitiveAction(self.kernel(), sensitive_type + '/' + coll_nam + 'Handler', name)\n        act.CollectionName = coll_nam\n        for parameter, value in six.iteritems(params):\n          setattr(act, parameter, value)\n        acts.append(act)\n\n    for act in acts:\n      act.enableUI()\n      seq.add(act)\n    if len(acts) > 1:\n      return (seq, acts)\n    return (seq, acts[0])",
  "def setupCalorimeter(self, name, type=None, collections=None):  # noqa: A002\n    \"\"\"\n    Setup subdetector of type 'calorimeter' and assign the proper sensitive action\n\n    \\author  M.Frank\n    \"\"\"\n    typ = type    # noqa: A002\n    self.description.sensitiveDetector(str(name))\n    # sd.setType('calorimeter')\n    if typ is None:\n      typ = self.sensitive_types['calorimeter']\n    return self.setupDetector(name, typ, collections)",
  "def setupTracker(self, name, type=None, collections=None):  # noqa: A002\n    \"\"\"\n    Setup subdetector of type 'tracker' and assign the proper sensitive action\n\n    \\author  M.Frank\n    \"\"\"\n    typ = type\n    self.description.sensitiveDetector(str(name))\n    # sd.setType('tracker')\n    if typ is None:\n      typ = self.sensitive_types['tracker']\n    return self.setupDetector(name, typ, collections)",
  "def _private_setupField(self, field, stepper, equation, prt):\n    import g4units\n    field.stepper = stepper\n    field.equation = equation\n    field.eps_min = 5e-05 * g4units.mm\n    field.eps_max = 0.001 * g4units.mm\n    field.min_chord_step = 0.01 * g4units.mm\n    field.delta_chord = 0.25 * g4units.mm\n    field.delta_intersection = 0.001 * g4units.mm\n    field.delta_one_step = 0.01 * g4units.mm\n    field.largest_step = 1000 * g4units.m\n    if prt:\n      logger.info('+++++> %s %s %s %s ', field.name, '-> stepper  = ', str(field.stepper), '')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> equation = ', str(field.equation), '')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> eps_min  = ', str(field.eps_min), '[mm]')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> eps_max  = ', str(field.eps_max), '[mm]')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> delta_chord        = ', str(field.delta_chord), '[mm]')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> min_chord_step     = ', str(field.min_chord_step), '[mm]')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> delta_one_step     = ', str(field.delta_one_step), '[mm]')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> delta_intersection = ', str(field.delta_intersection), '[mm]')\n      logger.info('+++++> %s %s %s %s ', field.name, '-> largest_step       = ', str(field.largest_step), '[mm]')\n    return field",
  "def setupTrackingFieldMT(self, name='MagFieldTrackingSetup',\n                           stepper='ClassicalRK4', equation='Mag_UsualEqRhs', prt=False):\n    seq, fld = self.addDetectorConstruction(\"Geant4FieldTrackingConstruction/\" + name)\n    self._private_setupField(fld, stepper, equation, prt)\n    return (seq, fld)",
  "def setupTrackingField(self, name='MagFieldTrackingSetup',\n                         stepper='ClassicalRK4', equation='Mag_UsualEqRhs', prt=False):\n    field = self.addConfig('Geant4FieldTrackingSetupAction/' + name)\n    self._private_setupField(field, stepper, equation, prt)\n    return field",
  "def setupPhysics(self, name):\n    phys = self.master().physicsList()\n    phys.extends = name\n    phys.decays = True\n    phys.enableUI()\n    phys.dump()\n    return phys",
  "def addPhysics(self, name):\n    phys = self.master().physicsList()\n    opt = PhysicsList(self.master(), name)\n    opt.enableUI()\n    phys.adopt(opt)\n    return opt",
  "def setupGun(self, name, particle, energy, typ=\"Geant4ParticleGun\", isotrop=True,\n               multiplicity=1, position=(0.0, 0.0, 0.0), register=True, **args):\n    gun = GeneratorAction(self.kernel(), typ + \"/\" + name, True)\n    for i in args.items():\n      setattr(gun, i[0], i[1])\n    gun.Energy = energy\n    gun.particle = particle\n    gun.multiplicity = multiplicity\n    gun.position = position\n    gun.isotrop = isotrop\n    gun.enableUI()\n    if register:\n      self.kernel().generatorAction().add(gun)\n    return gun",
  "def setupROOTOutput(self, name, output, mc_truth=True):\n    \"\"\"\n    Configure ROOT output for the simulated events\n\n    \\author  M.Frank\n    \"\"\"\n    evt_root = EventAction(self.kernel(), 'Geant4Output2ROOT/' + name, True)\n    evt_root.HandleMCTruth = mc_truth\n    evt_root.Control = True\n    if not output.endswith('.root'):\n      output = output + '.root'\n    evt_root.Output = output\n    evt_root.enableUI()\n    self.kernel().eventAction().add(evt_root)\n    return evt_root",
  "def setupLCIOOutput(self, name, output):\n    \"\"\"\n    Configure LCIO output for the simulated events\n\n    \\author  M.Frank\n    \"\"\"\n    evt_lcio = EventAction(self.kernel(), 'Geant4Output2LCIO/' + name, True)\n    evt_lcio.Control = True\n    evt_lcio.Output = output\n    evt_lcio.enableUI()\n    self.kernel().eventAction().add(evt_lcio)\n    return evt_lcio",
  "def setupEDM4hepOutput(self, name, output):\n    \"\"\"Configure EDM4hep root output for the simulated events.\"\"\"\n    evt_edm4hep = EventAction(self.kernel(), 'Geant4Output2EDM4hep/' + name, True)\n    evt_edm4hep.Control = True\n    evt_edm4hep.Output = output\n    evt_edm4hep.enableUI()\n    self.kernel().eventAction().add(evt_edm4hep)\n    return evt_edm4hep",
  "def buildInputStage(self, generator_input_modules, output_level=None, have_mctruth=True):\n    \"\"\"\n    Generic build of the input stage with multiple input modules.\n\n    Actions executed are:\n    1) Register Generation initialization action\n    2) Append all modules to build the complete input record\n    These modules are readers/particle sources, boosters and/or smearing actions.\n    3) Merge all existing interaction records\n    4) Add the MC truth handler\n\n    \\author  M.Frank\n    \"\"\"\n    ga = self.kernel().generatorAction()\n    # Register Generation initialization action\n    gen = GeneratorAction(self.kernel(), \"Geant4GeneratorActionInit/GenerationInit\")\n    if output_level is not None:\n      gen.OutputLevel = output_level\n    ga.adopt(gen)\n\n    # Now append all modules to build the complete input record\n    # These modules are readers/particle sources, boosters and/or smearing actions\n    for gen in generator_input_modules:\n      gen.enableUI()\n      if output_level is not None:\n        gen.OutputLevel = output_level\n      ga.adopt(gen)\n\n    # Merge all existing interaction records\n    gen = GeneratorAction(self.kernel(), \"Geant4InteractionMerger/InteractionMerger\")\n    gen.enableUI()\n    if output_level is not None:\n      gen.OutputLevel = output_level\n    ga.adopt(gen)\n\n    # Finally generate Geant4 primaries\n    if have_mctruth:\n      gen = GeneratorAction(self.kernel(), \"Geant4PrimaryHandler/PrimaryHandler\")\n      gen.RejectPDGs = \"{1,2,3,4,5,6,21,23,24}\"\n      gen.enableUI()\n      if output_level is not None:\n        gen.OutputLevel = output_level\n      ga.adopt(gen)\n    # Puuuhh! All done.\n    return self",
  "def run(self):\n    \"\"\"\n    Execute the main Geant4 action\n    \\author  M.Frank\n    \"\"\"\n    from ROOT import PyDDG4\n    PyDDG4.run(self.master().get())\n    return self",
  "def printOpts(opts):\n  o = eval(str(opts))\n  prefix = sys.argv[0].split(os.sep)[-1]\n  for name, value in o.items():\n    logger.info('%s > %-18s %s  [%s]', prefix, name + ':', str(value), str(value.__class__))",
  "def materialScan(opts):\n  kernel = DDG4.Kernel()\n  kernel.loadGeometry(str(opts.compact))\n  DDG4.Core.setPrintFormat(str(\"%-32s %6s %s\"))\n  geant4 = DDG4.Geant4(kernel)\n  # Configure UI\n  geant4.setupCshUI(ui=None)\n  for i in geant4.description.detectors():\n    o = DDG4.DetElement(i.second.ptr())\n    sd = geant4.description.sensitiveDetector(o.name())\n    if sd.isValid():\n      typ = sd.type()\n      if typ in geant4.sensitive_types:\n        geant4.setupDetector(o.name(), geant4.sensitive_types[typ])\n      else:\n        logger.error('+++  %-32s type:%-12s  --> Unknown Sensitive type: %s', o.name(), typ, typ)\n        sys.exit(errno.EINVAL)\n\n  geant4.setupGun(\"Gun\",\n                  Standalone=True,\n                  particle='geantino',\n                  energy=20 * g4units.GeV,\n                  position=opts.position,\n                  direction=opts.direction,\n                  multiplicity=1,\n                  isotrop=False)\n  scan = DDG4.SteppingAction(kernel, 'Geant4GeometryScanner/GeometryScan')\n  kernel.steppingAction().adopt(scan)\n\n  # Now build the physics list:\n  geant4.setupPhysics('QGSP_BERT')\n\n  kernel.configure()\n  kernel.initialize()\n  kernel.NumEvents = 1\n  kernel.run()\n  kernel.terminate()\n  return 0",
  "def printOpts(opts):\n  o = eval(str(opts))\n  prefix = sys.argv[0].split(os.sep)[-1]\n  for name, value in o.items():\n    logger.info('%s > %-18s %s  [%s]', prefix, name + ':', str(value), str(value.__class__))",
  "def materialScan(opts):\n  kernel = DDG4.Kernel()\n  kernel.loadGeometry(str(opts.compact))\n  DDG4.Core.setPrintFormat(str(\"%-32s %6s %s\"))\n  geant4 = DDG4.Geant4(kernel)\n  # Configure UI\n  geant4.setupCshUI(ui=None)\n  for i in geant4.description.detectors():\n    o = DDG4.DetElement(i.second.ptr())\n    sd = geant4.description.sensitiveDetector(o.name())\n    if sd.isValid():\n      typ = sd.type()\n      if typ in geant4.sensitive_types:\n        geant4.setupDetector(o.name(), geant4.sensitive_types[typ])\n      else:\n        logger.error('+++  %-32s type:%-12s  --> Unknown Sensitive type: %s', o.name(), typ, typ)\n        sys.exit(errno.EINVAL)\n\n  geant4.setupGun(\"Gun\",\n                  Standalone=True,\n                  particle='geantino',\n                  energy=20 * g4units.GeV,\n                  position=opts.position,\n                  direction=opts.direction,\n                  multiplicity=1,\n                  isotrop=False)\n  scan = DDG4.SteppingAction(kernel, 'Geant4MaterialScanner/MaterialScan')\n  kernel.steppingAction().adopt(scan)\n\n  # Now build the physics list:\n  geant4.setupPhysics('QGSP_BERT')\n\n  kernel.configure()\n  kernel.initialize()\n  kernel.NumEvents = 1\n  kernel.run()\n  kernel.terminate()\n  return 0",
  "class DD4hepSimulation(object):\n  \"\"\"Class to hold all the parameters and functions to run simulation\"\"\"\n\n  def __init__(self):\n    self.steeringFile = None\n    self.compactFile = []\n    self.inputFiles = []\n    self.outputFile = defaultOutputFile()\n    self.runType = \"batch\"\n    self.printLevel = 3\n\n    self.numberOfEvents = 0\n    self.skipNEvents = 0\n    self.physicsList = None  # deprecated use physics.list\n    self.crossingAngleBoost = 0.0\n    self.macroFile = ''\n    self.enableGun = False\n    self.enableG4GPS = False\n    self.enableG4Gun = False\n    self._g4gun = None\n    self._g4gps = None\n    self.vertexSigma = [0.0, 0.0, 0.0, 0.0]\n    self.vertexOffset = [0.0, 0.0, 0.0, 0.0]\n    self.enableDetailedShowerMode = False\n\n    self._errorMessages = []\n    self._dumpParameter = False\n    self._dumpSteeringFile = False\n\n    # objects for extended configuration option\n    self.output = Output()\n    self.random = Random()\n    self.gun = Gun()\n    self.part = ParticleHandler()\n    self.field = MagneticField()\n    self.action = Action()\n    self.outputConfig = OutputConfig()\n    self.inputConfig = InputConfig()\n    self.guineapig = GuineaPig()\n    self.lcio = LCIO()\n    self.hepmc3 = HepMC3()\n    self.meta = Meta()\n\n    self.geometry = Geometry()\n    self.filter = Filter()\n    self.physics = Physics()\n    self.ui = UI()\n\n    self._argv = None\n\n  def readSteeringFile(self):\n    \"\"\"Reads a steering file and sets the parameters to that of the\n    DD4hepSimulation object present in the steering file.\n    \"\"\"\n    globs = {}\n    locs = {}\n    if not self.steeringFile:\n      return\n    sFileTemp = self.steeringFile\n    exec(compile(open(self.steeringFile).read(), self.steeringFile, 'exec'), globs, locs)\n    for _name, obj in locs.items():\n      if isinstance(obj, DD4hepSimulation):\n        self.__dict__ = obj.__dict__\n    self.steeringFile = os.path.abspath(sFileTemp)\n\n  def parseOptions(self, argv=None):\n    \"\"\"parse the command line options\"\"\"\n\n    if argv is None:\n      self._argv = list(sys.argv)\n\n    parser = argparse.ArgumentParser(\"Running DD4hep Simulations:\",\n                                     formatter_class=argparse.RawTextHelpFormatter)\n\n    parser.add_argument(\"--steeringFile\", \"-S\", action=\"store\", default=self.steeringFile,\n                        help=\"Steering file to change default behaviour\")\n\n    # first we parse just the steering file, but only if we don't want to see the help message\n    if not any(opt in self._argv for opt in ('-h', '--help')):\n      parsed, _unknown = parser.parse_known_args()\n      self.steeringFile = parsed.steeringFile\n      self.readSteeringFile()\n\n    # readSteeringFile will set self._argv to None if there is a steering file\n    if self._argv is None:\n      self._argv = list(argv) if argv else list(sys.argv)\n\n    parser.add_argument(\"--compactFile\", nargs='+', action=\"store\",\n                        default=ConfigHelper.makeList(self.compactFile), type=str,\n                        help=\"The compact XML file, or multiple compact files, if the last one is the closer.\")\n\n    parser.add_argument(\"--runType\", action=\"store\", choices=(\"batch\", \"vis\", \"run\", \"shell\", \"qt\"),\n                        default=self.runType,\n                        help=\"The type of action to do in this invocation\"  # Note: implicit string concatenation\n                        \"\\nbatch: just simulate some events, needs numberOfEvents, and input file or gun\"\n                        \"\\nvis: enable visualisation, run the macroFile if it is set\"\n                        \"\\nqt: enable visualisation in Qt shell, run the macroFile if it is set\"\n                        \"\\nrun: run the macroFile and exit\"\n                        \"\\nshell: enable interactive session\")\n\n    parser.add_argument(\"--inputFiles\", \"-I\", nargs='+', action=\"store\", default=self.inputFiles,\n                        help=\"InputFiles for simulation %s files are supported\" % \", \".join(POSSIBLEINPUTFILES))\n\n    parser.add_argument(\"--outputFile\", \"-O\", action=\"store\", default=self.outputFile,\n                        help=\"Outputfile from the simulation: .slcio, edm4hep.root and .root\"\n                        \" output files are supported\")\n\n    parser.add_argument(\"-v\", \"--printLevel\", action=\"store\", default=self.printLevel, dest=\"printLevel\",\n                        choices=(1, 2, 3, 4, 5, 6, 7, 'VERBOSE', 'DEBUG',\n                                 'INFO', 'WARNING', 'ERROR', 'FATAL', 'ALWAYS'),\n                        type=outputLevelType,\n                        help=\"Verbosity use integers from 1(most) to 7(least) verbose\"\n                        \"\\nor strings: VERBOSE, DEBUG, INFO, WARNING, ERROR, FATAL, ALWAYS\")\n\n    parser.add_argument(\"--numberOfEvents\", \"-N\", action=\"store\", dest=\"numberOfEvents\", default=self.numberOfEvents,\n                        type=int, help=\"number of events to simulate, used in batch mode\")\n\n    parser.add_argument(\"--skipNEvents\", action=\"store\", dest=\"skipNEvents\", default=self.skipNEvents, type=int,\n                        help=\"Skip first N events when reading a file\")\n\n    parser.add_argument(\"--physicsList\", action=\"store\", dest=\"physicsList\", default=self.physicsList,\n                        help=\"Physics list to use in simulation\")\n\n    parser.add_argument(\"--crossingAngleBoost\", action=\"store\", dest=\"crossingAngleBoost\",\n                        default=self.crossingAngleBoost,\n                        type=float, help=\"Lorentz boost for the crossing angle, in radian!\")\n\n    parser.add_argument(\"--vertexSigma\", nargs=4, action=\"store\", dest=\"vertexSigma\",\n                        default=self.vertexSigma, metavar=('X', 'Y', 'Z', 'T'),\n                        type=float, help=\"FourVector of the Sigma for the Smearing of the Vertex position: x y z t\")\n\n    parser.add_argument(\"--vertexOffset\", nargs=4, action=\"store\", dest=\"vertexOffset\",\n                        default=self.vertexOffset, metavar=('X', 'Y', 'Z', 'T'),\n                        type=float, help=\"FourVector of translation for the Smearing of the Vertex position: x y z t\")\n\n    parser.add_argument(\"--macroFile\", \"-M\", action=\"store\", dest=\"macroFile\", default=self.macroFile,\n                        help=\"Macro file to execute for runType 'run' or 'vis'\")\n\n    parser.add_argument(\"--enableGun\", \"-G\", action=\"store_true\", dest=\"enableGun\", default=self.enableGun,\n                        help=\"enable the DDG4 particle gun\")\n\n    parser.add_argument(\"--enableG4GPS\", action=\"store_true\", dest=\"enableG4GPS\", default=self.enableG4GPS,\n                        help=\"enable the Geant4 GeneralParticleSource. Needs a macroFile (runType run)\"\n                        \"or use it with the shell (runType shell)\")\n\n    parser.add_argument(\"--enableG4Gun\", action=\"store_true\", dest=\"enableG4Gun\", default=self.enableG4Gun,\n                        help=\"enable the Geant4 particle gun. Needs a macroFile (runType run)\"\n                        \" or use it with the shell (runType shell)\")\n\n    parser.add_argument(\"--dumpParameter\", \"--dump\", action=\"store_true\", dest=\"dumpParameter\",\n                        default=self._dumpParameter, help=\"Print all configuration Parameters and exit\")\n\n    parser.add_argument(\"--enableDetailedShowerMode\", action=\"store_true\", dest=\"enableDetailedShowerMode\",\n                        default=self.enableDetailedShowerMode,\n                        help=\"use detailed shower mode\")\n\n    parser.add_argument(\"--dumpSteeringFile\", action=\"store_true\", dest=\"dumpSteeringFile\",\n                        default=self._dumpSteeringFile, help=\"print an example steering file to stdout\")\n\n    # output, or do something smarter with fullHelp only for example\n    ConfigHelper.addAllHelper(self, parser)\n    # now parse everything. The default values are now taken from the\n    # steeringFile if they were set so that the steering file parameters can be\n    # overwritten from the command line\n    if ARGCOMPLETEENABLED:\n      argcomplete.autocomplete(parser)\n    parsed = parser.parse_args()\n\n    self._dumpParameter = parsed.dumpParameter\n    self._dumpSteeringFile = parsed.dumpSteeringFile\n\n    self.compactFile = ConfigHelper.makeList(parsed.compactFile)\n    self.inputFiles = parsed.inputFiles\n    self.inputFiles = self.__checkFileFormat(self.inputFiles, POSSIBLEINPUTFILES)\n    self.outputFile = parsed.outputFile\n    self.__checkFileFormat(self.outputFile, ('.root', '.slcio'))\n    self.runType = parsed.runType\n    self.printLevel = self.__checkOutputLevel(parsed.printLevel)\n\n    self.numberOfEvents = parsed.numberOfEvents\n    self.skipNEvents = parsed.skipNEvents\n    self.physicsList = parsed.physicsList\n    self.crossingAngleBoost = parsed.crossingAngleBoost\n    self.macroFile = parsed.macroFile\n    self.enableGun = parsed.enableGun\n    self.enableG4Gun = parsed.enableG4Gun\n    self.enableG4GPS = parsed.enableG4GPS\n    self.enableDetailedShowerMode = parsed.enableDetailedShowerMode\n    self.vertexOffset = parsed.vertexOffset\n    self.vertexSigma = parsed.vertexSigma\n\n    self._consistencyChecks()\n\n    if self.printLevel <= 2:  # VERBOSE or DEBUG\n      logger.setLevel(logging.DEBUG)\n\n    # self.__treatUnknownArgs( parsed, unknown )\n    self.__parseAllHelper(parsed)\n    if self._errorMessages and not (self._dumpParameter or self._dumpSteeringFile):\n      parser.epilog = \"\\n\".join(self._errorMessages)\n      parser.print_help()\n      exit(1)\n\n    if self._dumpParameter:\n      from pprint import pprint\n      logger.info(\"=\" * 80)\n      pprint(vars(self))\n      logger.info(\"=\" * 80)\n      exit(0)\n\n    if self._dumpSteeringFile:\n      self.__printSteeringFile(parser)\n      exit(0)\n\n  def getDetectorLists(self, detectorDescription):\n    ''' get lists of trackers and calorimeters that are defined in detectorDescription (the compact xml file)'''\n    import DDG4\n    trackers, calos, unknown = [], [], []\n    for i in detectorDescription.detectors():\n      det = DDG4.DetElement(i.second.ptr())\n      name = det.name()\n      sd = detectorDescription.sensitiveDetector(name)\n      if sd.isValid():\n        detType = sd.type()\n        logger.info('getDetectorLists - found active detector %s type: %s', name, detType)\n        if any(pat.lower() in detType.lower() for pat in self.action.trackerSDTypes):\n          trackers.append(det.name())\n        elif any(pat.lower() in detType.lower() for pat in self.action.calorimeterSDTypes):\n          calos.append(det.name())\n        else:\n          logger.warning('Unknown sensitive detector type: %s', detType)\n          unknown.append(det.name())\n\n    return trackers, calos, unknown\n\n# ==================================================================================\n\n  def run(self):\n    \"\"\"setup the geometry and dd4hep and geant4 and do what was asked to be done\"\"\"\n    import ROOT\n    ROOT.PyConfig.IgnoreCommandLineOptions = True\n\n    import DDG4\n    import dd4hep\n\n    self.printLevel = getOutputLevel(self.printLevel)\n\n    kernel = DDG4.Kernel()\n    dd4hep.setPrintLevel(self.printLevel)\n\n    for compactFile in self.compactFile:\n      kernel.loadGeometry(str(\"file:\" + os.path.abspath(compactFile)))\n    detectorDescription = kernel.detectorDescription()\n\n    DDG4.importConstants(detectorDescription)\n\n  # ----------------------------------------------------------------------------------\n\n    # simple = DDG4.Geant4( kernel, tracker='Geant4TrackerAction',calo='Geant4CalorimeterAction')\n    # geant4 = DDG4.Geant4( kernel, tracker='Geant4TrackerCombineAction',calo='Geant4ScintillatorCalorimeterAction')\n    geant4 = DDG4.Geant4(kernel, tracker=self.action.tracker, calo=self.action.calo)\n\n    geant4.printDetectors()\n\n    if self.runType == \"vis\":\n      uiaction = geant4.setupUI(typ=\"tcsh\", vis=True, macro=self.macroFile)\n    elif self.runType == \"qt\":\n      uiaction = geant4.setupUI(typ=\"qt\", vis=True, macro=self.macroFile)\n    elif self.runType == \"run\":\n      uiaction = geant4.setupUI(typ=\"tcsh\", vis=False, macro=self.macroFile, ui=False)\n    elif self.runType == \"shell\":\n      uiaction = geant4.setupUI(typ=\"tcsh\", vis=False, macro=None, ui=True)\n    elif self.runType == \"batch\":\n      uiaction = geant4.setupUI(typ=\"tcsh\", vis=False, macro=None, ui=False)\n    else:\n      logger.error(\"unknown runType\")\n      exit(1)\n\n    # User Configuration for the Geant4Phases\n    uiaction.ConfigureCommands = self.ui._commandsConfigure\n    uiaction.InitializeCommands = self.ui._commandsInitialize\n    uiaction.PostRunCommands = self.ui._commandsPostRun\n    uiaction.PreRunCommands = self.ui._commandsPreRun\n    uiaction.TerminateCommands = self.ui._commandsTerminate\n\n    kernel.NumEvents = self.numberOfEvents\n\n    # -----------------------------------------------------------------------------------\n    # setup the magnetic field:\n    self.__setMagneticFieldOptions(geant4)\n\n    # configure geometry creation\n    self.geometry.constructGeometry(kernel, geant4, self.output.geometry)\n\n    # ----------------------------------------------------------------------------------\n    # Configure Run actions\n    run1 = DDG4.RunAction(kernel, 'Geant4TestRunAction/RunInit')\n    kernel.registerGlobalAction(run1)\n    kernel.runAction().add(run1)\n\n    # Configure the random seed, do it before the I/O because we might change the seed!\n    self.random.initialize(DDG4, kernel, self.output.random)\n\n    # Configure the output file format and plugin\n    self.outputConfig.initialize(dd4hepsimulation=self, geant4=geant4)\n\n    actionList = []\n\n    if self.enableGun:\n      gun = DDG4.GeneratorAction(kernel, \"Geant4ParticleGun/\" + \"Gun\")\n      self.gun.setOptions(gun)\n      gun.Standalone = False\n      gun.Mask = 1\n      actionList.append(gun)\n      self.__applyBoostOrSmear(kernel, actionList, 1)\n      logger.info(\"++++ Adding DD4hep Particle Gun ++++\")\n\n    if self.enableG4Gun:\n      # GPS Create something\n      self._g4gun = DDG4.GeneratorAction(kernel, \"Geant4GeneratorWrapper/Gun\")\n      self._g4gun.Uses = 'G4ParticleGun'\n      self._g4gun.Mask = 2\n      logger.info(\"++++ Adding Geant4 Particle Gun ++++\")\n      actionList.append(self._g4gun)\n\n    if self.enableG4GPS:\n      # GPS Create something\n      self._g4gps = DDG4.GeneratorAction(kernel, \"Geant4GeneratorWrapper/GPS\")\n      self._g4gps.Uses = 'G4GeneralParticleSource'\n      self._g4gps.Mask = 3\n      logger.info(\"++++ Adding Geant4 General Particle Source ++++\")\n      actionList.append(self._g4gps)\n\n    start = 4\n    for index, plugin in enumerate(self.inputConfig.userInputPlugin, start=start):\n      gen = plugin(self)\n      gen.Mask = index\n      start = index + 1\n      actionList.append(gen)\n      self.__applyBoostOrSmear(kernel, actionList, index)\n      logger.info(\"++++ Adding User Plugin %s ++++\", gen.Name)\n\n    for index, inputFile in enumerate(self.inputFiles, start=start):\n      if inputFile.endswith(\".slcio\"):\n        gen = DDG4.GeneratorAction(kernel, \"LCIOInputAction/LCIO%d\" % index)\n        gen.Parameters = self.lcio.getParameters()\n        gen.Input = \"LCIOFileReader|\" + inputFile\n      elif inputFile.endswith(\".stdhep\"):\n        gen = DDG4.GeneratorAction(kernel, \"LCIOInputAction/STDHEP%d\" % index)\n        gen.Input = \"LCIOStdHepReader|\" + inputFile\n      elif inputFile.endswith(\".HEPEvt\"):\n        gen = DDG4.GeneratorAction(kernel, \"Geant4InputAction/HEPEvt%d\" % index)\n        gen.Input = \"Geant4EventReaderHepEvtShort|\" + inputFile\n      elif inputFile.endswith(\".hepevt\"):\n        gen = DDG4.GeneratorAction(kernel, \"Geant4InputAction/hepevt%d\" % index)\n        gen.Input = \"Geant4EventReaderHepEvtLong|\" + inputFile\n      elif inputFile.endswith(tuple([\".hepmc\"] + HEPMC3_SUPPORTED_EXTENSIONS)):\n        if self.hepmc3.useHepMC3:\n          gen = DDG4.GeneratorAction(kernel, \"Geant4InputAction/hepmc%d\" % index)\n          gen.Parameters = self.hepmc3.getParameters()\n          gen.Input = \"HEPMC3FileReader|\" + inputFile\n        else:\n          gen = DDG4.GeneratorAction(kernel, \"Geant4InputAction/hepmc%d\" % index)\n          gen.Input = \"Geant4EventReaderHepMC|\" + inputFile\n      elif inputFile.endswith(\".pairs\"):\n        gen = DDG4.GeneratorAction(kernel, \"Geant4InputAction/GuineaPig%d\" % index)\n        gen.Input = \"Geant4EventReaderGuineaPig|\" + inputFile\n        gen.Parameters = self.guineapig.getParameters()\n      else:\n        # this should never happen because we already check at the top, but in case of some LogicError...\n        raise RuntimeError(\"Unknown input file type: %s\" % inputFile)\n      gen.Sync = self.skipNEvents\n      gen.Mask = index\n      actionList.append(gen)\n      self.__applyBoostOrSmear(kernel, actionList, index)\n\n    if actionList:\n      self._buildInputStage(geant4, actionList, output_level=self.output.inputStage,\n                            have_mctruth=self._enablePrimaryHandler())\n\n    # ================================================================================================\n\n    # And handle the simulation particles.\n    part = DDG4.GeneratorAction(kernel, \"Geant4ParticleHandler/ParticleHandler\")\n    kernel.generatorAction().adopt(part)\n    # part.SaveProcesses = ['conv','Decay']\n    part.SaveProcesses = self.part.saveProcesses\n    part.MinimalKineticEnergy = self.part.minimalKineticEnergy\n    part.KeepAllParticles = self.part.keepAllParticles\n    part.PrintEndTracking = self.part.printEndTracking\n    part.PrintStartTracking = self.part.printStartTracking\n    part.MinDistToParentVertex = self.part.minDistToParentVertex\n    part.OutputLevel = self.output.part\n    part.enableUI()\n\n    if self.part.enableDetailedHitsAndParticleInfo:\n      self.part.setDumpDetailedParticleInfo(kernel, DDG4)\n\n    self.part.setupUserParticleHandler(part, kernel, DDG4)\n\n    # =================================================================================\n\n    # Setup global filters for use in sensitive detectors\n    try:\n      self.filter.setupFilters(kernel)\n    except RuntimeError as e:\n      logger.error(\"%s\", e)\n      exit(1)\n\n    # =================================================================================\n    # get lists of trackers and calorimeters in detectorDescription\n\n    trk, cal, unk = self.getDetectorLists(detectorDescription)\n\n    for detectors, function, defFilter, abort in [(trk, geant4.setupTracker, self.filter.tracker, False),\n                                                  (cal, geant4.setupCalorimeter, self.filter.calo, False),\n                                                  (unk, geant4.setupDetector, None, True),\n                                                  ]:\n      try:\n        self.__setupSensitiveDetectors(detectors, function, defFilter, abort)\n      except Exception as e:\n        logger.error(\"Failed setting up sensitive detector %s\", e)\n        raise\n\n  # =================================================================================\n    # Now build the physics list:\n    _phys = self.physics.setupPhysics(kernel, name=self.physicsList)\n\n    # add the G4StepLimiterPhysics to activate the max step limits in volumes\n    ph = DDG4.PhysicsList(kernel, 'Geant4PhysicsList/Myphysics')\n    ph.addPhysicsConstructor(str('G4StepLimiterPhysics'))\n    _phys.add(ph)\n\n    dd4hep.setPrintLevel(self.printLevel)\n\n    kernel.configure()\n    kernel.initialize()\n\n    # GPS\n    if self._g4gun is not None:\n      self._g4gun.generator()\n    if self._g4gps is not None:\n      self._g4gps.generator()\n\n    startUpTime, _sysTime, _cuTime, _csTime, _elapsedTime = os.times()\n\n    kernel.run()\n    kernel.terminate()\n\n    totalTimeUser, totalTimeSys, _cuTime, _csTime, _elapsedTime = os.times()\n    if self.printLevel <= 3:\n      logger.info(\"DDSim            INFO  Total Time:   %3.2f s (User), %3.2f s (System)\" %\n                  (totalTimeUser, totalTimeSys))\n      if self.numberOfEvents != 0:\n        eventTime = totalTimeUser - startUpTime\n        perEventTime = eventTime / self.numberOfEvents\n        logger.info(\"DDSim            INFO  StartUp Time: %3.2f s, Event Processing: %3.2f s (%3.2f s/Event) \"\n                    % (startUpTime, eventTime, perEventTime))\n\n  def __setMagneticFieldOptions(self, geant4):\n    \"\"\" create and configure the magnetic tracking setup \"\"\"\n    field = geant4.addConfig('Geant4FieldTrackingSetupAction/MagFieldTrackingSetup')\n    field.stepper = self.field.stepper\n    field.equation = self.field.equation\n    field.eps_min = self.field.eps_min\n    field.eps_max = self.field.eps_max\n    field.min_chord_step = self.field.min_chord_step\n    field.delta_chord = self.field.delta_chord\n    field.delta_intersection = self.field.delta_intersection\n    field.delta_one_step = self.field.delta_one_step\n    field.largest_step = self.field.largest_step\n\n  def __checkFileFormat(self, fileNames, extensions):\n    \"\"\"check if the fileName is allowed, note that the filenames are case\n    sensitive, and in case of hepevt we depend on this to identify short and long versions of the content\n    \"\"\"\n    if isinstance(fileNames, str):\n      fileNames = [fileNames]\n    if not all(fileName.endswith(tuple(extensions)) for fileName in fileNames):\n      self._errorMessages.append(\"ERROR: Unknown fileformat for file: %s\" % fileNames)\n    is_hepmc3_extension = any(fileName.endswith(tuple(HEPMC3_SUPPORTED_EXTENSIONS)) for fileName in fileNames)\n    if not self.hepmc3.useHepMC3 and is_hepmc3_extension:\n      self._errorMessages.append(\"ERROR: HepMC3 files or compressed HepMC2 require the use of HepMC3 library\")\n    return fileNames\n\n  def __applyBoostOrSmear(self, kernel, actionList, mask):\n    \"\"\"apply boost or smearing for given mask index\"\"\"\n    import DDG4\n    if self.crossingAngleBoost:\n      lbo = DDG4.GeneratorAction(kernel, \"Geant4InteractionVertexBoost\")\n      lbo.Angle = self.crossingAngleBoost\n      lbo.Mask = mask\n      actionList.append(lbo)\n\n    if any(self.vertexSigma) or any(self.vertexOffset):\n      vSmear = DDG4.GeneratorAction(kernel, \"Geant4InteractionVertexSmear\")\n      vSmear.Offset = self.vertexOffset\n      vSmear.Sigma = self.vertexSigma\n      vSmear.Mask = mask\n      actionList.append(vSmear)\n\n  def __parseAllHelper(self, parsed):\n    \"\"\" parse all the options for the helper \"\"\"\n    parsedDict = vars(parsed)\n    for name, obj in vars(self).items():\n      if isinstance(obj, ConfigHelper):\n        for var in obj.getOptions():\n          key = \"%s.%s\" % (name, var)\n          if key in parsedDict:\n            try:\n              obj.setOption(var, parsedDict[key])\n            except RuntimeError as e:\n              self._errorMessages.append(\"ERROR: %s \" % e)\n              if logger.level <= logging.DEBUG:\n                self._errorMessages.append(traceback.format_exc())\n        obj._checkProperties()\n\n  def __checkOutputLevel(self, level):\n    \"\"\"return outputlevel as int so we don't have to import anything for faster startup\"\"\"\n    try:\n      return outputLevel(level)\n    except ValueError:\n      self._errorMessages.append(\"ERROR: printLevel is neither integer nor string\")\n      return -1\n    except KeyError:\n      self._errorMessages.append(\"ERROR: printLevel '%s' unknown\" % level)\n      return -1\n\n  def __setupSensitiveDetectors(self, detectors, setupFunction, defaultFilter=None,\n                                abortForMissingAction=False,\n                                ):\n    \"\"\"Attach sensitive detector actions for all subdetectors.\n\n    Can be steered with the `Action` ConfigHelpers\n\n    :param detectors: list of detectors\n    :param setupFunction: function used to register the sensitive detector\n    :param defaultFilter: default filter to apply for given types\n    :param abortForMissingAction: if true end program if there is no action found\n    \"\"\"\n    for det in detectors:\n      logger.info('Setting up SD for %s', det)\n      action = None\n      for pattern in self.action.mapActions:\n        if pattern.lower() in det.lower():\n          action = self.action.mapActions[pattern]\n          logger.info('       replace default action with : %s', action)\n          break\n      if abortForMissingAction and action is None:\n        logger.error('Cannot find Action for detector %s. You have to extend \"action.mapAction\"', det)\n        raise RuntimeError(\"Cannot find Action\")\n      seq, act = setupFunction(det, action)\n      self.filter.applyFilters(seq, det, defaultFilter)\n\n      # set detailed hit creation mode for this\n      if self.enableDetailedShowerMode:\n        if isinstance(act, list):\n          for a in act:\n            a.HitCreationMode = 2\n        else:\n          act.HitCreationMode = 2\n\n  def __printSteeringFile(self, parser):\n    \"\"\"print the parameters formated as a steering file\"\"\"\n\n    steeringFileBase = textwrap.dedent(\"\"\"\\\n        from DDSim.DD4hepSimulation import DD4hepSimulation\n        from g4units import mm, GeV, MeV\n        SIM = DD4hepSimulation()\n        \"\"\")\n    steeringFileBase += \"\\n\"\n    optionDict = parser._option_string_actions\n    parameters = vars(self)\n    for parName, parameter in sorted(list(parameters.items()), key=sortParameters):\n      if parName.startswith(\"_\"):\n        continue\n      if isinstance(parameter, ConfigHelper):\n        steeringFileBase += \"\\n\\n\"\n        steeringFileBase += \"################################################################################\\n\"\n        steeringFileBase += \"## %s \\n\" % \"\\n## \".join(parameter.__doc__.splitlines())\n        steeringFileBase += \"################################################################################\\n\"\n        options = parameter.getOptions()\n        for opt, optionsDict in sorted(options.items(), key=sortParameters):\n          if opt.startswith(\"_\"):\n            continue\n          parValue = optionsDict['default']\n          if isinstance(optionsDict.get('help'), str):\n            steeringFileBase += \"\\n## %s\\n\" % \"\\n## \".join(optionsDict.get('help').splitlines())\n          # add quotes if it is a string\n          if isinstance(parValue, str):\n            steeringFileBase += \"SIM.%s.%s = \\\"%s\\\"\\n\" % (parName, opt, parValue)\n          else:\n            steeringFileBase += \"SIM.%s.%s = %s\\n\" % (parName, opt, parValue)\n      else:\n        # get the docstring from the command line parameter\n        optionObj = optionDict.get(\"--\" + parName, None)\n        if isinstance(optionObj, argparse._StoreAction):\n          steeringFileBase += \"## %s\\n\" % \"\\n## \".join(optionObj.help.splitlines())\n        # add quotes if it is a string\n        if isinstance(parameter, str):\n          steeringFileBase += \"SIM.%s = \\\"%s\\\"\" % (parName, str(parameter))\n        else:\n          steeringFileBase += \"SIM.%s = %s\" % (parName, str(parameter))\n        steeringFileBase += \"\\n\"\n    for line in steeringFileBase.splitlines():\n      print(line)\n\n  def _consistencyChecks(self):\n    \"\"\"Check if the requested setup makes sense, or if there is something preventing it from working correctly\n\n    Appends error messages to self._errorMessages\n\n    :returns: None\n    \"\"\"\n\n    if not self.compactFile:\n      self._errorMessages.append(\"ERROR: No geometry compact file provided\")\n\n    if self.runType == \"batch\":\n      if not self.numberOfEvents:\n        self._errorMessages.append(\"ERROR: Batch mode requested, but did not set number of events\")\n      if not (self.inputFiles or self.enableGun or self.inputConfig.userInputPlugin):\n        self._errorMessages.append(\"ERROR: Batch mode requested, but did not set inputFile(s), gun, or userInputPlugin\")\n\n    if self.inputFiles and (self.enableG4Gun or self.enableG4GPS):\n      self._errorMessages.append(\"ERROR: Cannot use both inputFiles and Geant4Gun or GeneralParticleSource\")\n\n    if self.enableGun and (self.enableG4Gun or self.enableG4GPS):\n      self._errorMessages.append(\"ERROR: Cannot use both DD4hepGun and Geant4 Gun or GeneralParticleSource\")\n\n    if self.inputConfig.userInputPlugin and (self.enableG4Gun or self.enableG4GPS):\n      self._errorMessages.append(\"ERROR: Cannot use both userInputPlugin and Geant4 Gun or GeneralParticleSource\")\n\n    if self.numberOfEvents < 0 and not self.inputFiles:\n      self._errorMessages.append(\"ERROR: Negative number of events only sensible for inputFiles\")\n\n  def _enablePrimaryHandler(self):\n    \"\"\" the geant4 Gun or GeneralParticleSource cannot be used together with the PrimaryHandler.\n        Particles would be simulated multiple times\n\n    :returns: True or False\n    \"\"\"\n    enablePrimaryHandler = not (self.enableG4Gun or self.enableG4GPS)\n    if enablePrimaryHandler:\n      logger.info(\"Enabling the PrimaryHandler\")\n    else:\n      logger.info(\"Disabling the PrimaryHandler\")\n    return enablePrimaryHandler\n\n  def _buildInputStage(self, geant4, generator_input_modules, output_level=None, have_mctruth=True):\n    \"\"\"\n    Generic build of the input stage with multiple input modules.\n    Actions executed are:\n    1) Register Generation initialization action\n    2) Append all modules to build the complete input record\n    These modules are readers/particle sources, boosters and/or smearing actions.\n    3) Merge all existing interaction records\n    4) Add the MC truth handler\n    \"\"\"\n    from DDG4 import GeneratorAction\n    ga = geant4.kernel().generatorAction()\n\n    # Register Generation initialization action\n    gen = GeneratorAction(geant4.kernel(), \"Geant4GeneratorActionInit/GenerationInit\")\n    if output_level is not None:\n      gen.OutputLevel = output_level\n    ga.adopt(gen)\n\n    # Now append all modules to build the complete input record\n    # These modules are readers/particle sources, boosters and/or smearing actions\n    for gen in generator_input_modules:\n      gen.enableUI()\n      if output_level is not None:\n        gen.OutputLevel = output_level\n      ga.adopt(gen)\n\n    # Merge all existing interaction records\n    gen = GeneratorAction(geant4.kernel(), \"Geant4InteractionMerger/InteractionMerger\")\n    gen.enableUI()\n    if output_level is not None:\n      gen.OutputLevel = output_level\n    ga.adopt(gen)\n\n    # Finally generate Geant4 primaries\n    if have_mctruth:\n      gen = GeneratorAction(geant4.kernel(), \"Geant4PrimaryHandler/PrimaryHandler\")\n      gen.RejectPDGs = ConfigHelper.makeString(self.physics.rejectPDGs)\n      gen.ZeroTimePDGs = ConfigHelper.makeString(self.physics.zeroTimePDGs)\n      gen.enableUI()\n      if output_level is not None:\n        gen.OutputLevel = output_level\n      ga.adopt(gen)\n    # Puuuhh! All done.\n    return None",
  "def sortParameters(key):\n  from functools import cmp_to_key\n\n  def _sortParameters(parA, parB):\n    \"\"\"sort the parameters by name: first normal parameters, then set of\n    parameters based on ConfigHelper objects\n    \"\"\"\n    parTypeA = parA[1]\n    parTypeB = parB[1]\n    if isinstance(parTypeA, ConfigHelper) and isinstance(parTypeB, ConfigHelper):\n      return 1 if str(parA[0]) > str(parB[0]) else -1\n    elif isinstance(parTypeA, ConfigHelper):\n      return 1\n    elif isinstance(parTypeB, ConfigHelper):\n      return -1\n    else:\n      return 1 if str(parA[0]) > str(parB[0]) else -1\n\n  return cmp_to_key(_sortParameters)(key)",
  "def getOutputLevel(level):\n  \"\"\"return output.LEVEL\"\"\"\n  from DDG4 import OutputLevel\n  levels = {1: OutputLevel.VERBOSE,\n            2: OutputLevel.DEBUG,\n            3: OutputLevel.INFO,\n            4: OutputLevel.WARNING,\n            5: OutputLevel.ERROR,\n            6: OutputLevel.FATAL,\n            7: OutputLevel.ALWAYS}\n  return levels[level]",
  "def __init__(self):\n    self.steeringFile = None\n    self.compactFile = []\n    self.inputFiles = []\n    self.outputFile = defaultOutputFile()\n    self.runType = \"batch\"\n    self.printLevel = 3\n\n    self.numberOfEvents = 0\n    self.skipNEvents = 0\n    self.physicsList = None  # deprecated use physics.list\n    self.crossingAngleBoost = 0.0\n    self.macroFile = ''\n    self.enableGun = False\n    self.enableG4GPS = False\n    self.enableG4Gun = False\n    self._g4gun = None\n    self._g4gps = None\n    self.vertexSigma = [0.0, 0.0, 0.0, 0.0]\n    self.vertexOffset = [0.0, 0.0, 0.0, 0.0]\n    self.enableDetailedShowerMode = False\n\n    self._errorMessages = []\n    self._dumpParameter = False\n    self._dumpSteeringFile = False\n\n    # objects for extended configuration option\n    self.output = Output()\n    self.random = Random()\n    self.gun = Gun()\n    self.part = ParticleHandler()\n    self.field = MagneticField()\n    self.action = Action()\n    self.outputConfig = OutputConfig()\n    self.inputConfig = InputConfig()\n    self.guineapig = GuineaPig()\n    self.lcio = LCIO()\n    self.hepmc3 = HepMC3()\n    self.meta = Meta()\n\n    self.geometry = Geometry()\n    self.filter = Filter()\n    self.physics = Physics()\n    self.ui = UI()\n\n    self._argv = None",
  "def readSteeringFile(self):\n    \"\"\"Reads a steering file and sets the parameters to that of the\n    DD4hepSimulation object present in the steering file.\n    \"\"\"\n    globs = {}\n    locs = {}\n    if not self.steeringFile:\n      return\n    sFileTemp = self.steeringFile\n    exec(compile(open(self.steeringFile).read(), self.steeringFile, 'exec'), globs, locs)\n    for _name, obj in locs.items():\n      if isinstance(obj, DD4hepSimulation):\n        self.__dict__ = obj.__dict__\n    self.steeringFile = os.path.abspath(sFileTemp)",
  "def parseOptions(self, argv=None):\n    \"\"\"parse the command line options\"\"\"\n\n    if argv is None:\n      self._argv = list(sys.argv)\n\n    parser = argparse.ArgumentParser(\"Running DD4hep Simulations:\",\n                                     formatter_class=argparse.RawTextHelpFormatter)\n\n    parser.add_argument(\"--steeringFile\", \"-S\", action=\"store\", default=self.steeringFile,\n                        help=\"Steering file to change default behaviour\")\n\n    # first we parse just the steering file, but only if we don't want to see the help message\n    if not any(opt in self._argv for opt in ('-h', '--help')):\n      parsed, _unknown = parser.parse_known_args()\n      self.steeringFile = parsed.steeringFile\n      self.readSteeringFile()\n\n    # readSteeringFile will set self._argv to None if there is a steering file\n    if self._argv is None:\n      self._argv = list(argv) if argv else list(sys.argv)\n\n    parser.add_argument(\"--compactFile\", nargs='+', action=\"store\",\n                        default=ConfigHelper.makeList(self.compactFile), type=str,\n                        help=\"The compact XML file, or multiple compact files, if the last one is the closer.\")\n\n    parser.add_argument(\"--runType\", action=\"store\", choices=(\"batch\", \"vis\", \"run\", \"shell\", \"qt\"),\n                        default=self.runType,\n                        help=\"The type of action to do in this invocation\"  # Note: implicit string concatenation\n                        \"\\nbatch: just simulate some events, needs numberOfEvents, and input file or gun\"\n                        \"\\nvis: enable visualisation, run the macroFile if it is set\"\n                        \"\\nqt: enable visualisation in Qt shell, run the macroFile if it is set\"\n                        \"\\nrun: run the macroFile and exit\"\n                        \"\\nshell: enable interactive session\")\n\n    parser.add_argument(\"--inputFiles\", \"-I\", nargs='+', action=\"store\", default=self.inputFiles,\n                        help=\"InputFiles for simulation %s files are supported\" % \", \".join(POSSIBLEINPUTFILES))\n\n    parser.add_argument(\"--outputFile\", \"-O\", action=\"store\", default=self.outputFile,\n                        help=\"Outputfile from the simulation: .slcio, edm4hep.root and .root\"\n                        \" output files are supported\")\n\n    parser.add_argument(\"-v\", \"--printLevel\", action=\"store\", default=self.printLevel, dest=\"printLevel\",\n                        choices=(1, 2, 3, 4, 5, 6, 7, 'VERBOSE', 'DEBUG',\n                                 'INFO', 'WARNING', 'ERROR', 'FATAL', 'ALWAYS'),\n                        type=outputLevelType,\n                        help=\"Verbosity use integers from 1(most) to 7(least) verbose\"\n                        \"\\nor strings: VERBOSE, DEBUG, INFO, WARNING, ERROR, FATAL, ALWAYS\")\n\n    parser.add_argument(\"--numberOfEvents\", \"-N\", action=\"store\", dest=\"numberOfEvents\", default=self.numberOfEvents,\n                        type=int, help=\"number of events to simulate, used in batch mode\")\n\n    parser.add_argument(\"--skipNEvents\", action=\"store\", dest=\"skipNEvents\", default=self.skipNEvents, type=int,\n                        help=\"Skip first N events when reading a file\")\n\n    parser.add_argument(\"--physicsList\", action=\"store\", dest=\"physicsList\", default=self.physicsList,\n                        help=\"Physics list to use in simulation\")\n\n    parser.add_argument(\"--crossingAngleBoost\", action=\"store\", dest=\"crossingAngleBoost\",\n                        default=self.crossingAngleBoost,\n                        type=float, help=\"Lorentz boost for the crossing angle, in radian!\")\n\n    parser.add_argument(\"--vertexSigma\", nargs=4, action=\"store\", dest=\"vertexSigma\",\n                        default=self.vertexSigma, metavar=('X', 'Y', 'Z', 'T'),\n                        type=float, help=\"FourVector of the Sigma for the Smearing of the Vertex position: x y z t\")\n\n    parser.add_argument(\"--vertexOffset\", nargs=4, action=\"store\", dest=\"vertexOffset\",\n                        default=self.vertexOffset, metavar=('X', 'Y', 'Z', 'T'),\n                        type=float, help=\"FourVector of translation for the Smearing of the Vertex position: x y z t\")\n\n    parser.add_argument(\"--macroFile\", \"-M\", action=\"store\", dest=\"macroFile\", default=self.macroFile,\n                        help=\"Macro file to execute for runType 'run' or 'vis'\")\n\n    parser.add_argument(\"--enableGun\", \"-G\", action=\"store_true\", dest=\"enableGun\", default=self.enableGun,\n                        help=\"enable the DDG4 particle gun\")\n\n    parser.add_argument(\"--enableG4GPS\", action=\"store_true\", dest=\"enableG4GPS\", default=self.enableG4GPS,\n                        help=\"enable the Geant4 GeneralParticleSource. Needs a macroFile (runType run)\"\n                        \"or use it with the shell (runType shell)\")\n\n    parser.add_argument(\"--enableG4Gun\", action=\"store_true\", dest=\"enableG4Gun\", default=self.enableG4Gun,\n                        help=\"enable the Geant4 particle gun. Needs a macroFile (runType run)\"\n                        \" or use it with the shell (runType shell)\")\n\n    parser.add_argument(\"--dumpParameter\", \"--dump\", action=\"store_true\", dest=\"dumpParameter\",\n                        default=self._dumpParameter, help=\"Print all configuration Parameters and exit\")\n\n    parser.add_argument(\"--enableDetailedShowerMode\", action=\"store_true\", dest=\"enableDetailedShowerMode\",\n                        default=self.enableDetailedShowerMode,\n                        help=\"use detailed shower mode\")\n\n    parser.add_argument(\"--dumpSteeringFile\", action=\"store_true\", dest=\"dumpSteeringFile\",\n                        default=self._dumpSteeringFile, help=\"print an example steering file to stdout\")\n\n    # output, or do something smarter with fullHelp only for example\n    ConfigHelper.addAllHelper(self, parser)\n    # now parse everything. The default values are now taken from the\n    # steeringFile if they were set so that the steering file parameters can be\n    # overwritten from the command line\n    if ARGCOMPLETEENABLED:\n      argcomplete.autocomplete(parser)\n    parsed = parser.parse_args()\n\n    self._dumpParameter = parsed.dumpParameter\n    self._dumpSteeringFile = parsed.dumpSteeringFile\n\n    self.compactFile = ConfigHelper.makeList(parsed.compactFile)\n    self.inputFiles = parsed.inputFiles\n    self.inputFiles = self.__checkFileFormat(self.inputFiles, POSSIBLEINPUTFILES)\n    self.outputFile = parsed.outputFile\n    self.__checkFileFormat(self.outputFile, ('.root', '.slcio'))\n    self.runType = parsed.runType\n    self.printLevel = self.__checkOutputLevel(parsed.printLevel)\n\n    self.numberOfEvents = parsed.numberOfEvents\n    self.skipNEvents = parsed.skipNEvents\n    self.physicsList = parsed.physicsList\n    self.crossingAngleBoost = parsed.crossingAngleBoost\n    self.macroFile = parsed.macroFile\n    self.enableGun = parsed.enableGun\n    self.enableG4Gun = parsed.enableG4Gun\n    self.enableG4GPS = parsed.enableG4GPS\n    self.enableDetailedShowerMode = parsed.enableDetailedShowerMode\n    self.vertexOffset = parsed.vertexOffset\n    self.vertexSigma = parsed.vertexSigma\n\n    self._consistencyChecks()\n\n    if self.printLevel <= 2:  # VERBOSE or DEBUG\n      logger.setLevel(logging.DEBUG)\n\n    # self.__treatUnknownArgs( parsed, unknown )\n    self.__parseAllHelper(parsed)\n    if self._errorMessages and not (self._dumpParameter or self._dumpSteeringFile):\n      parser.epilog = \"\\n\".join(self._errorMessages)\n      parser.print_help()\n      exit(1)\n\n    if self._dumpParameter:\n      from pprint import pprint\n      logger.info(\"=\" * 80)\n      pprint(vars(self))\n      logger.info(\"=\" * 80)\n      exit(0)\n\n    if self._dumpSteeringFile:\n      self.__printSteeringFile(parser)\n      exit(0)",
  "def getDetectorLists(self, detectorDescription):\n    ''' get lists of trackers and calorimeters that are defined in detectorDescription (the compact xml file)'''\n    import DDG4\n    trackers, calos, unknown = [], [], []\n    for i in detectorDescription.detectors():\n      det = DDG4.DetElement(i.second.ptr())\n      name = det.name()\n      sd = detectorDescription.sensitiveDetector(name)\n      if sd.isValid():\n        detType = sd.type()\n        logger.info('getDetectorLists - found active detector %s type: %s', name, detType)\n        if any(pat.lower() in detType.lower() for pat in self.action.trackerSDTypes):\n          trackers.append(det.name())\n        elif any(pat.lower() in detType.lower() for pat in self.action.calorimeterSDTypes):\n          calos.append(det.name())\n        else:\n          logger.warning('Unknown sensitive detector type: %s', detType)\n          unknown.append(det.name())\n\n    return trackers, calos, unknown",
  "def run(self):\n    \"\"\"setup the geometry and dd4hep and geant4 and do what was asked to be done\"\"\"\n    import ROOT\n    ROOT.PyConfig.IgnoreCommandLineOptions = True\n\n    import DDG4\n    import dd4hep\n\n    self.printLevel = getOutputLevel(self.printLevel)\n\n    kernel = DDG4.Kernel()\n    dd4hep.setPrintLevel(self.printLevel)\n\n    for compactFile in self.compactFile:\n      kernel.loadGeometry(str(\"file:\" + os.path.abspath(compactFile)))\n    detectorDescription = kernel.detectorDescription()\n\n    DDG4.importConstants(detectorDescription)\n\n  # ----------------------------------------------------------------------------------\n\n    # simple = DDG4.Geant4( kernel, tracker='Geant4TrackerAction',calo='Geant4CalorimeterAction')\n    # geant4 = DDG4.Geant4( kernel, tracker='Geant4TrackerCombineAction',calo='Geant4ScintillatorCalorimeterAction')\n    geant4 = DDG4.Geant4(kernel, tracker=self.action.tracker, calo=self.action.calo)\n\n    geant4.printDetectors()\n\n    if self.runType == \"vis\":\n      uiaction = geant4.setupUI(typ=\"tcsh\", vis=True, macro=self.macroFile)\n    elif self.runType == \"qt\":\n      uiaction = geant4.setupUI(typ=\"qt\", vis=True, macro=self.macroFile)\n    elif self.runType == \"run\":\n      uiaction = geant4.setupUI(typ=\"tcsh\", vis=False, macro=self.macroFile, ui=False)\n    elif self.runType == \"shell\":\n      uiaction = geant4.setupUI(typ=\"tcsh\", vis=False, macro=None, ui=True)\n    elif self.runType == \"batch\":\n      uiaction = geant4.setupUI(typ=\"tcsh\", vis=False, macro=None, ui=False)\n    else:\n      logger.error(\"unknown runType\")\n      exit(1)\n\n    # User Configuration for the Geant4Phases\n    uiaction.ConfigureCommands = self.ui._commandsConfigure\n    uiaction.InitializeCommands = self.ui._commandsInitialize\n    uiaction.PostRunCommands = self.ui._commandsPostRun\n    uiaction.PreRunCommands = self.ui._commandsPreRun\n    uiaction.TerminateCommands = self.ui._commandsTerminate\n\n    kernel.NumEvents = self.numberOfEvents\n\n    # -----------------------------------------------------------------------------------\n    # setup the magnetic field:\n    self.__setMagneticFieldOptions(geant4)\n\n    # configure geometry creation\n    self.geometry.constructGeometry(kernel, geant4, self.output.geometry)\n\n    # ----------------------------------------------------------------------------------\n    # Configure Run actions\n    run1 = DDG4.RunAction(kernel, 'Geant4TestRunAction/RunInit')\n    kernel.registerGlobalAction(run1)\n    kernel.runAction().add(run1)\n\n    # Configure the random seed, do it before the I/O because we might change the seed!\n    self.random.initialize(DDG4, kernel, self.output.random)\n\n    # Configure the output file format and plugin\n    self.outputConfig.initialize(dd4hepsimulation=self, geant4=geant4)\n\n    actionList = []\n\n    if self.enableGun:\n      gun = DDG4.GeneratorAction(kernel, \"Geant4ParticleGun/\" + \"Gun\")\n      self.gun.setOptions(gun)\n      gun.Standalone = False\n      gun.Mask = 1\n      actionList.append(gun)\n      self.__applyBoostOrSmear(kernel, actionList, 1)\n      logger.info(\"++++ Adding DD4hep Particle Gun ++++\")\n\n    if self.enableG4Gun:\n      # GPS Create something\n      self._g4gun = DDG4.GeneratorAction(kernel, \"Geant4GeneratorWrapper/Gun\")\n      self._g4gun.Uses = 'G4ParticleGun'\n      self._g4gun.Mask = 2\n      logger.info(\"++++ Adding Geant4 Particle Gun ++++\")\n      actionList.append(self._g4gun)\n\n    if self.enableG4GPS:\n      # GPS Create something\n      self._g4gps = DDG4.GeneratorAction(kernel, \"Geant4GeneratorWrapper/GPS\")\n      self._g4gps.Uses = 'G4GeneralParticleSource'\n      self._g4gps.Mask = 3\n      logger.info(\"++++ Adding Geant4 General Particle Source ++++\")\n      actionList.append(self._g4gps)\n\n    start = 4\n    for index, plugin in enumerate(self.inputConfig.userInputPlugin, start=start):\n      gen = plugin(self)\n      gen.Mask = index\n      start = index + 1\n      actionList.append(gen)\n      self.__applyBoostOrSmear(kernel, actionList, index)\n      logger.info(\"++++ Adding User Plugin %s ++++\", gen.Name)\n\n    for index, inputFile in enumerate(self.inputFiles, start=start):\n      if inputFile.endswith(\".slcio\"):\n        gen = DDG4.GeneratorAction(kernel, \"LCIOInputAction/LCIO%d\" % index)\n        gen.Parameters = self.lcio.getParameters()\n        gen.Input = \"LCIOFileReader|\" + inputFile\n      elif inputFile.endswith(\".stdhep\"):\n        gen = DDG4.GeneratorAction(kernel, \"LCIOInputAction/STDHEP%d\" % index)\n        gen.Input = \"LCIOStdHepReader|\" + inputFile\n      elif inputFile.endswith(\".HEPEvt\"):\n        gen = DDG4.GeneratorAction(kernel, \"Geant4InputAction/HEPEvt%d\" % index)\n        gen.Input = \"Geant4EventReaderHepEvtShort|\" + inputFile\n      elif inputFile.endswith(\".hepevt\"):\n        gen = DDG4.GeneratorAction(kernel, \"Geant4InputAction/hepevt%d\" % index)\n        gen.Input = \"Geant4EventReaderHepEvtLong|\" + inputFile\n      elif inputFile.endswith(tuple([\".hepmc\"] + HEPMC3_SUPPORTED_EXTENSIONS)):\n        if self.hepmc3.useHepMC3:\n          gen = DDG4.GeneratorAction(kernel, \"Geant4InputAction/hepmc%d\" % index)\n          gen.Parameters = self.hepmc3.getParameters()\n          gen.Input = \"HEPMC3FileReader|\" + inputFile\n        else:\n          gen = DDG4.GeneratorAction(kernel, \"Geant4InputAction/hepmc%d\" % index)\n          gen.Input = \"Geant4EventReaderHepMC|\" + inputFile\n      elif inputFile.endswith(\".pairs\"):\n        gen = DDG4.GeneratorAction(kernel, \"Geant4InputAction/GuineaPig%d\" % index)\n        gen.Input = \"Geant4EventReaderGuineaPig|\" + inputFile\n        gen.Parameters = self.guineapig.getParameters()\n      else:\n        # this should never happen because we already check at the top, but in case of some LogicError...\n        raise RuntimeError(\"Unknown input file type: %s\" % inputFile)\n      gen.Sync = self.skipNEvents\n      gen.Mask = index\n      actionList.append(gen)\n      self.__applyBoostOrSmear(kernel, actionList, index)\n\n    if actionList:\n      self._buildInputStage(geant4, actionList, output_level=self.output.inputStage,\n                            have_mctruth=self._enablePrimaryHandler())\n\n    # ================================================================================================\n\n    # And handle the simulation particles.\n    part = DDG4.GeneratorAction(kernel, \"Geant4ParticleHandler/ParticleHandler\")\n    kernel.generatorAction().adopt(part)\n    # part.SaveProcesses = ['conv','Decay']\n    part.SaveProcesses = self.part.saveProcesses\n    part.MinimalKineticEnergy = self.part.minimalKineticEnergy\n    part.KeepAllParticles = self.part.keepAllParticles\n    part.PrintEndTracking = self.part.printEndTracking\n    part.PrintStartTracking = self.part.printStartTracking\n    part.MinDistToParentVertex = self.part.minDistToParentVertex\n    part.OutputLevel = self.output.part\n    part.enableUI()\n\n    if self.part.enableDetailedHitsAndParticleInfo:\n      self.part.setDumpDetailedParticleInfo(kernel, DDG4)\n\n    self.part.setupUserParticleHandler(part, kernel, DDG4)\n\n    # =================================================================================\n\n    # Setup global filters for use in sensitive detectors\n    try:\n      self.filter.setupFilters(kernel)\n    except RuntimeError as e:\n      logger.error(\"%s\", e)\n      exit(1)\n\n    # =================================================================================\n    # get lists of trackers and calorimeters in detectorDescription\n\n    trk, cal, unk = self.getDetectorLists(detectorDescription)\n\n    for detectors, function, defFilter, abort in [(trk, geant4.setupTracker, self.filter.tracker, False),\n                                                  (cal, geant4.setupCalorimeter, self.filter.calo, False),\n                                                  (unk, geant4.setupDetector, None, True),\n                                                  ]:\n      try:\n        self.__setupSensitiveDetectors(detectors, function, defFilter, abort)\n      except Exception as e:\n        logger.error(\"Failed setting up sensitive detector %s\", e)\n        raise\n\n  # =================================================================================\n    # Now build the physics list:\n    _phys = self.physics.setupPhysics(kernel, name=self.physicsList)\n\n    # add the G4StepLimiterPhysics to activate the max step limits in volumes\n    ph = DDG4.PhysicsList(kernel, 'Geant4PhysicsList/Myphysics')\n    ph.addPhysicsConstructor(str('G4StepLimiterPhysics'))\n    _phys.add(ph)\n\n    dd4hep.setPrintLevel(self.printLevel)\n\n    kernel.configure()\n    kernel.initialize()\n\n    # GPS\n    if self._g4gun is not None:\n      self._g4gun.generator()\n    if self._g4gps is not None:\n      self._g4gps.generator()\n\n    startUpTime, _sysTime, _cuTime, _csTime, _elapsedTime = os.times()\n\n    kernel.run()\n    kernel.terminate()\n\n    totalTimeUser, totalTimeSys, _cuTime, _csTime, _elapsedTime = os.times()\n    if self.printLevel <= 3:\n      logger.info(\"DDSim            INFO  Total Time:   %3.2f s (User), %3.2f s (System)\" %\n                  (totalTimeUser, totalTimeSys))\n      if self.numberOfEvents != 0:\n        eventTime = totalTimeUser - startUpTime\n        perEventTime = eventTime / self.numberOfEvents\n        logger.info(\"DDSim            INFO  StartUp Time: %3.2f s, Event Processing: %3.2f s (%3.2f s/Event) \"\n                    % (startUpTime, eventTime, perEventTime))",
  "def __setMagneticFieldOptions(self, geant4):\n    \"\"\" create and configure the magnetic tracking setup \"\"\"\n    field = geant4.addConfig('Geant4FieldTrackingSetupAction/MagFieldTrackingSetup')\n    field.stepper = self.field.stepper\n    field.equation = self.field.equation\n    field.eps_min = self.field.eps_min\n    field.eps_max = self.field.eps_max\n    field.min_chord_step = self.field.min_chord_step\n    field.delta_chord = self.field.delta_chord\n    field.delta_intersection = self.field.delta_intersection\n    field.delta_one_step = self.field.delta_one_step\n    field.largest_step = self.field.largest_step",
  "def __checkFileFormat(self, fileNames, extensions):\n    \"\"\"check if the fileName is allowed, note that the filenames are case\n    sensitive, and in case of hepevt we depend on this to identify short and long versions of the content\n    \"\"\"\n    if isinstance(fileNames, str):\n      fileNames = [fileNames]\n    if not all(fileName.endswith(tuple(extensions)) for fileName in fileNames):\n      self._errorMessages.append(\"ERROR: Unknown fileformat for file: %s\" % fileNames)\n    is_hepmc3_extension = any(fileName.endswith(tuple(HEPMC3_SUPPORTED_EXTENSIONS)) for fileName in fileNames)\n    if not self.hepmc3.useHepMC3 and is_hepmc3_extension:\n      self._errorMessages.append(\"ERROR: HepMC3 files or compressed HepMC2 require the use of HepMC3 library\")\n    return fileNames",
  "def __applyBoostOrSmear(self, kernel, actionList, mask):\n    \"\"\"apply boost or smearing for given mask index\"\"\"\n    import DDG4\n    if self.crossingAngleBoost:\n      lbo = DDG4.GeneratorAction(kernel, \"Geant4InteractionVertexBoost\")\n      lbo.Angle = self.crossingAngleBoost\n      lbo.Mask = mask\n      actionList.append(lbo)\n\n    if any(self.vertexSigma) or any(self.vertexOffset):\n      vSmear = DDG4.GeneratorAction(kernel, \"Geant4InteractionVertexSmear\")\n      vSmear.Offset = self.vertexOffset\n      vSmear.Sigma = self.vertexSigma\n      vSmear.Mask = mask\n      actionList.append(vSmear)",
  "def __parseAllHelper(self, parsed):\n    \"\"\" parse all the options for the helper \"\"\"\n    parsedDict = vars(parsed)\n    for name, obj in vars(self).items():\n      if isinstance(obj, ConfigHelper):\n        for var in obj.getOptions():\n          key = \"%s.%s\" % (name, var)\n          if key in parsedDict:\n            try:\n              obj.setOption(var, parsedDict[key])\n            except RuntimeError as e:\n              self._errorMessages.append(\"ERROR: %s \" % e)\n              if logger.level <= logging.DEBUG:\n                self._errorMessages.append(traceback.format_exc())\n        obj._checkProperties()",
  "def __checkOutputLevel(self, level):\n    \"\"\"return outputlevel as int so we don't have to import anything for faster startup\"\"\"\n    try:\n      return outputLevel(level)\n    except ValueError:\n      self._errorMessages.append(\"ERROR: printLevel is neither integer nor string\")\n      return -1\n    except KeyError:\n      self._errorMessages.append(\"ERROR: printLevel '%s' unknown\" % level)\n      return -1",
  "def __setupSensitiveDetectors(self, detectors, setupFunction, defaultFilter=None,\n                                abortForMissingAction=False,\n                                ):\n    \"\"\"Attach sensitive detector actions for all subdetectors.\n\n    Can be steered with the `Action` ConfigHelpers\n\n    :param detectors: list of detectors\n    :param setupFunction: function used to register the sensitive detector\n    :param defaultFilter: default filter to apply for given types\n    :param abortForMissingAction: if true end program if there is no action found\n    \"\"\"\n    for det in detectors:\n      logger.info('Setting up SD for %s', det)\n      action = None\n      for pattern in self.action.mapActions:\n        if pattern.lower() in det.lower():\n          action = self.action.mapActions[pattern]\n          logger.info('       replace default action with : %s', action)\n          break\n      if abortForMissingAction and action is None:\n        logger.error('Cannot find Action for detector %s. You have to extend \"action.mapAction\"', det)\n        raise RuntimeError(\"Cannot find Action\")\n      seq, act = setupFunction(det, action)\n      self.filter.applyFilters(seq, det, defaultFilter)\n\n      # set detailed hit creation mode for this\n      if self.enableDetailedShowerMode:\n        if isinstance(act, list):\n          for a in act:\n            a.HitCreationMode = 2\n        else:\n          act.HitCreationMode = 2",
  "def __printSteeringFile(self, parser):\n    \"\"\"print the parameters formated as a steering file\"\"\"\n\n    steeringFileBase = textwrap.dedent(\"\"\"\\\n        from DDSim.DD4hepSimulation import DD4hepSimulation\n        from g4units import mm, GeV, MeV\n        SIM = DD4hepSimulation()\n        \"\"\")\n    steeringFileBase += \"\\n\"\n    optionDict = parser._option_string_actions\n    parameters = vars(self)\n    for parName, parameter in sorted(list(parameters.items()), key=sortParameters):\n      if parName.startswith(\"_\"):\n        continue\n      if isinstance(parameter, ConfigHelper):\n        steeringFileBase += \"\\n\\n\"\n        steeringFileBase += \"################################################################################\\n\"\n        steeringFileBase += \"## %s \\n\" % \"\\n## \".join(parameter.__doc__.splitlines())\n        steeringFileBase += \"################################################################################\\n\"\n        options = parameter.getOptions()\n        for opt, optionsDict in sorted(options.items(), key=sortParameters):\n          if opt.startswith(\"_\"):\n            continue\n          parValue = optionsDict['default']\n          if isinstance(optionsDict.get('help'), str):\n            steeringFileBase += \"\\n## %s\\n\" % \"\\n## \".join(optionsDict.get('help').splitlines())\n          # add quotes if it is a string\n          if isinstance(parValue, str):\n            steeringFileBase += \"SIM.%s.%s = \\\"%s\\\"\\n\" % (parName, opt, parValue)\n          else:\n            steeringFileBase += \"SIM.%s.%s = %s\\n\" % (parName, opt, parValue)\n      else:\n        # get the docstring from the command line parameter\n        optionObj = optionDict.get(\"--\" + parName, None)\n        if isinstance(optionObj, argparse._StoreAction):\n          steeringFileBase += \"## %s\\n\" % \"\\n## \".join(optionObj.help.splitlines())\n        # add quotes if it is a string\n        if isinstance(parameter, str):\n          steeringFileBase += \"SIM.%s = \\\"%s\\\"\" % (parName, str(parameter))\n        else:\n          steeringFileBase += \"SIM.%s = %s\" % (parName, str(parameter))\n        steeringFileBase += \"\\n\"\n    for line in steeringFileBase.splitlines():\n      print(line)",
  "def _consistencyChecks(self):\n    \"\"\"Check if the requested setup makes sense, or if there is something preventing it from working correctly\n\n    Appends error messages to self._errorMessages\n\n    :returns: None\n    \"\"\"\n\n    if not self.compactFile:\n      self._errorMessages.append(\"ERROR: No geometry compact file provided\")\n\n    if self.runType == \"batch\":\n      if not self.numberOfEvents:\n        self._errorMessages.append(\"ERROR: Batch mode requested, but did not set number of events\")\n      if not (self.inputFiles or self.enableGun or self.inputConfig.userInputPlugin):\n        self._errorMessages.append(\"ERROR: Batch mode requested, but did not set inputFile(s), gun, or userInputPlugin\")\n\n    if self.inputFiles and (self.enableG4Gun or self.enableG4GPS):\n      self._errorMessages.append(\"ERROR: Cannot use both inputFiles and Geant4Gun or GeneralParticleSource\")\n\n    if self.enableGun and (self.enableG4Gun or self.enableG4GPS):\n      self._errorMessages.append(\"ERROR: Cannot use both DD4hepGun and Geant4 Gun or GeneralParticleSource\")\n\n    if self.inputConfig.userInputPlugin and (self.enableG4Gun or self.enableG4GPS):\n      self._errorMessages.append(\"ERROR: Cannot use both userInputPlugin and Geant4 Gun or GeneralParticleSource\")\n\n    if self.numberOfEvents < 0 and not self.inputFiles:\n      self._errorMessages.append(\"ERROR: Negative number of events only sensible for inputFiles\")",
  "def _enablePrimaryHandler(self):\n    \"\"\" the geant4 Gun or GeneralParticleSource cannot be used together with the PrimaryHandler.\n        Particles would be simulated multiple times\n\n    :returns: True or False\n    \"\"\"\n    enablePrimaryHandler = not (self.enableG4Gun or self.enableG4GPS)\n    if enablePrimaryHandler:\n      logger.info(\"Enabling the PrimaryHandler\")\n    else:\n      logger.info(\"Disabling the PrimaryHandler\")\n    return enablePrimaryHandler",
  "def _buildInputStage(self, geant4, generator_input_modules, output_level=None, have_mctruth=True):\n    \"\"\"\n    Generic build of the input stage with multiple input modules.\n    Actions executed are:\n    1) Register Generation initialization action\n    2) Append all modules to build the complete input record\n    These modules are readers/particle sources, boosters and/or smearing actions.\n    3) Merge all existing interaction records\n    4) Add the MC truth handler\n    \"\"\"\n    from DDG4 import GeneratorAction\n    ga = geant4.kernel().generatorAction()\n\n    # Register Generation initialization action\n    gen = GeneratorAction(geant4.kernel(), \"Geant4GeneratorActionInit/GenerationInit\")\n    if output_level is not None:\n      gen.OutputLevel = output_level\n    ga.adopt(gen)\n\n    # Now append all modules to build the complete input record\n    # These modules are readers/particle sources, boosters and/or smearing actions\n    for gen in generator_input_modules:\n      gen.enableUI()\n      if output_level is not None:\n        gen.OutputLevel = output_level\n      ga.adopt(gen)\n\n    # Merge all existing interaction records\n    gen = GeneratorAction(geant4.kernel(), \"Geant4InteractionMerger/InteractionMerger\")\n    gen.enableUI()\n    if output_level is not None:\n      gen.OutputLevel = output_level\n    ga.adopt(gen)\n\n    # Finally generate Geant4 primaries\n    if have_mctruth:\n      gen = GeneratorAction(geant4.kernel(), \"Geant4PrimaryHandler/PrimaryHandler\")\n      gen.RejectPDGs = ConfigHelper.makeString(self.physics.rejectPDGs)\n      gen.ZeroTimePDGs = ConfigHelper.makeString(self.physics.zeroTimePDGs)\n      gen.enableUI()\n      if output_level is not None:\n        gen.OutputLevel = output_level\n      ga.adopt(gen)\n    # Puuuhh! All done.\n    return None",
  "def _sortParameters(parA, parB):\n    \"\"\"sort the parameters by name: first normal parameters, then set of\n    parameters based on ConfigHelper objects\n    \"\"\"\n    parTypeA = parA[1]\n    parTypeB = parB[1]\n    if isinstance(parTypeA, ConfigHelper) and isinstance(parTypeB, ConfigHelper):\n      return 1 if str(parA[0]) > str(parB[0]) else -1\n    elif isinstance(parTypeA, ConfigHelper):\n      return 1\n    elif isinstance(parTypeB, ConfigHelper):\n      return -1\n    else:\n      return 1 if str(parA[0]) > str(parB[0]) else -1",
  "class Meta(ConfigHelper):\n  \"\"\"Configuration for the LCIO output file settings\"\"\"\n\n  def __init__(self):\n    super(Meta, self).__init__()\n    self._eventParameters_EXTRA = {'help': \"Event parameters to write in every event. \"\n                                           \"Use C/F/I ids to specify parameter type. \"\n                                           \"E.g parameterName/F=0.42 to set a float parameter\",\n                                   'nargs': '+'}\n    self.eventParameters = []\n    self._runNumberOffset_EXTRA = {'help': \"The run number offset to write in slcio output file. \"\n                                           \"E.g setting it to 42 will start counting runs from 42 instead of 0\",\n                                   'type': int}\n    self.runNumberOffset = 0\n    self._eventNumberOffset_EXTRA = {'help': \"The event number offset to write in slcio output file.\"\n                                             \" E.g setting it to 42 will start counting events from 42 instead of 0\",\n                                     'type': int}\n    self.eventNumberOffset = 0\n    # no closeProperties, allow adding arbitrary information to runHeader\n\n  def parseEventParameters(self):\n    \"\"\"\n    Parse the event parameters and return 3 event parameter dictionnaries, respectively\n    for string, int and float parameters\n    \"\"\"\n    stringParameters, intParameters, floatParameters, allParameters = {}, {}, {}, []\n    for p in self.eventParameters:\n      parameterAndValue = p.split(\"=\", 1)\n      if len(parameterAndValue) != 2:\n        raise SyntaxError(\"ERROR: Couldn't decode event parameter '%s'\" % (p))\n      parameterAndType = parameterAndValue[0].split(\"/\", 1)\n      if len(parameterAndType) != 2:\n        raise SyntaxError(\"ERROR: Couldn't decode event parameter '%s'\" % (p))\n      pname = parameterAndType[0]\n      ptype = parameterAndType[1]\n      pvalue = parameterAndValue[1]\n      if ptype.lower() not in [\"c\", \"f\", \"i\"]:\n        raise ValueError(\"ERROR: Event parameter '%s' with invalid type '%s'\" % (pname, ptype))\n      if pname in allParameters:\n        raise RuntimeError(\"ERROR: Event parameter '%s' specified twice\" % (pname))\n      if not pvalue:\n        raise RuntimeError(\"ERROR: Event parameter '%s' has empty value\" % (pname))\n      allParameters.append(pname)\n      logger.info(\"Event parameter '%s', type '%s', value='%s'\" % (pname, ptype, pvalue))\n      if ptype.lower() == \"c\":\n        stringParameters[pname] = pvalue\n      elif ptype.lower() == \"f\":\n        floatParameters[pname] = pvalue\n      elif ptype.lower() == \"i\":\n        intParameters[pname] = pvalue\n    return stringParameters, intParameters, floatParameters\n\n  @staticmethod\n  def addParametersToRunHeader(sim):\n    \"\"\"add the parameters to the (lcio) run Header\"\"\"\n    runHeader = {}\n    parameters = vars(sim)\n    for parName, parameter in parameters.items():\n      if isinstance(parameter, ConfigHelper):\n        options = parameter.getOptions()\n        for opt, optionsDict in options.items():\n          runHeader[\"%s.%s\" % (parName, opt)] = str(optionsDict['default'])\n      else:\n        runHeader[parName] = str(parameter)\n\n    # steeringFile content\n    if sim.steeringFile and os.path.exists(sim.steeringFile) and os.path.isfile(sim.steeringFile):\n      with open(sim.steeringFile) as sFile:\n        runHeader[\"SteeringFileContent\"] = sFile.read()\n\n    # macroFile content\n    if sim.macroFile and os.path.exists(sim.macroFile) and os.path.isfile(sim.macroFile):\n      with open(sim.macroFile) as mFile:\n        runHeader[\"MacroFileContent\"] = mFile.read()\n\n    # add command line\n    if sim._argv:\n      runHeader[\"CommandLine\"] = \" \".join(sim._argv)\n\n    # add current working directory (where we call from)\n    runHeader[\"WorkingDirectory\"] = os.getcwd()\n\n    # ILCSoft, LCGEo location from environment variables, names from init_ilcsoft.sh\n    runHeader[\"ILCSoft_location\"] = os.environ.get(\"ILCSOFT\", \"Unknown\")\n    runHeader[\"lcgeo_location\"] = os.environ.get(\"lcgeo_DIR\", \"Unknown\")\n\n    # add date\n    runHeader[\"DateUTC\"] = str(datetime.datetime.utcnow()) + \" UTC\"\n\n    # add User\n    import getpass\n    runHeader[\"User\"] = getpass.getuser()\n\n    return runHeader",
  "def __init__(self):\n    super(Meta, self).__init__()\n    self._eventParameters_EXTRA = {'help': \"Event parameters to write in every event. \"\n                                           \"Use C/F/I ids to specify parameter type. \"\n                                           \"E.g parameterName/F=0.42 to set a float parameter\",\n                                   'nargs': '+'}\n    self.eventParameters = []\n    self._runNumberOffset_EXTRA = {'help': \"The run number offset to write in slcio output file. \"\n                                           \"E.g setting it to 42 will start counting runs from 42 instead of 0\",\n                                   'type': int}\n    self.runNumberOffset = 0\n    self._eventNumberOffset_EXTRA = {'help': \"The event number offset to write in slcio output file.\"\n                                             \" E.g setting it to 42 will start counting events from 42 instead of 0\",\n                                     'type': int}\n    self.eventNumberOffset = 0",
  "def parseEventParameters(self):\n    \"\"\"\n    Parse the event parameters and return 3 event parameter dictionnaries, respectively\n    for string, int and float parameters\n    \"\"\"\n    stringParameters, intParameters, floatParameters, allParameters = {}, {}, {}, []\n    for p in self.eventParameters:\n      parameterAndValue = p.split(\"=\", 1)\n      if len(parameterAndValue) != 2:\n        raise SyntaxError(\"ERROR: Couldn't decode event parameter '%s'\" % (p))\n      parameterAndType = parameterAndValue[0].split(\"/\", 1)\n      if len(parameterAndType) != 2:\n        raise SyntaxError(\"ERROR: Couldn't decode event parameter '%s'\" % (p))\n      pname = parameterAndType[0]\n      ptype = parameterAndType[1]\n      pvalue = parameterAndValue[1]\n      if ptype.lower() not in [\"c\", \"f\", \"i\"]:\n        raise ValueError(\"ERROR: Event parameter '%s' with invalid type '%s'\" % (pname, ptype))\n      if pname in allParameters:\n        raise RuntimeError(\"ERROR: Event parameter '%s' specified twice\" % (pname))\n      if not pvalue:\n        raise RuntimeError(\"ERROR: Event parameter '%s' has empty value\" % (pname))\n      allParameters.append(pname)\n      logger.info(\"Event parameter '%s', type '%s', value='%s'\" % (pname, ptype, pvalue))\n      if ptype.lower() == \"c\":\n        stringParameters[pname] = pvalue\n      elif ptype.lower() == \"f\":\n        floatParameters[pname] = pvalue\n      elif ptype.lower() == \"i\":\n        intParameters[pname] = pvalue\n    return stringParameters, intParameters, floatParameters",
  "def addParametersToRunHeader(sim):\n    \"\"\"add the parameters to the (lcio) run Header\"\"\"\n    runHeader = {}\n    parameters = vars(sim)\n    for parName, parameter in parameters.items():\n      if isinstance(parameter, ConfigHelper):\n        options = parameter.getOptions()\n        for opt, optionsDict in options.items():\n          runHeader[\"%s.%s\" % (parName, opt)] = str(optionsDict['default'])\n      else:\n        runHeader[parName] = str(parameter)\n\n    # steeringFile content\n    if sim.steeringFile and os.path.exists(sim.steeringFile) and os.path.isfile(sim.steeringFile):\n      with open(sim.steeringFile) as sFile:\n        runHeader[\"SteeringFileContent\"] = sFile.read()\n\n    # macroFile content\n    if sim.macroFile and os.path.exists(sim.macroFile) and os.path.isfile(sim.macroFile):\n      with open(sim.macroFile) as mFile:\n        runHeader[\"MacroFileContent\"] = mFile.read()\n\n    # add command line\n    if sim._argv:\n      runHeader[\"CommandLine\"] = \" \".join(sim._argv)\n\n    # add current working directory (where we call from)\n    runHeader[\"WorkingDirectory\"] = os.getcwd()\n\n    # ILCSoft, LCGEo location from environment variables, names from init_ilcsoft.sh\n    runHeader[\"ILCSoft_location\"] = os.environ.get(\"ILCSOFT\", \"Unknown\")\n    runHeader[\"lcgeo_location\"] = os.environ.get(\"lcgeo_DIR\", \"Unknown\")\n\n    # add date\n    runHeader[\"DateUTC\"] = str(datetime.datetime.utcnow()) + \" UTC\"\n\n    # add User\n    import getpass\n    runHeader[\"User\"] = getpass.getuser()\n\n    return runHeader",
  "class Input(ConfigHelper):\n  \"\"\"Configuration for the InputFiles\"\"\"\n\n  def __init__(self):\n    super(Input, self).__init__()\n    self.__parameters = {}\n    self._closeProperties()\n\n  def getParameters(self):\n    return self.__parameters\n\n  @property\n  def _parameters(self):\n    return self.__parameters\n\n  @_parameters.setter\n  def _parameters(self, newParameters):\n    if isinstance(newParameters, dict):\n      for par, val in newParameters.items():\n        self.__parameters[par] = str(val)\n\n    else:\n      raise RuntimeError(\"Commandline setting of InputFileParameters is not supported, use a steeringFile: %s \"\n                         % newParameters)",
  "def __init__(self):\n    super(Input, self).__init__()\n    self.__parameters = {}\n    self._closeProperties()",
  "def getParameters(self):\n    return self.__parameters",
  "def _parameters(self):\n    return self.__parameters",
  "def _parameters(self, newParameters):\n    if isinstance(newParameters, dict):\n      for par, val in newParameters.items():\n        self.__parameters[par] = str(val)\n\n    else:\n      raise RuntimeError(\"Commandline setting of InputFileParameters is not supported, use a steeringFile: %s \"\n                         % newParameters)",
  "class MagneticField(ConfigHelper):\n  \"\"\"Configuration for the magnetic field (stepper)\"\"\"\n\n  def __init__(self):\n    super(MagneticField, self).__init__()\n    self.stepper = \"ClassicalRK4\"\n    self.equation = \"Mag_UsualEqRhs\"\n    self.eps_min = 5e-05 * mm\n    self.eps_max = 0.001 * mm\n    self.min_chord_step = 0.01 * mm\n    self.delta_chord = 0.25 * mm\n    self.delta_intersection = 0.001 * mm\n    self.delta_one_step = 0.01 * mm\n    self.largest_step = 10 * m\n    self._closeProperties()",
  "def __init__(self):\n    super(MagneticField, self).__init__()\n    self.stepper = \"ClassicalRK4\"\n    self.equation = \"Mag_UsualEqRhs\"\n    self.eps_min = 5e-05 * mm\n    self.eps_max = 0.001 * mm\n    self.min_chord_step = 0.01 * mm\n    self.delta_chord = 0.25 * mm\n    self.delta_intersection = 0.001 * mm\n    self.delta_one_step = 0.01 * mm\n    self.largest_step = 10 * m\n    self._closeProperties()",
  "class Action(ConfigHelper):\n  \"\"\"Helper holding sensitive detector actions.\n\n  The default tracker and calorimeter actions can be set with\n\n  >>> SIM = DD4hepSimulation()\n  >>> SIM.action.tracker=('Geant4TrackerWeightedAction', {'HitPositionCombination': 2, 'CollectSingleDeposits': False})\n  >>> SIM.action.calo = \"Geant4CalorimeterAction\"\n\n  The default sensitive actions for calorimeters and trackers are applied based on the sensitive type.\n  The list of sensitive types can be changed with\n\n  >>> SIM = DD4hepSimulation()\n  >>> SIM.action.trackerSDTypes = ['tracker', 'myTrackerSensType']\n  >>> SIM.calor.calorimeterSDTypes = ['calorimeter', 'myCaloSensType']\n\n  For specific subdetectors specific sensitive detectors can be set based on patterns in the name of the subdetector.\n\n  >>> SIM = DD4hepSimulation()\n  >>> SIM.action.mapActions['tpc'] = \"TPCSDAction\"\n\n  and additional parameters for the sensitive detectors can be set when the map is given a tuple\n\n  >>> SIM = DD4hepSimulation()\n  >>> SIM.action.mapActions['ecal'] =( \"CaloPreShowerSDAction\", {\"FirstLayerNumber\": 1} )\n\n  \"\"\"\n\n  def __init__(self):\n    super(Action, self).__init__()\n    self._tracker = ('Geant4TrackerWeightedAction', {'HitPositionCombination': 2, 'CollectSingleDeposits': False})\n    self._calo = 'Geant4ScintillatorCalorimeterAction'\n    self._mapActions = dict()\n    self._trackerSDTypes = ['tracker']\n    self._calorimeterSDTypes = ['calorimeter']\n    self._closeProperties()\n\n  @property\n  def tracker(self):\n    \"\"\" set the default tracker action \"\"\"\n    return self._tracker\n\n  @tracker.setter\n  def tracker(self, val):\n    self._tracker = val\n\n  @property\n  def calo(self):\n    \"\"\" set the default calorimeter action \"\"\"\n    return self._calo\n\n  @calo.setter\n  def calo(self, val):\n    self._calo = val\n\n  @property\n  def mapActions(self):\n    \"\"\"Create a map of patterns and actions to be applied to sensitive detectors.\n\n    Example: if the name of the detector matches 'tpc' the TPCSDAction is used.\n\n      SIM.action.mapActions['tpc'] = \"TPCSDAction\"\n    \"\"\"\n    return self._mapActions\n\n  @mapActions.setter\n  def mapActions(self, val):\n    \"\"\"check if the argument is a dict, then we just update mapActions\n    if it is a string or list, we use pairs as patterns --> Action\n    \"\"\"\n    if isinstance(val, dict):\n      self._mapActions.update(val)\n      return\n\n    if isinstance(val, str):\n      vals = val.split(\" \")\n    elif isinstance(val, list):\n      vals = val\n    if len(vals) % 2 != 0:\n      raise RuntimeError(\"Not enough parameters for mapActions\")\n    for index in range(0, len(vals), 2):\n      self._mapActions[vals[index]] = vals[index + 1]\n\n  def clearMapActions(self):\n    \"\"\"empty the mapActions dictionary\"\"\"\n    self._mapActions = dict()\n\n  @property\n  def trackerSDTypes(self):\n    \"\"\"List of patterns matching sensitive detectors of type Tracker.\"\"\"\n    return self._trackerSDTypes\n\n  @trackerSDTypes.setter\n  def trackerSDTypes(self, val):\n    self._trackerSDTypes = ConfigHelper.makeList(val)\n\n  @property\n  def calorimeterSDTypes(self):\n    \"\"\"List of patterns matching sensitive detectors of type Calorimeter.\"\"\"\n    return self._calorimeterSDTypes\n\n  @calorimeterSDTypes.setter\n  def calorimeterSDTypes(self, val):\n    self._calorimeterSDTypes = ConfigHelper.makeList(val)",
  "def __init__(self):\n    super(Action, self).__init__()\n    self._tracker = ('Geant4TrackerWeightedAction', {'HitPositionCombination': 2, 'CollectSingleDeposits': False})\n    self._calo = 'Geant4ScintillatorCalorimeterAction'\n    self._mapActions = dict()\n    self._trackerSDTypes = ['tracker']\n    self._calorimeterSDTypes = ['calorimeter']\n    self._closeProperties()",
  "def tracker(self):\n    \"\"\" set the default tracker action \"\"\"\n    return self._tracker",
  "def tracker(self, val):\n    self._tracker = val",
  "def calo(self):\n    \"\"\" set the default calorimeter action \"\"\"\n    return self._calo",
  "def calo(self, val):\n    self._calo = val",
  "def mapActions(self):\n    \"\"\"Create a map of patterns and actions to be applied to sensitive detectors.\n\n    Example: if the name of the detector matches 'tpc' the TPCSDAction is used.\n\n      SIM.action.mapActions['tpc'] = \"TPCSDAction\"\n    \"\"\"\n    return self._mapActions",
  "def mapActions(self, val):\n    \"\"\"check if the argument is a dict, then we just update mapActions\n    if it is a string or list, we use pairs as patterns --> Action\n    \"\"\"\n    if isinstance(val, dict):\n      self._mapActions.update(val)\n      return\n\n    if isinstance(val, str):\n      vals = val.split(\" \")\n    elif isinstance(val, list):\n      vals = val\n    if len(vals) % 2 != 0:\n      raise RuntimeError(\"Not enough parameters for mapActions\")\n    for index in range(0, len(vals), 2):\n      self._mapActions[vals[index]] = vals[index + 1]",
  "def clearMapActions(self):\n    \"\"\"empty the mapActions dictionary\"\"\"\n    self._mapActions = dict()",
  "def trackerSDTypes(self):\n    \"\"\"List of patterns matching sensitive detectors of type Tracker.\"\"\"\n    return self._trackerSDTypes",
  "def trackerSDTypes(self, val):\n    self._trackerSDTypes = ConfigHelper.makeList(val)",
  "def calorimeterSDTypes(self):\n    \"\"\"List of patterns matching sensitive detectors of type Calorimeter.\"\"\"\n    return self._calorimeterSDTypes",
  "def calorimeterSDTypes(self, val):\n    self._calorimeterSDTypes = ConfigHelper.makeList(val)",
  "class ConfigHelper(object):\n  \"\"\"Base class for configuration helper\"\"\"\n\n  # We need a static set of properties, because steeringFile parsing creates new Helper objects!\n  _setOfProperties = dict()\n\n  def __init__(self):\n    pass\n\n  def _name(self):\n    return self.__class__.__name__\n\n  def _closeProperties(self):\n    \"\"\"Store the list of properties.\"\"\"\n    self._setOfProperties[self._name()] = set(vars(self))\n\n  def _checkProperties(self):\n    newProps = set(vars(self))\n    if existingProps := self._setOfProperties.get(self._name(), set()):\n      if unknownProps := newProps - existingProps:\n        raise RuntimeError(f\"{self._name()} error: Trying to add unknown propert(y/ies): {unknownProps}!\")\n\n  def getOptions(self):\n    finalVars = {}\n\n    # get all direct members not starting with underscore\n    allVars = vars(self)\n    for var, val in allVars.items():\n      if not var.startswith('_'):\n        extraArgumentsName = \"_%s_EXTRA\" % var\n        options = getattr(self, extraArgumentsName) if hasattr(self, extraArgumentsName) else None\n        finalVars[var] = {'default': val}\n        if options:\n          finalVars[var].update(options)\n\n    # now get things defined with @property\n    props = [(p, getattr(type(self), p)) for p in dir(type(self)) if isinstance(getattr(type(self), p), property)]\n    for propName, prop in props:\n      optName = \"_%s_EXTRA\" % propName\n      doc = prop.__doc__\n      options = getattr(self, optName) if hasattr(self, optName) else None\n      finalVars[propName] = {'default': getattr(self, propName)}\n      if doc:\n        finalVars[propName]['help'] = doc\n      if options:\n        finalVars[propName].update(options)\n\n    return finalVars\n\n  def __repr__(self):\n    return self.printOptions()\n\n  def printOptions(self):\n    \"\"\"print all parameters\"\"\"\n    options = []\n    for opt, val in self.getOptions().items():\n      options.append(\"\\n\\t'%s': '%s'\" % (opt, val['default']))\n    return \"\".join(options)\n\n  def setOption(self, name, val):\n    \"\"\" set the attribute name to val \"\"\"\n    setattr(self, name, val)\n\n  @staticmethod\n  def makeList(stringVal, sep=\" \"):\n    \"\"\"returns a list from a string separated by sep\"\"\"\n    if not stringVal:\n      return []\n    if isinstance(stringVal, list):\n      return stringVal\n    else:\n      return stringVal.split(sep)\n\n  @staticmethod\n  def makeSet(stringVal, sep=\" \"):\n    \"\"\"returns a set from a string separated by sep\"\"\"\n    if not stringVal:\n      return set()\n    if isinstance(stringVal, (list, set, tuple)):\n      return set(stringVal)\n    else:\n      return set(stringVal.split(sep))\n\n  @staticmethod\n  def makeString(container):\n    \"\"\"Return a string that can be parsed by dd4hep into a vector.\"\"\"\n    if not container:\n      return \"\"\n    if isinstance(container, set):\n      return '{%s}' % ','.join([str(s) for s in container])\n\n  @staticmethod\n  def makeTuple(val):\n    \"\"\" returns a tuple of the string, separators are space or comma \"\"\"\n    myTuple = None\n    if isinstance(val, tuple):\n      myTuple = val\n    if isinstance(val, list):\n      myTuple = tuple(val)\n    if isinstance(val, str):\n      sep = ',' if ',' in val else ' '\n      myTuple = tuple([_.strip(\"(), \") for _ in val.split(sep)])\n    if myTuple is None:\n      raise RuntimeError(\"Cannot parse input value %s\" % val)\n    return myTuple\n\n  @staticmethod\n  def makeBool(val):\n    \"\"\"check if val is a bool or a string of true/false, otherwise raise exception\"\"\"\n    if isinstance(val, bool):\n      return val\n    elif isinstance(val, str):\n      if val.lower() == 'true':\n        return True\n      elif val.lower() == 'false':\n        return False\n    raise RuntimeError(val)\n\n  @staticmethod\n  def addAllHelper(ddsim, parser):\n    \"\"\"all configHelper objects to commandline args\"\"\"\n    for name, obj in vars(ddsim).items():\n      if isinstance(obj, ConfigHelper):\n        for var, optionsDict in obj.getOptions().items():\n          optionsDict['action'] = ('store_true' if var.startswith((\"enable\", \"force\"))\n                                   else optionsDict.get('action', 'store'))\n          parser.add_argument(\"--%s.%s\" % (name, var),\n                              dest=\"%s.%s\" % (name, var),\n                              **optionsDict\n                              )",
  "def __init__(self):\n    pass",
  "def _name(self):\n    return self.__class__.__name__",
  "def _closeProperties(self):\n    \"\"\"Store the list of properties.\"\"\"\n    self._setOfProperties[self._name()] = set(vars(self))",
  "def _checkProperties(self):\n    newProps = set(vars(self))\n    if existingProps := self._setOfProperties.get(self._name(), set()):\n      if unknownProps := newProps - existingProps:\n        raise RuntimeError(f\"{self._name()} error: Trying to add unknown propert(y/ies): {unknownProps}!\")",
  "def getOptions(self):\n    finalVars = {}\n\n    # get all direct members not starting with underscore\n    allVars = vars(self)\n    for var, val in allVars.items():\n      if not var.startswith('_'):\n        extraArgumentsName = \"_%s_EXTRA\" % var\n        options = getattr(self, extraArgumentsName) if hasattr(self, extraArgumentsName) else None\n        finalVars[var] = {'default': val}\n        if options:\n          finalVars[var].update(options)\n\n    # now get things defined with @property\n    props = [(p, getattr(type(self), p)) for p in dir(type(self)) if isinstance(getattr(type(self), p), property)]\n    for propName, prop in props:\n      optName = \"_%s_EXTRA\" % propName\n      doc = prop.__doc__\n      options = getattr(self, optName) if hasattr(self, optName) else None\n      finalVars[propName] = {'default': getattr(self, propName)}\n      if doc:\n        finalVars[propName]['help'] = doc\n      if options:\n        finalVars[propName].update(options)\n\n    return finalVars",
  "def __repr__(self):\n    return self.printOptions()",
  "def printOptions(self):\n    \"\"\"print all parameters\"\"\"\n    options = []\n    for opt, val in self.getOptions().items():\n      options.append(\"\\n\\t'%s': '%s'\" % (opt, val['default']))\n    return \"\".join(options)",
  "def setOption(self, name, val):\n    \"\"\" set the attribute name to val \"\"\"\n    setattr(self, name, val)",
  "def makeList(stringVal, sep=\" \"):\n    \"\"\"returns a list from a string separated by sep\"\"\"\n    if not stringVal:\n      return []\n    if isinstance(stringVal, list):\n      return stringVal\n    else:\n      return stringVal.split(sep)",
  "def makeSet(stringVal, sep=\" \"):\n    \"\"\"returns a set from a string separated by sep\"\"\"\n    if not stringVal:\n      return set()\n    if isinstance(stringVal, (list, set, tuple)):\n      return set(stringVal)\n    else:\n      return set(stringVal.split(sep))",
  "def makeString(container):\n    \"\"\"Return a string that can be parsed by dd4hep into a vector.\"\"\"\n    if not container:\n      return \"\"\n    if isinstance(container, set):\n      return '{%s}' % ','.join([str(s) for s in container])",
  "def makeTuple(val):\n    \"\"\" returns a tuple of the string, separators are space or comma \"\"\"\n    myTuple = None\n    if isinstance(val, tuple):\n      myTuple = val\n    if isinstance(val, list):\n      myTuple = tuple(val)\n    if isinstance(val, str):\n      sep = ',' if ',' in val else ' '\n      myTuple = tuple([_.strip(\"(), \") for _ in val.split(sep)])\n    if myTuple is None:\n      raise RuntimeError(\"Cannot parse input value %s\" % val)\n    return myTuple",
  "def makeBool(val):\n    \"\"\"check if val is a bool or a string of true/false, otherwise raise exception\"\"\"\n    if isinstance(val, bool):\n      return val\n    elif isinstance(val, str):\n      if val.lower() == 'true':\n        return True\n      elif val.lower() == 'false':\n        return False\n    raise RuntimeError(val)",
  "def addAllHelper(ddsim, parser):\n    \"\"\"all configHelper objects to commandline args\"\"\"\n    for name, obj in vars(ddsim).items():\n      if isinstance(obj, ConfigHelper):\n        for var, optionsDict in obj.getOptions().items():\n          optionsDict['action'] = ('store_true' if var.startswith((\"enable\", \"force\"))\n                                   else optionsDict.get('action', 'store'))\n          parser.add_argument(\"--%s.%s\" % (name, var),\n                              dest=\"%s.%s\" % (name, var),\n                              **optionsDict\n                              )",
  "class Gun(ConfigHelper):\n  \"\"\"Configuration for the DDG4 ParticleGun\"\"\"\n\n  def __init__(self):\n    super(Gun, self).__init__()\n    self.particle = \"mu-\"\n    self.multiplicity = 1\n    self._position = (0.0, 0.0, 0.0)\n    self._isotrop = False\n    self._direction = (0, 0, 1)\n\n    self._phiMin_EXTRA = {'help': \"Minimal azimuthal angle for random distribution\"}\n    self.phiMin = None\n    self._phiMax_EXTRA = {'help': \"Maximal azimuthal angle for random distribution\"}\n    self.phiMax = None\n    self._thetaMin_EXTRA = {'help': \"Minimal polar angle for random distribution\"}\n    self.thetaMin = None\n    self._thetaMax_EXTRA = {'help': \"Maximal polar angle for random distribution\"}\n    self.thetaMax = None\n    self._etaMin_EXTRA = {'help': \"Minimal pseudorapidity for random distibution (overrides thetaMax)\"}\n    self.etaMin = None\n    self._etaMax_EXTRA = {'help': \"Maximal pseudorapidity for random distibution (overrides thetaMin)\"}\n    self.etaMax = None\n    self._momentumMin_EXTRA = {'help': \"Minimal momentum when using distribution (default = 0.0)\"}\n    self.momentumMin = 0 * GeV\n    self._momentumMax_EXTRA = {'help': \"Maximal momentum when using distribution (default = 0.0)\"}\n    self.momentumMax = 10 * GeV\n    self._energy_EXTRA = {'help': \"The kinetic energy for the particle gun.\\n\\n\"\n                          \"If not None, it will overwrite the setting of momentumMin and momentumMax\"}\n    self.energy = None\n\n    self._distribution_EXTRA = {'choices': ['uniform', 'cos(theta)',\n                                            'eta', 'pseudorapidity',\n                                            'ffbar']}  # (1+cos^2 theta)\n    self._distribution = None\n    self._closeProperties()\n\n  @property\n  def distribution(self):\n    \"\"\"choose the distribution of the random direction for theta\n\n    Options for random distributions:\n\n    'uniform' is the default distribution, flat in theta\n    'cos(theta)' is flat in cos(theta)\n    'eta', or 'pseudorapidity' is flat in pseudorapity\n    'ffbar' is distributed according to 1+cos^2(theta)\n\n    Setting a distribution will set isotrop = True\n    \"\"\"\n    return self._distribution\n\n  @distribution.setter\n  def distribution(self, val):\n    if val is None:\n      return\n    possibleDistributions = self._distribution_EXTRA['choices']\n    if not isinstance(val, str):\n      raise RuntimeError(\"malformed input '%s' for gun.distribution. Need a string : %s \" %\n                         (val, \",\".join(possibleDistributions)))\n    if val not in possibleDistributions:\n      # surround options by quots to be explicit\n      stringified = [\"'%s'\" % _ for _ in possibleDistributions]\n      raise RuntimeError(\"Unknown distribution '%s', Use one of: %s \" % (val,\n                                                                         \", \".join(stringified)))\n    self._distribution = val\n    self._isotrop = True\n\n  @property\n  def isotrop(self):\n    \"\"\" isotropic distribution for the particle gun\n\n    use the options phiMin, phiMax, thetaMin, and thetaMax to limit the range of randomly distributed directions\n    if one of these options is not None the random distribution will be set to True and cannot be turned off!\n    \"\"\"\n    return self._isotrop or bool(self._distribution)\n\n  @isotrop.setter\n  def isotrop(self, val):\n    \"\"\"check that value is equivalent to bool\"\"\"\n    try:\n      self._isotrop = ConfigHelper.makeBool(val)\n    except RuntimeError:\n      raise RuntimeError(\"malformed input '%s' for gun.isotrop \" % val)\n    if val and self.distribution is None:\n      self.distribution = 'uniform'\n\n  @property\n  def direction(self):\n    \"\"\" direction of the particle gun, 3 vector \"\"\"\n    return self._direction\n\n  @direction.setter\n  def direction(self, val):\n    \"\"\" make sure the direction is parseable by boost, i.e. (1.0, 1.0, 1.0) \"\"\"\n    self._direction = ConfigHelper.makeTuple(val)\n    if len(self._direction) != 3:\n      raise RuntimeError(\n          \" gun.direction: malformed input '%s', needs to be a string representing a three vector \" % (val,))\n\n  @property\n  def position(self):\n    \"\"\" position of the particle gun, 3 vector \"\"\"\n    return self._position\n\n  @position.setter\n  def position(self, val):\n    \"\"\"check that the position is a three vector and can be parsed by ddg4\"\"\"\n    self._position = ConfigHelper.makeTuple(val)\n    if len(self._position) != 3:\n      raise RuntimeError(\n          \" gun.position: malformed input '%s', needs to be a string representing a three vector \" % (val,))\n\n  def setOptions(self, ddg4Gun):\n    \"\"\"set the starting properties of the DDG4 particle gun\"\"\"\n    try:\n      if self.energy:\n        ddg4Gun.Energy = self.energy\n      ddg4Gun.particle = self.particle\n      ddg4Gun.multiplicity = self.multiplicity\n      ddg4Gun.position = self.position\n      ddg4Gun.isotrop = self.isotrop\n      ddg4Gun.direction = self.direction\n      ddg4Gun.Distribution = self.distribution\n      if self.thetaMin is not None:\n        ddg4Gun.ThetaMin = self.thetaMin\n        ddg4Gun.isotrop = True\n      if self.thetaMax is not None:\n        ddg4Gun.ThetaMax = self.thetaMax\n        ddg4Gun.isotrop = True\n      if self.phiMin is not None:\n        ddg4Gun.PhiMin = self.phiMin\n        ddg4Gun.isotrop = True\n      if self.phiMax is not None:\n        ddg4Gun.PhiMax = self.phiMax\n        ddg4Gun.isotrop = True\n      if self.etaMin is not None:\n        ddg4Gun.ThetaMax = 2. * atan(exp(-float(self.etaMin)))\n        ddg4Gun.isotrop = True\n      if self.etaMax is not None:\n        ddg4Gun.ThetaMin = 2. * atan(exp(-float(self.etaMax)))\n        ddg4Gun.isotrop = True\n      # this avoids issues if momentumMin is None because of previous default\n      ddg4Gun.MomentumMin = self.momentumMin if self.momentumMin else 0.0\n      ddg4Gun.MomentumMax = self.momentumMax\n    except Exception as e:  # pylint: disable=W0703\n      logger.error(\"parsing gun options:\\n%s\\nException: %s \" % (self, e))\n      exit(1)",
  "def __init__(self):\n    super(Gun, self).__init__()\n    self.particle = \"mu-\"\n    self.multiplicity = 1\n    self._position = (0.0, 0.0, 0.0)\n    self._isotrop = False\n    self._direction = (0, 0, 1)\n\n    self._phiMin_EXTRA = {'help': \"Minimal azimuthal angle for random distribution\"}\n    self.phiMin = None\n    self._phiMax_EXTRA = {'help': \"Maximal azimuthal angle for random distribution\"}\n    self.phiMax = None\n    self._thetaMin_EXTRA = {'help': \"Minimal polar angle for random distribution\"}\n    self.thetaMin = None\n    self._thetaMax_EXTRA = {'help': \"Maximal polar angle for random distribution\"}\n    self.thetaMax = None\n    self._etaMin_EXTRA = {'help': \"Minimal pseudorapidity for random distibution (overrides thetaMax)\"}\n    self.etaMin = None\n    self._etaMax_EXTRA = {'help': \"Maximal pseudorapidity for random distibution (overrides thetaMin)\"}\n    self.etaMax = None\n    self._momentumMin_EXTRA = {'help': \"Minimal momentum when using distribution (default = 0.0)\"}\n    self.momentumMin = 0 * GeV\n    self._momentumMax_EXTRA = {'help': \"Maximal momentum when using distribution (default = 0.0)\"}\n    self.momentumMax = 10 * GeV\n    self._energy_EXTRA = {'help': \"The kinetic energy for the particle gun.\\n\\n\"\n                          \"If not None, it will overwrite the setting of momentumMin and momentumMax\"}\n    self.energy = None\n\n    self._distribution_EXTRA = {'choices': ['uniform', 'cos(theta)',\n                                            'eta', 'pseudorapidity',\n                                            'ffbar']}  # (1+cos^2 theta)\n    self._distribution = None\n    self._closeProperties()",
  "def distribution(self):\n    \"\"\"choose the distribution of the random direction for theta\n\n    Options for random distributions:\n\n    'uniform' is the default distribution, flat in theta\n    'cos(theta)' is flat in cos(theta)\n    'eta', or 'pseudorapidity' is flat in pseudorapity\n    'ffbar' is distributed according to 1+cos^2(theta)\n\n    Setting a distribution will set isotrop = True\n    \"\"\"\n    return self._distribution",
  "def distribution(self, val):\n    if val is None:\n      return\n    possibleDistributions = self._distribution_EXTRA['choices']\n    if not isinstance(val, str):\n      raise RuntimeError(\"malformed input '%s' for gun.distribution. Need a string : %s \" %\n                         (val, \",\".join(possibleDistributions)))\n    if val not in possibleDistributions:\n      # surround options by quots to be explicit\n      stringified = [\"'%s'\" % _ for _ in possibleDistributions]\n      raise RuntimeError(\"Unknown distribution '%s', Use one of: %s \" % (val,\n                                                                         \", \".join(stringified)))\n    self._distribution = val\n    self._isotrop = True",
  "def isotrop(self):\n    \"\"\" isotropic distribution for the particle gun\n\n    use the options phiMin, phiMax, thetaMin, and thetaMax to limit the range of randomly distributed directions\n    if one of these options is not None the random distribution will be set to True and cannot be turned off!\n    \"\"\"\n    return self._isotrop or bool(self._distribution)",
  "def isotrop(self, val):\n    \"\"\"check that value is equivalent to bool\"\"\"\n    try:\n      self._isotrop = ConfigHelper.makeBool(val)\n    except RuntimeError:\n      raise RuntimeError(\"malformed input '%s' for gun.isotrop \" % val)\n    if val and self.distribution is None:\n      self.distribution = 'uniform'",
  "def direction(self):\n    \"\"\" direction of the particle gun, 3 vector \"\"\"\n    return self._direction",
  "def direction(self, val):\n    \"\"\" make sure the direction is parseable by boost, i.e. (1.0, 1.0, 1.0) \"\"\"\n    self._direction = ConfigHelper.makeTuple(val)\n    if len(self._direction) != 3:\n      raise RuntimeError(\n          \" gun.direction: malformed input '%s', needs to be a string representing a three vector \" % (val,))",
  "def position(self):\n    \"\"\" position of the particle gun, 3 vector \"\"\"\n    return self._position",
  "def position(self, val):\n    \"\"\"check that the position is a three vector and can be parsed by ddg4\"\"\"\n    self._position = ConfigHelper.makeTuple(val)\n    if len(self._position) != 3:\n      raise RuntimeError(\n          \" gun.position: malformed input '%s', needs to be a string representing a three vector \" % (val,))",
  "def setOptions(self, ddg4Gun):\n    \"\"\"set the starting properties of the DDG4 particle gun\"\"\"\n    try:\n      if self.energy:\n        ddg4Gun.Energy = self.energy\n      ddg4Gun.particle = self.particle\n      ddg4Gun.multiplicity = self.multiplicity\n      ddg4Gun.position = self.position\n      ddg4Gun.isotrop = self.isotrop\n      ddg4Gun.direction = self.direction\n      ddg4Gun.Distribution = self.distribution\n      if self.thetaMin is not None:\n        ddg4Gun.ThetaMin = self.thetaMin\n        ddg4Gun.isotrop = True\n      if self.thetaMax is not None:\n        ddg4Gun.ThetaMax = self.thetaMax\n        ddg4Gun.isotrop = True\n      if self.phiMin is not None:\n        ddg4Gun.PhiMin = self.phiMin\n        ddg4Gun.isotrop = True\n      if self.phiMax is not None:\n        ddg4Gun.PhiMax = self.phiMax\n        ddg4Gun.isotrop = True\n      if self.etaMin is not None:\n        ddg4Gun.ThetaMax = 2. * atan(exp(-float(self.etaMin)))\n        ddg4Gun.isotrop = True\n      if self.etaMax is not None:\n        ddg4Gun.ThetaMin = 2. * atan(exp(-float(self.etaMax)))\n        ddg4Gun.isotrop = True\n      # this avoids issues if momentumMin is None because of previous default\n      ddg4Gun.MomentumMin = self.momentumMin if self.momentumMin else 0.0\n      ddg4Gun.MomentumMax = self.momentumMax\n    except Exception as e:  # pylint: disable=W0703\n      logger.error(\"parsing gun options:\\n%s\\nException: %s \" % (self, e))\n      exit(1)",
  "class GuineaPig(Input):\n  \"\"\"Configuration for the GuineaPig InputFiles\"\"\"\n\n  def __init__(self):\n    super(GuineaPig, self).__init__()\n    self._parameters[\"ParticlesPerEvent\"] = -1\n    self._closeProperties()\n\n  @property\n  def particlesPerEvent(self):\n    \"\"\"Set the number of pair particles to simulate per event.\n    Only used if inputFile ends with \".pairs\"\n    If \"-1\" all particles will be simulated in a single event\n    \"\"\"\n    return self._parameters[\"ParticlesPerEvent\"]\n\n  @particlesPerEvent.setter\n  def particlesPerEvent(self, val):\n    self._parameters[\"ParticlesPerEvent\"] = str(val)",
  "def __init__(self):\n    super(GuineaPig, self).__init__()\n    self._parameters[\"ParticlesPerEvent\"] = -1\n    self._closeProperties()",
  "def particlesPerEvent(self):\n    \"\"\"Set the number of pair particles to simulate per event.\n    Only used if inputFile ends with \".pairs\"\n    If \"-1\" all particles will be simulated in a single event\n    \"\"\"\n    return self._parameters[\"ParticlesPerEvent\"]",
  "def particlesPerEvent(self, val):\n    self._parameters[\"ParticlesPerEvent\"] = str(val)",
  "def defaultOutputFile():\n  if DD4HEP_USE_LCIO:\n    return \"dummyOutput.slcio\"\n  return \"dummyOutput.root\"",
  "class OutputConfig(ConfigHelper):\n  \"\"\"Configuration for Output Files.\"\"\"\n\n  def __init__(self):\n    super(OutputConfig, self).__init__()\n    self._userPlugin = None\n    self._forceLCIO = False\n    self._forceEDM4HEP = False\n    self._forceDD4HEP = False\n    # no closeProperties, allow custom ones for userPlugin configuration\n\n  def _checkConsistency(self):\n    \"\"\"Raise error if more than one force flag is true.\"\"\"\n    if self._forceLCIO + self._forceEDM4HEP + self._forceDD4HEP > 1:\n      raise RuntimeError(f\"OutputConfig error: More than one force flag enabled: LCIO({self._forceLCIO}),\"\n                         f\" EDM4HEP({self._forceEDM4HEP}), DD4HEP({self._forceDD4HEP})\")\n\n  @property\n  def forceLCIO(self):\n    \"\"\"Use the LCIO output plugin regardless of outputfilename.\"\"\"\n    return self._forceLCIO\n\n  @forceLCIO.setter\n  def forceLCIO(self, val):\n    self._forceLCIO = self.makeBool(val)\n    if self._forceLCIO:\n      if not DD4HEP_USE_LCIO:\n        raise RuntimeError(\"OutputConfig error: forceLCIO requested, but LCIO not available!\")\n      self._checkConsistency()\n\n  @property\n  def forceEDM4HEP(self):\n    \"\"\"Use the EDM4HEP output plugin regardless of outputfilename.\"\"\"\n    return self._forceEDM4HEP\n\n  @forceEDM4HEP.setter\n  def forceEDM4HEP(self, val):\n    self._forceEDM4HEP = self.makeBool(val)\n    if self._forceEDM4HEP:\n      if not DD4HEP_USE_EDM4HEP:\n        raise RuntimeError(\"OutputConfig error: forceEDM4HEP requested, but EDM4HEP not available!\")\n      self._checkConsistency()\n\n  @property\n  def forceDD4HEP(self):\n    \"\"\"Use the DD4HEP output plugin regardless of outputfilename.\"\"\"\n    return self._forceDD4HEP\n\n  @forceDD4HEP.setter\n  def forceDD4HEP(self, val):\n    self._forceDD4HEP = self.makeBool(val)\n    if self._forceDD4HEP:\n      self._checkConsistency()\n\n  @property\n  def userOutputPlugin(self):\n    \"\"\"Set a function to configure the outputFile.\n\n    The function must take a ``DD4hepSimulation`` object as its only argument and return ``None``.\n\n    For example one can add this to the ddsim steering file:\n\n      def exampleUserPlugin(dd4hepSimulation):\n        '''Example code for user created plugin.\n\n        :param DD4hepSimulation dd4hepSimulation: The DD4hepSimulation instance, so all parameters can be accessed\n        :return: None\n        '''\n        from DDG4 import EventAction, Kernel\n        dd = dd4hepSimulation  # just shorter variable name\n        evt_root = EventAction(Kernel(), 'Geant4Output2ROOT/' + dd.outputFile, True)\n        evt_root.HandleMCTruth = True or False\n        evt_root.Control = True\n        output = dd.outputFile\n        if not dd.outputFile.endswith(dd.outputConfig.myExtension):\n          output = dd.outputFile + dd.outputConfig.myExtension\n        evt_root.Output = output\n        evt_root.enableUI()\n        Kernel().eventAction().add(evt_root)\n        return None\n\n      SIM.outputConfig.userOutputPlugin = exampleUserPlugin\n      # arbitrary options can be created and set via the steering file or command line\n      SIM.outputConfig.myExtension = '.csv'\n    \"\"\"\n    return self._userPlugin\n\n  @userOutputPlugin.setter\n  def userOutputPlugin(self, userOutputPluginConfig):\n    if userOutputPluginConfig is None:\n      return\n    if not callable(userOutputPluginConfig):\n      raise RuntimeError(\"The provided userPlugin is not a callable function.\")\n    self._userPlugin = userOutputPluginConfig\n\n  def initialize(self, dd4hepsimulation, geant4):\n    \"\"\"Configure the output file and plugin.\"\"\"\n    if callable(self._userPlugin):\n      logger.info(\"++++ Setting up UserPlugin for Output ++++\")\n      return self._userPlugin(dd4hepsimulation)\n\n    if self.forceLCIO:\n      return self._configureLCIO(dd4hepsimulation, geant4)\n\n    if self.forceEDM4HEP:\n      return self._configureEDM4HEP(dd4hepsimulation, geant4)\n\n    if self.forceDD4HEP:\n      return self._configureDD4HEP(dd4hepsimulation, geant4)\n\n    if dd4hepsimulation.outputFile.endswith(\".slcio\"):\n      return self._configureLCIO(dd4hepsimulation, geant4)\n\n    if dd4hepsimulation.outputFile.endswith(\".root\") and DD4HEP_USE_EDM4HEP:\n      return self._configureEDM4HEP(dd4hepsimulation, geant4)\n\n    if dd4hepsimulation.outputFile.endswith(\".root\"):\n      return self._configureDD4HEP(dd4hepsimulation, geant4)\n\n  def _configureLCIO(self, dds, geant4):\n    if not DD4HEP_USE_LCIO:\n      raise RuntimeError(\"DD4HEP was not build wiht LCIO support: please change output format %s\" % dds.outputFile)\n    logger.info(\"++++ Setting up LCIO Output ++++\")\n    lcOut = geant4.setupLCIOOutput('LcioOutput', dds.outputFile)\n    lcOut.RunHeader = dds.meta.addParametersToRunHeader(dds)\n    eventPars = dds.meta.parseEventParameters()\n    lcOut.EventParametersString, lcOut.EventParametersInt, lcOut.EventParametersFloat = eventPars\n    lcOut.RunNumberOffset = dds.meta.runNumberOffset if dds.meta.runNumberOffset > 0 else 0\n    lcOut.EventNumberOffset = dds.meta.eventNumberOffset if dds.meta.eventNumberOffset > 0 else 0\n    return\n\n  def _configureEDM4HEP(self, dds, geant4):\n    logger.info(\"++++ Setting up EDM4hep ROOT Output ++++\")\n    e4Out = geant4.setupEDM4hepOutput('EDM4hepOutput', dds.outputFile)\n    eventPars = dds.meta.parseEventParameters()\n    e4Out.RunHeader = dds.meta.addParametersToRunHeader(dds)\n    e4Out.EventParametersString, e4Out.EventParametersInt, e4Out.EventParametersFloat = eventPars\n    e4Out.RunNumberOffset = dds.meta.runNumberOffset if dds.meta.runNumberOffset > 0 else 0\n    e4Out.EventNumberOffset = dds.meta.eventNumberOffset if dds.meta.eventNumberOffset > 0 else 0\n    return\n\n  def _configureDD4HEP(self, dds, geant4):\n    logger.info(\"++++ Setting up DD4hep's ROOT Output ++++\")\n    geant4.setupROOTOutput('RootOutput', dds.outputFile)\n    return",
  "def __init__(self):\n    super(OutputConfig, self).__init__()\n    self._userPlugin = None\n    self._forceLCIO = False\n    self._forceEDM4HEP = False\n    self._forceDD4HEP = False",
  "def _checkConsistency(self):\n    \"\"\"Raise error if more than one force flag is true.\"\"\"\n    if self._forceLCIO + self._forceEDM4HEP + self._forceDD4HEP > 1:\n      raise RuntimeError(f\"OutputConfig error: More than one force flag enabled: LCIO({self._forceLCIO}),\"\n                         f\" EDM4HEP({self._forceEDM4HEP}), DD4HEP({self._forceDD4HEP})\")",
  "def forceLCIO(self):\n    \"\"\"Use the LCIO output plugin regardless of outputfilename.\"\"\"\n    return self._forceLCIO",
  "def forceLCIO(self, val):\n    self._forceLCIO = self.makeBool(val)\n    if self._forceLCIO:\n      if not DD4HEP_USE_LCIO:\n        raise RuntimeError(\"OutputConfig error: forceLCIO requested, but LCIO not available!\")\n      self._checkConsistency()",
  "def forceEDM4HEP(self):\n    \"\"\"Use the EDM4HEP output plugin regardless of outputfilename.\"\"\"\n    return self._forceEDM4HEP",
  "def forceEDM4HEP(self, val):\n    self._forceEDM4HEP = self.makeBool(val)\n    if self._forceEDM4HEP:\n      if not DD4HEP_USE_EDM4HEP:\n        raise RuntimeError(\"OutputConfig error: forceEDM4HEP requested, but EDM4HEP not available!\")\n      self._checkConsistency()",
  "def forceDD4HEP(self):\n    \"\"\"Use the DD4HEP output plugin regardless of outputfilename.\"\"\"\n    return self._forceDD4HEP",
  "def forceDD4HEP(self, val):\n    self._forceDD4HEP = self.makeBool(val)\n    if self._forceDD4HEP:\n      self._checkConsistency()",
  "def userOutputPlugin(self):\n    \"\"\"Set a function to configure the outputFile.\n\n    The function must take a ``DD4hepSimulation`` object as its only argument and return ``None``.\n\n    For example one can add this to the ddsim steering file:\n\n      def exampleUserPlugin(dd4hepSimulation):\n        '''Example code for user created plugin.\n\n        :param DD4hepSimulation dd4hepSimulation: The DD4hepSimulation instance, so all parameters can be accessed\n        :return: None\n        '''\n        from DDG4 import EventAction, Kernel\n        dd = dd4hepSimulation  # just shorter variable name\n        evt_root = EventAction(Kernel(), 'Geant4Output2ROOT/' + dd.outputFile, True)\n        evt_root.HandleMCTruth = True or False\n        evt_root.Control = True\n        output = dd.outputFile\n        if not dd.outputFile.endswith(dd.outputConfig.myExtension):\n          output = dd.outputFile + dd.outputConfig.myExtension\n        evt_root.Output = output\n        evt_root.enableUI()\n        Kernel().eventAction().add(evt_root)\n        return None\n\n      SIM.outputConfig.userOutputPlugin = exampleUserPlugin\n      # arbitrary options can be created and set via the steering file or command line\n      SIM.outputConfig.myExtension = '.csv'\n    \"\"\"\n    return self._userPlugin",
  "def userOutputPlugin(self, userOutputPluginConfig):\n    if userOutputPluginConfig is None:\n      return\n    if not callable(userOutputPluginConfig):\n      raise RuntimeError(\"The provided userPlugin is not a callable function.\")\n    self._userPlugin = userOutputPluginConfig",
  "def initialize(self, dd4hepsimulation, geant4):\n    \"\"\"Configure the output file and plugin.\"\"\"\n    if callable(self._userPlugin):\n      logger.info(\"++++ Setting up UserPlugin for Output ++++\")\n      return self._userPlugin(dd4hepsimulation)\n\n    if self.forceLCIO:\n      return self._configureLCIO(dd4hepsimulation, geant4)\n\n    if self.forceEDM4HEP:\n      return self._configureEDM4HEP(dd4hepsimulation, geant4)\n\n    if self.forceDD4HEP:\n      return self._configureDD4HEP(dd4hepsimulation, geant4)\n\n    if dd4hepsimulation.outputFile.endswith(\".slcio\"):\n      return self._configureLCIO(dd4hepsimulation, geant4)\n\n    if dd4hepsimulation.outputFile.endswith(\".root\") and DD4HEP_USE_EDM4HEP:\n      return self._configureEDM4HEP(dd4hepsimulation, geant4)\n\n    if dd4hepsimulation.outputFile.endswith(\".root\"):\n      return self._configureDD4HEP(dd4hepsimulation, geant4)",
  "def _configureLCIO(self, dds, geant4):\n    if not DD4HEP_USE_LCIO:\n      raise RuntimeError(\"DD4HEP was not build wiht LCIO support: please change output format %s\" % dds.outputFile)\n    logger.info(\"++++ Setting up LCIO Output ++++\")\n    lcOut = geant4.setupLCIOOutput('LcioOutput', dds.outputFile)\n    lcOut.RunHeader = dds.meta.addParametersToRunHeader(dds)\n    eventPars = dds.meta.parseEventParameters()\n    lcOut.EventParametersString, lcOut.EventParametersInt, lcOut.EventParametersFloat = eventPars\n    lcOut.RunNumberOffset = dds.meta.runNumberOffset if dds.meta.runNumberOffset > 0 else 0\n    lcOut.EventNumberOffset = dds.meta.eventNumberOffset if dds.meta.eventNumberOffset > 0 else 0\n    return",
  "def _configureEDM4HEP(self, dds, geant4):\n    logger.info(\"++++ Setting up EDM4hep ROOT Output ++++\")\n    e4Out = geant4.setupEDM4hepOutput('EDM4hepOutput', dds.outputFile)\n    eventPars = dds.meta.parseEventParameters()\n    e4Out.RunHeader = dds.meta.addParametersToRunHeader(dds)\n    e4Out.EventParametersString, e4Out.EventParametersInt, e4Out.EventParametersFloat = eventPars\n    e4Out.RunNumberOffset = dds.meta.runNumberOffset if dds.meta.runNumberOffset > 0 else 0\n    e4Out.EventNumberOffset = dds.meta.eventNumberOffset if dds.meta.eventNumberOffset > 0 else 0\n    return",
  "def _configureDD4HEP(self, dds, geant4):\n    logger.info(\"++++ Setting up DD4hep's ROOT Output ++++\")\n    geant4.setupROOTOutput('RootOutput', dds.outputFile)\n    return",
  "def outputLevelType(level):\n  \"\"\"Return verbosity level as integer if possible.\n\n  Still benefit from argparsers list of possible choices\n  \"\"\"\n  try:\n    return int(level)\n  except ValueError:\n    return str(level)",
  "def outputLevel(level):\n  \"\"\"return INT for outputlevel\"\"\"\n  if isinstance(level, int):\n    if level < 1 or 7 < level:\n      raise KeyError\n    return level\n  outputlevels = {\"VERBOSE\": 1,\n                  \"DEBUG\": 2,\n                  \"INFO\": 3,\n                  \"WARNING\": 4,\n                  \"ERROR\": 5,\n                  \"FATAL\": 6,\n                  \"ALWAYS\": 7}\n  return outputlevels[level.upper()]",
  "class Output(ConfigHelper):\n  \"\"\"Configuration for the output levels of DDG4 components\"\"\"\n\n  def __init__(self):\n    super(Output, self).__init__()\n    self._kernel_EXTRA = {'choices': OUTPUT_CHOICES, 'type': outputLevelType}\n    self._kernel = outputLevel('INFO')\n\n    self._part_EXTRA = {'choices': OUTPUT_CHOICES, 'type': outputLevelType}\n    self._part = outputLevel('INFO')\n\n    self._inputStage_EXTRA = {'choices': OUTPUT_CHOICES, 'type': outputLevelType}\n    self._inputStage = outputLevel('INFO')\n\n    self._random_EXTRA = {'choices': OUTPUT_CHOICES, 'type': outputLevelType}\n    self._random = outputLevel('FATAL')\n\n    self._geometry_EXTRA = {'choices': OUTPUT_CHOICES, 'type': outputLevelType}\n    self._geometry = outputLevel('DEBUG')\n    self._closeProperties()\n\n  @property\n  def inputStage(self):\n    \"\"\"Output level for input sources\"\"\"\n    return self._inputStage\n\n  @inputStage.setter\n  def inputStage(self, level):\n    self._inputStage = outputLevel(level)\n\n  @property\n  def kernel(self):\n    \"\"\"Output level for Geant4 kernel\"\"\"\n    return self._kernel\n\n  @kernel.setter\n  def kernel(self, level):\n    self._kernel = outputLevel(level)\n\n  @property\n  def part(self):\n    \"\"\"Output level for ParticleHandler\"\"\"\n    return self._part\n\n  @part.setter\n  def part(self, level):\n    self._part = outputLevel(level)\n\n  @property\n  def random(self):\n    \"\"\"Output level for Random Number Generator setup\"\"\"\n    return self._random\n\n  @random.setter\n  def random(self, level):\n    self._random = outputLevel(level)\n\n  @property\n  def geometry(self):\n    \"\"\"Output level for geometry.\"\"\"\n    return self._geometry\n\n  @geometry.setter\n  def geometry(self, level):\n    self._geometry = outputLevel(level)",
  "def __init__(self):\n    super(Output, self).__init__()\n    self._kernel_EXTRA = {'choices': OUTPUT_CHOICES, 'type': outputLevelType}\n    self._kernel = outputLevel('INFO')\n\n    self._part_EXTRA = {'choices': OUTPUT_CHOICES, 'type': outputLevelType}\n    self._part = outputLevel('INFO')\n\n    self._inputStage_EXTRA = {'choices': OUTPUT_CHOICES, 'type': outputLevelType}\n    self._inputStage = outputLevel('INFO')\n\n    self._random_EXTRA = {'choices': OUTPUT_CHOICES, 'type': outputLevelType}\n    self._random = outputLevel('FATAL')\n\n    self._geometry_EXTRA = {'choices': OUTPUT_CHOICES, 'type': outputLevelType}\n    self._geometry = outputLevel('DEBUG')\n    self._closeProperties()",
  "def inputStage(self):\n    \"\"\"Output level for input sources\"\"\"\n    return self._inputStage",
  "def inputStage(self, level):\n    self._inputStage = outputLevel(level)",
  "def kernel(self):\n    \"\"\"Output level for Geant4 kernel\"\"\"\n    return self._kernel",
  "def kernel(self, level):\n    self._kernel = outputLevel(level)",
  "def part(self):\n    \"\"\"Output level for ParticleHandler\"\"\"\n    return self._part",
  "def part(self, level):\n    self._part = outputLevel(level)",
  "def random(self):\n    \"\"\"Output level for Random Number Generator setup\"\"\"\n    return self._random",
  "def random(self, level):\n    self._random = outputLevel(level)",
  "def geometry(self):\n    \"\"\"Output level for geometry.\"\"\"\n    return self._geometry",
  "def geometry(self, level):\n    self._geometry = outputLevel(level)",
  "class LCIO(Input):\n  \"\"\"Configuration for the generator-level InputFiles\"\"\"\n\n  def __init__(self):\n    super(LCIO, self).__init__()\n    self._parameters[\"MCParticleCollectionName\"] = \"MCParticle\"\n    self._closeProperties()\n\n  @property\n  def mcParticleCollectionName(self):\n    \"\"\"Set the name of the collection containing the MCParticle input.\n    Default is \"MCParticle\".\n    \"\"\"\n    return self._parameters[\"MCParticleCollectionName\"]\n\n  @mcParticleCollectionName.setter\n  def mcParticleCollectionName(self, val):\n    self._parameters[\"MCParticleCollectionName\"] = val",
  "def __init__(self):\n    super(LCIO, self).__init__()\n    self._parameters[\"MCParticleCollectionName\"] = \"MCParticle\"\n    self._closeProperties()",
  "def mcParticleCollectionName(self):\n    \"\"\"Set the name of the collection containing the MCParticle input.\n    Default is \"MCParticle\".\n    \"\"\"\n    return self._parameters[\"MCParticleCollectionName\"]",
  "def mcParticleCollectionName(self, val):\n    self._parameters[\"MCParticleCollectionName\"] = val",
  "class Random (ConfigHelper):\n  \"\"\"Properties for the random number generator\"\"\"\n\n  def __init__(self):\n    super(Random, self).__init__()\n    self.seed = None\n    self.type = None\n    self.luxury = 1\n    self.replace_gRandom = True\n    self.file = None\n    self._random = None\n\n    self._enableEventSeed_EXTRA = {'help': \"If True, calculate random seed for each event based\"\n                                           \"on eventID and runID\\nAllows reproducibility even when\"\n                                           \"SkippingEvents\"}\n    self.enableEventSeed = False\n    self._closeProperties()\n\n  def initialize(self, DDG4, kernel, output):\n    \"\"\" initialize the random generator\n\n    :param DDG4: DDG4 module\n    :param kernel: Geant4 kernel\n    :param int output: output level\n    :returns: Geant4Random instance\n    \"\"\"\n    if self._random:\n      return self._random\n    self._random = DDG4.Action(kernel, 'Geant4Random/R1')\n\n    if self.seed is None:\n      # System provided random source, truely random according to documentation\n      self.seed = random.SystemRandom().randint(0, 2**31 - 1)\n      logger.info(\"Choosing random seed for you: %s\", self.seed)\n\n    self._random.Seed = self.seed\n    self._random.Luxury = self.luxury\n\n    if self.type is not None:\n      self._random.Type = self.type\n\n    self._random.initialize()\n\n    if self.seed is not None and self.enableEventSeed:\n      self._eventseed = DDG4.RunAction(kernel, 'Geant4EventSeed/EventSeeder1')\n\n    # Needs to be called after initilisation\n    if output <= 3:\n      self._random.showStatus()\n    return self._random",
  "def __init__(self):\n    super(Random, self).__init__()\n    self.seed = None\n    self.type = None\n    self.luxury = 1\n    self.replace_gRandom = True\n    self.file = None\n    self._random = None\n\n    self._enableEventSeed_EXTRA = {'help': \"If True, calculate random seed for each event based\"\n                                           \"on eventID and runID\\nAllows reproducibility even when\"\n                                           \"SkippingEvents\"}\n    self.enableEventSeed = False\n    self._closeProperties()",
  "def initialize(self, DDG4, kernel, output):\n    \"\"\" initialize the random generator\n\n    :param DDG4: DDG4 module\n    :param kernel: Geant4 kernel\n    :param int output: output level\n    :returns: Geant4Random instance\n    \"\"\"\n    if self._random:\n      return self._random\n    self._random = DDG4.Action(kernel, 'Geant4Random/R1')\n\n    if self.seed is None:\n      # System provided random source, truely random according to documentation\n      self.seed = random.SystemRandom().randint(0, 2**31 - 1)\n      logger.info(\"Choosing random seed for you: %s\", self.seed)\n\n    self._random.Seed = self.seed\n    self._random.Luxury = self.luxury\n\n    if self.type is not None:\n      self._random.Type = self.type\n\n    self._random.initialize()\n\n    if self.seed is not None and self.enableEventSeed:\n      self._eventseed = DDG4.RunAction(kernel, 'Geant4EventSeed/EventSeeder1')\n\n    # Needs to be called after initilisation\n    if output <= 3:\n      self._random.showStatus()\n    return self._random",
  "class Geometry(ConfigHelper):\n  \"\"\"Configuration for the Detector Construction.\"\"\"\n\n  def __init__(self):\n    super(Geometry, self).__init__()\n\n    self._enableDebugMaterials_EXTRA = {\"help\": \"Print Debug information about Materials\"}\n    self.enableDebugMaterials = False\n    self._enableDebugElements_EXTRA = {\"help\": \"Print Debug information about Elements\"}\n    self.enableDebugElements = False\n    self._enableDebugVolumes_EXTRA = {\"help\": \"Print Debug information about Volumes\"}\n    self.enableDebugVolumes = False\n    self._enableDebugShapes_EXTRA = {\"help\": \"Print Debug information about Shapes\"}\n    self.enableDebugShapes = False\n    self._enableDebugPlacements_EXTRA = {\"help\": \"Print Debug information about Placements\"}\n    self.enableDebugPlacements = False\n    self._enableDebugReflections_EXTRA = {\"help\": \"Print Debug information about Reflections\"}\n    self.enableDebugReflections = False\n    self._enableDebugRegions_EXTRA = {\"help\": \"Print Debug information about Regions\"}\n    self.enableDebugRegions = False\n    self._enableDebugSurfaces_EXTRA = {\"help\": \"Print Debug information about Surfaces\"}\n    self.enableDebugSurfaces = False\n    self._dumpHierachy_EXTRA = {\"help\": \"If larger than 0, the depth up to which detector hierarchy is dumped\"}\n    self.dumpHierarchy = 0\n\n    self._enablePrintPlacements_EXTRA = {\"help\": \"Print information about placements\"}\n    self.enablePrintPlacements = False\n    self._enablePrintSensitives_EXTRA = {\"help\": \"Print information about Sensitives\"}\n    self.enablePrintSensitives = False\n\n    self._dumpDGDML_EXTRA = {\"help\": \"If not empty, filename to dump the Geometry as GDML\"}\n    self.dumpGDML = \"\"\n    self._closeProperties()\n\n  def constructGeometry(self, kernel, geant4, geoPrintLevel=2, numberOfThreads=1):\n    \"\"\"Construct Geant4 geometry.\"\"\"\n    from DDG4 import DetectorConstruction\n\n    seq, act = geant4.addDetectorConstruction('Geant4DetectorGeometryConstruction/ConstructGeo')\n    act.DebugMaterials = self.enableDebugMaterials\n    act.DebugElements = self.enableDebugElements\n    act.DebugVolumes = self.enableDebugVolumes\n    act.DebugShapes = self.enableDebugShapes\n    act.DebugPlacements = self.enableDebugPlacements\n    act.DebugReflections = self.enableDebugReflections\n    act.DebugRegions = self.enableDebugRegions\n    act.DebugSurfaces = self.enableDebugSurfaces\n    act.PrintPlacements = self.enablePrintPlacements\n    act.PrintSensitives = self.enablePrintSensitives\n    act.GeoInfoPrintLevel = geoPrintLevel\n    act.DumpHierarchy = self.dumpHierarchy\n    act.DumpGDML = self.dumpGDML\n\n    # Apply sensitive detectors\n    sensitives = DetectorConstruction(kernel, str('Geant4DetectorSensitivesConstruction/ConstructSD'))\n    sensitives.enableUI()\n    seq.adopt(sensitives)",
  "def __init__(self):\n    super(Geometry, self).__init__()\n\n    self._enableDebugMaterials_EXTRA = {\"help\": \"Print Debug information about Materials\"}\n    self.enableDebugMaterials = False\n    self._enableDebugElements_EXTRA = {\"help\": \"Print Debug information about Elements\"}\n    self.enableDebugElements = False\n    self._enableDebugVolumes_EXTRA = {\"help\": \"Print Debug information about Volumes\"}\n    self.enableDebugVolumes = False\n    self._enableDebugShapes_EXTRA = {\"help\": \"Print Debug information about Shapes\"}\n    self.enableDebugShapes = False\n    self._enableDebugPlacements_EXTRA = {\"help\": \"Print Debug information about Placements\"}\n    self.enableDebugPlacements = False\n    self._enableDebugReflections_EXTRA = {\"help\": \"Print Debug information about Reflections\"}\n    self.enableDebugReflections = False\n    self._enableDebugRegions_EXTRA = {\"help\": \"Print Debug information about Regions\"}\n    self.enableDebugRegions = False\n    self._enableDebugSurfaces_EXTRA = {\"help\": \"Print Debug information about Surfaces\"}\n    self.enableDebugSurfaces = False\n    self._dumpHierachy_EXTRA = {\"help\": \"If larger than 0, the depth up to which detector hierarchy is dumped\"}\n    self.dumpHierarchy = 0\n\n    self._enablePrintPlacements_EXTRA = {\"help\": \"Print information about placements\"}\n    self.enablePrintPlacements = False\n    self._enablePrintSensitives_EXTRA = {\"help\": \"Print information about Sensitives\"}\n    self.enablePrintSensitives = False\n\n    self._dumpDGDML_EXTRA = {\"help\": \"If not empty, filename to dump the Geometry as GDML\"}\n    self.dumpGDML = \"\"\n    self._closeProperties()",
  "def constructGeometry(self, kernel, geant4, geoPrintLevel=2, numberOfThreads=1):\n    \"\"\"Construct Geant4 geometry.\"\"\"\n    from DDG4 import DetectorConstruction\n\n    seq, act = geant4.addDetectorConstruction('Geant4DetectorGeometryConstruction/ConstructGeo')\n    act.DebugMaterials = self.enableDebugMaterials\n    act.DebugElements = self.enableDebugElements\n    act.DebugVolumes = self.enableDebugVolumes\n    act.DebugShapes = self.enableDebugShapes\n    act.DebugPlacements = self.enableDebugPlacements\n    act.DebugReflections = self.enableDebugReflections\n    act.DebugRegions = self.enableDebugRegions\n    act.DebugSurfaces = self.enableDebugSurfaces\n    act.PrintPlacements = self.enablePrintPlacements\n    act.PrintSensitives = self.enablePrintSensitives\n    act.GeoInfoPrintLevel = geoPrintLevel\n    act.DumpHierarchy = self.dumpHierarchy\n    act.DumpGDML = self.dumpGDML\n\n    # Apply sensitive detectors\n    sensitives = DetectorConstruction(kernel, str('Geant4DetectorSensitivesConstruction/ConstructSD'))\n    sensitives.enableUI()\n    seq.adopt(sensitives)",
  "class Filter(ConfigHelper):\n  \"\"\"Configuration for sensitive detector filters\n\n  Set the default filter for 'tracker'\n  >>> SIM.filter.tracker = \"edep1kev\"\n  Use no filter for 'calorimeter' by default\n  >>> SIM.filter.calo = \"\"\n\n  Assign a filter to a sensitive detector via pattern matching\n  >>> SIM.filter.mapDetFilter['FTD'] = \"edep1kev\"\n\n  Or more than one filter:\n  >>> SIM.filter.mapDetFilter['FTD'] = [\"edep1kev\", \"geantino\"]\n\n  Don't use the default filter or anything else:\n  >>> SIM.filter.mapDetFilter['TPC'] = None ## or \"\" or []\n\n  Create a custom filter. The dictionary is used to instantiate the filter later on\n  >>> SIM.filter.filters['edep3kev'] = dict(name=\"EnergyDepositMinimumCut/3keV\", parameter={\"Cut\": 3.0*keV} )\n\n  \"\"\"\n\n  def __init__(self):\n    super(Filter, self).__init__()\n    self._mapDetFilter = {}\n    self._tracker = \"edep1kev\"\n    self._calo = \"edep0\"\n    self._filters = {}\n    self._createDefaultFilters()\n    self._closeProperties()\n\n  @property\n  def tracker(self):\n    \"\"\" default filter for tracking sensitive detectors; this is applied if no other filter is used for a tracker\"\"\"\n    return self._tracker\n\n  @tracker.setter\n  def tracker(self, val):\n    self._tracker = val\n\n  @property\n  def calo(self):\n    \"\"\"\n    default filter for calorimeter sensitive detectors;\n    this is applied if no other filter is used for a calorimeter\n    \"\"\"\n    return self._calo\n\n  @calo.setter\n  def calo(self, val):\n    self._calo = val\n\n  @property\n  def filters(self):\n    \"\"\" list of filter objects: map between name and parameter dictionary \"\"\"\n    return self._filters\n\n  @filters.setter\n  def filters(self, val):\n    if isinstance(val, dict):\n      self._filters.update(val)\n      return\n    ##\n    raise RuntimeError(\"Commandline setting of filters is not supported, use a steeringFile: %s \" % val)\n\n  @property\n  def mapDetFilter(self):\n    \"\"\" a map between patterns and filter objects, using patterns to attach filters to sensitive detector \"\"\"\n    return self._mapDetFilter\n\n  @mapDetFilter.setter\n  def mapDetFilter(self, val):\n    if isinstance(val, dict):\n      self._mapDetFilter.update(val)\n      return\n\n    if isinstance(val, str):\n      vals = val.split(\" \")\n    elif isinstance(val, list):\n      vals = val\n    if len(vals) % 2 != 0:\n      raise RuntimeError(\"Not enough parameters for mapDetFilter\")\n    for index in range(0, len(vals), 2):\n      self._mapDetFilter[vals[index]] = vals[index + 1]\n\n  def resetFilter(self):\n    \"\"\" remove all filters \"\"\"\n    self._filters = {}\n\n  def _createDefaultFilters(self):\n    \"\"\" create the map with the default filters \"\"\"\n    self.filters[\"geantino\"] = dict(name=\"GeantinoRejectFilter/GeantinoRejector\",\n                                    parameter={})\n\n    self.filters[\"edep1kev\"] = dict(name=\"EnergyDepositMinimumCut\",\n                                    parameter={\"Cut\": 1.0 * keV})\n\n    self.filters[\"edep0\"] = dict(name=\"EnergyDepositMinimumCut/Cut0\",\n                                 parameter={\"Cut\": 0.0})\n\n  def __makeMapDetList(self):\n    \"\"\" create the values of the mapDetFilters a list of filters \"\"\"\n    for pattern, filters in self._mapDetFilter.items():\n      self._mapDetFilter[pattern] = ConfigHelper.makeList(filters)\n\n  def setupFilters(self, kernel):\n    \"\"\" attach all filters to the kernel \"\"\"\n    import DDG4\n    setOfFilters = set()\n\n    for name, filt in self.filters.items():\n      setOfFilters.add(name)\n      ddFilt = DDG4.Filter(kernel, filt['name'])\n      for para, value in filt['parameter'].items():\n        setattr(ddFilt, para, value)\n      kernel.registerGlobalFilter(ddFilt)\n      filt['filter'] = ddFilt\n\n    from itertools import chain\n    listOfFilters = []\n    for val in self.mapDetFilter.values():\n      listOfFilters += ConfigHelper.makeList(val)\n    requestedFilter = set(chain(ConfigHelper.makeList(self.tracker), ConfigHelper.makeList(self.calo), listOfFilters))\n    logger.info(\"ReqFilt %s\", requestedFilter)\n    if requestedFilter - setOfFilters:\n      raise RuntimeError(\" Filter(s) '%s' are not registered!\" % str(requestedFilter - setOfFilters))\n\n  def applyFilters(self, seq, det, defaultFilter=None):\n    \"\"\"apply the filters to to the sensitive detector\n\n    :param seq: sequence object returned when creating sensitive detector\n    :param det: sensitive detector name\n    :returns: None\n    \"\"\"\n    self.__makeMapDetList()\n    foundFilter = False\n    for pattern, filts in self.mapDetFilter.items():\n      if pattern.lower() in det.lower():\n        foundFilter = True\n        for filt in filts:\n          logger.info(\"Adding filter '%s' matched with '%s' to sensitive detector for '%s' \" % (filt, pattern, det))\n          seq.add(self.filters[filt]['filter'])\n\n    if foundFilter:\n      return\n    if defaultFilter:\n      logger.info(\"Adding default filter '%s' to sensitive detector for '%s' \" % (defaultFilter, det))\n      seq.add(self.filters[defaultFilter]['filter'])\n      return\n    logger.info(\"Not adding any filter to sensitive detector for '%s' \" % det)",
  "def __init__(self):\n    super(Filter, self).__init__()\n    self._mapDetFilter = {}\n    self._tracker = \"edep1kev\"\n    self._calo = \"edep0\"\n    self._filters = {}\n    self._createDefaultFilters()\n    self._closeProperties()",
  "def tracker(self):\n    \"\"\" default filter for tracking sensitive detectors; this is applied if no other filter is used for a tracker\"\"\"\n    return self._tracker",
  "def tracker(self, val):\n    self._tracker = val",
  "def calo(self):\n    \"\"\"\n    default filter for calorimeter sensitive detectors;\n    this is applied if no other filter is used for a calorimeter\n    \"\"\"\n    return self._calo",
  "def calo(self, val):\n    self._calo = val",
  "def filters(self):\n    \"\"\" list of filter objects: map between name and parameter dictionary \"\"\"\n    return self._filters",
  "def filters(self, val):\n    if isinstance(val, dict):\n      self._filters.update(val)\n      return\n    ##\n    raise RuntimeError(\"Commandline setting of filters is not supported, use a steeringFile: %s \" % val)",
  "def mapDetFilter(self):\n    \"\"\" a map between patterns and filter objects, using patterns to attach filters to sensitive detector \"\"\"\n    return self._mapDetFilter",
  "def mapDetFilter(self, val):\n    if isinstance(val, dict):\n      self._mapDetFilter.update(val)\n      return\n\n    if isinstance(val, str):\n      vals = val.split(\" \")\n    elif isinstance(val, list):\n      vals = val\n    if len(vals) % 2 != 0:\n      raise RuntimeError(\"Not enough parameters for mapDetFilter\")\n    for index in range(0, len(vals), 2):\n      self._mapDetFilter[vals[index]] = vals[index + 1]",
  "def resetFilter(self):\n    \"\"\" remove all filters \"\"\"\n    self._filters = {}",
  "def _createDefaultFilters(self):\n    \"\"\" create the map with the default filters \"\"\"\n    self.filters[\"geantino\"] = dict(name=\"GeantinoRejectFilter/GeantinoRejector\",\n                                    parameter={})\n\n    self.filters[\"edep1kev\"] = dict(name=\"EnergyDepositMinimumCut\",\n                                    parameter={\"Cut\": 1.0 * keV})\n\n    self.filters[\"edep0\"] = dict(name=\"EnergyDepositMinimumCut/Cut0\",\n                                 parameter={\"Cut\": 0.0})",
  "def __makeMapDetList(self):\n    \"\"\" create the values of the mapDetFilters a list of filters \"\"\"\n    for pattern, filters in self._mapDetFilter.items():\n      self._mapDetFilter[pattern] = ConfigHelper.makeList(filters)",
  "def setupFilters(self, kernel):\n    \"\"\" attach all filters to the kernel \"\"\"\n    import DDG4\n    setOfFilters = set()\n\n    for name, filt in self.filters.items():\n      setOfFilters.add(name)\n      ddFilt = DDG4.Filter(kernel, filt['name'])\n      for para, value in filt['parameter'].items():\n        setattr(ddFilt, para, value)\n      kernel.registerGlobalFilter(ddFilt)\n      filt['filter'] = ddFilt\n\n    from itertools import chain\n    listOfFilters = []\n    for val in self.mapDetFilter.values():\n      listOfFilters += ConfigHelper.makeList(val)\n    requestedFilter = set(chain(ConfigHelper.makeList(self.tracker), ConfigHelper.makeList(self.calo), listOfFilters))\n    logger.info(\"ReqFilt %s\", requestedFilter)\n    if requestedFilter - setOfFilters:\n      raise RuntimeError(\" Filter(s) '%s' are not registered!\" % str(requestedFilter - setOfFilters))",
  "def applyFilters(self, seq, det, defaultFilter=None):\n    \"\"\"apply the filters to to the sensitive detector\n\n    :param seq: sequence object returned when creating sensitive detector\n    :param det: sensitive detector name\n    :returns: None\n    \"\"\"\n    self.__makeMapDetList()\n    foundFilter = False\n    for pattern, filts in self.mapDetFilter.items():\n      if pattern.lower() in det.lower():\n        foundFilter = True\n        for filt in filts:\n          logger.info(\"Adding filter '%s' matched with '%s' to sensitive detector for '%s' \" % (filt, pattern, det))\n          seq.add(self.filters[filt]['filter'])\n\n    if foundFilter:\n      return\n    if defaultFilter:\n      logger.info(\"Adding default filter '%s' to sensitive detector for '%s' \" % (defaultFilter, det))\n      seq.add(self.filters[defaultFilter]['filter'])\n      return\n    logger.info(\"Not adding any filter to sensitive detector for '%s' \" % det)",
  "class Physics(ConfigHelper):\n  \"\"\"Configuration for the PhysicsList\"\"\"\n\n  def __init__(self):\n    super(Physics, self).__init__()\n    self._rangecut = 0.7 * mm\n    self._list = \"FTFP_BERT\"\n    self._decays = False\n    self._pdgfile = None\n    self._rejectPDGs = {1, 2, 3, 4, 5, 6,  # quarks\n                        21, 23, 24, 25,  # bosons\n                        1103,  # d? diquarks\n                        2101, 2103, 2203,  # u? diquarks\n                        3101, 3103, 3201, 3203, 3303,  # s? diquarks\n                        4101, 4103, 4201, 4203, 4301, 4303, 4403,  # c? diquarks\n                        5101, 5103, 5201, 5203, 5301, 5303, 5401, 5403, 5503}  # b? diquarks\n    self._zeroTimePDGs = {11, 13, 15, 17}\n    self._userFunctions = []\n    self._closeProperties()\n\n  @property\n  def rejectPDGs(self):\n    \"\"\"Set of PDG IDs that will not be passed from the input record to Geant4.\n\n    Quarks, gluons and W's Z's etc should not be treated by Geant4\n    \"\"\"\n    return self._rejectPDGs\n\n  @rejectPDGs.setter\n  def rejectPDGs(self, val):\n    self._rejectPDGs = self.makeSet(val)\n\n  @property\n  def zeroTimePDGs(self):\n    \"\"\"Set of PDG IDs for particles that should not be passed to Geant4 if their properTime is 0.\n\n    The properTime of 0 indicates a documentation to add FSR to a lepton for example.\n    \"\"\"\n    return self._zeroTimePDGs\n\n  @zeroTimePDGs.setter\n  def zeroTimePDGs(self, val):\n    self._zeroTimePDGs = self.makeSet(val)\n\n  @property\n  def rangecut(self):\n    \"\"\" The global geant4 rangecut for secondary production\n\n    Default is 0.7 mm as is the case in geant4 10\n\n    To disable this plugin and be absolutely sure to use the Geant4 default range cut use \"None\"\n\n    Set printlevel to DEBUG to see a printout of all range cuts,\n    but this only works if range cut is not \"None\"\n    \"\"\"\n    return self._rangecut\n\n  @rangecut.setter\n  def rangecut(self, val):\n    if val is None:\n      self._rangecut = None\n      return\n    if isinstance(val, str):\n      if val == \"None\":\n        self._rangecut = None\n        return\n    self._rangecut = val\n\n  @property\n  def pdgfile(self):\n    \"\"\" location of particle.tbl file containing extra particles and their lifetime information\n\n    For example in $DD4HEP/examples/DDG4/examples/particle.tbl\n    \"\"\"\n    return self._pdgfile\n\n  @pdgfile.setter\n  def pdgfile(self, val):\n    if not val:\n      self._pdgfile = None\n      return\n    if not os.path.exists(val):\n      raise RuntimeError(\"PDGFile: %s not found\" % os.path.abspath(val))\n    self._pdgfile = os.path.abspath(val)\n\n  @property\n  def decays(self):\n    \"\"\"If true, add decay processes for all particles.\n\n    Only enable when creating a physics list not based on an existing Geant4 list!\n    \"\"\"\n    return self._decays\n\n  @decays.setter\n  def decays(self, val):\n    self._decays = val\n\n  @property\n  def list(self):  # noqa: A003\n    \"\"\"The name of the Geant4 Physics list.\"\"\"\n    return self._list\n\n  @list.setter\n  def list(self, val):  # noqa: A003\n    self._list = val\n\n  def setupPhysics(self, kernel, name=None):\n    seq = kernel.physicsList()\n    seq.extends = name if name is not None else self.list\n    seq.decays = self.decays\n    seq.enableUI()\n    seq.dump()\n\n    from DDG4 import PhysicsList\n\n    # Add special particle types from specialized physics constructor\n    if self.pdgfile:\n      seq = kernel.physicsList()\n      part = PhysicsList(kernel, 'Geant4ExtraParticles/ExtraParticles')\n      part.enableUI()\n      seq.adopt(part)\n      part.pdgfile = self.pdgfile\n\n    # Add global range cut\n    if self.rangecut is not None:\n      seq = kernel.physicsList()\n      rg = PhysicsList(kernel, 'Geant4DefaultRangeCut/GlobalRangeCut')\n      rg.enableUI()\n      seq.adopt(rg)\n      rg.RangeCut = self.rangecut\n\n    for func in self._userFunctions:\n      try:\n        func(kernel)\n      except Exception as e:\n        logger.error(\"Exception in UserFunction: %r\", e)\n        raise RuntimeError(\"Exception in UserFunction: %r\" % e)\n\n    return seq\n\n  def setupUserPhysics(self, userFunction):\n    \"\"\"Add a function to setup physics plugins.\n\n    The function must take the DDG4.Kernel() object as the only argument.\n\n    For example, add a function definition and the call to a steering file::\n\n      def setupCerenkov(kernel):\n        from DDG4 import PhysicsList\n        seq = kernel.physicsList()\n        cerenkov = PhysicsList(kernel, 'Geant4CerenkovPhysics/CerenkovPhys')\n        cerenkov.MaxNumPhotonsPerStep = 10\n        cerenkov.MaxBetaChangePerStep = 10.0\n        cerenkov.TrackSecondariesFirst = True\n        cerenkov.VerboseLevel = 2\n        cerenkov.enableUI()\n        seq.adopt(cerenkov)\n        ph = PhysicsList(kernel, 'Geant4OpticalPhotonPhysics/OpticalGammaPhys')\n        ph.addParticleConstructor('G4OpticalPhoton')\n        ph.VerboseLevel = 2\n        ph.enableUI()\n        seq.adopt(ph)\n        return None\n\n      SIM.physics.setupUserPhysics(setupCerenkov)\n    \"\"\"\n    self._userFunctions.append(userFunction)",
  "def __init__(self):\n    super(Physics, self).__init__()\n    self._rangecut = 0.7 * mm\n    self._list = \"FTFP_BERT\"\n    self._decays = False\n    self._pdgfile = None\n    self._rejectPDGs = {1, 2, 3, 4, 5, 6,  # quarks\n                        21, 23, 24, 25,  # bosons\n                        1103,  # d? diquarks\n                        2101, 2103, 2203,  # u? diquarks\n                        3101, 3103, 3201, 3203, 3303,  # s? diquarks\n                        4101, 4103, 4201, 4203, 4301, 4303, 4403,  # c? diquarks\n                        5101, 5103, 5201, 5203, 5301, 5303, 5401, 5403, 5503}  # b? diquarks\n    self._zeroTimePDGs = {11, 13, 15, 17}\n    self._userFunctions = []\n    self._closeProperties()",
  "def rejectPDGs(self):\n    \"\"\"Set of PDG IDs that will not be passed from the input record to Geant4.\n\n    Quarks, gluons and W's Z's etc should not be treated by Geant4\n    \"\"\"\n    return self._rejectPDGs",
  "def rejectPDGs(self, val):\n    self._rejectPDGs = self.makeSet(val)",
  "def zeroTimePDGs(self):\n    \"\"\"Set of PDG IDs for particles that should not be passed to Geant4 if their properTime is 0.\n\n    The properTime of 0 indicates a documentation to add FSR to a lepton for example.\n    \"\"\"\n    return self._zeroTimePDGs",
  "def zeroTimePDGs(self, val):\n    self._zeroTimePDGs = self.makeSet(val)",
  "def rangecut(self):\n    \"\"\" The global geant4 rangecut for secondary production\n\n    Default is 0.7 mm as is the case in geant4 10\n\n    To disable this plugin and be absolutely sure to use the Geant4 default range cut use \"None\"\n\n    Set printlevel to DEBUG to see a printout of all range cuts,\n    but this only works if range cut is not \"None\"\n    \"\"\"\n    return self._rangecut",
  "def rangecut(self, val):\n    if val is None:\n      self._rangecut = None\n      return\n    if isinstance(val, str):\n      if val == \"None\":\n        self._rangecut = None\n        return\n    self._rangecut = val",
  "def pdgfile(self):\n    \"\"\" location of particle.tbl file containing extra particles and their lifetime information\n\n    For example in $DD4HEP/examples/DDG4/examples/particle.tbl\n    \"\"\"\n    return self._pdgfile",
  "def pdgfile(self, val):\n    if not val:\n      self._pdgfile = None\n      return\n    if not os.path.exists(val):\n      raise RuntimeError(\"PDGFile: %s not found\" % os.path.abspath(val))\n    self._pdgfile = os.path.abspath(val)",
  "def decays(self):\n    \"\"\"If true, add decay processes for all particles.\n\n    Only enable when creating a physics list not based on an existing Geant4 list!\n    \"\"\"\n    return self._decays",
  "def decays(self, val):\n    self._decays = val",
  "def list(self):  # noqa: A003\n    \"\"\"The name of the Geant4 Physics list.\"\"\"\n    return self._list",
  "def list(self, val):  # noqa: A003\n    self._list = val",
  "def setupPhysics(self, kernel, name=None):\n    seq = kernel.physicsList()\n    seq.extends = name if name is not None else self.list\n    seq.decays = self.decays\n    seq.enableUI()\n    seq.dump()\n\n    from DDG4 import PhysicsList\n\n    # Add special particle types from specialized physics constructor\n    if self.pdgfile:\n      seq = kernel.physicsList()\n      part = PhysicsList(kernel, 'Geant4ExtraParticles/ExtraParticles')\n      part.enableUI()\n      seq.adopt(part)\n      part.pdgfile = self.pdgfile\n\n    # Add global range cut\n    if self.rangecut is not None:\n      seq = kernel.physicsList()\n      rg = PhysicsList(kernel, 'Geant4DefaultRangeCut/GlobalRangeCut')\n      rg.enableUI()\n      seq.adopt(rg)\n      rg.RangeCut = self.rangecut\n\n    for func in self._userFunctions:\n      try:\n        func(kernel)\n      except Exception as e:\n        logger.error(\"Exception in UserFunction: %r\", e)\n        raise RuntimeError(\"Exception in UserFunction: %r\" % e)\n\n    return seq",
  "def setupUserPhysics(self, userFunction):\n    \"\"\"Add a function to setup physics plugins.\n\n    The function must take the DDG4.Kernel() object as the only argument.\n\n    For example, add a function definition and the call to a steering file::\n\n      def setupCerenkov(kernel):\n        from DDG4 import PhysicsList\n        seq = kernel.physicsList()\n        cerenkov = PhysicsList(kernel, 'Geant4CerenkovPhysics/CerenkovPhys')\n        cerenkov.MaxNumPhotonsPerStep = 10\n        cerenkov.MaxBetaChangePerStep = 10.0\n        cerenkov.TrackSecondariesFirst = True\n        cerenkov.VerboseLevel = 2\n        cerenkov.enableUI()\n        seq.adopt(cerenkov)\n        ph = PhysicsList(kernel, 'Geant4OpticalPhotonPhysics/OpticalGammaPhys')\n        ph.addParticleConstructor('G4OpticalPhoton')\n        ph.VerboseLevel = 2\n        ph.enableUI()\n        seq.adopt(ph)\n        return None\n\n      SIM.physics.setupUserPhysics(setupCerenkov)\n    \"\"\"\n    self._userFunctions.append(userFunction)",
  "class ParticleHandler(ConfigHelper):\n  \"\"\"Configuration for the Particle Handler/ MCTruth treatment\"\"\"\n\n  def __init__(self):\n    super(ParticleHandler, self).__init__()\n    self._saveProcesses = ['Decay']\n    self._minimalKineticEnergy = 1 * MeV\n    self._keepAllParticles = False\n    self._printEndTracking = False\n    self._printStartTracking = False\n    self._minDistToParentVertex = 2.2e-14 * mm\n    self._enableDetailedHitsAndParticleInfo = False\n    self._userParticleHandler = \"Geant4TCUserParticleHandler\"\n    self._closeProperties()\n\n  @property\n  def enableDetailedHitsAndParticleInfo(self):\n    \"\"\"Enable lots of printout on simulated hits and MC-truth information\"\"\"\n    return self._enableDetailedHitsAndParticleInfo\n\n  @enableDetailedHitsAndParticleInfo.setter\n  def enableDetailedHitsAndParticleInfo(self, val):\n    self._enableDetailedHitsAndParticleInfo = val\n\n  @property\n  def userParticleHandler(self):\n    \"\"\"Optionally enable an extended Particle Handler\"\"\"\n    return self._userParticleHandler\n\n  @userParticleHandler.setter\n  def userParticleHandler(self, val):\n    self._userParticleHandler = val\n\n  @property\n  def minDistToParentVertex(self):\n    \"\"\"Minimal distance between particle vertex and endpoint of parent after\n    which the vertexIsNotEndpointOfParent flag is set\n    \"\"\"\n    return self._minDistToParentVertex\n\n  @minDistToParentVertex.setter\n  def minDistToParentVertex(self, val):\n    self._minDistToParentVertex = val\n\n  @property\n  def saveProcesses(self):\n    \"\"\"List of processes to save, on command line give as whitespace separated string in quotation marks\"\"\"\n    return self._saveProcesses\n\n  @saveProcesses.setter\n  def saveProcesses(self, stringVal):\n    self._saveProcesses = ConfigHelper.makeList(stringVal)\n\n  @property\n  def minimalKineticEnergy(self):\n    \"\"\"MinimalKineticEnergy to store particles created in the tracking region\"\"\"\n    return self._minimalKineticEnergy\n\n  @minimalKineticEnergy.setter\n  def minimalKineticEnergy(self, val):\n    self._minimalKineticEnergy = val\n\n  @property\n  def keepAllParticles(self):\n    \"\"\" Keep all created particles \"\"\"\n    return self._keepAllParticles\n\n  @keepAllParticles.setter\n  def keepAllParticles(self, val):\n    self._keepAllParticles = val\n\n  @property\n  def printStartTracking(self):\n    \"\"\" Printout at Start of Tracking \"\"\"\n    return self._printStartTracking\n\n  @printStartTracking.setter\n  def printStartTracking(self, val):\n    self._printEndTracking = val\n\n  @property\n  def printEndTracking(self):\n    \"\"\" Printout at End of Tracking \"\"\"\n    return self._printEndTracking\n\n  @printEndTracking.setter\n  def printEndTracking(self, val):\n    self._printEndTracking = val\n\n  def setDumpDetailedParticleInfo(self, kernel, DDG4):\n    # ---- debug code from Markus for detailed dumps of hits and MC-truth assignement ------\n    # Add the particle dumper to associate the MC truth\n    evt = DDG4.EventAction(kernel, \"Geant4ParticleDumpAction/ParticleDump\")\n    kernel.eventAction().adopt(evt)\n    evt.enableUI()\n    # Add the hit dumper BEFORE any hit truth is fixed\n    evt = DDG4.EventAction(kernel, \"Geant4HitDumpAction/RawDump\")\n    kernel.eventAction().adopt(evt)\n    evt.enableUI()\n    # Add the hit dumper to the event action sequence\n    evt = DDG4.EventAction(kernel, \"Geant4HitTruthHandler/HitTruth\")\n    kernel.eventAction().adopt(evt)\n    evt.enableUI()\n    # Add the hit dumper AFTER any hit truth is fixed. We should see the reduced track references\n    evt = DDG4.EventAction(kernel, \"Geant4HitDumpAction/HitDump\")\n    kernel.eventAction().adopt(evt)\n    evt.enableUI()\n\n  def setupUserParticleHandler(self, part, kernel, DDG4):\n    \"\"\"Create the UserParticleHandler and configure it.\n\n    FIXME: this is not extensible at the moment\n    \"\"\"\n    if not self.userParticleHandler:\n      return\n\n    if self.userParticleHandler not in [\"Geant4TCUserParticleHandler\"]:\n      logger.error(\"unknown UserParticleHandler: %r\" % self.userParticleHandler)\n      exit(1)\n\n    if self.userParticleHandler == \"Geant4TCUserParticleHandler\":\n      user = DDG4.Action(kernel, \"%s/UserParticleHandler\" % self.userParticleHandler)\n      try:\n        user.TrackingVolume_Zmax = DDG4.tracker_region_zmax\n        user.TrackingVolume_Rmax = DDG4.tracker_region_rmax\n      except AttributeError as e:\n        logger.error(\"Attribute of tracker region missing in detector model %s\", e)\n        logger.error(\"   make sure to specify the global constants tracker_region_zmax and tracker_region_rmax \")\n        logger.error(\"   this is needed for the MC-truth link of created sim-hits  !  \")\n        logger.error(\" Or Disable the User Particle Handler with --part.userParticleHandler=''\")\n        exit(1)\n\n      try:\n        user.TrackingVolume_Zmin = DDG4.tracker_region_zmin\n      except AttributeError as e:\n        logger.debug(\"Attribute tracker_region_zmin for asymmetric tracker region missing %s\", e)\n        logger.debug(\"  will use symmetric region defined by tracker_region_zmax\")\n        user.TrackingVolume_Zmin = str(-float(user.TrackingVolume_Zmax))\n\n      logger.info(\" *** definition of tracker region *** \")\n      logger.info(\"    tracker_region_zmin = %s\", user.TrackingVolume_Zmin)\n      logger.info(\"    tracker_region_zmax = %s\", user.TrackingVolume_Zmax)\n      logger.info(\"    tracker_region_rmax = %s\", user.TrackingVolume_Rmax)\n      logger.info(\" ************************************ \")\n\n      part.adopt(user)\n\n    return",
  "def __init__(self):\n    super(ParticleHandler, self).__init__()\n    self._saveProcesses = ['Decay']\n    self._minimalKineticEnergy = 1 * MeV\n    self._keepAllParticles = False\n    self._printEndTracking = False\n    self._printStartTracking = False\n    self._minDistToParentVertex = 2.2e-14 * mm\n    self._enableDetailedHitsAndParticleInfo = False\n    self._userParticleHandler = \"Geant4TCUserParticleHandler\"\n    self._closeProperties()",
  "def enableDetailedHitsAndParticleInfo(self):\n    \"\"\"Enable lots of printout on simulated hits and MC-truth information\"\"\"\n    return self._enableDetailedHitsAndParticleInfo",
  "def enableDetailedHitsAndParticleInfo(self, val):\n    self._enableDetailedHitsAndParticleInfo = val",
  "def userParticleHandler(self):\n    \"\"\"Optionally enable an extended Particle Handler\"\"\"\n    return self._userParticleHandler",
  "def userParticleHandler(self, val):\n    self._userParticleHandler = val",
  "def minDistToParentVertex(self):\n    \"\"\"Minimal distance between particle vertex and endpoint of parent after\n    which the vertexIsNotEndpointOfParent flag is set\n    \"\"\"\n    return self._minDistToParentVertex",
  "def minDistToParentVertex(self, val):\n    self._minDistToParentVertex = val",
  "def saveProcesses(self):\n    \"\"\"List of processes to save, on command line give as whitespace separated string in quotation marks\"\"\"\n    return self._saveProcesses",
  "def saveProcesses(self, stringVal):\n    self._saveProcesses = ConfigHelper.makeList(stringVal)",
  "def minimalKineticEnergy(self):\n    \"\"\"MinimalKineticEnergy to store particles created in the tracking region\"\"\"\n    return self._minimalKineticEnergy",
  "def minimalKineticEnergy(self, val):\n    self._minimalKineticEnergy = val",
  "def keepAllParticles(self):\n    \"\"\" Keep all created particles \"\"\"\n    return self._keepAllParticles",
  "def keepAllParticles(self, val):\n    self._keepAllParticles = val",
  "def printStartTracking(self):\n    \"\"\" Printout at Start of Tracking \"\"\"\n    return self._printStartTracking",
  "def printStartTracking(self, val):\n    self._printEndTracking = val",
  "def printEndTracking(self):\n    \"\"\" Printout at End of Tracking \"\"\"\n    return self._printEndTracking",
  "def printEndTracking(self, val):\n    self._printEndTracking = val",
  "def setDumpDetailedParticleInfo(self, kernel, DDG4):\n    # ---- debug code from Markus for detailed dumps of hits and MC-truth assignement ------\n    # Add the particle dumper to associate the MC truth\n    evt = DDG4.EventAction(kernel, \"Geant4ParticleDumpAction/ParticleDump\")\n    kernel.eventAction().adopt(evt)\n    evt.enableUI()\n    # Add the hit dumper BEFORE any hit truth is fixed\n    evt = DDG4.EventAction(kernel, \"Geant4HitDumpAction/RawDump\")\n    kernel.eventAction().adopt(evt)\n    evt.enableUI()\n    # Add the hit dumper to the event action sequence\n    evt = DDG4.EventAction(kernel, \"Geant4HitTruthHandler/HitTruth\")\n    kernel.eventAction().adopt(evt)\n    evt.enableUI()\n    # Add the hit dumper AFTER any hit truth is fixed. We should see the reduced track references\n    evt = DDG4.EventAction(kernel, \"Geant4HitDumpAction/HitDump\")\n    kernel.eventAction().adopt(evt)\n    evt.enableUI()",
  "def setupUserParticleHandler(self, part, kernel, DDG4):\n    \"\"\"Create the UserParticleHandler and configure it.\n\n    FIXME: this is not extensible at the moment\n    \"\"\"\n    if not self.userParticleHandler:\n      return\n\n    if self.userParticleHandler not in [\"Geant4TCUserParticleHandler\"]:\n      logger.error(\"unknown UserParticleHandler: %r\" % self.userParticleHandler)\n      exit(1)\n\n    if self.userParticleHandler == \"Geant4TCUserParticleHandler\":\n      user = DDG4.Action(kernel, \"%s/UserParticleHandler\" % self.userParticleHandler)\n      try:\n        user.TrackingVolume_Zmax = DDG4.tracker_region_zmax\n        user.TrackingVolume_Rmax = DDG4.tracker_region_rmax\n      except AttributeError as e:\n        logger.error(\"Attribute of tracker region missing in detector model %s\", e)\n        logger.error(\"   make sure to specify the global constants tracker_region_zmax and tracker_region_rmax \")\n        logger.error(\"   this is needed for the MC-truth link of created sim-hits  !  \")\n        logger.error(\" Or Disable the User Particle Handler with --part.userParticleHandler=''\")\n        exit(1)\n\n      try:\n        user.TrackingVolume_Zmin = DDG4.tracker_region_zmin\n      except AttributeError as e:\n        logger.debug(\"Attribute tracker_region_zmin for asymmetric tracker region missing %s\", e)\n        logger.debug(\"  will use symmetric region defined by tracker_region_zmax\")\n        user.TrackingVolume_Zmin = str(-float(user.TrackingVolume_Zmax))\n\n      logger.info(\" *** definition of tracker region *** \")\n      logger.info(\"    tracker_region_zmin = %s\", user.TrackingVolume_Zmin)\n      logger.info(\"    tracker_region_zmax = %s\", user.TrackingVolume_Zmax)\n      logger.info(\"    tracker_region_rmax = %s\", user.TrackingVolume_Rmax)\n      logger.info(\" ************************************ \")\n\n      part.adopt(user)\n\n    return",
  "class UI(ConfigHelper):\n  \"\"\"Configuration for setting commands to run during different phases.\n\n  In this section, one can configure commands that should be run during the different phases of the Geant4 execution.\n\n  1. Configuration\n  2. Initialization\n  3. Pre Run\n  4. Post Run\n  5. Terminate / Finalization\n\n  For example, one can add\n\n  >>> SIM.ui.commandsConfigure = ['/physics_lists/em/SyncRadiation true']\n\n  Further details should be taken from the Geant4 documentation.\n  \"\"\"\n\n  def __init__(self):\n    super(UI, self).__init__()\n\n    self._commandsConfigure = []\n    self._commandsInitialize = []\n    self._commandsPostRun = []\n    self._commandsPreRun = []\n    self._commandsTerminate = []\n    self._closeProperties()\n\n  @property\n  def commandsConfigure(self):\n    \"\"\"List of UI commands to run during the 'Configure' phase.\"\"\"\n    return self._commandsConfigure\n\n  @commandsConfigure.setter\n  def commandsConfigure(self, val):\n    self._commandsConfigure = self.makeList(val)\n\n  @property\n  def commandsInitialize(self):\n    \"\"\"List of UI commands to run during the 'Initialize' phase.\"\"\"\n    return self._commandsInitialize\n\n  @commandsInitialize.setter\n  def commandsInitialize(self, val):\n    self._commandsInitialize = self.makeList(val)\n\n  @property\n  def commandsPostRun(self):\n    \"\"\"List of UI commands to run during the 'PostRun' phase.\"\"\"\n    return self._commandsPostRun\n\n  @commandsPostRun.setter\n  def commandsPostRun(self, val):\n    self._commandsPostRun = self.makeList(val)\n\n  @property\n  def commandsPreRun(self):\n    \"\"\"List of UI commands to run during the 'PreRun' phase.\"\"\"\n    return self._commandsPreRun\n\n  @commandsPreRun.setter\n  def commandsPreRun(self, val):\n    self._commandsPreRun = self.makeList(val)\n\n  @property\n  def commandsTerminate(self):\n    \"\"\"List of UI commands to run during the 'Terminate' phase.\"\"\"\n    return self._commandsTerminate\n\n  @commandsTerminate.setter\n  def commandsTerminate(self, val):\n    self._commandsTerminate = self.makeList(val)",
  "def __init__(self):\n    super(UI, self).__init__()\n\n    self._commandsConfigure = []\n    self._commandsInitialize = []\n    self._commandsPostRun = []\n    self._commandsPreRun = []\n    self._commandsTerminate = []\n    self._closeProperties()",
  "def commandsConfigure(self):\n    \"\"\"List of UI commands to run during the 'Configure' phase.\"\"\"\n    return self._commandsConfigure",
  "def commandsConfigure(self, val):\n    self._commandsConfigure = self.makeList(val)",
  "def commandsInitialize(self):\n    \"\"\"List of UI commands to run during the 'Initialize' phase.\"\"\"\n    return self._commandsInitialize",
  "def commandsInitialize(self, val):\n    self._commandsInitialize = self.makeList(val)",
  "def commandsPostRun(self):\n    \"\"\"List of UI commands to run during the 'PostRun' phase.\"\"\"\n    return self._commandsPostRun",
  "def commandsPostRun(self, val):\n    self._commandsPostRun = self.makeList(val)",
  "def commandsPreRun(self):\n    \"\"\"List of UI commands to run during the 'PreRun' phase.\"\"\"\n    return self._commandsPreRun",
  "def commandsPreRun(self, val):\n    self._commandsPreRun = self.makeList(val)",
  "def commandsTerminate(self):\n    \"\"\"List of UI commands to run during the 'Terminate' phase.\"\"\"\n    return self._commandsTerminate",
  "def commandsTerminate(self, val):\n    self._commandsTerminate = self.makeList(val)",
  "class InputConfig(ConfigHelper):\n  \"\"\"Configuration for Input Files.\"\"\"\n\n  def __init__(self):\n    super(InputConfig, self).__init__()\n    self._userPlugin = []\n    self._closeProperties()\n\n  @property\n  def userInputPlugin(self):\n    \"\"\"Set one or more functions to configure input steps.\n\n    The functions must take a ``DD4hepSimulation`` object as their only argument and return the created generatorAction\n    ``gen`` (for example).\n\n    For example one can add this to the ddsim steering file:\n\n      def exampleUserPlugin(dd4hepSimulation):\n        '''Example code for user created plugin.\n\n        :param DD4hepSimulation dd4hepSimulation: The DD4hepSimulation instance, so all parameters can be accessed\n        :return: GeneratorAction\n        '''\n        from DDG4 import GeneratorAction, Kernel\n        # Geant4InputAction is the type of plugin, Cry1 just an identifier\n        gen = GeneratorAction(Kernel(), 'Geant4InputAction/Cry1' , True)\n        # CRYEventReader is the actual plugin, steeringFile its constructor parameter\n        gen.Input = 'CRYEventReader|' + 'steeringFile'\n        # we can give a dictionary of Parameters that has to be interpreted by the setParameters function of the plugin\n        gen.Parameters = {'DataFilePath': '/path/to/files/data'}\n        gen.enableUI()\n        return gen\n\n      SIM.inputConfig.userInputPlugin = exampleUserPlugin\n\n    Repeat function definition and assignment to add multiple input steps\n\n    \"\"\"\n    return self._userPlugin\n\n  @userInputPlugin.setter\n  def userInputPlugin(self, userInputPluginConfig):\n    if not userInputPluginConfig:\n      return\n\n    if isinstance(userInputPluginConfig, list):\n      if not all(callable(func) for func in userInputPluginConfig):\n        raise RuntimeError(\"Some provided userPlugins are not a callable function\")\n      self._userPlugin = userInputPluginConfig\n      return\n\n    if not callable(userInputPluginConfig):\n      raise RuntimeError(\"The provided userPlugin is not a callable function: %s, %s\" % (type(userInputPluginConfig),\n                                                                                         repr(userInputPluginConfig)))\n    self._userPlugin.append(userInputPluginConfig)",
  "def __init__(self):\n    super(InputConfig, self).__init__()\n    self._userPlugin = []\n    self._closeProperties()",
  "def userInputPlugin(self):\n    \"\"\"Set one or more functions to configure input steps.\n\n    The functions must take a ``DD4hepSimulation`` object as their only argument and return the created generatorAction\n    ``gen`` (for example).\n\n    For example one can add this to the ddsim steering file:\n\n      def exampleUserPlugin(dd4hepSimulation):\n        '''Example code for user created plugin.\n\n        :param DD4hepSimulation dd4hepSimulation: The DD4hepSimulation instance, so all parameters can be accessed\n        :return: GeneratorAction\n        '''\n        from DDG4 import GeneratorAction, Kernel\n        # Geant4InputAction is the type of plugin, Cry1 just an identifier\n        gen = GeneratorAction(Kernel(), 'Geant4InputAction/Cry1' , True)\n        # CRYEventReader is the actual plugin, steeringFile its constructor parameter\n        gen.Input = 'CRYEventReader|' + 'steeringFile'\n        # we can give a dictionary of Parameters that has to be interpreted by the setParameters function of the plugin\n        gen.Parameters = {'DataFilePath': '/path/to/files/data'}\n        gen.enableUI()\n        return gen\n\n      SIM.inputConfig.userInputPlugin = exampleUserPlugin\n\n    Repeat function definition and assignment to add multiple input steps\n\n    \"\"\"\n    return self._userPlugin",
  "def userInputPlugin(self, userInputPluginConfig):\n    if not userInputPluginConfig:\n      return\n\n    if isinstance(userInputPluginConfig, list):\n      if not all(callable(func) for func in userInputPluginConfig):\n        raise RuntimeError(\"Some provided userPlugins are not a callable function\")\n      self._userPlugin = userInputPluginConfig\n      return\n\n    if not callable(userInputPluginConfig):\n      raise RuntimeError(\"The provided userPlugin is not a callable function: %s, %s\" % (type(userInputPluginConfig),\n                                                                                         repr(userInputPluginConfig)))\n    self._userPlugin.append(userInputPluginConfig)",
  "class HepMC3(Input):\n  \"\"\"Configuration for the hepmc3 InputFiles\"\"\"\n\n  def __init__(self):\n    super(HepMC3, self).__init__()\n    self._parameters[\"Flow1\"] = \"flow1\"\n    self._parameters[\"Flow2\"] = \"flow2\"\n    # this option will evaluate to True if the HEPMC3 plugin was build\n    self._useHepMC3 = (\"@DD4HEP_USE_HEPMC3@\" != \"OFF\")\n    self._closeProperties()\n\n  @property\n  def useHepMC3(self):\n    \"\"\"Set to false if the input should be opened with the hepmc2 ascii reader.\n\n    If ``True`` a  '.hepmc' file will be opened with the HEPMC3 Reader Factory.\n\n    Defaults to true if DD4hep was build with HEPMC3 support.\n    \"\"\"\n    return self._useHepMC3\n\n  @useHepMC3.setter\n  def useHepMC3(self, val):\n    self._useHepMC3 = self.makeBool(val)\n\n  @property\n  def Flow1(self):\n    \"\"\"Set the name of the attribute contraining color flow information index 0.\"\"\"\n    return self._parameters[\"Flow1\"]\n\n  @Flow1.setter\n  def Flow1(self, val):\n    self._parameters[\"Flow1\"] = val\n\n  @property\n  def Flow2(self):\n    \"\"\"Set the name of the attribute contraining color flow information index 1.\"\"\"\n    return self._parameters[\"Flow2\"]\n\n  @Flow2.setter\n  def Flow2(self, val):\n    self._parameters[\"Flow2\"] = val",
  "def __init__(self):\n    super(HepMC3, self).__init__()\n    self._parameters[\"Flow1\"] = \"flow1\"\n    self._parameters[\"Flow2\"] = \"flow2\"\n    # this option will evaluate to True if the HEPMC3 plugin was build\n    self._useHepMC3 = (\"@DD4HEP_USE_HEPMC3@\" != \"OFF\")\n    self._closeProperties()",
  "def useHepMC3(self):\n    \"\"\"Set to false if the input should be opened with the hepmc2 ascii reader.\n\n    If ``True`` a  '.hepmc' file will be opened with the HEPMC3 Reader Factory.\n\n    Defaults to true if DD4hep was build with HEPMC3 support.\n    \"\"\"\n    return self._useHepMC3",
  "def useHepMC3(self, val):\n    self._useHepMC3 = self.makeBool(val)",
  "def Flow1(self):\n    \"\"\"Set the name of the attribute contraining color flow information index 0.\"\"\"\n    return self._parameters[\"Flow1\"]",
  "def Flow1(self, val):\n    self._parameters[\"Flow1\"] = val",
  "def Flow2(self):\n    \"\"\"Set the name of the attribute contraining color flow information index 1.\"\"\"\n    return self._parameters[\"Flow2\"]",
  "def Flow2(self, val):\n    self._parameters[\"Flow2\"] = val",
  "def _get_filename():\n  if _libname:\n    return _libname\n  import platform\n  name = platform.system()\n\n  fname = {\n      'Darwin': \"libGaudiPluginService.dylib\",\n      'Windows': \"libGaudiPluginService.dll\",\n      'Linux': \"libGaudiPluginService.so\",\n      }[name]\n  return fname",
  "class Registry(ctypes.Structure):\n  '''Registry holds the list of factories known by the gaudi PluginService.\n  '''\n  _fields_ = [(\"_registry\", ctypes.c_void_p)]\n\n  @property\n  def factories(self):\n    facts = {}\n    n = _lib.cgaudi_pluginsvc_get_factory_size(self)\n    for i in range(n):\n      f = _lib.cgaudi_pluginsvc_get_factory_at(self, i)\n      facts[f.name] = f\n    return facts\n\n  pass",
  "def registry():\n  '''registry returns the singleton-like instance of the plugin service.'''\n\n  global _instance\n  if _instance:\n    return _instance\n  _instance = _lib.cgaudi_pluginsvc_instance()\n  return _instance",
  "def factories():\n  '''\n  factories returns the list of components factory informations known to the plugin service\n  '''\n  return registry().factories",
  "class Factory(ctypes.Structure):\n  \"\"\"\n  Factory holds informations about a component's factory:\n  - its name\n  - the library hosting that component\n  - the type of component (algorithm, service, tool, ...)\n  - the return type of this factory\n  - the C++ class name of that component\n  - the properties which may decorate that component.\n  \"\"\"\n  _fields_ = [\n      (\"_registry\", Registry),\n      (\"_id\", ctypes.c_char_p),\n      ]\n\n  @property\n  def name(self):\n    return self._id\n\n  @property\n  def library(self):\n    return _lib.cgaudi_factory_get_library(self)\n\n  @property\n  def type(self):  # noqa: A003\n    return _lib.cgaudi_factory_get_type(self)\n\n  @property\n  def classname(self):\n    return _lib.cgaudi_factory_get_classname(self)\n\n  @property\n  def properties(self):\n    props = {}\n    nprops = _lib.cgaudi_factory_get_property_size(self)\n    for i in range(nprops):\n      prop = _lib.cgaudi_factory_get_property_at(self, i)\n      props[prop.key] = prop.value\n    return props\n\n  def load(self):\n    '''load the C++ library hosting this factory\n    '''\n    return ctypes.CDLL(self.library, ctypes.RTLD_GLOBAL)\n\n  def __repr__(self):\n    return \"<Factory id=%s library=%s type=%s class=%s props=%d>\" % (\n        self._id,\n        self.library,\n        self.type,\n        self.classname,\n        len(self.properties),\n        )\n\n  pass",
  "class Property(ctypes.Structure):\n  '''\n  Property is a pair (key, value) optionally decorating a factory.\n  It is used to attach additional informations about a factory.\n  '''\n  _fields_ = [\n      (\"_registry\", Registry),\n      (\"_id\", ctypes.c_char_p),\n      (\"_key\", ctypes.c_char_p),\n      ]\n\n  @property\n  def key(self):\n    return _lib.cgaudi_property_get_key(self)\n\n  @property\n  def value(self):\n    return _lib.cgaudi_property_get_value(self)\n\n  pass",
  "def factories(self):\n    facts = {}\n    n = _lib.cgaudi_pluginsvc_get_factory_size(self)\n    for i in range(n):\n      f = _lib.cgaudi_pluginsvc_get_factory_at(self, i)\n      facts[f.name] = f\n    return facts",
  "def name(self):\n    return self._id",
  "def library(self):\n    return _lib.cgaudi_factory_get_library(self)",
  "def type(self):  # noqa: A003\n    return _lib.cgaudi_factory_get_type(self)",
  "def classname(self):\n    return _lib.cgaudi_factory_get_classname(self)",
  "def properties(self):\n    props = {}\n    nprops = _lib.cgaudi_factory_get_property_size(self)\n    for i in range(nprops):\n      prop = _lib.cgaudi_factory_get_property_at(self, i)\n      props[prop.key] = prop.value\n    return props",
  "def load(self):\n    '''load the C++ library hosting this factory\n    '''\n    return ctypes.CDLL(self.library, ctypes.RTLD_GLOBAL)",
  "def __repr__(self):\n    return \"<Factory id=%s library=%s type=%s class=%s props=%d>\" % (\n        self._id,\n        self.library,\n        self.type,\n        self.classname,\n        len(self.properties),\n        )",
  "def key(self):\n    return _lib.cgaudi_property_get_key(self)",
  "def value(self):\n    return _lib.cgaudi_property_get_value(self)",
  "class ComponentDumper:\n  def __init__(self):\n    os.environ['DD4HEP_TRACE'] = 'ON'\n    self.all_components = []\n\n  def scanPath(self):\n    ldp = os.environ['LD_LIBRARY_PATH'].split(':')\n    for p in ldp:\n      if len(p):\n        logger.info('+== Search component directory: ' + p)\n        files = os.listdir(p)\n        for f in files:\n          fname = p + os.sep + f\n          ext = os.path.splitext(fname)[-1].lower()\n          if ext == '.components':\n            self.readComponents(fname)\n          elif ext == '.rootmap':\n            self.dumpDictionaries(fname)\n\n  def readComponents(self, fname):\n    logger.info('+== Search component file:  ' + fname)\n    file = open(fname, \"r\")\n    lines = file.readlines()\n    dirname = os.path.dirname(fname)\n    for line in lines:\n      line = line[:-1]\n      if len(line) > 2 and (line[0:2] == '//' or line[0] == '#'):\n        continue\n      lib, comp = line.split(':')\n      self.all_components.append([dirname + os.sep + lib, comp])\n    file.close()\n\n  def searchDuplicates(self, summary_only=False):\n    entries = {}\n    component_count = 0\n    duplicate_count = 0\n    for lib, comp in self.all_components:\n      if comp in entries:\n        dupl = entries[comp]\n        if dupl[1] == 0:\n          if not summary_only:\n            logger.info('+' + ('===' * 40))\n            logger.info('| Component entry:  ' + comp + '  in library:  ' + dupl[0])\n          entries[comp][1] = 1\n        if not summary_only:\n          logger.info('|    --> Duplicate factory declaration in: ' + lib)\n        duplicate_count = duplicate_count + 1\n        continue\n      entries[comp] = [lib, 0]\n      component_count = component_count + 1\n    logger.info('+' + ('===' * 40))\n    logger.info('|      Found %d dd4hep factory entries and %d DUPLICATES in component files.' %\n                (component_count, duplicate_count,))\n    logger.info('+' + ('===' * 40))\n\n  def dumpInventory(self, summary_only=False, dump=True, load=False, interactive=True):\n    entries = {}\n    do_load = load\n    library_count = 0\n    component_count = 0\n    for lib, comp in self.all_components:\n      if lib not in entries:\n        entries[lib] = [comp]\n        library_count = library_count + 1\n        component_count = component_count + 1\n        continue\n      entries[lib].append(comp)\n      component_count = component_count + 1\n    if not summary_only:\n      for lib, comp in entries.items():\n        if dump:\n          logger.info('+==  Component library:  ' + lib)\n        count = 0\n        for c in comp:\n          count = count + 1\n          if dump:\n            logger.info('| %-3d       Component:  %s' % (count, c,))\n        if do_load:\n          ret = 'D'\n          if interactive:\n            try:\n              ret = input(\"<CR> to DUMP the list of components \\n\"\n                          \"<Q>  to QUIT                        \\n\"\n                          \"<D>  to DUMP the list of components \\n\"\n                          \"<S>  to SKIP this particular library\\n\"\n                          \"<L>  to no longer LOAD libraries    \\n\")\n            except Exception:\n              ret = 'D'\n          if not len(ret):\n            ret = 'D'\n          if ret[0].upper() == 'Q':\n            sys.exit(0)\n          elif ret[0].upper() == 'D':\n            gSystem.Load(lib)\n          elif ret[0].upper() == 'L':\n            do_load = False\n    logger.info('+' + ('===' * 40))\n    logger.info('|      Found %d dd4hep factory libraries with %d components.' % (library_count, component_count,))\n    logger.info('+' + ('===' * 40))\n\n  def dumpDictionaries(self, fname):\n    pass",
  "def __init__(self):\n    os.environ['DD4HEP_TRACE'] = 'ON'\n    self.all_components = []",
  "def scanPath(self):\n    ldp = os.environ['LD_LIBRARY_PATH'].split(':')\n    for p in ldp:\n      if len(p):\n        logger.info('+== Search component directory: ' + p)\n        files = os.listdir(p)\n        for f in files:\n          fname = p + os.sep + f\n          ext = os.path.splitext(fname)[-1].lower()\n          if ext == '.components':\n            self.readComponents(fname)\n          elif ext == '.rootmap':\n            self.dumpDictionaries(fname)",
  "def readComponents(self, fname):\n    logger.info('+== Search component file:  ' + fname)\n    file = open(fname, \"r\")\n    lines = file.readlines()\n    dirname = os.path.dirname(fname)\n    for line in lines:\n      line = line[:-1]\n      if len(line) > 2 and (line[0:2] == '//' or line[0] == '#'):\n        continue\n      lib, comp = line.split(':')\n      self.all_components.append([dirname + os.sep + lib, comp])\n    file.close()",
  "def searchDuplicates(self, summary_only=False):\n    entries = {}\n    component_count = 0\n    duplicate_count = 0\n    for lib, comp in self.all_components:\n      if comp in entries:\n        dupl = entries[comp]\n        if dupl[1] == 0:\n          if not summary_only:\n            logger.info('+' + ('===' * 40))\n            logger.info('| Component entry:  ' + comp + '  in library:  ' + dupl[0])\n          entries[comp][1] = 1\n        if not summary_only:\n          logger.info('|    --> Duplicate factory declaration in: ' + lib)\n        duplicate_count = duplicate_count + 1\n        continue\n      entries[comp] = [lib, 0]\n      component_count = component_count + 1\n    logger.info('+' + ('===' * 40))\n    logger.info('|      Found %d dd4hep factory entries and %d DUPLICATES in component files.' %\n                (component_count, duplicate_count,))\n    logger.info('+' + ('===' * 40))",
  "def dumpInventory(self, summary_only=False, dump=True, load=False, interactive=True):\n    entries = {}\n    do_load = load\n    library_count = 0\n    component_count = 0\n    for lib, comp in self.all_components:\n      if lib not in entries:\n        entries[lib] = [comp]\n        library_count = library_count + 1\n        component_count = component_count + 1\n        continue\n      entries[lib].append(comp)\n      component_count = component_count + 1\n    if not summary_only:\n      for lib, comp in entries.items():\n        if dump:\n          logger.info('+==  Component library:  ' + lib)\n        count = 0\n        for c in comp:\n          count = count + 1\n          if dump:\n            logger.info('| %-3d       Component:  %s' % (count, c,))\n        if do_load:\n          ret = 'D'\n          if interactive:\n            try:\n              ret = input(\"<CR> to DUMP the list of components \\n\"\n                          \"<Q>  to QUIT                        \\n\"\n                          \"<D>  to DUMP the list of components \\n\"\n                          \"<S>  to SKIP this particular library\\n\"\n                          \"<L>  to no longer LOAD libraries    \\n\")\n            except Exception:\n              ret = 'D'\n          if not len(ret):\n            ret = 'D'\n          if ret[0].upper() == 'Q':\n            sys.exit(0)\n          elif ret[0].upper() == 'D':\n            gSystem.Load(lib)\n          elif ret[0].upper() == 'L':\n            do_load = False\n    logger.info('+' + ('===' * 40))\n    logger.info('|      Found %d dd4hep factory libraries with %d components.' % (library_count, component_count,))\n    logger.info('+' + ('===' * 40))",
  "def dumpDictionaries(self, fname):\n    pass",
  "def compileAClick(dictionary, g4=True):\n  \"\"\"\n  We compile the DDG4 plugin on the fly if it does not exist using the AClick mechanism.\n\n  \"\"\"\n  from ROOT import gInterpreter, gSystem\n  import os.path\n  dd4hep = os.environ['DD4hepINSTALL']\n  inc = ' -I' + os.environ['ROOTSYS'] + '/include -I' + dd4hep + '/include '\n  lib = ' -L' + dd4hep + '/lib -lDDCore -lDDG4 -lDDSegmentation '\n  if g4:\n    geant4 = os.environ['G4INSTALL']\n    inc = inc + ' -I' + geant4 + '/include/Geant4 -Wno-shadow -g -O0 '\n    lib = lib + ' -L' + geant4 + '/lib  -L' + geant4 + '/lib64 -lG4event -lG4tracking -lG4particles '\n\n  gSystem.AddIncludePath(inc)\n  gSystem.AddLinkedLibs(lib)\n  logger.info('Loading AClick %s', dictionary)\n  package = imp.find_module('DDG4')\n  dic = os.path.dirname(package[1]) + os.sep + dictionary\n  gInterpreter.ProcessLine('.L ' + dic + '+')\n  from ROOT import dd4hep as module\n  return module",
  "def loaddd4hep():\n  \"\"\"\n  Import DD4hep module from ROOT using ROOT reflection\n  \"\"\"\n  import os\n  import sys\n  # Add ROOT to the python path in case it is not yet there....\n  sys.path.append(os.environ['ROOTSYS'] + os.sep + 'lib')\n  from ROOT import gSystem\n\n  import platform\n  if platform.system() == \"Darwin\":\n    gSystem.SetDynamicPath(os.environ['DD4HEP_LIBRARY_PATH'])\n    os.environ['DYLD_LIBRARY_PATH'] = os.pathsep.join([os.environ['DD4HEP_LIBRARY_PATH'],\n                                                       os.environ.get('DYLD_LIBRARY_PATH', '')]).strip(os.pathsep)\n  result = gSystem.Load(\"libDDCore\")\n  if result < 0:\n    raise Exception('dd4hep.py: Failed to load the dd4hep library libDDCore: ' + gSystem.GetErrorStr())\n  from ROOT import dd4hep as module\n  return module",
  "def import_namespace_item(ns, nam):\n  scope = getattr(name_space, ns)\n  attr = getattr(scope, nam)\n  setattr(name_space, nam, attr)\n  return attr",
  "def import_root(nam):\n  setattr(name_space, nam, getattr(ROOT, nam))",
  "class _Levels:\n  def __init__(self):\n    self.VERBOSE = 1\n    self.DEBUG = 2\n    self.INFO = 3\n    self.WARNING = 4\n    self.ERROR = 5\n    self.FATAL = 6\n    self.ALWAYS = 7",
  "def unicode_2_string(value):\n  \"\"\"Turn any unicode literal into str, needed when passing to c++.\n\n  Recursively transverses dicts, lists, sets, tuples\n\n  :return: always a str\n  \"\"\"\n  import ddsix as six\n  if isinstance(value, (bool, float, six.integer_types)):\n    value = value\n  elif isinstance(value, six.string_types):\n    value = str(value)\n  elif isinstance(value, (list, set, tuple)):\n    value = [unicode_2_string(x) for x in value]\n  elif isinstance(value, dict):\n    tempDict = {}\n    for key, val in value.items():\n      key = unicode_2_string(key)\n      val = unicode_2_string(val)\n      tempDict[key] = val\n    value = tempDict\n  return str(value)",
  "def import_detail():\n  import_namespace_item('detail', 'DD4hepUI')",
  "def import_geometry():\n  import_namespace_item('core', 'setPrintLevel')\n  import_namespace_item('core', 'setPrintFormat')\n  import_namespace_item('core', 'printLevel')\n  import_namespace_item('core', 'PrintLevel')\n\n  import_namespace_item('core', 'debug')\n  import_namespace_item('core', 'info')\n  import_namespace_item('core', 'warning')\n  import_namespace_item('core', 'error')\n  import_namespace_item('core', 'fatal')\n  import_namespace_item('core', 'exception')\n\n  import_namespace_item('core', 'Detector')\n  import_namespace_item('core', 'evaluator')\n  import_namespace_item('core', 'g4Evaluator')\n\n  import_namespace_item('core', 'VolumeManager')\n  import_namespace_item('core', 'OverlayedField')\n  import_namespace_item('core', 'Ref_t')\n\n  # // Objects.h\n  import_namespace_item('core', 'Author')\n  import_namespace_item('core', 'Header')\n  import_namespace_item('core', 'Constant')\n  import_namespace_item('core', 'Atom')\n  import_namespace_item('core', 'Material')\n  import_namespace_item('core', 'VisAttr')\n  import_namespace_item('core', 'Limit')\n  import_namespace_item('core', 'LimitSet')\n  import_namespace_item('core', 'LimitSetObject')\n  import_namespace_item('core', 'Region')\n  import_namespace_item('core', 'RegionObject')\n  import_namespace_item('core', 'HitCollection')\n\n  # // Readout.h\n  import_namespace_item('core', 'Segmentation')\n  import_namespace_item('core', 'SegmentationObject')\n  import_namespace_item('core', 'Readout')\n  import_namespace_item('core', 'ReadoutObject')\n\n  # // Alignments.h\n  import_namespace_item('core', 'Alignment')\n  import_namespace_item('core', 'AlignmentCondition')\n\n  # // Conditions.h\n  import_namespace_item('core', 'Condition')\n  import_namespace_item('core', 'ConditionKey')\n\n  # // DetElement.h\n  import_namespace_item('core', 'World')\n  import_namespace_item('core', 'DetElement')\n  import_namespace_item('core', 'SensitiveDetector')\n\n  # // Volume.h\n  import_namespace_item('core', 'Volume')\n  import_namespace_item('core', 'PlacedVolume')\n\n  # // Shapes.h\n  import_namespace_item('core', 'Solid')\n  import_namespace_item('core', 'Box')\n  import_namespace_item('core', 'HalfSpace')\n  import_namespace_item('core', 'Polycone')\n  import_namespace_item('core', 'ConeSegment')\n  import_namespace_item('core', 'Tube')\n  import_namespace_item('core', 'CutTube')\n  import_namespace_item('core', 'TruncatedTube')\n  import_namespace_item('core', 'EllipticalTube')\n  import_namespace_item('core', 'Cone')\n  import_namespace_item('core', 'Trap')\n  import_namespace_item('core', 'PseudoTrap')\n  import_namespace_item('core', 'Trapezoid')\n  import_namespace_item('core', 'Torus')\n  import_namespace_item('core', 'Sphere')\n  import_namespace_item('core', 'Paraboloid')\n  import_namespace_item('core', 'Hyperboloid')\n  import_namespace_item('core', 'PolyhedraRegular')\n  import_namespace_item('core', 'Polyhedra')\n  import_namespace_item('core', 'ExtrudedPolygon')\n  import_namespace_item('core', 'EightPointSolid')\n  import_namespace_item('core', 'BooleanSolid')\n  import_namespace_item('core', 'SubtractionSolid')\n  import_namespace_item('core', 'UnionSolid')\n  import_namespace_item('core', 'IntersectionSolid')",
  "def import_tgeo():\n  import_root('TGeoManager')\n  import_root('TGeoNode')\n  import_root('TGeoNodeMatrix')\n\n  import_root('TGeoVolume')\n  import_root('TGeoVolumeMulti')\n  import_root('TGeoVolumeAssembly')\n\n  import_root('TGeoMaterial')\n  import_root('TGeoMedium')\n  import_root('TGeoIsotope')\n  import_root('TGeoElement')\n\n  import_root('TGeoMatrix')\n  import_root('TGeoHMatrix')\n  import_root('TGeoIdentity')\n  import_root('TGeoTranslation')\n  import_root('TGeoRotation')\n  import_root('TGeoScale')\n  import_root('TGeoCombiTrans')\n\n  import_root('TGeoShape')\n  import_root('TGeoBBox')\n  import_root('TGeoArb8')\n  import_root('TGeoTrap')\n  import_root('TGeoGtra')\n  import_root('TGeoCompositeShape')\n  import_root('TGeoCone')\n  import_root('TGeoConeSeg')\n  import_root('TGeoTube')\n  import_root('TGeoTubeSeg')\n  import_root('TGeoCtub')\n  import_root('TGeoEltu')\n  import_root('TGeoHype')\n  import_root('TGeoHalfSpace')\n  import_root('TGeoPara')\n  import_root('TGeoParaboloid')\n  import_root('TGeoPcon')\n  import_root('TGeoPgon')\n  import_root('TGeoScaledShape')\n  import_root('TGeoShapeAssembly')\n  import_root('TGeoSphere')\n  import_root('TGeoTorus')\n  import_root('TGeoTrd1')\n  import_root('TGeoTrd2')\n  import_root('TGeoXtru')",
  "class Logger:\n  \"\"\"\n  Helper class to use the dd4hep printout functions from python\n\n  \\author  M.Frank\n  \\version 1.0\n  \"\"\"\n\n  def __init__(self, name):\n    \"Logger constructor\"\n    self.name = name\n\n  def setPrintLevel(self, level):\n    \"Adjust printout level of dd4hep\"\n    dd4hep.setPrintLevel(level)\n\n  def always(self, msg):\n    \"Call dd4hep printout function with level ALWAYS\"\n    dd4hep.always(self.name, msg)\n\n  def verbose(self, msg):\n    \"Call dd4hep printout function with level VERBOSE\"\n    dd4hep.verbose(self.name, msg)\n\n  def debug(self, msg):\n    \"Call dd4hep printout function with level DEBUG\"\n    dd4hep.debug(self.name, msg)\n\n  def info(self, msg):\n    \"Call dd4hep printout function with level INFO\"\n    dd4hep.info(self.name, msg)\n\n  def warning(self, msg):\n    \"Call dd4hep printout function with level WARNING\"\n    dd4hep.warning(self.name, msg)\n\n  def error(self, msg):\n    \"Call dd4hep printout function with level ERROR\"\n    dd4hep.error(self.name, msg)\n\n  def fatal(self, msg):\n    \"Call dd4hep printout function with level FATAL\"\n    dd4hep.fatal(self.name, msg)\n\n  def exception(self, msg):\n    \"Call dd4hep exception function\"\n    dd4hep.exception(self.name, msg)",
  "class CommandLine:\n  \"\"\"\n  Helper to ease parsing the command line.\n  Any argument given in the command line is accessible\n  from the object. If no value is supplied, the returned\n  value is True. If the argument is not present None is returned.\n\n  \\author  M.Frank\n  \\version 1.0\n  \"\"\"\n  def __init__(self, help=None):  # noqa: A002\n    import sys\n    self.data = {}\n    help_call = help\n    have_help = False\n    for i in range(len(sys.argv)):\n      if sys.argv[i][0] == '-':\n        key = sys.argv[i][1:]\n        val = True\n        if i + 1 < len(sys.argv):\n          v = sys.argv[i + 1]\n          if v[0] != '-':\n            val = v\n        self.data[key] = val\n        if key.upper() == 'HELP' or key.upper() == '?':\n         have_help = True\n    if have_help and help_call:\n      help_call()\n\n  def __getattr__(self, attr):\n    if self.data.get(attr):\n      return self.data.get(attr)\n    return None",
  "def __init__(self):\n    self.VERBOSE = 1\n    self.DEBUG = 2\n    self.INFO = 3\n    self.WARNING = 4\n    self.ERROR = 5\n    self.FATAL = 6\n    self.ALWAYS = 7",
  "def __init__(self, name):\n    \"Logger constructor\"\n    self.name = name",
  "def setPrintLevel(self, level):\n    \"Adjust printout level of dd4hep\"\n    dd4hep.setPrintLevel(level)",
  "def always(self, msg):\n    \"Call dd4hep printout function with level ALWAYS\"\n    dd4hep.always(self.name, msg)",
  "def verbose(self, msg):\n    \"Call dd4hep printout function with level VERBOSE\"\n    dd4hep.verbose(self.name, msg)",
  "def debug(self, msg):\n    \"Call dd4hep printout function with level DEBUG\"\n    dd4hep.debug(self.name, msg)",
  "def info(self, msg):\n    \"Call dd4hep printout function with level INFO\"\n    dd4hep.info(self.name, msg)",
  "def warning(self, msg):\n    \"Call dd4hep printout function with level WARNING\"\n    dd4hep.warning(self.name, msg)",
  "def error(self, msg):\n    \"Call dd4hep printout function with level ERROR\"\n    dd4hep.error(self.name, msg)",
  "def fatal(self, msg):\n    \"Call dd4hep printout function with level FATAL\"\n    dd4hep.fatal(self.name, msg)",
  "def exception(self, msg):\n    \"Call dd4hep exception function\"\n    dd4hep.exception(self.name, msg)",
  "def __init__(self, help=None):  # noqa: A002\n    import sys\n    self.data = {}\n    help_call = help\n    have_help = False\n    for i in range(len(sys.argv)):\n      if sys.argv[i][0] == '-':\n        key = sys.argv[i][1:]\n        val = True\n        if i + 1 < len(sys.argv):\n          v = sys.argv[i + 1]\n          if v[0] != '-':\n            val = v\n        self.data[key] = val\n        if key.upper() == 'HELP' or key.upper() == '?':\n         have_help = True\n    if have_help and help_call:\n      help_call()",
  "def __getattr__(self, attr):\n    if self.data.get(attr):\n      return self.data.get(attr)\n    return None",
  "def import_units(ns=None):\n    if ns is None:\n      ns = name_space\n\n    logger.debug('Importing units into namespace ' + str(ns.__name__))\n    count = 0\n    for nam in dir(dd4hep.dd4hep_units):\n      if nam[0] != '_':\n        count = count + 1\n        setattr(ns, nam, getattr(core.dd4hep_units, nam))\n        # setattr(ns, nam, getattr(core, nam))\n    return count",
  "def import_units(ns=None):\n    return 0",
  "def _add_doc(func, doc):\n    \"\"\"Add documentation to a function.\"\"\"\n    func.__doc__ = doc",
  "def _import_module(name):\n    \"\"\"Import module, returning the module after the last dot.\"\"\"\n    __import__(name)\n    return sys.modules[name]",
  "class _LazyDescr(object):\n\n    def __init__(self, name):\n        self.name = name\n\n    def __get__(self, obj, tp):\n        result = self._resolve()\n        setattr(obj, self.name, result)  # Invokes __set__.\n        try:\n            # This is a bit ugly, but it avoids running this again by\n            # removing this descriptor.\n            delattr(obj.__class__, self.name)\n        except AttributeError:\n            pass\n        return result",
  "class MovedModule(_LazyDescr):\n\n    def __init__(self, name, old, new=None):\n        super(MovedModule, self).__init__(name)\n        if PY3:\n            if new is None:\n                new = name\n            self.mod = new\n        else:\n            self.mod = old\n\n    def _resolve(self):\n        return _import_module(self.mod)\n\n    def __getattr__(self, attr):\n        _module = self._resolve()\n        value = getattr(_module, attr)\n        setattr(self, attr, value)\n        return value",
  "class _LazyModule(types.ModuleType):\n\n    def __init__(self, name):\n        super(_LazyModule, self).__init__(name)\n        self.__doc__ = self.__class__.__doc__\n\n    def __dir__(self):\n        attrs = [\"__doc__\", \"__name__\"]\n        attrs += [attr.name for attr in self._moved_attributes]\n        return attrs\n\n    # Subclasses should override this\n    _moved_attributes = []",
  "class MovedAttribute(_LazyDescr):\n\n    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):\n        super(MovedAttribute, self).__init__(name)\n        if PY3:\n            if new_mod is None:\n                new_mod = name\n            self.mod = new_mod\n            if new_attr is None:\n                if old_attr is None:\n                    new_attr = name\n                else:\n                    new_attr = old_attr\n            self.attr = new_attr\n        else:\n            self.mod = old_mod\n            if old_attr is None:\n                old_attr = name\n            self.attr = old_attr\n\n    def _resolve(self):\n        module = _import_module(self.mod)\n        return getattr(module, self.attr)",
  "class _SixMetaPathImporter(object):\n\n    \"\"\"\n    A meta path importer to import six.moves and its submodules.\n\n    This class implements a PEP302 finder and loader. It should be compatible\n    with Python 2.5 and all existing versions of Python3\n    \"\"\"\n\n    def __init__(self, six_module_name):\n        self.name = six_module_name\n        self.known_modules = {}\n\n    def _add_module(self, mod, *fullnames):\n        for fullname in fullnames:\n            self.known_modules[self.name + \".\" + fullname] = mod\n\n    def _get_module(self, fullname):\n        return self.known_modules[self.name + \".\" + fullname]\n\n    def find_module(self, fullname, path=None):\n        if fullname in self.known_modules:\n            return self\n        return None\n\n    def __get_module(self, fullname):\n        try:\n            return self.known_modules[fullname]\n        except KeyError:\n            raise ImportError(\"This loader does not know module \" + fullname)\n\n    def load_module(self, fullname):\n        try:\n            # in case of a reload\n            return sys.modules[fullname]\n        except KeyError:\n            pass\n        mod = self.__get_module(fullname)\n        if isinstance(mod, MovedModule):\n            mod = mod._resolve()\n        else:\n            mod.__loader__ = self\n        sys.modules[fullname] = mod\n        return mod\n\n    def is_package(self, fullname):\n        \"\"\"\n        Return true, if the named module is a package.\n\n        We need this method to get correct spec objects with\n        Python 3.4 (see PEP451)\n        \"\"\"\n        return hasattr(self.__get_module(fullname), \"__path__\")\n\n    def get_code(self, fullname):\n        \"\"\"Return None\n\n        Required, if is_package is implemented\"\"\"\n        self.__get_module(fullname)  # eventually raises ImportError\n        return None\n    get_source = get_code",
  "class _MovedItems(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects\"\"\"\n    __path__ = []",
  "class Module_six_moves_urllib_parse(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_parse\"\"\"",
  "class Module_six_moves_urllib_error(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_error\"\"\"",
  "class Module_six_moves_urllib_request(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_request\"\"\"",
  "class Module_six_moves_urllib_response(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_response\"\"\"",
  "class Module_six_moves_urllib_robotparser(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_robotparser\"\"\"",
  "class Module_six_moves_urllib(types.ModuleType):\n\n    \"\"\"Create a six.moves.urllib namespace that resembles the Python 3 namespace\"\"\"\n    __path__ = []  # mark as package\n    parse = _importer._get_module(\"moves.urllib_parse\")\n    error = _importer._get_module(\"moves.urllib_error\")\n    request = _importer._get_module(\"moves.urllib_request\")\n    response = _importer._get_module(\"moves.urllib_response\")\n    robotparser = _importer._get_module(\"moves.urllib_robotparser\")\n\n    def __dir__(self):\n        return ['parse', 'error', 'request', 'response', 'robotparser']",
  "def add_move(move):\n    \"\"\"Add an item to six.moves.\"\"\"\n    setattr(_MovedItems, move.name, move)",
  "def remove_move(name):\n    \"\"\"Remove item from six.moves.\"\"\"\n    try:\n        delattr(_MovedItems, name)\n    except AttributeError:\n        try:\n            del moves.__dict__[name]\n        except KeyError:\n            raise AttributeError(\"no such move, %r\" % (name,))",
  "def assertCountEqual(self, *args, **kwargs):\n    return getattr(self, _assertCountEqual)(*args, **kwargs)",
  "def assertRaisesRegex(self, *args, **kwargs):\n    return getattr(self, _assertRaisesRegex)(*args, **kwargs)",
  "def assertRegex(self, *args, **kwargs):\n    return getattr(self, _assertRegex)(*args, **kwargs)",
  "def with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    # This requires a bit of explanation: the basic idea is to make a dummy\n    # metaclass for one level of class instantiation that replaces itself with\n    # the actual metaclass.\n    class metaclass(type):\n\n        def __new__(cls, name, this_bases, d):\n            return meta(name, bases, d)\n\n        @classmethod\n        def __prepare__(cls, name, this_bases):\n            return meta.__prepare__(name, bases)\n    return type.__new__(metaclass, 'temporary_class', (), {})",
  "def add_metaclass(metaclass):\n    \"\"\"Class decorator for creating a class with a metaclass.\"\"\"\n    def wrapper(cls):\n        orig_vars = cls.__dict__.copy()\n        slots = orig_vars.get('__slots__')\n        if slots is not None:\n            if isinstance(slots, str):\n                slots = [slots]\n            for slots_var in slots:\n                orig_vars.pop(slots_var)\n        orig_vars.pop('__dict__', None)\n        orig_vars.pop('__weakref__', None)\n        if hasattr(cls, '__qualname__'):\n            orig_vars['__qualname__'] = cls.__qualname__\n        return metaclass(cls.__name__, cls.__bases__, orig_vars)\n    return wrapper",
  "def ensure_binary(s, encoding='utf-8', errors='strict'):\n    \"\"\"Coerce **s** to six.binary_type.\n\n    For Python 2:\n      - `unicode` -> encoded to `str`\n      - `str` -> `str`\n\n    For Python 3:\n      - `str` -> encoded to `bytes`\n      - `bytes` -> `bytes`\n    \"\"\"\n    if isinstance(s, text_type):\n        return s.encode(encoding, errors)\n    elif isinstance(s, binary_type):\n        return s\n    else:\n        raise TypeError(\"not expecting type '%s'\" % type(s))",
  "def ensure_str(s, encoding='utf-8', errors='strict'):\n    \"\"\"Coerce *s* to `str`.\n\n    For Python 2:\n      - `unicode` -> encoded to `str`\n      - `str` -> `str`\n\n    For Python 3:\n      - `str` -> `str`\n      - `bytes` -> decoded to `str`\n    \"\"\"\n    if not isinstance(s, (text_type, binary_type)):\n        raise TypeError(\"not expecting type '%s'\" % type(s))\n    if PY2 and isinstance(s, text_type):\n        s = s.encode(encoding, errors)\n    elif PY3 and isinstance(s, binary_type):\n        s = s.decode(encoding, errors)\n    return s",
  "def ensure_text(s, encoding='utf-8', errors='strict'):\n    \"\"\"Coerce *s* to six.text_type.\n\n    For Python 2:\n      - `unicode` -> `unicode`\n      - `str` -> `unicode`\n\n    For Python 3:\n      - `str` -> `str`\n      - `bytes` -> decoded to `str`\n    \"\"\"\n    if isinstance(s, binary_type):\n        return s.decode(encoding, errors)\n    elif isinstance(s, text_type):\n        return s\n    else:\n        raise TypeError(\"not expecting type '%s'\" % type(s))",
  "def python_2_unicode_compatible(klass):\n    \"\"\"\n    A decorator that defines __unicode__ and __str__ methods under Python 2.\n    Under Python 3 it does nothing.\n\n    To support Python 2 and 3 with a single code base, define a __str__ method\n    returning text and apply this decorator to the class.\n    \"\"\"\n    if PY2:\n        if '__str__' not in klass.__dict__:\n            raise ValueError(\"@python_2_unicode_compatible cannot be applied \"\n                             \"to %s because it doesn't define __str__().\" %\n                             klass.__name__)\n        klass.__unicode__ = klass.__str__\n        klass.__str__ = lambda self: self.__unicode__().encode('utf-8')\n    return klass",
  "def __init__(self, name):\n        self.name = name",
  "def __get__(self, obj, tp):\n        result = self._resolve()\n        setattr(obj, self.name, result)  # Invokes __set__.\n        try:\n            # This is a bit ugly, but it avoids running this again by\n            # removing this descriptor.\n            delattr(obj.__class__, self.name)\n        except AttributeError:\n            pass\n        return result",
  "def __init__(self, name, old, new=None):\n        super(MovedModule, self).__init__(name)\n        if PY3:\n            if new is None:\n                new = name\n            self.mod = new\n        else:\n            self.mod = old",
  "def _resolve(self):\n        return _import_module(self.mod)",
  "def __getattr__(self, attr):\n        _module = self._resolve()\n        value = getattr(_module, attr)\n        setattr(self, attr, value)\n        return value",
  "def __init__(self, name):\n        super(_LazyModule, self).__init__(name)\n        self.__doc__ = self.__class__.__doc__",
  "def __dir__(self):\n        attrs = [\"__doc__\", \"__name__\"]\n        attrs += [attr.name for attr in self._moved_attributes]\n        return attrs",
  "def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):\n        super(MovedAttribute, self).__init__(name)\n        if PY3:\n            if new_mod is None:\n                new_mod = name\n            self.mod = new_mod\n            if new_attr is None:\n                if old_attr is None:\n                    new_attr = name\n                else:\n                    new_attr = old_attr\n            self.attr = new_attr\n        else:\n            self.mod = old_mod\n            if old_attr is None:\n                old_attr = name\n            self.attr = old_attr",
  "def _resolve(self):\n        module = _import_module(self.mod)\n        return getattr(module, self.attr)",
  "def __init__(self, six_module_name):\n        self.name = six_module_name\n        self.known_modules = {}",
  "def _add_module(self, mod, *fullnames):\n        for fullname in fullnames:\n            self.known_modules[self.name + \".\" + fullname] = mod",
  "def _get_module(self, fullname):\n        return self.known_modules[self.name + \".\" + fullname]",
  "def find_module(self, fullname, path=None):\n        if fullname in self.known_modules:\n            return self\n        return None",
  "def __get_module(self, fullname):\n        try:\n            return self.known_modules[fullname]\n        except KeyError:\n            raise ImportError(\"This loader does not know module \" + fullname)",
  "def load_module(self, fullname):\n        try:\n            # in case of a reload\n            return sys.modules[fullname]\n        except KeyError:\n            pass\n        mod = self.__get_module(fullname)\n        if isinstance(mod, MovedModule):\n            mod = mod._resolve()\n        else:\n            mod.__loader__ = self\n        sys.modules[fullname] = mod\n        return mod",
  "def is_package(self, fullname):\n        \"\"\"\n        Return true, if the named module is a package.\n\n        We need this method to get correct spec objects with\n        Python 3.4 (see PEP451)\n        \"\"\"\n        return hasattr(self.__get_module(fullname), \"__path__\")",
  "def get_code(self, fullname):\n        \"\"\"Return None\n\n        Required, if is_package is implemented\"\"\"\n        self.__get_module(fullname)  # eventually raises ImportError\n        return None",
  "def __dir__(self):\n        return ['parse', 'error', 'request', 'response', 'robotparser']",
  "def get_unbound_function(unbound):\n        return unbound",
  "def create_unbound_method(func, cls):\n        return func",
  "def get_unbound_function(unbound):\n        return unbound.im_func",
  "def create_bound_method(func, obj):\n        return types.MethodType(func, obj, obj.__class__)",
  "def create_unbound_method(func, cls):\n        return types.MethodType(func, None, cls)",
  "class Iterator(object):\n\n        def next(self):\n            return type(self).__next__(self)",
  "def iterkeys(d, **kw):\n        return iter(d.keys(**kw))",
  "def itervalues(d, **kw):\n        return iter(d.values(**kw))",
  "def iteritems(d, **kw):\n        return iter(d.items(**kw))",
  "def iterlists(d, **kw):\n        return iter(d.lists(**kw))",
  "def iterkeys(d, **kw):\n        return d.iterkeys(**kw)",
  "def itervalues(d, **kw):\n        return d.itervalues(**kw)",
  "def iteritems(d, **kw):\n        return d.iteritems(**kw)",
  "def iterlists(d, **kw):\n        return d.iterlists(**kw)",
  "def b(s):\n        return s.encode(\"latin-1\")",
  "def u(s):\n        return s",
  "def b(s):\n        return s",
  "def u(s):\n        return unicode(s.replace(r'\\\\', r'\\\\\\\\'), \"unicode_escape\")",
  "def byte2int(bs):\n        return ord(bs[0])",
  "def indexbytes(buf, i):\n        return ord(buf[i])",
  "def reraise(tp, value, tb=None):\n        try:\n            if value is None:\n                value = tp()\n            if value.__traceback__ is not tb:\n                raise value.with_traceback(tb)\n            raise value\n        finally:\n            value = None\n            tb = None",
  "def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")",
  "def print_(*args, **kwargs):\n        \"\"\"The new-style print function for Python 2.4 and 2.5.\"\"\"\n        fp = kwargs.pop(\"file\", sys.stdout)\n        if fp is None:\n            return\n\n        def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            # If the file has an encoding, encode unicode with it.\n            if (isinstance(fp, file) and\n                    isinstance(data, unicode) and\n                    fp.encoding is not None):\n                errors = getattr(fp, \"errors\", None)\n                if errors is None:\n                    errors = \"strict\"\n                data = data.encode(fp.encoding, errors)\n            fp.write(data)\n        want_unicode = False\n        sep = kwargs.pop(\"sep\", None)\n        if sep is not None:\n            if isinstance(sep, unicode):\n                want_unicode = True\n            elif not isinstance(sep, str):\n                raise TypeError(\"sep must be None or a string\")\n        end = kwargs.pop(\"end\", None)\n        if end is not None:\n            if isinstance(end, unicode):\n                want_unicode = True\n            elif not isinstance(end, str):\n                raise TypeError(\"end must be None or a string\")\n        if kwargs:\n            raise TypeError(\"invalid keyword arguments to print()\")\n        if not want_unicode:\n            for arg in args:\n                if isinstance(arg, unicode):\n                    want_unicode = True\n                    break\n        if want_unicode:\n            newline = unicode(\"\\n\")\n            space = unicode(\" \")\n        else:\n            newline = \"\\n\"\n            space = \" \"\n        if sep is None:\n            sep = space\n        if end is None:\n            end = newline\n        for i, arg in enumerate(args):\n            if i:\n                write(sep)\n            write(arg)\n        write(end)",
  "def print_(*args, **kwargs):\n        fp = kwargs.get(\"file\", sys.stdout)\n        flush = kwargs.pop(\"flush\", False)\n        _print(*args, **kwargs)\n        if flush and fp is not None:\n            fp.flush()",
  "def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,\n              updated=functools.WRAPPER_UPDATES):\n        def wrapper(f):\n            f = functools.wraps(wrapped, assigned, updated)(f)\n            f.__wrapped__ = wrapped\n            return f\n        return wrapper",
  "class metaclass(type):\n\n        def __new__(cls, name, this_bases, d):\n            return meta(name, bases, d)\n\n        @classmethod\n        def __prepare__(cls, name, this_bases):\n            return meta.__prepare__(name, bases)",
  "def wrapper(cls):\n        orig_vars = cls.__dict__.copy()\n        slots = orig_vars.get('__slots__')\n        if slots is not None:\n            if isinstance(slots, str):\n                slots = [slots]\n            for slots_var in slots:\n                orig_vars.pop(slots_var)\n        orig_vars.pop('__dict__', None)\n        orig_vars.pop('__weakref__', None)\n        if hasattr(cls, '__qualname__'):\n            orig_vars['__qualname__'] = cls.__qualname__\n        return metaclass(cls.__name__, cls.__bases__, orig_vars)",
  "class X(object):\n\n            def __len__(self):\n                return 1 << 31",
  "def advance_iterator(it):\n        return it.next()",
  "def callable(obj):\n        return any(\"__call__\" in klass.__dict__ for klass in type(obj).__mro__)",
  "def next(self):\n            return type(self).__next__(self)",
  "def raise_from(value, from_value):\n        raise value",
  "def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            # If the file has an encoding, encode unicode with it.\n            if (isinstance(fp, file) and\n                    isinstance(data, unicode) and\n                    fp.encoding is not None):\n                errors = getattr(fp, \"errors\", None)\n                if errors is None:\n                    errors = \"strict\"\n                data = data.encode(fp.encoding, errors)\n            fp.write(data)",
  "def wrapper(f):\n            f = functools.wraps(wrapped, assigned, updated)(f)\n            f.__wrapped__ = wrapped\n            return f",
  "def __new__(cls, name, this_bases, d):\n            return meta(name, bases, d)",
  "def __prepare__(cls, name, this_bases):\n            return meta.__prepare__(name, bases)",
  "def __len__(self):\n                return 1 << 31",
  "def test_module(moduleName):\n  \"\"\" Try to import a module from DD4hep.\n\n      Modules that are in the ALLOWED_TO_FAIL list are shown as skipped and generate a warning\n\n      Modules that require graphic libraries (GRAPHIC_MODULES) are skipped on container\n  \"\"\"\n\n  try:\n    __import__(moduleName)\n\n    # Test whether it is correctly imported from DD4hep\n\n  except ImportError as e:\n    msg = \"could not import %s: %s\" % (moduleName, repr(e))\n    print(traceback.print_exc())\n\n    if moduleName in ALLOWED_TO_FAIL:\n      warnings.warn(msg)\n      pytest.skip(\"WARN: \" + msg)\n    elif moduleName in GRAPHIC_MODULES:\n      warnings.warn(msg + \"(Possibly due to system graphic libraries not present)\")\n      pytest.skip(\"WARN: \" + msg + \"(Possibly due to system graphic libraries not present)\")\n    else:\n      pytest.fail(\"ERROR: \" + msg)",
  "def test_module_ddg4():\n    test_module(u'DDG4')",
  "def createParsers():\n  \"\"\" make files for all parsers\"\"\"\n\n  listOfTypes = ['int',\n                 'long',\n                 'char',\n                 'bool',\n                 'short',\n                 'float',\n                 'double',\n                 'long long',\n                 'long double',\n                 'unsigned int',\n                 'unsigned long',\n                 'unsigned char',\n                 'unsigned short',\n                 'unsigned long long',\n                 'std::string',\n                 'signed char',\n                 ]\n  listOfContainers = ['std::vector', 'std::list', 'std::set', 'std::deque']\n  listOfMaps = ['int', 'unsigned long', 'std::string', ]\n\n  for typ in listOfTypes:\n    for cont in listOfContainers:\n      createContainerFile(typ, cont)\n    for mtype in listOfMaps:\n      createMapFile(typ, mtype)\n\n    createMappedFile(typ)",
  "def createMappedFile(typ):\n  \"\"\" create file for mapped parsers \"\"\"\n  tName = typ[5:] if typ.startswith(\"std::\") else typ\n  filename = \"ParserStandardList_Mapped_%s.cpp\" % (tName.replace(\" \", \"\"))\n  fileContent = \"\"\"\n#include \"ParsersStandardListCommon.h\"\nnamespace dd4hep{ namespace Parsers{\nIMPLEMENT_MAPPED_PARSERS(pair,%(type)s)\n  }}\n\"\"\" % {\"type\": typ}\n  fileContent = LICENSE + fileContent\n  if os.path.exists(filename):\n    os.remove(filename)\n  with open(filename, \"w\") as parseFile:\n    parseFile.write(fileContent)",
  "def createContainerFile(typ, cont):\n  \"\"\"create file to make container parser\"\"\"\n  tName = typ[5:] if typ.startswith(\"std::\") else typ\n  filename = \"ParserStandardList_%s_%s.cpp\" % (cont[5:], tName.replace(\" \", \"\"))\n  fileContent = \"\"\"\n#include \"ParsersStandardListCommon.h\"\nnamespace dd4hep{ namespace Parsers{\nIMPLEMENT_STL_PARSER(%(cont)s,%(type)s)\n  }}\n\"\"\" % {\"cont\": cont, \"type\": typ}\n  fileContent = LICENSE + fileContent\n  if os.path.exists(filename):\n    os.remove(filename)\n  with open(filename, \"w\") as parseFile:\n    parseFile.write(fileContent)",
  "def createMapFile(typ, mtype):\n  \"\"\" create file to make map parser\"\"\"\n  mName = mtype[5:] if mtype.startswith(\"std::\") else mtype\n  tName = typ[5:] if typ.startswith(\"std::\") else typ\n  filename = \"ParserStandardList_Map%s_%s.cpp\" % (mName.replace(\" \", \"\"), tName.replace(\" \", \"\"))\n  fileContent = \"\"\"\n#include \"ParsersStandardListCommon.h\"\nnamespace dd4hep{ namespace Parsers{\nIMPLEMENT_STL_MAP_PARSER(std::map,%(mtype)s,%(type)s)\n  }}\n\"\"\" % {\"mtype\": mtype, \"type\": typ}\n  fileContent = LICENSE + fileContent\n  if os.path.exists(filename):\n    os.remove(filename)\n  with open(filename, \"w\") as parseFile:\n    parseFile.write(fileContent)"
]