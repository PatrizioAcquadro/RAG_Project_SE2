[
  "def get_map_file_path() -> Path:\n    return Path(__file__).parent / \"test\" / \"pickle_data\" / \"DeathAuraLE.xz\"",
  "class OrderedDict2(OrderedDict):\n\n    def __repr__(self):\n        if not self:\n            return \"{}\"\n        return (\n            \"{\" +\n            \", \".join(f\"{repr(key)}: {repr(value)}\"\n                      for key, value in sorted(self.items(), key=lambda u: u[0].name)) + \"}\"\n        )",
  "class OrderedSet2(set):\n\n    def __repr__(self):\n        if not self:\n            return \"set()\"\n        return \"{\" + \", \".join(repr(item) for item in sorted(self, key=lambda u: u.name)) + \"}\"",
  "def dump_dict_to_file(\n    my_dict: OrderedDict2, file_path: Path, dict_name: str, file_header: str = \"\", dict_type_annotation: str = \"\"\n):\n    with file_path.open(\"w\") as f:\n        f.write(file_header)\n        f.write(\"\\n\")\n        f.write(f\"{dict_name}{dict_type_annotation} = \")\n        assert isinstance(my_dict, OrderedDict2)\n        logger.info(my_dict)\n        f.write(repr(my_dict))\n\n    # Apply formatting\n    subprocess.run([\"poetry\", \"run\", \"yapf\", file_path, \"-i\"])",
  "def generate_init_file(dict_file_paths: List[Path], file_path: Path, file_header: str):\n    base_file_names = sorted(path.stem for path in dict_file_paths)\n\n    with file_path.open(\"w\") as f:\n        f.write(file_header)\n        f.write(\"\\n\")\n\n        all_line = f\"__all__ = {base_file_names}\"\n        logger.info(all_line)\n        f.write(all_line)\n\n    # Apply formatting\n    subprocess.run([\"poetry\", \"run\", \"yapf\", file_path, \"-i\"])",
  "def get_unit_train_build_abilities(data):\n    ability_data = data[\"Ability\"]\n    unit_data = data[\"Unit\"]\n    upgrade_data = data[\"Upgrade\"]\n\n    # From which abilities can a unit be trained\n    train_abilities: Dict[UnitTypeId, Set[AbilityId]] = OrderedDict2()\n    # If the ability requires a placement position\n    ability_requires_placement: Set[AbilityId] = set()\n    # Map ability to unittypeid\n    ability_to_unittypeid_dict: Dict[AbilityId, UnitTypeId] = OrderedDict2()\n\n    # From which abilities can a unit be morphed\n    # unit_morph_abilities: Dict[UnitTypeId, Set[AbilityId]] = {}\n\n    entry: dict\n    for entry in ability_data:\n        \"\"\"\n        \"target\": \"PointOrUnit\"\n        \"\"\"\n        if isinstance(entry.get(\"target\", {}), str):\n            continue\n        ability_id: AbilityId = AbilityId(entry[\"id\"])\n        created_unit_type_id: UnitTypeId\n\n        # Check if it is a unit train ability\n        requires_placement = False\n        train_unit_type_id_value: int = entry.get(\"target\", {}).get(\"Train\", {}).get(\"produces\", 0)\n        train_place_unit_type_id_value: int = entry.get(\"target\", {}).get(\"TrainPlace\", {}).get(\"produces\", 0)\n        morph_unit_type_id_value: int = entry.get(\"target\", {}).get(\"Morph\", {}).get(\"produces\", 0)\n        build_unit_type_id_value: int = entry.get(\"target\", {}).get(\"Build\", {}).get(\"produces\", 0)\n        build_on_unit_unit_type_id_value: int = entry.get(\"target\", {}).get(\"BuildOnUnit\", {}).get(\"produces\", 0)\n\n        if not train_unit_type_id_value and train_place_unit_type_id_value:\n            train_unit_type_id_value = train_place_unit_type_id_value\n            requires_placement = True\n\n        # Collect larva morph abilities, and one way morphs (exclude burrow, hellbat morph, siege tank siege)\n        # Also doesnt include building addons\n        if not train_unit_type_id_value and (\n            \"LARVATRAIN_\" in ability_id.name or ability_id in {\n                AbilityId.MORPHTOBROODLORD_BROODLORD,\n                AbilityId.MORPHZERGLINGTOBANELING_BANELING,\n                AbilityId.MORPHTORAVAGER_RAVAGER,\n                AbilityId.MORPH_LURKER,\n                AbilityId.UPGRADETOLAIR_LAIR,\n                AbilityId.UPGRADETOHIVE_HIVE,\n                AbilityId.UPGRADETOGREATERSPIRE_GREATERSPIRE,\n                AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND,\n                AbilityId.UPGRADETOPLANETARYFORTRESS_PLANETARYFORTRESS,\n                AbilityId.MORPH_OVERLORDTRANSPORT,\n                AbilityId.MORPH_OVERSEER,\n            }\n        ):\n            # If all morph units are used, unit_trained_from.py will be \"wrong\" because it will list that a siege tank can be trained from siegetanksieged and similar:\n            # UnitTypeId.SIEGETANK: {UnitTypeId.SIEGETANKSIEGED, UnitTypeId.FACTORY},\n            # if not train_unit_type_id_value and morph_unit_type_id_value:\n            train_unit_type_id_value = morph_unit_type_id_value\n\n        # Add all build abilities, like construct buildings and train queen (exception)\n        if not train_unit_type_id_value and build_unit_type_id_value:\n            train_unit_type_id_value = build_unit_type_id_value\n            if \"BUILD_\" in entry[\"name\"]:\n                requires_placement = True\n\n        # Add build gas building (refinery, assimilator, extractor)\n        # TODO: target needs to be a unit, not a position, but i dont want to store an extra line just for this - needs to be an exception in bot_ai.py\n        if not train_unit_type_id_value and build_on_unit_unit_type_id_value:\n            train_unit_type_id_value = build_on_unit_unit_type_id_value\n\n        if train_unit_type_id_value:\n            created_unit_type_id = UnitTypeId(train_unit_type_id_value)\n\n            if created_unit_type_id not in train_abilities:\n                train_abilities[created_unit_type_id] = {ability_id}\n            else:\n                train_abilities[created_unit_type_id].add(ability_id)\n            if requires_placement:\n                ability_requires_placement.add(ability_id)\n\n            ability_to_unittypeid_dict[ability_id] = created_unit_type_id\n    \"\"\"\n    unit_train_abilities = {\n        UnitTypeId.GATEWAY: {\n            UnitTypeId.ADEPT: {\n                \"ability\": AbilityId.TRAIN_ADEPT,\n                \"requires_techlab\": False,\n                \"required_building\": UnitTypeId.CYBERNETICSCORE, # Or None\n                \"requires_placement_position\": False, # True for warp gate\n                \"requires_power\": True, # If a pylon nearby is required\n            },\n            UnitTypeId.Zealot: {\n                \"ability\": AbilityId.GATEWAYTRAIN_ZEALOT,\n                ...\n            }\n        }\n    }\n    \"\"\"\n    unit_train_abilities: Dict[UnitTypeId, Dict[str, Union[AbilityId, bool, UnitTypeId]]] = OrderedDict2()\n    for entry in unit_data:\n        unit_abilities = entry.get(\"abilities\", [])\n        unit_type = UnitTypeId(entry[\"id\"])\n        current_unit_train_abilities = OrderedDict2()\n        for ability_info in unit_abilities:\n            ability_id_value: int = ability_info.get(\"ability\", 0)\n            if ability_id_value:\n                ability_id: AbilityId = AbilityId(ability_id_value)\n                # Ability is not a train ability\n                if ability_id not in ability_to_unittypeid_dict:\n                    continue\n\n                requires_techlab: bool = False\n                required_building: Optional[UnitTypeId] = None\n                requires_placement_position: bool = False\n                requires_power: bool = False\n                \"\"\"\n                requirements = [\n                    {\n                        \"addon\": 5\n                    },\n                    {\n                        \"building\": 29\n                    }\n                  ]\n                \"\"\"\n                requirements: List[Dict[str, int]] = ability_info.get(\"requirements\", [])\n                if requirements:\n                    # Assume train abilities only have one tech building requirement; thors requiring armory and techlab is seperatedly counted\n                    assert (\n                        len([req for req in requirements if req.get(\"building\", 0)]) <= 1\n                    ), f\"Error: Building {unit_type} has more than one tech requirements with train ability {ability_id}\"\n                    # UnitTypeId 5 == Techlab\n                    requires_techlab: bool = any(req for req in requirements if req.get(\"addon\", 0) == 5)\n                    requires_tech_builing_id_value: int = next(\n                        (req[\"building\"] for req in requirements if req.get(\"building\", 0)), 0\n                    )\n                    if requires_tech_builing_id_value:\n                        required_building = UnitTypeId(requires_tech_builing_id_value)\n\n                if ability_id in ability_requires_placement:\n                    requires_placement_position = True\n\n                requires_power = entry.get(\"needs_power\", False)\n\n                resulting_unit = ability_to_unittypeid_dict[ability_id]\n\n                ability_dict = {\"ability\": ability_id}\n                # Only add boolean values and tech requirement if they actually exist, to make the resulting dict file smaller\n                if requires_techlab:\n                    ability_dict[\"requires_techlab\"] = requires_techlab\n                if required_building:\n                    ability_dict[\"required_building\"] = required_building\n                if requires_placement_position:\n                    ability_dict[\"requires_placement_position\"] = requires_placement_position\n                if requires_power:\n                    ability_dict[\"requires_power\"] = requires_power\n                current_unit_train_abilities[resulting_unit] = ability_dict\n\n        if current_unit_train_abilities:\n            unit_train_abilities[unit_type] = current_unit_train_abilities\n\n    return unit_train_abilities",
  "def get_upgrade_abilities(data):\n    ability_data = data[\"Ability\"]\n    unit_data = data[\"Unit\"]\n    upgrade_data = data[\"Upgrade\"]\n\n    ability_to_upgrade_dict: Dict[AbilityId, UpgradeId] = OrderedDict2()\n    \"\"\"\n    We want to be able to research an upgrade by doing\n    await self.can_research(UpgradeId, return_idle_structures=True) -> returns list of idle structures that can research it\n    So we need to assign each upgrade id one building type, and its research ability and requirements (e.g. armory for infantry level 2)\n    \"\"\"\n\n    # Collect all upgrades and their corresponding abilities\n    entry: dict\n    for entry in ability_data:\n        if isinstance(entry.get(\"target\", {}), str):\n            continue\n        ability_id: AbilityId = AbilityId(entry[\"id\"])\n        researched_ability_id: UnitTypeId\n\n        upgrade_id_value: int = entry.get(\"target\", {}).get(\"Research\", {}).get(\"upgrade\", 0)\n        if upgrade_id_value:\n            upgrade_id: UpgradeId = UpgradeId(upgrade_id_value)\n\n            ability_to_upgrade_dict[ability_id] = upgrade_id\n    \"\"\"\n    unit_research_abilities = {\n        UnitTypeId.ENGINEERINGBAY: {\n            UpgradeId.TERRANINFANTRYWEAPONSLEVEL1:\n            {\n                \"ability\": AbilityId.ENGINEERINGBAYRESEARCH_TERRANINFANTRYWEAPONSLEVEL1,\n                \"required_building\": None,\n                \"requires_power\": False, # If a pylon nearby is required\n            },\n            UpgradeId.TERRANINFANTRYWEAPONSLEVEL2: {\n                \"ability\": AbilityId.ENGINEERINGBAYRESEARCH_TERRANINFANTRYWEAPONSLEVEL2,\n                \"required_building\": UnitTypeId.ARMORY,\n                \"requires_power\": False, # If a pylon nearby is required\n            },\n        }\n    }\n    \"\"\"\n    unit_research_abilities = OrderedDict2()\n    for entry in unit_data:\n        unit_abilities = entry.get(\"abilities\", [])\n        unit_type = UnitTypeId(entry[\"id\"])\n\n        if unit_type == UnitTypeId.TECHLAB:\n            continue\n\n        current_unit_research_abilities = OrderedDict2()\n        for ability_info in unit_abilities:\n            ability_id_value: int = ability_info.get(\"ability\", 0)\n            if ability_id_value:\n                ability_id: AbilityId = AbilityId(ability_id_value)\n                # Upgrade is not a known upgrade ability\n                if ability_id not in ability_to_upgrade_dict:\n                    continue\n\n                required_building = None\n                required_upgrade = None\n                requirements = ability_info.get(\"requirements\", [])\n                if requirements:\n                    req_building_id_value = next(\n                        (req[\"building\"] for req in requirements if req.get(\"building\", 0)), None\n                    )\n                    if req_building_id_value:\n                        req_building_id = UnitTypeId(req_building_id_value)\n                        required_building = req_building_id\n\n                    req_upgrade_id_value = next((req[\"upgrade\"] for req in requirements if req.get(\"upgrade\", 0)), None)\n                    if req_upgrade_id_value:\n                        req_upgrade_id = UpgradeId(req_upgrade_id_value)\n                        required_upgrade = req_upgrade_id\n\n                requires_power = entry.get(\"needs_power\", False)\n\n                resulting_upgrade = ability_to_upgrade_dict[ability_id]\n\n                research_info = {\"ability\": ability_id}\n                if required_building:\n                    research_info[\"required_building\"] = required_building\n                if required_upgrade:\n                    research_info[\"required_upgrade\"] = required_upgrade\n                if requires_power:\n                    research_info[\"requires_power\"] = requires_power\n                current_unit_research_abilities[resulting_upgrade] = research_info\n\n        if current_unit_research_abilities:\n            unit_research_abilities[unit_type] = current_unit_research_abilities\n\n    return unit_research_abilities",
  "def get_unit_created_from(unit_train_abilities: dict):\n    unit_created_from = OrderedDict2()\n\n    for creator_unit, create_abilities in unit_train_abilities.items():\n        for created_unit, create_info in create_abilities.items():\n            if created_unit not in unit_created_from:\n                unit_created_from[created_unit] = OrderedSet2()\n            unit_created_from[created_unit].add(creator_unit)\n\n    return unit_created_from",
  "def get_upgrade_researched_from(unit_research_abilities: dict):\n    upgrade_researched_from = OrderedDict2()\n\n    for researcher_unit, research_abilities in unit_research_abilities.items():\n        for upgrade, research_info in research_abilities.items():\n            # This if statement is to prevent LAIR and HIVE overriding \"UpgradeId.OVERLORDSPEED\" as well as greater spire overriding upgrade abilities\n            if upgrade not in upgrade_researched_from:\n                upgrade_researched_from[upgrade] = researcher_unit\n\n    return upgrade_researched_from",
  "def get_unit_abilities(data: dict):\n    ability_data = data[\"Ability\"]\n    unit_data = data[\"Unit\"]\n    upgrade_data = data[\"Upgrade\"]\n\n    all_unit_abilities: Dict[UnitTypeId, Set[AbilityId]] = OrderedDict2()\n    entry: dict\n    for entry in unit_data:\n        entry_unit_abilities = entry.get(\"abilities\", [])\n        unit_type = UnitTypeId(entry[\"id\"])\n        current_collected_unit_abilities: Set[AbilityId] = OrderedSet2()\n        for ability_info in entry_unit_abilities:\n            ability_id_value: int = ability_info.get(\"ability\", 0)\n            if ability_id_value:\n                ability_id: AbilityId = AbilityId(ability_id_value)\n                current_collected_unit_abilities.add(ability_id)\n\n        # logger.info(unit_type, current_unit_abilities)\n        if current_collected_unit_abilities:\n            all_unit_abilities[unit_type] = current_collected_unit_abilities\n    return all_unit_abilities",
  "def generate_unit_alias_dict(data: dict):\n    ability_data = data[\"Ability\"]\n    unit_data = data[\"Unit\"]\n    upgrade_data = data[\"Upgrade\"]\n\n    # Load pickled game data files from one of the test files\n    pickled_file_path = get_map_file_path()\n    assert pickled_file_path.is_file(), f\"Could not find pickled data file {pickled_file_path}\"\n    logger.info(f\"Loading pickled game data file {pickled_file_path}\")\n    with lzma.open(pickled_file_path.absolute(), \"rb\") as f:\n        raw_game_data, raw_game_info, raw_observation = pickle.load(f)\n        game_data = GameData(raw_game_data.data)\n\n    all_unit_aliases: Dict[UnitTypeId, UnitTypeId] = OrderedDict2()\n    all_tech_aliases: Dict[UnitTypeId, Set[UnitTypeId]] = OrderedDict2()\n\n    entry: dict\n    for entry in unit_data:\n        unit_type_value = entry[\"id\"]\n        unit_type = UnitTypeId(entry[\"id\"])\n\n        current_unit_tech_aliases: Set[UnitTypeId] = OrderedSet2()\n\n        assert (\n            unit_type_value in game_data.units\n        ), f\"Unit {unit_type} not listed in game_data.units - perhaps pickled file {pickled_file_path} is outdated?\"\n        unit_alias: int = game_data.units[unit_type_value]._proto.unit_alias\n        if unit_alias:\n            # Might be 0 if it has no alias\n            unit_alias_unit_type_id = UnitTypeId(unit_alias)\n            all_unit_aliases[unit_type] = unit_alias_unit_type_id\n\n        tech_aliases: List[int] = game_data.units[unit_type_value]._proto.tech_alias\n\n        for tech_alias in tech_aliases:\n            # Might be 0 if it has no alias\n            unit_alias_unit_type_id = UnitTypeId(tech_alias)\n            current_unit_tech_aliases.add(unit_alias_unit_type_id)\n\n        if current_unit_tech_aliases:\n            all_tech_aliases[unit_type] = current_unit_tech_aliases\n\n    return all_unit_aliases, all_tech_aliases",
  "def generate_redirect_abilities_dict(data: dict):\n    ability_data = data[\"Ability\"]\n    unit_data = data[\"Unit\"]\n    upgrade_data = data[\"Upgrade\"]\n\n    # Load pickled game data files\n    pickled_file_path = get_map_file_path()\n    assert pickled_file_path.is_file(), f\"Could not find pickled data file {pickled_file_path}\"\n    logger.info(f\"Loading pickled game data file {pickled_file_path}\")\n    with lzma.open(pickled_file_path.absolute(), \"rb\") as f:\n        raw_game_data, raw_game_info, raw_observation = pickle.load(f)\n        game_data = GameData(raw_game_data.data)\n\n    all_redirect_abilities: Dict[AbilityId, AbilityId] = OrderedDict2()\n\n    entry: dict\n    for entry in ability_data:\n        ability_id_value: int = entry[\"id\"]\n        try:\n            ability_id: AbilityId = AbilityId(ability_id_value)\n        except Exception as e:\n            logger.info(f\"Error with ability id value {ability_id_value}\")\n            continue\n\n        generic_redirect_ability_value: int = game_data.abilities[ability_id_value]._proto.remaps_to_ability_id\n        if generic_redirect_ability_value:\n            # Might be 0 if it has no redirect ability\n            all_redirect_abilities[ability_id] = AbilityId(generic_redirect_ability_value)\n\n    return all_redirect_abilities",
  "def main():\n    path = Path(__file__).parent\n\n    data_path = path / \"data\" / \"data.json\"\n    with data_path.open() as f:\n        data = json.load(f)\n\n    dicts_path = path / \"sc2\" / \"dicts\"\n    os.makedirs(dicts_path, exist_ok=True)\n\n    # All unit train and build abilities\n    unit_train_abilities = get_unit_train_build_abilities(data=data)\n    unit_creation_dict_path = dicts_path / \"unit_train_build_abilities.py\"\n\n    # All upgrades and which building can research which upgrade\n    unit_research_abilities = get_upgrade_abilities(data=data)\n    unit_research_abilities_dict_path = dicts_path / \"unit_research_abilities.py\"\n\n    # All train abilities (where a unit can be trained from)\n    unit_trained_from = get_unit_created_from(unit_train_abilities=unit_train_abilities)\n    unit_trained_from_dict_path = dicts_path / \"unit_trained_from.py\"\n\n    # All research abilities (where an upgrade can be researched from)\n    upgrade_researched_from = get_upgrade_researched_from(unit_research_abilities=unit_research_abilities)\n    upgrade_researched_from_dict_path = dicts_path / \"upgrade_researched_from.py\"\n\n    # All unit abilities without requirements\n    unit_abilities = get_unit_abilities(data=data)\n    unit_abilities_dict_path = dicts_path / \"unit_abilities.py\"\n\n    # All unit_alias and tech_alias of a unit type\n    unit_unit_alias, unit_tech_alias = generate_unit_alias_dict(data=data)\n    unit_unit_alias_dict_path = dicts_path / \"unit_unit_alias.py\"\n    unit_tech_alias_dict_path = dicts_path / \"unit_tech_alias.py\"\n\n    # All redirect (generic) abilities of abilities\n    all_redirect_abilities = generate_redirect_abilities_dict(data=data)\n    all_redirect_abilities_path = dicts_path / \"generic_redirect_abilities.py\"\n\n    file_name = Path(__file__).name\n    file_header = f\"\"\"\n# THIS FILE WAS AUTOMATICALLY GENERATED BY \"{file_name}\" DO NOT CHANGE MANUALLY!\n# ANY CHANGE WILL BE OVERWRITTEN\n\nfrom ..ids.unit_typeid import UnitTypeId\nfrom ..ids.ability_id import AbilityId\nfrom ..ids.upgrade_id import UpgradeId\n# from ..ids.buff_id import BuffId\n# from ..ids.effect_id import EffectId\n\nfrom typing import Dict, Set, Union\n    \"\"\"\n\n    dict_file_paths = [\n        unit_creation_dict_path,\n        unit_research_abilities_dict_path,\n        unit_trained_from_dict_path,\n        upgrade_researched_from_dict_path,\n        unit_abilities_dict_path,\n        unit_unit_alias_dict_path,\n        unit_tech_alias_dict_path,\n        all_redirect_abilities_path,\n    ]\n    init_file_path = dicts_path / \"__init__.py\"\n    init_header = f\"\"\"# DO NOT EDIT!\n# This file was automatically generated by \"{file_name}\"\n    \n    \"\"\"\n    generate_init_file(dict_file_paths=dict_file_paths, file_path=init_file_path, file_header=init_header)\n\n    dump_dict_to_file(\n        unit_train_abilities,\n        unit_creation_dict_path,\n        dict_name=\"TRAIN_INFO\",\n        file_header=file_header,\n        dict_type_annotation=\": Dict[UnitTypeId, Dict[UnitTypeId, Dict[str, Union[AbilityId, bool, UnitTypeId]]]]\",\n    )\n    dump_dict_to_file(\n        unit_research_abilities,\n        unit_research_abilities_dict_path,\n        dict_name=\"RESEARCH_INFO\",\n        file_header=file_header,\n        dict_type_annotation=\n        \": Dict[UnitTypeId, Dict[UpgradeId, Dict[str, Union[AbilityId, bool, UnitTypeId, UpgradeId]]]]\",\n    )\n    dump_dict_to_file(\n        unit_trained_from,\n        unit_trained_from_dict_path,\n        dict_name=\"UNIT_TRAINED_FROM\",\n        file_header=file_header,\n        dict_type_annotation=\": Dict[UnitTypeId, Set[UnitTypeId]]\",\n    )\n    dump_dict_to_file(\n        upgrade_researched_from,\n        upgrade_researched_from_dict_path,\n        dict_name=\"UPGRADE_RESEARCHED_FROM\",\n        file_header=file_header,\n        dict_type_annotation=\": Dict[UpgradeId, UnitTypeId]\",\n    )\n    dump_dict_to_file(\n        unit_abilities,\n        unit_abilities_dict_path,\n        dict_name=\"UNIT_ABILITIES\",\n        file_header=file_header,\n        dict_type_annotation=\": Dict[UnitTypeId, Set[AbilityId]]\",\n    )\n    dump_dict_to_file(\n        unit_unit_alias,\n        unit_unit_alias_dict_path,\n        dict_name=\"UNIT_UNIT_ALIAS\",\n        file_header=file_header,\n        dict_type_annotation=\": Dict[UnitTypeId, UnitTypeId]\",\n    )\n    dump_dict_to_file(\n        unit_tech_alias,\n        unit_tech_alias_dict_path,\n        dict_name=\"UNIT_TECH_ALIAS\",\n        file_header=file_header,\n        dict_type_annotation=\": Dict[UnitTypeId, Set[UnitTypeId]]\",\n    )\n    dump_dict_to_file(\n        all_redirect_abilities,\n        all_redirect_abilities_path,\n        dict_name=\"GENERIC_REDIRECT_ABILITIES\",\n        file_header=file_header,\n        dict_type_annotation=\": Dict[AbilityId, AbilityId]\",\n    )",
  "def __repr__(self):\n        if not self:\n            return \"{}\"\n        return (\n            \"{\" +\n            \", \".join(f\"{repr(key)}: {repr(value)}\"\n                      for key, value in sorted(self.items(), key=lambda u: u[0].name)) + \"}\"\n        )",
  "def __repr__(self):\n        if not self:\n            return \"set()\"\n        return \"{\" + \", \".join(repr(item) for item in sorted(self, key=lambda u: u.name)) + \"}\"",
  "class RunLocal:\n\n    def __init__(self):\n        self.server_process = None\n        # Realtime and visualize setting, e.g. {\"Realtime\": False, \"Visualize\": False}\n        self.data = {}\n        # List of games, e.g. [\"basic_bot,T,python,loser_bot,T,python,AcropolisLE\"]\n        self.games_queue = deque()\n        self.runner = GameRunner()\n\n    def start_server(self):\n        if os.name == \"nt\":\n            # Comment out for linux, TODO use import platform\n            self.server_process = Process(target=run_server, args=[False])\n            self.server_process.daemon = True\n            self.server_process.start()\n\n    def stop_server(self):\n        if os.name == \"nt\":\n            self.server_process.terminate()\n\n    def __enter__(self):\n        self.start_server()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.stop_server()\n\n    def add_games_to_queue(self, games: List[str]):\n        for game in games:\n            self.games_queue.append(game)\n\n    def read_ladderbots(self, directory: Path, exclude_names: Set[str]):\n        botdir: Path\n        bots: List[str] = []\n        for botdir in [x for x in directory.iterdir() if x.is_dir()]:\n            for file in [x for x in botdir.iterdir() if x.is_file()]:\n                if str(file).endswith(\"ladderbots.json\"):\n                    with open(str(file)) as f:\n                        contents = json.load(f)\n                        bots_data: dict = contents[\"Bots\"]\n                        for bot_name, bot_data in bots_data.items():\n                            if bot_name.lower() in exclude_names:\n                                continue\n                            bot_race = bot_data[\"Race\"][0]\n                            bot_type = bot_data[\"Type\"]\n                            bots.append(\",\".join([bot_name, bot_race, bot_type]))\n                            break\n        return bots\n\n    def generate_games_list(self, bot1_list: List[str], bot2_list: List[str], map_list: List[str]) -> List[str]:\n        \"\"\"\n        Generates games list, every bot from 'bot1_list' will be matched against every bot from 'bot2_list' on every map in 'map_list'.\n\n        Example input:\n            generate_games_list([\"CreepyBot,Z,python\"], [\"basic_bot,T,python\", \"loser_bot,T,python], [\"AcropolisLE\", \"TritonLE\"])\n        \"\"\"\n        games = []\n        for bot1_string in bot1_list:\n            for bot2_string in bot2_list:\n                for map_name in map_list:\n                    games.append(\",\".join([bot1_string, bot2_string, map_name]))\n        return games\n\n    async def run_local_games(self):\n        while self.games_queue:\n            games = [self.games_queue.popleft()]\n            await self.runner.run_local_game(games, self.data)",
  "async def main():\n    # Alternatively you can use start_server() and stop_server()\n    with RunLocal() as run_local:\n        # Not needed, default: realtime=False and visualize=False\n        run_local.data = {\"Realtime\": False, \"Visualize\": False}\n\n        # If you want to let your bot play vs multiple bots, edit the following\n        # path = Path(\"/root\") / \"StarCraftII\" / \"Bots\"\n        # bot1_list = [\"CreepyBot,Z,python\"]\n        # bot2_list = run_local.read_ladderbots(path, exclude_names={\"creepybot\", \"basic_bot\", \"loser_bot\"})\n        # print(f\"Generated bot2_list: {bot2_list}\")\n\n        bot1_list = [\"loser_bot,Z,python\"]\n        bot2_list = [\"basic_bot,Z,python\"]\n        map_list = [\"TritonLE\"]\n        \"\"\"\n            \"python\": [\"run.py\", \"Python\"],\n            \"cppwin32\": [f\"{bot_name}.exe\", \"Wine\"],\n            \"cpplinux\": [f\"{bot_name}\", \"BinaryCpp\"],\n            \"dotnetcore\": [f\"{bot_name}.dll\", \"DotNetCore\"],\n            \"java\": [f\"{bot_name}.jar\", \"Java\"],\n            \"nodejs\": [\"main.jar\", \"NodeJS\"],\n            \"Python\": [\"run.py\", \"Python\"],\n            \"Wine\": [f\"{bot_name}.exe\", \"Wine\"],\n            \"BinaryCpp\": [f\"{bot_name}\", \"BinaryCpp\"],\n            \"DotNetCore\": [f\"{bot_name}.dll\", \"DotNetCore\"],\n            \"Java\": [f\"{bot_name}.jar\", \"Java\"],\n            \"NodeJS\": [\"main.jar\", \"NodeJS\"],\n        \"\"\"\n        # Generates all possible map and bot combinations\n        games = run_local.generate_games_list(bot1_list, bot2_list, map_list)\n\n        # If you only want to play a specific game:\n        # games = [\"basic_bot,T,python,loser_bot,T,python,AcropolisLE\"]\n\n        # Add games to queue\n        run_local.add_games_to_queue(games)\n\n        await run_local.run_local_games()",
  "def __init__(self):\n        self.server_process = None\n        # Realtime and visualize setting, e.g. {\"Realtime\": False, \"Visualize\": False}\n        self.data = {}\n        # List of games, e.g. [\"basic_bot,T,python,loser_bot,T,python,AcropolisLE\"]\n        self.games_queue = deque()\n        self.runner = GameRunner()",
  "def start_server(self):\n        if os.name == \"nt\":\n            # Comment out for linux, TODO use import platform\n            self.server_process = Process(target=run_server, args=[False])\n            self.server_process.daemon = True\n            self.server_process.start()",
  "def stop_server(self):\n        if os.name == \"nt\":\n            self.server_process.terminate()",
  "def __enter__(self):\n        self.start_server()\n        return self",
  "def __exit__(self, exc_type, exc_val, exc_tb):\n        self.stop_server()",
  "def add_games_to_queue(self, games: List[str]):\n        for game in games:\n            self.games_queue.append(game)",
  "def read_ladderbots(self, directory: Path, exclude_names: Set[str]):\n        botdir: Path\n        bots: List[str] = []\n        for botdir in [x for x in directory.iterdir() if x.is_dir()]:\n            for file in [x for x in botdir.iterdir() if x.is_file()]:\n                if str(file).endswith(\"ladderbots.json\"):\n                    with open(str(file)) as f:\n                        contents = json.load(f)\n                        bots_data: dict = contents[\"Bots\"]\n                        for bot_name, bot_data in bots_data.items():\n                            if bot_name.lower() in exclude_names:\n                                continue\n                            bot_race = bot_data[\"Race\"][0]\n                            bot_type = bot_data[\"Type\"]\n                            bots.append(\",\".join([bot_name, bot_race, bot_type]))\n                            break\n        return bots",
  "def generate_games_list(self, bot1_list: List[str], bot2_list: List[str], map_list: List[str]) -> List[str]:\n        \"\"\"\n        Generates games list, every bot from 'bot1_list' will be matched against every bot from 'bot2_list' on every map in 'map_list'.\n\n        Example input:\n            generate_games_list([\"CreepyBot,Z,python\"], [\"basic_bot,T,python\", \"loser_bot,T,python], [\"AcropolisLE\", \"TritonLE\"])\n        \"\"\"\n        games = []\n        for bot1_string in bot1_list:\n            for bot2_string in bot2_list:\n                for map_name in map_list:\n                    games.append(\",\".join([bot1_string, bot2_string, map_name]))\n        return games",
  "async def run_local_games(self):\n        while self.games_queue:\n            games = [self.games_queue.popleft()]\n            await self.runner.run_local_game(games, self.data)",
  "class CompetitiveBot(BotAI):\n\n    async def on_start(self):\n        self.client.game_step = 2\n\n    async def on_step(self, iteration):\n        if iteration == 0:\n            await self.chat_send(\"(glhf)\")\n\n        # Draw creep pixelmap for debugging\n        # self.draw_creep_pixelmap()\n\n        # If townhall no longer exists: attack move with all units to enemy start location\n        if not self.townhalls:\n            for unit in self.units.exclude_type({UnitTypeId.EGG, UnitTypeId.LARVA}):\n                unit.attack(self.enemy_start_locations[0])\n            return\n\n        hatch: Unit = self.townhalls[0]\n\n        # Pick a target location\n        target: Point2 = self.enemy_structures.not_flying.random_or(self.enemy_start_locations[0]).position\n\n        # Give all zerglings an attack command\n        for zergling in self.units(UnitTypeId.ZERGLING):\n            zergling.attack(target)\n\n        # Inject hatchery if queen has more than 25 energy\n        for queen in self.units(UnitTypeId.QUEEN):\n            if queen.energy >= 25 and not hatch.has_buff(BuffId.QUEENSPAWNLARVATIMER):\n                queen(AbilityId.EFFECT_INJECTLARVA, hatch)\n\n        # Pull workers out of gas if we have almost enough gas mined, this will stop mining when we reached 100 gas mined\n        if self.vespene >= 88 or self.already_pending_upgrade(UpgradeId.ZERGLINGMOVEMENTSPEED) > 0:\n            gas_drones: Units = self.workers.filter(lambda w: w.is_carrying_vespene and len(w.orders) < 2)\n            drone: Unit\n            for drone in gas_drones:\n                minerals: Units = self.mineral_field.closer_than(10, hatch)\n                if minerals:\n                    mineral: Unit = minerals.closest_to(drone)\n                    drone.gather(mineral, queue=True)\n\n        # If we have 100 vespene, this will try to research zergling speed once the spawning pool is at 100% completion\n        if self.already_pending_upgrade(UpgradeId.ZERGLINGMOVEMENTSPEED\n                                        ) == 0 and self.can_afford(UpgradeId.ZERGLINGMOVEMENTSPEED):\n            spawning_pools_ready: Units = self.structures(UnitTypeId.SPAWNINGPOOL).ready\n            if spawning_pools_ready:\n                self.research(UpgradeId.ZERGLINGMOVEMENTSPEED)\n\n        # If we have less than 2 supply left and no overlord is in the queue: train an overlord\n        if self.supply_left < 2 and self.already_pending(UnitTypeId.OVERLORD) < 1:\n            self.train(UnitTypeId.OVERLORD, 1)\n\n        # While we have less than 88 vespene mined: send drones into extractor one frame at a time\n        if (\n            self.gas_buildings.ready and self.vespene < 88\n            and self.already_pending_upgrade(UpgradeId.ZERGLINGMOVEMENTSPEED) == 0\n        ):\n            extractor: Unit = self.gas_buildings.first\n            if extractor.surplus_harvesters < 0:\n                self.workers.random.gather(extractor)\n\n        # If we have lost of minerals, make a macro hatchery\n        if self.minerals > 500:\n            for d in range(4, 15):\n                pos: Point2 = hatch.position.towards(self.game_info.map_center, d)\n                if await self.can_place_single(UnitTypeId.HATCHERY, pos):\n                    self.workers.random.build(UnitTypeId.HATCHERY, pos)\n                    break\n\n        # While we have less than 16 drones, make more drones\n        if self.can_afford(UnitTypeId.DRONE) and self.supply_workers < 16:\n            self.train(UnitTypeId.DRONE)\n\n        # If our spawningpool is completed, start making zerglings\n        if self.structures(UnitTypeId.SPAWNINGPOOL).ready and self.larva and self.can_afford(UnitTypeId.ZERGLING):\n            amount_trained: int = self.train(UnitTypeId.ZERGLING, self.larva.amount)\n\n        # If we have no extractor, build extractor\n        if (\n            self.gas_buildings.amount + self.already_pending(UnitTypeId.EXTRACTOR) == 0\n            and self.can_afford(UnitTypeId.EXTRACTOR) and self.workers\n        ):\n            drone: Unit = self.workers.random\n            target: Unit = self.vespene_geyser.closest_to(drone)\n            drone.build_gas(target)\n\n        # If we have no spawning pool, try to build spawning pool\n        elif self.structures(UnitTypeId.SPAWNINGPOOL).amount + self.already_pending(UnitTypeId.SPAWNINGPOOL) == 0:\n            if self.can_afford(UnitTypeId.SPAWNINGPOOL):\n                for d in range(4, 15):\n                    pos: Point2 = hatch.position.towards(self.game_info.map_center, d)\n                    if await self.can_place_single(UnitTypeId.SPAWNINGPOOL, pos):\n                        drone: Unit = self.workers.closest_to(pos)\n                        drone.build(UnitTypeId.SPAWNINGPOOL, pos)\n\n        # If we have no queen, try to build a queen if we have a spawning pool compelted\n        elif (\n            self.units(UnitTypeId.QUEEN).amount + self.already_pending(UnitTypeId.QUEEN) < self.townhalls.amount\n            and self.structures(UnitTypeId.SPAWNINGPOOL).ready\n        ):\n            if self.can_afford(UnitTypeId.QUEEN):\n                self.train(UnitTypeId.QUEEN)",
  "async def on_start(self):\n        self.client.game_step = 2",
  "async def on_step(self, iteration):\n        if iteration == 0:\n            await self.chat_send(\"(glhf)\")\n\n        # Draw creep pixelmap for debugging\n        # self.draw_creep_pixelmap()\n\n        # If townhall no longer exists: attack move with all units to enemy start location\n        if not self.townhalls:\n            for unit in self.units.exclude_type({UnitTypeId.EGG, UnitTypeId.LARVA}):\n                unit.attack(self.enemy_start_locations[0])\n            return\n\n        hatch: Unit = self.townhalls[0]\n\n        # Pick a target location\n        target: Point2 = self.enemy_structures.not_flying.random_or(self.enemy_start_locations[0]).position\n\n        # Give all zerglings an attack command\n        for zergling in self.units(UnitTypeId.ZERGLING):\n            zergling.attack(target)\n\n        # Inject hatchery if queen has more than 25 energy\n        for queen in self.units(UnitTypeId.QUEEN):\n            if queen.energy >= 25 and not hatch.has_buff(BuffId.QUEENSPAWNLARVATIMER):\n                queen(AbilityId.EFFECT_INJECTLARVA, hatch)\n\n        # Pull workers out of gas if we have almost enough gas mined, this will stop mining when we reached 100 gas mined\n        if self.vespene >= 88 or self.already_pending_upgrade(UpgradeId.ZERGLINGMOVEMENTSPEED) > 0:\n            gas_drones: Units = self.workers.filter(lambda w: w.is_carrying_vespene and len(w.orders) < 2)\n            drone: Unit\n            for drone in gas_drones:\n                minerals: Units = self.mineral_field.closer_than(10, hatch)\n                if minerals:\n                    mineral: Unit = minerals.closest_to(drone)\n                    drone.gather(mineral, queue=True)\n\n        # If we have 100 vespene, this will try to research zergling speed once the spawning pool is at 100% completion\n        if self.already_pending_upgrade(UpgradeId.ZERGLINGMOVEMENTSPEED\n                                        ) == 0 and self.can_afford(UpgradeId.ZERGLINGMOVEMENTSPEED):\n            spawning_pools_ready: Units = self.structures(UnitTypeId.SPAWNINGPOOL).ready\n            if spawning_pools_ready:\n                self.research(UpgradeId.ZERGLINGMOVEMENTSPEED)\n\n        # If we have less than 2 supply left and no overlord is in the queue: train an overlord\n        if self.supply_left < 2 and self.already_pending(UnitTypeId.OVERLORD) < 1:\n            self.train(UnitTypeId.OVERLORD, 1)\n\n        # While we have less than 88 vespene mined: send drones into extractor one frame at a time\n        if (\n            self.gas_buildings.ready and self.vespene < 88\n            and self.already_pending_upgrade(UpgradeId.ZERGLINGMOVEMENTSPEED) == 0\n        ):\n            extractor: Unit = self.gas_buildings.first\n            if extractor.surplus_harvesters < 0:\n                self.workers.random.gather(extractor)\n\n        # If we have lost of minerals, make a macro hatchery\n        if self.minerals > 500:\n            for d in range(4, 15):\n                pos: Point2 = hatch.position.towards(self.game_info.map_center, d)\n                if await self.can_place_single(UnitTypeId.HATCHERY, pos):\n                    self.workers.random.build(UnitTypeId.HATCHERY, pos)\n                    break\n\n        # While we have less than 16 drones, make more drones\n        if self.can_afford(UnitTypeId.DRONE) and self.supply_workers < 16:\n            self.train(UnitTypeId.DRONE)\n\n        # If our spawningpool is completed, start making zerglings\n        if self.structures(UnitTypeId.SPAWNINGPOOL).ready and self.larva and self.can_afford(UnitTypeId.ZERGLING):\n            amount_trained: int = self.train(UnitTypeId.ZERGLING, self.larva.amount)\n\n        # If we have no extractor, build extractor\n        if (\n            self.gas_buildings.amount + self.already_pending(UnitTypeId.EXTRACTOR) == 0\n            and self.can_afford(UnitTypeId.EXTRACTOR) and self.workers\n        ):\n            drone: Unit = self.workers.random\n            target: Unit = self.vespene_geyser.closest_to(drone)\n            drone.build_gas(target)\n\n        # If we have no spawning pool, try to build spawning pool\n        elif self.structures(UnitTypeId.SPAWNINGPOOL).amount + self.already_pending(UnitTypeId.SPAWNINGPOOL) == 0:\n            if self.can_afford(UnitTypeId.SPAWNINGPOOL):\n                for d in range(4, 15):\n                    pos: Point2 = hatch.position.towards(self.game_info.map_center, d)\n                    if await self.can_place_single(UnitTypeId.SPAWNINGPOOL, pos):\n                        drone: Unit = self.workers.closest_to(pos)\n                        drone.build(UnitTypeId.SPAWNINGPOOL, pos)\n\n        # If we have no queen, try to build a queen if we have a spawning pool compelted\n        elif (\n            self.units(UnitTypeId.QUEEN).amount + self.already_pending(UnitTypeId.QUEEN) < self.townhalls.amount\n            and self.structures(UnitTypeId.SPAWNINGPOOL).ready\n        ):\n            if self.can_afford(UnitTypeId.QUEEN):\n                self.train(UnitTypeId.QUEEN)",
  "def run_ladder_game(bot):\n    # Load command line arguments\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--GamePort\", type=int, nargs=\"?\", help=\"Game port\")\n    parser.add_argument(\"--StartPort\", type=int, nargs=\"?\", help=\"Start port\")\n    parser.add_argument(\"--LadderServer\", type=str, nargs=\"?\", help=\"Ladder server\")\n    parser.add_argument(\"--ComputerOpponent\", type=str, nargs=\"?\", help=\"Computer opponent\")\n    parser.add_argument(\"--ComputerRace\", type=str, nargs=\"?\", help=\"Computer race\")\n    parser.add_argument(\"--ComputerDifficulty\", type=str, nargs=\"?\", help=\"Computer difficulty\")\n    parser.add_argument(\"--OpponentId\", type=str, nargs=\"?\", help=\"Opponent ID\")\n    parser.add_argument(\"--RealTime\", action=\"store_true\", help=\"Real time flag\")\n    args, unknown = parser.parse_known_args()\n\n    if args.LadderServer == None:\n        host = \"127.0.0.1\"\n    else:\n        host = args.LadderServer\n\n    host_port = args.GamePort\n    lan_port = args.StartPort\n\n    # Add opponent_id to the bot class (accessed through self.opponent_id)\n    bot.ai.opponent_id = args.OpponentId\n\n    realtime = args.RealTime\n\n    # Versus Computer doesn't work yet\n    computer_opponent = False\n    if args.ComputerOpponent:\n        computer_opponent = True\n        computer_race = args.ComputerRace\n        computer_difficulty = args.ComputerDifficulty\n\n    # Port config\n    if lan_port is None:\n        portconfig = None\n    else:\n        ports = [lan_port + p for p in range(1, 6)]\n\n        portconfig = sc2.portconfig.Portconfig()\n        portconfig.server = [ports[1], ports[2]]\n        portconfig.players = [[ports[3], ports[4]]]\n\n    # Join ladder game\n    g = join_ladder_game(host=host, port=host_port, players=[bot], realtime=realtime, portconfig=portconfig)\n\n    # Run it\n    result = asyncio.get_event_loop().run_until_complete(g)\n    return result, args.OpponentId",
  "async def join_ladder_game(\n    host, port, players, realtime, portconfig, save_replay_as=None, step_time_limit=None, game_time_limit=None\n):\n    ws_url = \"ws://{}:{}/sc2api\".format(host, port)\n    ws_connection = await aiohttp.ClientSession().ws_connect(ws_url, timeout=120)\n    client = Client(ws_connection)\n    try:\n        result = await sc2.main._play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\n        if save_replay_as is not None:\n            await client.save_replay(save_replay_as)\n        # await client.leave()\n        # await client.quit()\n    except ConnectionAlreadyClosed:\n        logger.error(f\"Connection was closed before the game ended\")\n        return None\n    finally:\n        ws_connection.close()\n\n    return result",
  "class CompetitiveBot(sc2.BotAI):\n\n    async def on_start(self):\n        print(\"Game started\")\n        # Do things here before the game starts\n\n    async def on_step(self, iteration):\n        # Populate this function with whatever your bot should do!\n        pass\n\n    def on_end(self, result):\n        print(\"Game ended.\")",
  "async def on_start(self):\n        print(\"Game started\")",
  "async def on_step(self, iteration):\n        # Populate this function with whatever your bot should do!\n        pass",
  "def on_end(self, result):\n        print(\"Game ended.\")",
  "def run_ladder_game(bot):\n    # Load command line arguments\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--GamePort\", type=int, nargs=\"?\", help=\"Game port\")\n    parser.add_argument(\"--StartPort\", type=int, nargs=\"?\", help=\"Start port\")\n    parser.add_argument(\"--LadderServer\", type=str, nargs=\"?\", help=\"Ladder server\")\n    parser.add_argument(\"--ComputerOpponent\", type=str, nargs=\"?\", help=\"Computer opponent\")\n    parser.add_argument(\"--ComputerRace\", type=str, nargs=\"?\", help=\"Computer race\")\n    parser.add_argument(\"--ComputerDifficulty\", type=str, nargs=\"?\", help=\"Computer difficulty\")\n    parser.add_argument(\"--OpponentId\", type=str, nargs=\"?\", help=\"Opponent ID\")\n    parser.add_argument(\"--RealTime\", action=\"store_true\", help=\"Real time flag\")\n    args, unknown = parser.parse_known_args()\n\n    if args.LadderServer == None:\n        host = \"127.0.0.1\"\n    else:\n        host = args.LadderServer\n\n    host_port = args.GamePort\n    lan_port = args.StartPort\n\n    # Add opponent_id to the bot class (accessed through self.opponent_id)\n    bot.ai.opponent_id = args.OpponentId\n\n    realtime = args.RealTime\n\n    # Versus Computer doesn't work yet\n    computer_opponent = False\n    if args.ComputerOpponent:\n        computer_opponent = True\n        computer_race = args.ComputerRace\n        computer_difficulty = args.ComputerDifficulty\n\n    # Port config\n    if lan_port is None:\n        portconfig = None\n    else:\n        ports = [lan_port + p for p in range(1, 6)]\n\n        portconfig = sc2.portconfig.Portconfig()\n        portconfig.server = [ports[1], ports[2]]\n        portconfig.players = [[ports[3], ports[4]]]\n\n    # Join ladder game\n    g = join_ladder_game(host=host, port=host_port, players=[bot], realtime=realtime, portconfig=portconfig)\n\n    # Run it\n    result = asyncio.get_event_loop().run_until_complete(g)\n    return result, args.OpponentId",
  "async def join_ladder_game(\n    host, port, players, realtime, portconfig, save_replay_as=None, step_time_limit=None, game_time_limit=None\n):\n    ws_url = \"ws://{}:{}/sc2api\".format(host, port)\n    ws_connection = await aiohttp.ClientSession().ws_connect(ws_url, timeout=120)\n    client = Client(ws_connection)\n    try:\n        result = await sc2.main._play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\n        if save_replay_as is not None:\n            await client.save_replay(save_replay_as)\n        # await client.leave()\n        # await client.quit()\n    except ConnectionAlreadyClosed:\n        logger.error(f\"Connection was closed before the game ended\")\n        return None\n    finally:\n        ws_connection.close()\n\n    return result",
  "class UnitCommand:\n\n    def __init__(self, ability: AbilityId, unit: Unit, target: Union[Unit, Point2] = None, queue: bool = False):\n        \"\"\"\n        :param ability:\n        :param unit:\n        :param target:\n        :param queue:\n        \"\"\"\n        assert ability in AbilityId, f\"ability {ability} is not in AbilityId\"\n        assert unit.__class__.__name__ == \"Unit\", f\"unit {unit} is of type {type(unit)}\"\n        assert any(\n            [\n                target is None,\n                isinstance(target, Point2),\n                unit.__class__.__name__ == \"Unit\",\n            ]\n        ), f\"target {target} is of type {type(target)}\"\n        assert isinstance(queue, bool), f\"queue flag {queue} is of type {type(queue)}\"\n        self.ability = ability\n        self.unit = unit\n        self.target = target\n        self.queue = queue\n\n    @property\n    def combining_tuple(self):\n        return self.ability, self.target, self.queue, self.ability in COMBINEABLE_ABILITIES\n\n    def __repr__(self):\n        return f\"UnitCommand({self.ability}, {self.unit}, {self.target}, {self.queue})\"",
  "def __init__(self, ability: AbilityId, unit: Unit, target: Union[Unit, Point2] = None, queue: bool = False):\n        \"\"\"\n        :param ability:\n        :param unit:\n        :param target:\n        :param queue:\n        \"\"\"\n        assert ability in AbilityId, f\"ability {ability} is not in AbilityId\"\n        assert unit.__class__.__name__ == \"Unit\", f\"unit {unit} is of type {type(unit)}\"\n        assert any(\n            [\n                target is None,\n                isinstance(target, Point2),\n                unit.__class__.__name__ == \"Unit\",\n            ]\n        ), f\"target {target} is of type {type(target)}\"\n        assert isinstance(queue, bool), f\"queue flag {queue} is of type {type(queue)}\"\n        self.ability = ability\n        self.unit = unit\n        self.target = target\n        self.queue = queue",
  "def combining_tuple(self):\n        return self.ability, self.target, self.queue, self.ability in COMBINEABLE_ABILITIES",
  "def __repr__(self):\n        return f\"UnitCommand({self.ability}, {self.unit}, {self.target}, {self.queue})\"",
  "class Blip:\n\n    def __init__(self, proto):\n        \"\"\"\n        :param proto:\n        \"\"\"\n        self._proto = proto\n\n    @property\n    def is_blip(self) -> bool:\n        \"\"\"Detected by sensor tower.\"\"\"\n        return self._proto.is_blip\n\n    @property\n    def is_snapshot(self) -> bool:\n        return self._proto.display_type == DisplayType.Snapshot.value\n\n    @property\n    def is_visible(self) -> bool:\n        return self._proto.display_type == DisplayType.Visible.value\n\n    @property\n    def alliance(self) -> Alliance:\n        return self._proto.alliance\n\n    @property\n    def is_mine(self) -> bool:\n        return self._proto.alliance == Alliance.Self.value\n\n    @property\n    def is_enemy(self) -> bool:\n        return self._proto.alliance == Alliance.Enemy.value\n\n    @property\n    def position(self) -> Point2:\n        \"\"\"2d position of the blip.\"\"\"\n        return Point2.from_proto(self._proto.pos)\n\n    @property\n    def position3d(self) -> Point3:\n        \"\"\"3d position of the blip.\"\"\"\n        return Point3.from_proto(self._proto.pos)",
  "class Common:\n    ATTRIBUTES = [\n        \"player_id\",\n        \"minerals\",\n        \"vespene\",\n        \"food_cap\",\n        \"food_used\",\n        \"food_army\",\n        \"food_workers\",\n        \"idle_worker_count\",\n        \"army_count\",\n        \"warp_gate_count\",\n        \"larva_count\",\n    ]\n\n    def __init__(self, proto):\n        self._proto = proto\n\n    def __getattr__(self, attr):\n        assert attr in self.ATTRIBUTES, f\"'{attr}' is not a valid attribute\"\n        return int(getattr(self._proto, attr))",
  "class EffectData:\n\n    def __init__(self, proto, fake=False):\n        \"\"\"\n        :param proto:\n        :param fake:\n        \"\"\"\n        self._proto = proto\n        self.fake = fake\n\n    @property\n    def id(self) -> Union[EffectId, str]:\n        if self.fake:\n            # Returns the string from constants.py, e.g. \"KD8CHARGE\"\n            return FakeEffectID[self._proto.unit_type]\n        else:\n            return EffectId(self._proto.effect_id)\n\n    @property\n    def positions(self) -> Set[Point2]:\n        if self.fake:\n            return {Point2.from_proto(self._proto.pos)}\n        else:\n            return {Point2.from_proto(p) for p in self._proto.pos}\n\n    @property\n    def alliance(self) -> Alliance:\n        return self._proto.alliance\n\n    @property\n    def is_mine(self) -> bool:\n        \"\"\" Checks if the effect is caused by me. \"\"\"\n        return self._proto.alliance == IS_MINE\n\n    @property\n    def is_enemy(self) -> bool:\n        \"\"\" Checks if the effect is hostile. \"\"\"\n        return self._proto.alliance == IS_ENEMY\n\n    @property\n    def owner(self) -> int:\n        return self._proto.owner\n\n    @property\n    def radius(self) -> float:\n        if self.fake:\n            return FakeEffectRadii[self._proto.unit_type]\n        else:\n            return self._proto.radius\n\n    def __repr__(self) -> str:\n        return f\"{self.id} with radius {self.radius} at {self.positions}\"",
  "class ChatMessage:\n    player_id: int\n    message: str",
  "class AbilityLookupTemplateClass:\n\n    @property\n    def exact_id(self) -> AbilityId:\n        return AbilityId(self.ability_id)\n\n    @property\n    def generic_id(self) -> AbilityId:\n        \"\"\"\n        See https://github.com/BurnySc2/python-sc2/blob/511c34f6b7ae51bd11e06ba91b6a9624dc04a0c0/sc2/dicts/generic_redirect_abilities.py#L13\n        \"\"\"\n        return GENERIC_REDIRECT_ABILITIES.get(self.exact_id, self.exact_id)",
  "class ActionRawUnitCommand(AbilityLookupTemplateClass):\n    game_loop: int\n    ability_id: int\n    unit_tags: List[int]\n    queue_command: bool\n    target_world_space_pos: Optional[Point2]\n    target_unit_tag: Optional[int] = None",
  "class ActionRawToggleAutocast(AbilityLookupTemplateClass):\n    game_loop: int\n    ability_id: int\n    unit_tags: List[int]",
  "class ActionRawCameraMove:\n    center_world_space: Point2",
  "class ActionError(AbilityLookupTemplateClass):\n    ability_id: int\n    unit_tag: int\n    # See here for the codes of 'result': https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/error.proto#L6\n    result: int",
  "class GameState:\n\n    def __init__(self, response_observation, previous_observation=None):\n        \"\"\"\n        :param response_observation:\n        \"\"\"\n        # Only filled in realtime=True in case the bot skips frames\n        self.previous_observation = previous_observation\n        self.response_observation = response_observation\n\n        # https://github.com/Blizzard/s2client-proto/blob/51662231c0965eba47d5183ed0a6336d5ae6b640/s2clientprotocol/sc2api.proto#L575\n        self.observation = response_observation.observation\n        self.observation_raw = self.observation.raw_data\n        self.player_result = response_observation.player_result\n        self.common: Common = Common(self.observation.player_common)\n\n        # Area covered by Pylons and Warpprisms\n        self.psionic_matrix: PsionicMatrix = PsionicMatrix.from_proto(self.observation_raw.player.power_sources)\n        # 22.4 per second on faster game speed\n        self.game_loop: int = self.observation.game_loop\n\n        # https://github.com/Blizzard/s2client-proto/blob/33f0ecf615aa06ca845ffe4739ef3133f37265a9/s2clientprotocol/score.proto#L31\n        self.score: ScoreDetails = ScoreDetails(self.observation.score)\n        self.abilities = self.observation.abilities  # abilities of selected units\n        self.upgrades: Set[UpgradeId] = {UpgradeId(upgrade) for upgrade in self.observation_raw.player.upgrade_ids}\n\n        # self.visibility[point]: 0=Hidden, 1=Fogged, 2=Visible\n        self.visibility: PixelMap = PixelMap(self.observation_raw.map_state.visibility, mirrored=False)\n        # self.creep[point]: 0=No creep, 1=creep\n        self.creep: PixelMap = PixelMap(self.observation_raw.map_state.creep, in_bits=True, mirrored=False)\n\n        # Effects like ravager bile shot, lurker attack, everything in effect_id.py\n        self.effects: Set[EffectData] = {EffectData(effect) for effect in self.observation_raw.effects}\n        \"\"\" Usage:\n        for effect in self.state.effects:\n            if effect.id == EffectId.RAVAGERCORROSIVEBILECP:\n                positions = effect.positions\n                # dodge the ravager biles\n        \"\"\"\n\n    @property_cache_forever\n    def dead_units(self) -> Set[int]:\n        \"\"\" A set of unit tags that died this frame \"\"\"\n        _dead_units = {dead_unit_tag for dead_unit_tag in self.observation_raw.event.dead_units}\n        if self.previous_observation:\n            return _dead_units | {\n                dead_unit_tag\n                for dead_unit_tag in self.previous_observation.observation.raw_data.event.dead_units\n            }\n        return _dead_units\n\n    @property_cache_forever\n    def chat(self) -> List[ChatMessage]:\n        \"\"\"List of chat messages sent this frame (by either player).\"\"\"\n        previous_frame_chat = self.previous_observation and self.previous_observation.chat or []\n        return [\n            ChatMessage(message.player_id, message.message)\n            for message in chain(previous_frame_chat, self.response_observation.chat)\n        ]\n\n    @property_cache_forever\n    def alerts(self) -> List[int]:\n        \"\"\"\n        Game alerts, see https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/sc2api.proto#L683-L706\n        \"\"\"\n        if self.previous_observation:\n            return list(chain(self.previous_observation.observation.alerts, self.observation.alerts))\n        return self.observation.alerts\n\n    @property_cache_forever\n    def actions(self) -> List[Union[ActionRawUnitCommand, ActionRawToggleAutocast, ActionRawCameraMove]]:\n        \"\"\"\n        List of successful actions since last frame.\n        See https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/sc2api.proto#L630-L637\n\n        Each action is converted into Python dataclasses: ActionRawUnitCommand, ActionRawToggleAutocast, ActionRawCameraMove\n        \"\"\"\n        previous_frame_actions = self.previous_observation and self.previous_observation.actions or []\n        actions = []\n        for action in chain(previous_frame_actions, self.response_observation.actions):\n            action_raw = action.action_raw\n            game_loop = action.game_loop\n            if action_raw.HasField(\"unit_command\"):\n                # Unit commands\n                raw_unit_command = action_raw.unit_command\n                if raw_unit_command.HasField(\"target_world_space_pos\"):\n                    # Actions that have a point as target\n                    actions.append(\n                        ActionRawUnitCommand(\n                            game_loop,\n                            raw_unit_command.ability_id,\n                            raw_unit_command.unit_tags,\n                            raw_unit_command.queue_command,\n                            Point2.from_proto(raw_unit_command.target_world_space_pos),\n                        )\n                    )\n                else:\n                    # Actions that have a unit as target\n                    actions.append(\n                        ActionRawUnitCommand(\n                            game_loop,\n                            raw_unit_command.ability_id,\n                            raw_unit_command.unit_tags,\n                            raw_unit_command.queue_command,\n                            None,\n                            raw_unit_command.target_unit_tag,\n                        )\n                    )\n            elif action_raw.HasField(\"toggle_autocast\"):\n                # Toggle autocast actions\n                raw_toggle_autocast_action = action_raw.toggle_autocast\n                actions.append(\n                    ActionRawToggleAutocast(\n                        game_loop,\n                        raw_toggle_autocast_action.ability_id,\n                        raw_toggle_autocast_action.unit_tags,\n                    )\n                )\n            else:\n                # Camera move actions\n                actions.append(ActionRawCameraMove(Point2.from_proto(action.action_raw.camera_move.center_world_space)))\n        return actions\n\n    @property_cache_forever\n    def actions_unit_commands(self) -> List[ActionRawUnitCommand]:\n        \"\"\"\n        List of successful unit actions since last frame.\n        See https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/raw.proto#L185-L193\n        \"\"\"\n        return list(filter(lambda action: isinstance(action, ActionRawUnitCommand), self.actions))\n\n    @property_cache_forever\n    def actions_toggle_autocast(self) -> List[ActionRawToggleAutocast]:\n        \"\"\"\n        List of successful autocast toggle actions since last frame.\n        See https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/raw.proto#L199-L202\n        \"\"\"\n        return list(filter(lambda action: isinstance(action, ActionRawToggleAutocast), self.actions))\n\n    @property_cache_forever\n    def action_errors(self) -> List[ActionError]:\n        \"\"\"\n        List of erroneous actions since last frame.\n        See https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/sc2api.proto#L648-L652\n        \"\"\"\n        previous_frame_errors = self.previous_observation and self.previous_observation.action_errors or []\n        return [\n            ActionError(error.ability_id, error.unit_tag, error.result)\n            for error in chain(self.response_observation.action_errors, previous_frame_errors)\n        ]",
  "def __init__(self, proto):\n        \"\"\"\n        :param proto:\n        \"\"\"\n        self._proto = proto",
  "def is_blip(self) -> bool:\n        \"\"\"Detected by sensor tower.\"\"\"\n        return self._proto.is_blip",
  "def is_snapshot(self) -> bool:\n        return self._proto.display_type == DisplayType.Snapshot.value",
  "def is_visible(self) -> bool:\n        return self._proto.display_type == DisplayType.Visible.value",
  "def alliance(self) -> Alliance:\n        return self._proto.alliance",
  "def is_mine(self) -> bool:\n        return self._proto.alliance == Alliance.Self.value",
  "def is_enemy(self) -> bool:\n        return self._proto.alliance == Alliance.Enemy.value",
  "def position(self) -> Point2:\n        \"\"\"2d position of the blip.\"\"\"\n        return Point2.from_proto(self._proto.pos)",
  "def position3d(self) -> Point3:\n        \"\"\"3d position of the blip.\"\"\"\n        return Point3.from_proto(self._proto.pos)",
  "def __init__(self, proto):\n        self._proto = proto",
  "def __getattr__(self, attr):\n        assert attr in self.ATTRIBUTES, f\"'{attr}' is not a valid attribute\"\n        return int(getattr(self._proto, attr))",
  "def __init__(self, proto, fake=False):\n        \"\"\"\n        :param proto:\n        :param fake:\n        \"\"\"\n        self._proto = proto\n        self.fake = fake",
  "def id(self) -> Union[EffectId, str]:\n        if self.fake:\n            # Returns the string from constants.py, e.g. \"KD8CHARGE\"\n            return FakeEffectID[self._proto.unit_type]\n        else:\n            return EffectId(self._proto.effect_id)",
  "def positions(self) -> Set[Point2]:\n        if self.fake:\n            return {Point2.from_proto(self._proto.pos)}\n        else:\n            return {Point2.from_proto(p) for p in self._proto.pos}",
  "def alliance(self) -> Alliance:\n        return self._proto.alliance",
  "def is_mine(self) -> bool:\n        \"\"\" Checks if the effect is caused by me. \"\"\"\n        return self._proto.alliance == IS_MINE",
  "def is_enemy(self) -> bool:\n        \"\"\" Checks if the effect is hostile. \"\"\"\n        return self._proto.alliance == IS_ENEMY",
  "def owner(self) -> int:\n        return self._proto.owner",
  "def radius(self) -> float:\n        if self.fake:\n            return FakeEffectRadii[self._proto.unit_type]\n        else:\n            return self._proto.radius",
  "def __repr__(self) -> str:\n        return f\"{self.id} with radius {self.radius} at {self.positions}\"",
  "def exact_id(self) -> AbilityId:\n        return AbilityId(self.ability_id)",
  "def generic_id(self) -> AbilityId:\n        \"\"\"\n        See https://github.com/BurnySc2/python-sc2/blob/511c34f6b7ae51bd11e06ba91b6a9624dc04a0c0/sc2/dicts/generic_redirect_abilities.py#L13\n        \"\"\"\n        return GENERIC_REDIRECT_ABILITIES.get(self.exact_id, self.exact_id)",
  "def __init__(self, response_observation, previous_observation=None):\n        \"\"\"\n        :param response_observation:\n        \"\"\"\n        # Only filled in realtime=True in case the bot skips frames\n        self.previous_observation = previous_observation\n        self.response_observation = response_observation\n\n        # https://github.com/Blizzard/s2client-proto/blob/51662231c0965eba47d5183ed0a6336d5ae6b640/s2clientprotocol/sc2api.proto#L575\n        self.observation = response_observation.observation\n        self.observation_raw = self.observation.raw_data\n        self.player_result = response_observation.player_result\n        self.common: Common = Common(self.observation.player_common)\n\n        # Area covered by Pylons and Warpprisms\n        self.psionic_matrix: PsionicMatrix = PsionicMatrix.from_proto(self.observation_raw.player.power_sources)\n        # 22.4 per second on faster game speed\n        self.game_loop: int = self.observation.game_loop\n\n        # https://github.com/Blizzard/s2client-proto/blob/33f0ecf615aa06ca845ffe4739ef3133f37265a9/s2clientprotocol/score.proto#L31\n        self.score: ScoreDetails = ScoreDetails(self.observation.score)\n        self.abilities = self.observation.abilities  # abilities of selected units\n        self.upgrades: Set[UpgradeId] = {UpgradeId(upgrade) for upgrade in self.observation_raw.player.upgrade_ids}\n\n        # self.visibility[point]: 0=Hidden, 1=Fogged, 2=Visible\n        self.visibility: PixelMap = PixelMap(self.observation_raw.map_state.visibility, mirrored=False)\n        # self.creep[point]: 0=No creep, 1=creep\n        self.creep: PixelMap = PixelMap(self.observation_raw.map_state.creep, in_bits=True, mirrored=False)\n\n        # Effects like ravager bile shot, lurker attack, everything in effect_id.py\n        self.effects: Set[EffectData] = {EffectData(effect) for effect in self.observation_raw.effects}\n        \"\"\" Usage:\n        for effect in self.state.effects:\n            if effect.id == EffectId.RAVAGERCORROSIVEBILECP:\n                positions = effect.positions\n                # dodge the ravager biles\n        \"\"\"",
  "def dead_units(self) -> Set[int]:\n        \"\"\" A set of unit tags that died this frame \"\"\"\n        _dead_units = {dead_unit_tag for dead_unit_tag in self.observation_raw.event.dead_units}\n        if self.previous_observation:\n            return _dead_units | {\n                dead_unit_tag\n                for dead_unit_tag in self.previous_observation.observation.raw_data.event.dead_units\n            }\n        return _dead_units",
  "def chat(self) -> List[ChatMessage]:\n        \"\"\"List of chat messages sent this frame (by either player).\"\"\"\n        previous_frame_chat = self.previous_observation and self.previous_observation.chat or []\n        return [\n            ChatMessage(message.player_id, message.message)\n            for message in chain(previous_frame_chat, self.response_observation.chat)\n        ]",
  "def alerts(self) -> List[int]:\n        \"\"\"\n        Game alerts, see https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/sc2api.proto#L683-L706\n        \"\"\"\n        if self.previous_observation:\n            return list(chain(self.previous_observation.observation.alerts, self.observation.alerts))\n        return self.observation.alerts",
  "def actions(self) -> List[Union[ActionRawUnitCommand, ActionRawToggleAutocast, ActionRawCameraMove]]:\n        \"\"\"\n        List of successful actions since last frame.\n        See https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/sc2api.proto#L630-L637\n\n        Each action is converted into Python dataclasses: ActionRawUnitCommand, ActionRawToggleAutocast, ActionRawCameraMove\n        \"\"\"\n        previous_frame_actions = self.previous_observation and self.previous_observation.actions or []\n        actions = []\n        for action in chain(previous_frame_actions, self.response_observation.actions):\n            action_raw = action.action_raw\n            game_loop = action.game_loop\n            if action_raw.HasField(\"unit_command\"):\n                # Unit commands\n                raw_unit_command = action_raw.unit_command\n                if raw_unit_command.HasField(\"target_world_space_pos\"):\n                    # Actions that have a point as target\n                    actions.append(\n                        ActionRawUnitCommand(\n                            game_loop,\n                            raw_unit_command.ability_id,\n                            raw_unit_command.unit_tags,\n                            raw_unit_command.queue_command,\n                            Point2.from_proto(raw_unit_command.target_world_space_pos),\n                        )\n                    )\n                else:\n                    # Actions that have a unit as target\n                    actions.append(\n                        ActionRawUnitCommand(\n                            game_loop,\n                            raw_unit_command.ability_id,\n                            raw_unit_command.unit_tags,\n                            raw_unit_command.queue_command,\n                            None,\n                            raw_unit_command.target_unit_tag,\n                        )\n                    )\n            elif action_raw.HasField(\"toggle_autocast\"):\n                # Toggle autocast actions\n                raw_toggle_autocast_action = action_raw.toggle_autocast\n                actions.append(\n                    ActionRawToggleAutocast(\n                        game_loop,\n                        raw_toggle_autocast_action.ability_id,\n                        raw_toggle_autocast_action.unit_tags,\n                    )\n                )\n            else:\n                # Camera move actions\n                actions.append(ActionRawCameraMove(Point2.from_proto(action.action_raw.camera_move.center_world_space)))\n        return actions",
  "def actions_unit_commands(self) -> List[ActionRawUnitCommand]:\n        \"\"\"\n        List of successful unit actions since last frame.\n        See https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/raw.proto#L185-L193\n        \"\"\"\n        return list(filter(lambda action: isinstance(action, ActionRawUnitCommand), self.actions))",
  "def actions_toggle_autocast(self) -> List[ActionRawToggleAutocast]:\n        \"\"\"\n        List of successful autocast toggle actions since last frame.\n        See https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/raw.proto#L199-L202\n        \"\"\"\n        return list(filter(lambda action: isinstance(action, ActionRawToggleAutocast), self.actions))",
  "def action_errors(self) -> List[ActionError]:\n        \"\"\"\n        List of erroneous actions since last frame.\n        See https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/sc2api.proto#L648-L652\n        \"\"\"\n        previous_frame_errors = self.previous_observation and self.previous_observation.action_errors or []\n        return [\n            ActionError(error.ability_id, error.unit_tag, error.result)\n            for error in chain(self.response_observation.action_errors, previous_frame_errors)\n        ]",
  "class Ramp:\n\n    def __init__(self, points: Set[Point2], game_info: GameInfo):\n        \"\"\"\n        :param points:\n        :param game_info:\n        \"\"\"\n        self._points: Set[Point2] = points\n        self.__game_info = game_info\n        # Tested by printing actual building locations vs calculated depot positions\n        self.x_offset = 0.5\n        self.y_offset = 0.5\n        # Can this be removed?\n        self.cache = {}\n\n    @property_immutable_cache\n    def _height_map(self):\n        return self.__game_info.terrain_height\n\n    @property_immutable_cache\n    def _placement_grid(self):\n        return self.__game_info.placement_grid\n\n    @property_immutable_cache\n    def size(self) -> int:\n        return len(self._points)\n\n    def height_at(self, p: Point2) -> int:\n        return self._height_map[p]\n\n    @property_mutable_cache\n    def points(self) -> Set[Point2]:\n        return self._points.copy()\n\n    @property_mutable_cache\n    def upper(self) -> Set[Point2]:\n        \"\"\" Returns the upper points of a ramp. \"\"\"\n        current_max = -10000\n        result = set()\n        for p in self._points:\n            height = self.height_at(p)\n            if height > current_max:\n                current_max = height\n                result = {p}\n            elif height == current_max:\n                result.add(p)\n        return result\n\n    @property_mutable_cache\n    def upper2_for_ramp_wall(self) -> Set[Point2]:\n        \"\"\" Returns the 2 upper ramp points of the main base ramp required for the supply depot and barracks placement properties used in this file. \"\"\"\n        if len(self.upper) > 5:\n            # NOTE: this was way too slow on large ramps\n            return set()  # HACK: makes this work for now\n            # FIXME: please do\n\n        return set(sorted(list(self.upper), key=lambda x: x.distance_to_point2(self.bottom_center), reverse=True)[:2])\n\n    @property_immutable_cache\n    def top_center(self) -> Point2:\n        upper = self.upper\n        length = len(upper)\n        pos = Point2((sum(p.x for p in upper) / length, sum(p.y for p in upper) / length))\n        return pos\n\n    @property_mutable_cache\n    def lower(self) -> Set[Point2]:\n        current_min = 10000\n        result = set()\n        for p in self._points:\n            height = self.height_at(p)\n            if height < current_min:\n                current_min = height\n                result = {p}\n            elif height == current_min:\n                result.add(p)\n        return result\n\n    @property_immutable_cache\n    def bottom_center(self) -> Point2:\n        lower = self.lower\n        length = len(lower)\n        pos = Point2((sum(p.x for p in lower) / length, sum(p.y for p in lower) / length))\n        return pos\n\n    @property_immutable_cache\n    def barracks_in_middle(self) -> Optional[Point2]:\n        \"\"\" Barracks position in the middle of the 2 depots \"\"\"\n        if len(self.upper) not in {2, 5}:\n            return None\n        if len(self.upper2_for_ramp_wall) == 2:\n            points = self.upper2_for_ramp_wall\n            p1 = points.pop().offset((self.x_offset, self.y_offset))\n            p2 = points.pop().offset((self.x_offset, self.y_offset))\n            # Offset from top point to barracks center is (2, 1)\n            intersects = p1.circle_intersection(p2, 5**0.5)\n            anyLowerPoint = next(iter(self.lower))\n            return max(intersects, key=lambda p: p.distance_to_point2(anyLowerPoint))\n        raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")\n\n    @property_immutable_cache\n    def depot_in_middle(self) -> Optional[Point2]:\n        \"\"\" Depot in the middle of the 3 depots \"\"\"\n        if len(self.upper) not in {2, 5}:\n            return None\n        if len(self.upper2_for_ramp_wall) == 2:\n            points = self.upper2_for_ramp_wall\n            p1 = points.pop().offset((self.x_offset, self.y_offset))\n            p2 = points.pop().offset((self.x_offset, self.y_offset))\n            # Offset from top point to depot center is (1.5, 0.5)\n            try:\n                intersects = p1.circle_intersection(p2, 2.5**0.5)\n            except AssertionError:\n                # Returns None when no placement was found, this is the case on the map Honorgrounds LE with an exceptionally large main base ramp\n                return None\n            anyLowerPoint = next(iter(self.lower))\n            return max(intersects, key=lambda p: p.distance_to_point2(anyLowerPoint))\n        raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")\n\n    @property_mutable_cache\n    def corner_depots(self) -> Set[Point2]:\n        \"\"\" Finds the 2 depot positions on the outside \"\"\"\n        if not self.upper2_for_ramp_wall:\n            return set()\n        if len(self.upper2_for_ramp_wall) == 2:\n            points = self.upper2_for_ramp_wall\n            p1 = points.pop().offset((self.x_offset, self.y_offset))\n            p2 = points.pop().offset((self.x_offset, self.y_offset))\n            center = p1.towards(p2, p1.distance_to_point2(p2) / 2)\n            depotPosition = self.depot_in_middle\n            if depotPosition is None:\n                return set()\n            # Offset from middle depot to corner depots is (2, 1)\n            intersects = center.circle_intersection(depotPosition, 5**0.5)\n            return intersects\n        raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")\n\n    @property_immutable_cache\n    def barracks_can_fit_addon(self) -> bool:\n        \"\"\" Test if a barracks can fit an addon at natural ramp \"\"\"\n        # https://i.imgur.com/4b2cXHZ.png\n        if len(self.upper2_for_ramp_wall) == 2:\n            return self.barracks_in_middle.x + 1 > max(self.corner_depots, key=lambda depot: depot.x).x\n        raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")\n\n    @property_immutable_cache\n    def barracks_correct_placement(self) -> Optional[Point2]:\n        \"\"\" Corrected placement so that an addon can fit \"\"\"\n        if self.barracks_in_middle is None:\n            return None\n        if len(self.upper2_for_ramp_wall) == 2:\n            if self.barracks_can_fit_addon:\n                return self.barracks_in_middle\n            else:\n                return self.barracks_in_middle.offset((-2, 0))\n        raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")\n\n    @property_immutable_cache\n    def protoss_wall_pylon(self) -> Optional[Point2]:\n        \"\"\"\n        Pylon position that powers the two wall buildings and the warpin position.\n        \"\"\"\n        if len(self.upper) not in {2, 5}:\n            return None\n        if len(self.upper2_for_ramp_wall) != 2:\n            raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")\n        middle = self.depot_in_middle\n        # direction up the ramp\n        direction = self.barracks_in_middle.negative_offset(middle)\n        return middle + 6 * direction\n\n    @property_mutable_cache\n    def protoss_wall_buildings(self) -> List[Point2]:\n        \"\"\"\n        List of two positions for 3x3 buildings that form a wall with a spot for a one unit block.\n        These buildings can be powered by a pylon on the protoss_wall_pylon position.\n        \"\"\"\n        if len(self.upper) not in {2, 5}:\n            return []\n        if len(self.upper2_for_ramp_wall) == 2:\n            middle = self.depot_in_middle\n            # direction up the ramp\n            direction = self.barracks_in_middle.negative_offset(middle)\n            # sort depots based on distance to start to get wallin orientation\n            sorted_depots = sorted(\n                self.corner_depots, key=lambda depot: depot.distance_to(self.__game_info.player_start_location)\n            )\n            wall1 = sorted_depots[1].offset(direction)\n            wall2 = middle + direction + (middle - wall1) / 1.5\n            return [wall1, wall2]\n        raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")\n\n    @property_immutable_cache\n    def protoss_wall_warpin(self) -> Optional[Point2]:\n        \"\"\"\n        Position for a unit to block the wall created by protoss_wall_buildings.\n        Powered by protoss_wall_pylon.\n        \"\"\"\n        if len(self.upper) not in {2, 5}:\n            return None\n        if len(self.upper2_for_ramp_wall) != 2:\n            raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")\n        middle = self.depot_in_middle\n        # direction up the ramp\n        direction = self.barracks_in_middle.negative_offset(middle)\n        # sort depots based on distance to start to get wallin orientation\n        sorted_depots = sorted(self.corner_depots, key=lambda x: x.distance_to(self.__game_info.player_start_location))\n        return sorted_depots[0].negative_offset(direction)",
  "class GameInfo:\n\n    def __init__(self, proto):\n        self._proto = proto\n        self.players: List[Player] = [Player.from_proto(p) for p in self._proto.player_info]\n        self.map_name: str = self._proto.map_name\n        self.local_map_path: str = self._proto.local_map_path\n        self.map_size: Size = Size.from_proto(self._proto.start_raw.map_size)\n\n        # self.pathing_grid[point]: if 0, point is not pathable, if 1, point is pathable\n        self.pathing_grid: PixelMap = PixelMap(self._proto.start_raw.pathing_grid, in_bits=True, mirrored=False)\n        # self.terrain_height[point]: returns the height in range of 0 to 255 at that point\n        self.terrain_height: PixelMap = PixelMap(self._proto.start_raw.terrain_height, mirrored=False)\n        # self.placement_grid[point]: if 0, point is not placeable, if 1, point is pathable\n        self.placement_grid: PixelMap = PixelMap(self._proto.start_raw.placement_grid, in_bits=True, mirrored=False)\n        self.playable_area = Rect.from_proto(self._proto.start_raw.playable_area)\n        self.map_center = self.playable_area.center\n        self.map_ramps: List[Ramp] = None  # Filled later by BotAI._prepare_first_step\n        self.vision_blockers: Set[Point2] = None  # Filled later by BotAI._prepare_first_step\n        self.player_races: Dict[int, Race] = {\n            p.player_id: p.race_actual or p.race_requested\n            for p in self._proto.player_info\n        }\n        self.start_locations: List[Point2] = [Point2.from_proto(sl) for sl in self._proto.start_raw.start_locations]\n        self.player_start_location: Point2 = None  # Filled later by BotAI._prepare_first_step\n\n    def _find_ramps_and_vision_blockers(self) -> Tuple[List[Ramp], Set[Point2]]:\n        \"\"\"Calculate points that are pathable but not placeable.\n        Then divide them into ramp points if not all points around the points are equal height\n        and into vision blockers if they are.\"\"\"\n\n        def equal_height_around(tile):\n            # mask to slice array 1 around tile\n            sliced = self.terrain_height.data_numpy[tile[1] - 1:tile[1] + 2, tile[0] - 1:tile[0] + 2]\n            return len(np.unique(sliced)) == 1\n\n        map_area = self.playable_area\n        # all points in the playable area that are pathable but not placable\n        points = [\n            Point2((a, b)) for (b, a), value in np.ndenumerate(self.pathing_grid.data_numpy)\n            if value == 1 and map_area.x <= a < map_area.x + map_area.width and map_area.y <= b < map_area.y +\n            map_area.height and self.placement_grid[(a, b)] == 0\n        ]\n        # divide points into ramp points and vision blockers\n        rampPoints = [point for point in points if not equal_height_around(point)]\n        visionBlockers = set(point for point in points if equal_height_around(point))\n        ramps = [Ramp(group, self) for group in self._find_groups(rampPoints)]\n        return ramps, visionBlockers\n\n    def _find_groups(self, points: Set[Point2], minimum_points_per_group: int = 8):\n        \"\"\"\n        From a set of points, this function will try to group points together by\n        painting clusters of points in a rectangular map using flood fill algorithm.\n        Returns groups of points as list, like [{p1, p2, p3}, {p4, p5, p6, p7, p8}]\n        \"\"\"\n        # TODO do we actually need colors here? the ramps will never touch anyways.\n        NOT_COLORED_YET = -1\n        map_width = self.pathing_grid.width\n        map_height = self.pathing_grid.height\n        currentColor: int = NOT_COLORED_YET\n        picture: List[List[int]] = [[-2 for _ in range(map_width)] for _ in range(map_height)]\n\n        def paint(pt: Point2) -> None:\n            picture[pt.y][pt.x] = currentColor\n\n        nearby = [(a, b) for a in [-1, 0, 1] for b in [-1, 0, 1] if a != 0 or b != 0]\n\n        remaining: Set[Point2] = set(points)\n        for point in remaining:\n            paint(point)\n        currentColor = 1\n        queue: Deque[Point2] = deque()\n        while remaining:\n            currentGroup: Set[Point2] = set()\n            if not queue:\n                start = remaining.pop()\n                paint(start)\n                queue.append(start)\n                currentGroup.add(start)\n            while queue:\n                base: Point2 = queue.popleft()\n                for offset in nearby:\n                    px, py = base.x + offset[0], base.y + offset[1]\n                    if not (0 <= px < map_width and 0 <= py < map_height):\n                        continue\n                    if picture[py][px] != NOT_COLORED_YET:\n                        continue\n                    point: Point2 = Point2((px, py))\n                    remaining.discard(point)\n                    paint(point)\n                    queue.append(point)\n                    currentGroup.add(point)\n            if len(currentGroup) >= minimum_points_per_group:\n                yield currentGroup",
  "def __init__(self, points: Set[Point2], game_info: GameInfo):\n        \"\"\"\n        :param points:\n        :param game_info:\n        \"\"\"\n        self._points: Set[Point2] = points\n        self.__game_info = game_info\n        # Tested by printing actual building locations vs calculated depot positions\n        self.x_offset = 0.5\n        self.y_offset = 0.5\n        # Can this be removed?\n        self.cache = {}",
  "def _height_map(self):\n        return self.__game_info.terrain_height",
  "def _placement_grid(self):\n        return self.__game_info.placement_grid",
  "def size(self) -> int:\n        return len(self._points)",
  "def height_at(self, p: Point2) -> int:\n        return self._height_map[p]",
  "def points(self) -> Set[Point2]:\n        return self._points.copy()",
  "def upper(self) -> Set[Point2]:\n        \"\"\" Returns the upper points of a ramp. \"\"\"\n        current_max = -10000\n        result = set()\n        for p in self._points:\n            height = self.height_at(p)\n            if height > current_max:\n                current_max = height\n                result = {p}\n            elif height == current_max:\n                result.add(p)\n        return result",
  "def upper2_for_ramp_wall(self) -> Set[Point2]:\n        \"\"\" Returns the 2 upper ramp points of the main base ramp required for the supply depot and barracks placement properties used in this file. \"\"\"\n        if len(self.upper) > 5:\n            # NOTE: this was way too slow on large ramps\n            return set()  # HACK: makes this work for now\n            # FIXME: please do\n\n        return set(sorted(list(self.upper), key=lambda x: x.distance_to_point2(self.bottom_center), reverse=True)[:2])",
  "def top_center(self) -> Point2:\n        upper = self.upper\n        length = len(upper)\n        pos = Point2((sum(p.x for p in upper) / length, sum(p.y for p in upper) / length))\n        return pos",
  "def lower(self) -> Set[Point2]:\n        current_min = 10000\n        result = set()\n        for p in self._points:\n            height = self.height_at(p)\n            if height < current_min:\n                current_min = height\n                result = {p}\n            elif height == current_min:\n                result.add(p)\n        return result",
  "def bottom_center(self) -> Point2:\n        lower = self.lower\n        length = len(lower)\n        pos = Point2((sum(p.x for p in lower) / length, sum(p.y for p in lower) / length))\n        return pos",
  "def barracks_in_middle(self) -> Optional[Point2]:\n        \"\"\" Barracks position in the middle of the 2 depots \"\"\"\n        if len(self.upper) not in {2, 5}:\n            return None\n        if len(self.upper2_for_ramp_wall) == 2:\n            points = self.upper2_for_ramp_wall\n            p1 = points.pop().offset((self.x_offset, self.y_offset))\n            p2 = points.pop().offset((self.x_offset, self.y_offset))\n            # Offset from top point to barracks center is (2, 1)\n            intersects = p1.circle_intersection(p2, 5**0.5)\n            anyLowerPoint = next(iter(self.lower))\n            return max(intersects, key=lambda p: p.distance_to_point2(anyLowerPoint))\n        raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")",
  "def depot_in_middle(self) -> Optional[Point2]:\n        \"\"\" Depot in the middle of the 3 depots \"\"\"\n        if len(self.upper) not in {2, 5}:\n            return None\n        if len(self.upper2_for_ramp_wall) == 2:\n            points = self.upper2_for_ramp_wall\n            p1 = points.pop().offset((self.x_offset, self.y_offset))\n            p2 = points.pop().offset((self.x_offset, self.y_offset))\n            # Offset from top point to depot center is (1.5, 0.5)\n            try:\n                intersects = p1.circle_intersection(p2, 2.5**0.5)\n            except AssertionError:\n                # Returns None when no placement was found, this is the case on the map Honorgrounds LE with an exceptionally large main base ramp\n                return None\n            anyLowerPoint = next(iter(self.lower))\n            return max(intersects, key=lambda p: p.distance_to_point2(anyLowerPoint))\n        raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")",
  "def corner_depots(self) -> Set[Point2]:\n        \"\"\" Finds the 2 depot positions on the outside \"\"\"\n        if not self.upper2_for_ramp_wall:\n            return set()\n        if len(self.upper2_for_ramp_wall) == 2:\n            points = self.upper2_for_ramp_wall\n            p1 = points.pop().offset((self.x_offset, self.y_offset))\n            p2 = points.pop().offset((self.x_offset, self.y_offset))\n            center = p1.towards(p2, p1.distance_to_point2(p2) / 2)\n            depotPosition = self.depot_in_middle\n            if depotPosition is None:\n                return set()\n            # Offset from middle depot to corner depots is (2, 1)\n            intersects = center.circle_intersection(depotPosition, 5**0.5)\n            return intersects\n        raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")",
  "def barracks_can_fit_addon(self) -> bool:\n        \"\"\" Test if a barracks can fit an addon at natural ramp \"\"\"\n        # https://i.imgur.com/4b2cXHZ.png\n        if len(self.upper2_for_ramp_wall) == 2:\n            return self.barracks_in_middle.x + 1 > max(self.corner_depots, key=lambda depot: depot.x).x\n        raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")",
  "def barracks_correct_placement(self) -> Optional[Point2]:\n        \"\"\" Corrected placement so that an addon can fit \"\"\"\n        if self.barracks_in_middle is None:\n            return None\n        if len(self.upper2_for_ramp_wall) == 2:\n            if self.barracks_can_fit_addon:\n                return self.barracks_in_middle\n            else:\n                return self.barracks_in_middle.offset((-2, 0))\n        raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")",
  "def protoss_wall_pylon(self) -> Optional[Point2]:\n        \"\"\"\n        Pylon position that powers the two wall buildings and the warpin position.\n        \"\"\"\n        if len(self.upper) not in {2, 5}:\n            return None\n        if len(self.upper2_for_ramp_wall) != 2:\n            raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")\n        middle = self.depot_in_middle\n        # direction up the ramp\n        direction = self.barracks_in_middle.negative_offset(middle)\n        return middle + 6 * direction",
  "def protoss_wall_buildings(self) -> List[Point2]:\n        \"\"\"\n        List of two positions for 3x3 buildings that form a wall with a spot for a one unit block.\n        These buildings can be powered by a pylon on the protoss_wall_pylon position.\n        \"\"\"\n        if len(self.upper) not in {2, 5}:\n            return []\n        if len(self.upper2_for_ramp_wall) == 2:\n            middle = self.depot_in_middle\n            # direction up the ramp\n            direction = self.barracks_in_middle.negative_offset(middle)\n            # sort depots based on distance to start to get wallin orientation\n            sorted_depots = sorted(\n                self.corner_depots, key=lambda depot: depot.distance_to(self.__game_info.player_start_location)\n            )\n            wall1 = sorted_depots[1].offset(direction)\n            wall2 = middle + direction + (middle - wall1) / 1.5\n            return [wall1, wall2]\n        raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")",
  "def protoss_wall_warpin(self) -> Optional[Point2]:\n        \"\"\"\n        Position for a unit to block the wall created by protoss_wall_buildings.\n        Powered by protoss_wall_pylon.\n        \"\"\"\n        if len(self.upper) not in {2, 5}:\n            return None\n        if len(self.upper2_for_ramp_wall) != 2:\n            raise Exception(\"Not implemented. Trying to access a ramp that has a wrong amount of upper points.\")\n        middle = self.depot_in_middle\n        # direction up the ramp\n        direction = self.barracks_in_middle.negative_offset(middle)\n        # sort depots based on distance to start to get wallin orientation\n        sorted_depots = sorted(self.corner_depots, key=lambda x: x.distance_to(self.__game_info.player_start_location))\n        return sorted_depots[0].negative_offset(direction)",
  "def __init__(self, proto):\n        self._proto = proto\n        self.players: List[Player] = [Player.from_proto(p) for p in self._proto.player_info]\n        self.map_name: str = self._proto.map_name\n        self.local_map_path: str = self._proto.local_map_path\n        self.map_size: Size = Size.from_proto(self._proto.start_raw.map_size)\n\n        # self.pathing_grid[point]: if 0, point is not pathable, if 1, point is pathable\n        self.pathing_grid: PixelMap = PixelMap(self._proto.start_raw.pathing_grid, in_bits=True, mirrored=False)\n        # self.terrain_height[point]: returns the height in range of 0 to 255 at that point\n        self.terrain_height: PixelMap = PixelMap(self._proto.start_raw.terrain_height, mirrored=False)\n        # self.placement_grid[point]: if 0, point is not placeable, if 1, point is pathable\n        self.placement_grid: PixelMap = PixelMap(self._proto.start_raw.placement_grid, in_bits=True, mirrored=False)\n        self.playable_area = Rect.from_proto(self._proto.start_raw.playable_area)\n        self.map_center = self.playable_area.center\n        self.map_ramps: List[Ramp] = None  # Filled later by BotAI._prepare_first_step\n        self.vision_blockers: Set[Point2] = None  # Filled later by BotAI._prepare_first_step\n        self.player_races: Dict[int, Race] = {\n            p.player_id: p.race_actual or p.race_requested\n            for p in self._proto.player_info\n        }\n        self.start_locations: List[Point2] = [Point2.from_proto(sl) for sl in self._proto.start_raw.start_locations]\n        self.player_start_location: Point2 = None",
  "def _find_ramps_and_vision_blockers(self) -> Tuple[List[Ramp], Set[Point2]]:\n        \"\"\"Calculate points that are pathable but not placeable.\n        Then divide them into ramp points if not all points around the points are equal height\n        and into vision blockers if they are.\"\"\"\n\n        def equal_height_around(tile):\n            # mask to slice array 1 around tile\n            sliced = self.terrain_height.data_numpy[tile[1] - 1:tile[1] + 2, tile[0] - 1:tile[0] + 2]\n            return len(np.unique(sliced)) == 1\n\n        map_area = self.playable_area\n        # all points in the playable area that are pathable but not placable\n        points = [\n            Point2((a, b)) for (b, a), value in np.ndenumerate(self.pathing_grid.data_numpy)\n            if value == 1 and map_area.x <= a < map_area.x + map_area.width and map_area.y <= b < map_area.y +\n            map_area.height and self.placement_grid[(a, b)] == 0\n        ]\n        # divide points into ramp points and vision blockers\n        rampPoints = [point for point in points if not equal_height_around(point)]\n        visionBlockers = set(point for point in points if equal_height_around(point))\n        ramps = [Ramp(group, self) for group in self._find_groups(rampPoints)]\n        return ramps, visionBlockers",
  "def _find_groups(self, points: Set[Point2], minimum_points_per_group: int = 8):\n        \"\"\"\n        From a set of points, this function will try to group points together by\n        painting clusters of points in a rectangular map using flood fill algorithm.\n        Returns groups of points as list, like [{p1, p2, p3}, {p4, p5, p6, p7, p8}]\n        \"\"\"\n        # TODO do we actually need colors here? the ramps will never touch anyways.\n        NOT_COLORED_YET = -1\n        map_width = self.pathing_grid.width\n        map_height = self.pathing_grid.height\n        currentColor: int = NOT_COLORED_YET\n        picture: List[List[int]] = [[-2 for _ in range(map_width)] for _ in range(map_height)]\n\n        def paint(pt: Point2) -> None:\n            picture[pt.y][pt.x] = currentColor\n\n        nearby = [(a, b) for a in [-1, 0, 1] for b in [-1, 0, 1] if a != 0 or b != 0]\n\n        remaining: Set[Point2] = set(points)\n        for point in remaining:\n            paint(point)\n        currentColor = 1\n        queue: Deque[Point2] = deque()\n        while remaining:\n            currentGroup: Set[Point2] = set()\n            if not queue:\n                start = remaining.pop()\n                paint(start)\n                queue.append(start)\n                currentGroup.add(start)\n            while queue:\n                base: Point2 = queue.popleft()\n                for offset in nearby:\n                    px, py = base.x + offset[0], base.y + offset[1]\n                    if not (0 <= px < map_width and 0 <= py < map_height):\n                        continue\n                    if picture[py][px] != NOT_COLORED_YET:\n                        continue\n                    point: Point2 = Point2((px, py))\n                    remaining.discard(point)\n                    paint(point)\n                    queue.append(point)\n                    currentGroup.add(point)\n            if len(currentGroup) >= minimum_points_per_group:\n                yield currentGroup",
  "def equal_height_around(tile):\n            # mask to slice array 1 around tile\n            sliced = self.terrain_height.data_numpy[tile[1] - 1:tile[1] + 2, tile[0] - 1:tile[0] + 2]\n            return len(np.unique(sliced)) == 1",
  "def paint(pt: Point2) -> None:\n            picture[pt.y][pt.x] = currentColor",
  "class Units(list):\n    \"\"\"A collection of Unit objects. Makes it easy to select units by selectors.\"\"\"\n\n    @classmethod\n    def from_proto(cls, units, bot_object: BotAI):\n        return cls((Unit(u, bot_object=bot_object) for u in units))\n\n    def __init__(self, units, bot_object: BotAI):\n        \"\"\"\n        :param units:\n        :param bot_object:\n        \"\"\"\n        super().__init__(units)\n        self._bot_object = bot_object\n\n    def __call__(self, *args, **kwargs):\n        return UnitSelection(self, *args, **kwargs)\n\n    def __iter__(self) -> Generator[Unit, None, None]:\n        return (item for item in super().__iter__())\n\n    def select(self, *args, **kwargs):\n        return UnitSelection(self, *args, **kwargs)\n\n    def copy(self):\n        return self.subgroup(self)\n\n    def __or__(self, other: Units) -> Units:\n        return Units(\n            chain(\n                iter(self),\n                (other_unit for other_unit in other if other_unit.tag not in (self_unit.tag for self_unit in self)),\n            ),\n            self._bot_object,\n        )\n\n    def __add__(self, other: Units) -> Units:\n        return Units(\n            chain(\n                iter(self),\n                (other_unit for other_unit in other if other_unit.tag not in (self_unit.tag for self_unit in self)),\n            ),\n            self._bot_object,\n        )\n\n    def __and__(self, other: Units) -> Units:\n        return Units(\n            (other_unit for other_unit in other if other_unit.tag in (self_unit.tag for self_unit in self)),\n            self._bot_object,\n        )\n\n    def __sub__(self, other: Units) -> Units:\n        return Units(\n            (self_unit for self_unit in self if self_unit.tag not in (other_unit.tag for other_unit in other)),\n            self._bot_object,\n        )\n\n    def __hash__(self):\n        return hash(unit.tag for unit in self)\n\n    @property\n    def amount(self) -> int:\n        return len(self)\n\n    @property\n    def empty(self) -> bool:\n        return not bool(self)\n\n    @property\n    def exists(self) -> bool:\n        return bool(self)\n\n    def find_by_tag(self, tag) -> Optional[Unit]:\n        for unit in self:\n            if unit.tag == tag:\n                return unit\n        return None\n\n    def by_tag(self, tag):\n        unit = self.find_by_tag(tag)\n        if unit is None:\n            raise KeyError(\"Unit not found\")\n        return unit\n\n    @property\n    def first(self) -> Unit:\n        assert self, \"Units object is empty\"\n        return self[0]\n\n    def take(self, n: int) -> Units:\n        if n >= self.amount:\n            return self\n        else:\n            return self.subgroup(self[:n])\n\n    @property\n    def random(self) -> Unit:\n        assert self, \"Units object is empty\"\n        return random.choice(self)\n\n    def random_or(self, other: any) -> Unit:\n        return random.choice(self) if self else other\n\n    def random_group_of(self, n: int) -> Units:\n        \"\"\" Returns self if n >= self.amount. \"\"\"\n        if n < 1:\n            return Units([], self._bot_object)\n        elif n >= self.amount:\n            return self\n        else:\n            return self.subgroup(random.sample(self, n))\n\n    def in_attack_range_of(self, unit: Unit, bonus_distance: Union[int, float] = 0) -> Units:\n        \"\"\"\n        Filters units that are in attack range of the given unit.\n        This uses the unit and target unit.radius when calculating the distance, so it should be accurate.\n        Caution: This may not work well for static structures (bunker, sieged tank, planetary fortress, photon cannon, spine and spore crawler) because it seems attack ranges differ for static / immovable units.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                all_zerglings_my_marine_can_attack = enemy_zerglings.in_attack_range_of(my_marine)\n\n        Example::\n\n            enemy_mutalisks = self.enemy_units(UnitTypeId.MUTALISK)\n            my_marauder = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARAUDER), None)\n            if my_marauder:\n                all_mutalisks_my_marauder_can_attack = enemy_mutaliskss.in_attack_range_of(my_marauder)\n                # Is empty because mutalisk are flying and marauder cannot attack air\n\n        :param unit:\n        :param bonus_distance:\"\"\"\n        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))\n\n    def closest_distance_to(self, position: Union[Unit, Point2, Point3]) -> float:\n        \"\"\"\n        Returns the distance between the closest unit from this group to the target unit.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                closest_zergling_distance = enemy_zerglings.closest_distance_to(my_marine)\n            # Contains the distance between the marine and the closest zergling\n\n        :param position:\"\"\"\n        assert self, \"Units object is empty\"\n        if isinstance(position, Unit):\n            return min(self._bot_object._distance_squared_unit_to_unit(unit, position) for unit in self)**0.5\n        return min(self._bot_object._distance_units_to_pos(self, position))\n\n    def furthest_distance_to(self, position: Union[Unit, Point2, Point3]) -> float:\n        \"\"\"\n        Returns the distance between the furthest unit from this group to the target unit\n\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                furthest_zergling_distance = enemy_zerglings.furthest_distance_to(my_marine)\n                # Contains the distance between the marine and the furthest away zergling\n\n        :param position:\"\"\"\n        assert self, \"Units object is empty\"\n        if isinstance(position, Unit):\n            return max(self._bot_object._distance_squared_unit_to_unit(unit, position) for unit in self)**0.5\n        return max(self._bot_object._distance_units_to_pos(self, position))\n\n    def closest_to(self, position: Union[Unit, Point2, Point3]) -> Unit:\n        \"\"\"\n        Returns the closest unit (from this Units object) to the target unit or position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                closest_zergling = enemy_zerglings.closest_to(my_marine)\n                # Contains the zergling that is closest to the target marine\n\n        :param position:\"\"\"\n        assert self, \"Units object is empty\"\n        if isinstance(position, Unit):\n            return min(\n                (unit1 for unit1 in self),\n                key=lambda unit2: self._bot_object._distance_squared_unit_to_unit(unit2, position),\n            )\n\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        return min(((unit, dist) for unit, dist in zip(self, distances)), key=lambda my_tuple: my_tuple[1])[0]\n\n    def furthest_to(self, position: Union[Unit, Point2, Point3]) -> Unit:\n        \"\"\"\n        Returns the furhest unit (from this Units object) to the target unit or position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                furthest_zergling = enemy_zerglings.furthest_to(my_marine)\n                # Contains the zergling that is furthest away to the target marine\n\n        :param position:\"\"\"\n        assert self, \"Units object is empty\"\n        if isinstance(position, Unit):\n            return max(\n                (unit1 for unit1 in self),\n                key=lambda unit2: self._bot_object._distance_squared_unit_to_unit(unit2, position),\n            )\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        return max(((unit, dist) for unit, dist in zip(self, distances)), key=lambda my_tuple: my_tuple[1])[0]\n\n    def closer_than(self, distance: Union[int, float], position: Union[Unit, Point2, Point3]) -> Units:\n        \"\"\"\n        Returns all units (from this Units object) that are closer than 'distance' away from target unit or position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                close_zerglings = enemy_zerglings.closer_than(3, my_marine)\n                # Contains all zerglings that are distance 3 or less away from the marine (does not include unit radius in calculation)\n\n        :param distance:\n        :param position:\n        \"\"\"\n        if not self:\n            return self\n        if isinstance(position, Unit):\n            distance_squared = distance**2\n            return self.subgroup(\n                unit for unit in self\n                if self._bot_object._distance_squared_unit_to_unit(unit, position) < distance_squared\n            )\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        return self.subgroup(unit for unit, dist in zip(self, distances) if dist < distance)\n\n    def further_than(self, distance: Union[int, float], position: Union[Unit, Point2, Point3]) -> Units:\n        \"\"\"\n        Returns all units (from this Units object) that are further than 'distance' away from target unit or position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                far_zerglings = enemy_zerglings.further_than(3, my_marine)\n                # Contains all zerglings that are distance 3 or more away from the marine (does not include unit radius in calculation)\n\n        :param distance:\n        :param position:\n        \"\"\"\n        if not self:\n            return self\n        if isinstance(position, Unit):\n            distance_squared = distance**2\n            return self.subgroup(\n                unit for unit in self\n                if distance_squared < self._bot_object._distance_squared_unit_to_unit(unit, position)\n            )\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        return self.subgroup(unit for unit, dist in zip(self, distances) if distance < dist)\n\n    def in_distance_between(\n        self, position: Union[Unit, Point2, Tuple[float, float]], distance1: float, distance2: float\n    ) -> Units:\n        \"\"\"\n        Returns units that are further than distance1 and closer than distance2 to unit or position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                zerglings_filtered = enemy_zerglings.in_distance_between(my_marine, 3, 5)\n                # Contains all zerglings that are between distance 3 and 5 away from the marine (does not include unit radius in calculation)\n\n        :param position:\n        :param distance1:\n        :param distance2:\n        \"\"\"\n        if not self:\n            return self\n        if isinstance(position, Unit):\n            distance1_squared = distance1**2\n            distance2_squared = distance2**2\n            return self.subgroup(\n                unit for unit in self if\n                distance1_squared < self._bot_object._distance_squared_unit_to_unit(unit, position) < distance2_squared\n            )\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        return self.subgroup(unit for unit, dist in zip(self, distances) if distance1 < dist < distance2)\n\n    def closest_n_units(self, position: Union[Unit, Point2], n: int) -> Units:\n        \"\"\"\n        Returns the n closest units in distance to position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                zerglings_filtered = enemy_zerglings.closest_n_units(my_marine, 5)\n                # Contains 5 zerglings that are the closest to the marine\n\n        :param position:\n        :param n:\n        \"\"\"\n        if not self:\n            return self\n        return self.subgroup(self._list_sorted_by_distance_to(position)[:n])\n\n    def furthest_n_units(self, position: Union[Unit, Point2, np.ndarray], n: int) -> Units:\n        \"\"\"\n        Returns the n furhest units in distance to position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                zerglings_filtered = enemy_zerglings.furthest_n_units(my_marine, 5)\n                # Contains 5 zerglings that are the furthest to the marine\n\n        :param position:\n        :param n:\n        \"\"\"\n        if not self:\n            return self\n        return self.subgroup(self._list_sorted_by_distance_to(position)[-n:])\n\n    def in_distance_of_group(self, other_units: Units, distance: float) -> Units:\n        \"\"\"Returns units that are closer than distance from any unit in the other units object.\n\n        :param other_units:\n        :param distance:\n        \"\"\"\n        assert other_units, \"Other units object is empty\"\n        # Return self because there are no enemies\n        if not self:\n            return self\n        distance_squared = distance**2\n        if len(self) == 1:\n            if any(\n                self._bot_object._distance_squared_unit_to_unit(self[0], target) < distance_squared\n                for target in other_units\n            ):\n                return self\n            else:\n                return self.subgroup([])\n\n        return self.subgroup(\n            self_unit for self_unit in self if any(\n                self._bot_object._distance_squared_unit_to_unit(self_unit, other_unit) < distance_squared\n                for other_unit in other_units\n            )\n        )\n\n    def in_closest_distance_to_group(self, other_units: Units) -> Unit:\n        \"\"\"\n        Returns unit in shortest distance from any unit in self to any unit in group.\n\n        Loops over all units in self, then loops over all units in other_units and calculates the shortest distance. Returns the units that is closest to any unit of 'other_units'.\n\n        :param other_units:\"\"\"\n        assert self, \"Units object is empty\"\n        assert other_units, \"Given units object is empty\"\n        return min(\n            self,\n            key=lambda self_unit:\n            min(self._bot_object._distance_squared_unit_to_unit(self_unit, other_unit) for other_unit in other_units),\n        )\n\n    def _list_sorted_closest_to_distance(self, position: Union[Unit, Point2], distance: float) -> List[Unit]:\n        \"\"\" This function should be a bit faster than using units.sorted(key=lambda u: u.distance_to(position)) \"\"\"\n        if isinstance(position, Unit):\n            return sorted(\n                self,\n                key=lambda unit: abs(self._bot_object._distance_squared_unit_to_unit(unit, position) - distance),\n                reverse=True,\n            )\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        unit_dist_dict = {unit.tag: dist for unit, dist in zip(self, distances)}\n        return sorted(self, key=lambda unit2: abs(unit_dist_dict[unit2.tag] - distance), reverse=True)\n\n    def n_closest_to_distance(self, position: Union[Point2, np.ndarray], distance: Union[int, float], n: int) -> Units:\n        \"\"\"Returns n units that are the closest to distance away.\n        For example if the distance is set to 5 and you want 3 units, from units with distance [3, 4, 5, 6, 7] to position,\n        the units with distance [4, 5, 6] will be returned\"\"\"\n        return self.subgroup(self._list_sorted_closest_to_distance(position=position, distance=distance)[:n])\n\n    def n_furthest_to_distance(self, position: Union[Point2, np.ndarray], distance: Union[int, float], n: int) -> Units:\n        \"\"\" Inverse of the function 'n_closest_to_distance', returns the furthest units instead \"\"\"\n        return self.subgroup(self._list_sorted_closest_to_distance(position=position, distance=distance)[-n:])\n\n    def subgroup(self, units):\n        \"\"\"\n        Creates a new mutable Units object from Units or list object.\n\n        :param units:\"\"\"\n        return Units(units, self._bot_object)\n\n    def filter(self, pred: callable) -> Units:\n        \"\"\"\n        Filters the current Units object and returns a new Units object.\n\n        Example::\n\n            from sc2.ids.unit_typeid import UnitTypeId\n            my_marines = self.units.filter(lambda unit: unit.type_id == UnitTypeId.MARINE)\n\n            completed_structures = self.structures.filter(lambda structure: structure.is_ready)\n\n            queens_with_energy_to_inject = self.units.filter(lambda unit: unit.type_id == UnitTypeId.QUEEN and unit.energy >= 25)\n\n            orbitals_with_energy_to_mule = self.structures.filter(lambda structure: structure.type_id == UnitTypeId.ORBITALCOMMAND and structure.energy >= 50)\n\n            my_units_that_can_shoot_up = self.units.filter(lambda unit: unit.can_attack_air)\n\n        See more unit properties in unit.py\n\n        :param pred:\n        \"\"\"\n        assert callable(pred), \"Function is not callable\"\n        return self.subgroup(filter(pred, self))\n\n    def sorted(self, key: callable, reverse: bool = False) -> Units:\n        return self.subgroup(sorted(self, key=key, reverse=reverse))\n\n    def _list_sorted_by_distance_to(self, position: Union[Unit, Point2], reverse: bool = False) -> List[Unit]:\n        \"\"\" This function should be a bit faster than using units.sorted(key=lambda u: u.distance_to(position)) \"\"\"\n        if isinstance(position, Unit):\n            return sorted(\n                self, key=lambda unit: self._bot_object._distance_squared_unit_to_unit(unit, position), reverse=reverse\n            )\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        unit_dist_dict = {unit.tag: dist for unit, dist in zip(self, distances)}\n        return sorted(self, key=lambda unit2: unit_dist_dict[unit2.tag], reverse=reverse)\n\n    def sorted_by_distance_to(self, position: Union[Unit, Point2], reverse: bool = False) -> Units:\n        \"\"\" This function should be a bit faster than using units.sorted(key=lambda u: u.distance_to(position)) \"\"\"\n        return self.subgroup(self._list_sorted_by_distance_to(position, reverse=reverse))\n\n    def tags_in(self, other: Union[Set[int], List[int], Dict[int, Any]]) -> Units:\n        \"\"\"Filters all units that have their tags in the 'other' set/list/dict\n\n        Example::\n\n            my_inject_queens = self.units.tags_in(self.queen_tags_assigned_to_do_injects)\n\n            # Do not use the following as it is slower because it first loops over all units to filter out if they are queens and loops over those again to check if their tags are in the list/set\n            my_inject_queens_slow = self.units(QUEEN).tags_in(self.queen_tags_assigned_to_do_injects)\n\n        :param other:\n        \"\"\"\n        return self.filter(lambda unit: unit.tag in other)\n\n    def tags_not_in(self, other: Union[Set[int], List[int], Dict[int, Any]]) -> Units:\n        \"\"\"\n        Filters all units that have their tags not in the 'other' set/list/dict\n\n        Example::\n\n            my_non_inject_queens = self.units.tags_not_in(self.queen_tags_assigned_to_do_injects)\n\n            # Do not use the following as it is slower because it first loops over all units to filter out if they are queens and loops over those again to check if their tags are in the list/set\n            my_non_inject_queens_slow = self.units(QUEEN).tags_not_in(self.queen_tags_assigned_to_do_injects)\n\n        :param other:\n        \"\"\"\n        return self.filter(lambda unit: unit.tag not in other)\n\n    def of_type(self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]) -> Units:\n        \"\"\"\n        Filters all units that are of a specific type\n\n        Example::\n\n            # Use a set instead of lists in the argument\n            some_attack_units = self.units.of_type({ZERGLING, ROACH, HYDRALISK, BROODLORD})\n\n        :param other:\"\"\"\n        if isinstance(other, UnitTypeId):\n            other = {other}\n        elif isinstance(other, list):\n            other = set(other)\n        return self.filter(lambda unit: unit.type_id in other)\n\n    def exclude_type(self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]) -> Units:\n        \"\"\"\n        Filters all units that are not of a specific type\n\n        Example::\n\n            # Use a set instead of lists in the argument\n            ignore_units = self.enemy_units.exclude_type({LARVA, EGG, OVERLORD})\n\n        :param other:\"\"\"\n        if isinstance(other, UnitTypeId):\n            other = {other}\n        elif isinstance(other, list):\n            other = set(other)\n        return self.filter(lambda unit: unit.type_id not in other)\n\n    def same_tech(self, other: Set[UnitTypeId]) -> Units:\n        \"\"\"\n        Returns all structures that have the same base structure.\n\n        Untested: This should return the equivalents for WarpPrism, Observer, Overseer, SupplyDepot and others\n\n        Example::\n\n            # All command centers, flying command centers, orbital commands, flying orbital commands, planetary fortress\n            terran_townhalls = self.townhalls.same_tech(UnitTypeId.COMMANDCENTER)\n\n            # All hatcheries, lairs and hives\n            zerg_townhalls = self.townhalls.same_tech({UnitTypeId.HATCHERY})\n\n            # All spires and greater spires\n            spires = self.townhalls.same_tech({UnitTypeId.SPIRE})\n            # The following returns the same\n            spires = self.townhalls.same_tech({UnitTypeId.GREATERSPIRE})\n\n            # This also works with multiple unit types\n            zerg_townhalls_and_spires = self.structures.same_tech({UnitTypeId.HATCHERY, UnitTypeId.SPIRE})\n\n        :param other:\n        \"\"\"\n        assert isinstance(other, set), (\n            f\"Please use a set as this filter function is already fairly slow. For example\" +\n            \" 'self.units.same_tech({UnitTypeId.LAIR})'\"\n        )\n        tech_alias_types: Set[int] = {u.value for u in other}\n        unit_data = self._bot_object._game_data.units\n        for unitType in other:\n            for same in unit_data[unitType.value]._proto.tech_alias:\n                tech_alias_types.add(same)\n        return self.filter(\n            lambda unit: unit._proto.unit_type in tech_alias_types or\n            any(same in tech_alias_types for same in unit._type_data._proto.tech_alias)\n        )\n\n    def same_unit(self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]) -> Units:\n        \"\"\"\n        Returns all units that have the same base unit while being in different modes.\n\n        Untested: This should return the equivalents for WarpPrism, Observer, Overseer, SupplyDepot and other units that have different modes but still act as the same unit\n\n        Example::\n\n            # All command centers on the ground and flying\n            ccs = self.townhalls.same_unit(UnitTypeId.COMMANDCENTER)\n\n            # All orbital commands on the ground and flying\n            ocs = self.townhalls.same_unit(UnitTypeId.ORBITALCOMMAND)\n\n            # All roaches and burrowed roaches\n            roaches = self.units.same_unit(UnitTypeId.ROACH)\n            # This is useful because roach has a different type id when burrowed\n            burrowed_roaches = self.units(UnitTypeId.ROACHBURROWED)\n\n        :param other:\n        \"\"\"\n        if isinstance(other, UnitTypeId):\n            other = {other}\n        unit_alias_types: Set[int] = {u.value for u in other}\n        unit_data = self._bot_object._game_data.units\n        for unitType in other:\n            unit_alias_types.add(unit_data[unitType.value]._proto.unit_alias)\n        unit_alias_types.discard(0)\n        return self.filter(\n            lambda unit: unit._proto.unit_type in unit_alias_types or unit._type_data._proto.unit_alias in\n            unit_alias_types\n        )\n\n    @property\n    def center(self) -> Point2:\n        \"\"\" Returns the central position of all units. \"\"\"\n        assert self, f\"Units object is empty\"\n        amount = self.amount\n        return Point2(\n            (\n                sum(unit._proto.pos.x for unit in self) / amount,\n                sum(unit._proto.pos.y for unit in self) / amount,\n            )\n        )\n\n    @property\n    def selected(self) -> Units:\n        \"\"\" Returns all units that are selected by the human player. \"\"\"\n        return self.filter(lambda unit: unit.is_selected)\n\n    @property\n    def tags(self) -> Set[int]:\n        \"\"\" Returns all unit tags as a set. \"\"\"\n        return {unit.tag for unit in self}\n\n    @property\n    def ready(self) -> Units:\n        \"\"\" Returns all structures that are ready (construction complete). \"\"\"\n        return self.filter(lambda unit: unit.is_ready)\n\n    @property\n    def not_ready(self) -> Units:\n        \"\"\" Returns all structures that are not ready (construction not complete). \"\"\"\n        return self.filter(lambda unit: not unit.is_ready)\n\n    @property\n    def idle(self) -> Units:\n        \"\"\" Returns all units or structures that are doing nothing (unit is standing still, structure is doing nothing). \"\"\"\n        return self.filter(lambda unit: unit.is_idle)\n\n    @property\n    def owned(self) -> Units:\n        \"\"\" Deprecated: All your units. \"\"\"\n        return self.filter(lambda unit: unit.is_mine)\n\n    @property\n    def enemy(self) -> Units:\n        \"\"\" Deprecated: All enemy units.\"\"\"\n        return self.filter(lambda unit: unit.is_enemy)\n\n    @property\n    def flying(self) -> Units:\n        \"\"\" Returns all units that are flying. \"\"\"\n        return self.filter(lambda unit: unit.is_flying)\n\n    @property\n    def not_flying(self) -> Units:\n        \"\"\" Returns all units that not are flying. \"\"\"\n        return self.filter(lambda unit: not unit.is_flying)\n\n    @property\n    def structure(self) -> Units:\n        \"\"\" Deprecated: All structures. \"\"\"\n        return self.filter(lambda unit: unit.is_structure)\n\n    @property\n    def not_structure(self) -> Units:\n        \"\"\" Deprecated: All units that are not structures. \"\"\"\n        return self.filter(lambda unit: not unit.is_structure)\n\n    @property\n    def gathering(self) -> Units:\n        \"\"\" Returns all workers that are mining minerals or vespene (gather command). \"\"\"\n        return self.filter(lambda unit: unit.is_gathering)\n\n    @property\n    def returning(self) -> Units:\n        \"\"\" Returns all workers that are carrying minerals or vespene and are returning to a townhall. \"\"\"\n        return self.filter(lambda unit: unit.is_returning)\n\n    @property\n    def collecting(self) -> Units:\n        \"\"\" Returns all workers that are mining or returning resources. \"\"\"\n        return self.filter(lambda unit: unit.is_collecting)\n\n    @property\n    def visible(self) -> Units:\n        \"\"\"Returns all units or structures that are visible.\n        TODO: add proper description on which units are exactly visible (not snapshots?)\"\"\"\n        return self.filter(lambda unit: unit.is_visible)\n\n    @property\n    def mineral_field(self) -> Units:\n        \"\"\" Returns all units that are mineral fields. \"\"\"\n        return self.filter(lambda unit: unit.is_mineral_field)\n\n    @property\n    def vespene_geyser(self) -> Units:\n        \"\"\" Returns all units that are vespene geysers. \"\"\"\n        return self.filter(lambda unit: unit.is_vespene_geyser)\n\n    @property\n    def prefer_idle(self) -> Units:\n        \"\"\" Sorts units based on if they are idle. Idle units come first. \"\"\"\n        return self.sorted(lambda unit: unit.is_idle, reverse=True)",
  "class UnitSelection(Units):\n\n    def __init__(self, parent, selection=None):\n        if isinstance(selection, (UnitTypeId)):\n            super().__init__((unit for unit in parent if unit.type_id == selection), parent._bot_object)\n        elif isinstance(selection, set):\n            assert all(isinstance(t, UnitTypeId) for t in selection), f\"Not all ids in selection are of type UnitTypeId\"\n            super().__init__((unit for unit in parent if unit.type_id in selection), parent._bot_object)\n        elif selection is None:\n            super().__init__((unit for unit in parent), parent._bot_object)\n        else:\n            assert isinstance(\n                selection, (UnitTypeId, set)\n            ), f\"selection is not None or of type UnitTypeId or Set[UnitTypeId]\"",
  "def from_proto(cls, units, bot_object: BotAI):\n        return cls((Unit(u, bot_object=bot_object) for u in units))",
  "def __init__(self, units, bot_object: BotAI):\n        \"\"\"\n        :param units:\n        :param bot_object:\n        \"\"\"\n        super().__init__(units)\n        self._bot_object = bot_object",
  "def __call__(self, *args, **kwargs):\n        return UnitSelection(self, *args, **kwargs)",
  "def __iter__(self) -> Generator[Unit, None, None]:\n        return (item for item in super().__iter__())",
  "def select(self, *args, **kwargs):\n        return UnitSelection(self, *args, **kwargs)",
  "def copy(self):\n        return self.subgroup(self)",
  "def __or__(self, other: Units) -> Units:\n        return Units(\n            chain(\n                iter(self),\n                (other_unit for other_unit in other if other_unit.tag not in (self_unit.tag for self_unit in self)),\n            ),\n            self._bot_object,\n        )",
  "def __add__(self, other: Units) -> Units:\n        return Units(\n            chain(\n                iter(self),\n                (other_unit for other_unit in other if other_unit.tag not in (self_unit.tag for self_unit in self)),\n            ),\n            self._bot_object,\n        )",
  "def __and__(self, other: Units) -> Units:\n        return Units(\n            (other_unit for other_unit in other if other_unit.tag in (self_unit.tag for self_unit in self)),\n            self._bot_object,\n        )",
  "def __sub__(self, other: Units) -> Units:\n        return Units(\n            (self_unit for self_unit in self if self_unit.tag not in (other_unit.tag for other_unit in other)),\n            self._bot_object,\n        )",
  "def __hash__(self):\n        return hash(unit.tag for unit in self)",
  "def amount(self) -> int:\n        return len(self)",
  "def empty(self) -> bool:\n        return not bool(self)",
  "def exists(self) -> bool:\n        return bool(self)",
  "def find_by_tag(self, tag) -> Optional[Unit]:\n        for unit in self:\n            if unit.tag == tag:\n                return unit\n        return None",
  "def by_tag(self, tag):\n        unit = self.find_by_tag(tag)\n        if unit is None:\n            raise KeyError(\"Unit not found\")\n        return unit",
  "def first(self) -> Unit:\n        assert self, \"Units object is empty\"\n        return self[0]",
  "def take(self, n: int) -> Units:\n        if n >= self.amount:\n            return self\n        else:\n            return self.subgroup(self[:n])",
  "def random(self) -> Unit:\n        assert self, \"Units object is empty\"\n        return random.choice(self)",
  "def random_or(self, other: any) -> Unit:\n        return random.choice(self) if self else other",
  "def random_group_of(self, n: int) -> Units:\n        \"\"\" Returns self if n >= self.amount. \"\"\"\n        if n < 1:\n            return Units([], self._bot_object)\n        elif n >= self.amount:\n            return self\n        else:\n            return self.subgroup(random.sample(self, n))",
  "def in_attack_range_of(self, unit: Unit, bonus_distance: Union[int, float] = 0) -> Units:\n        \"\"\"\n        Filters units that are in attack range of the given unit.\n        This uses the unit and target unit.radius when calculating the distance, so it should be accurate.\n        Caution: This may not work well for static structures (bunker, sieged tank, planetary fortress, photon cannon, spine and spore crawler) because it seems attack ranges differ for static / immovable units.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                all_zerglings_my_marine_can_attack = enemy_zerglings.in_attack_range_of(my_marine)\n\n        Example::\n\n            enemy_mutalisks = self.enemy_units(UnitTypeId.MUTALISK)\n            my_marauder = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARAUDER), None)\n            if my_marauder:\n                all_mutalisks_my_marauder_can_attack = enemy_mutaliskss.in_attack_range_of(my_marauder)\n                # Is empty because mutalisk are flying and marauder cannot attack air\n\n        :param unit:\n        :param bonus_distance:\"\"\"\n        return self.filter(lambda x: unit.target_in_range(x, bonus_distance=bonus_distance))",
  "def closest_distance_to(self, position: Union[Unit, Point2, Point3]) -> float:\n        \"\"\"\n        Returns the distance between the closest unit from this group to the target unit.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                closest_zergling_distance = enemy_zerglings.closest_distance_to(my_marine)\n            # Contains the distance between the marine and the closest zergling\n\n        :param position:\"\"\"\n        assert self, \"Units object is empty\"\n        if isinstance(position, Unit):\n            return min(self._bot_object._distance_squared_unit_to_unit(unit, position) for unit in self)**0.5\n        return min(self._bot_object._distance_units_to_pos(self, position))",
  "def furthest_distance_to(self, position: Union[Unit, Point2, Point3]) -> float:\n        \"\"\"\n        Returns the distance between the furthest unit from this group to the target unit\n\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                furthest_zergling_distance = enemy_zerglings.furthest_distance_to(my_marine)\n                # Contains the distance between the marine and the furthest away zergling\n\n        :param position:\"\"\"\n        assert self, \"Units object is empty\"\n        if isinstance(position, Unit):\n            return max(self._bot_object._distance_squared_unit_to_unit(unit, position) for unit in self)**0.5\n        return max(self._bot_object._distance_units_to_pos(self, position))",
  "def closest_to(self, position: Union[Unit, Point2, Point3]) -> Unit:\n        \"\"\"\n        Returns the closest unit (from this Units object) to the target unit or position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                closest_zergling = enemy_zerglings.closest_to(my_marine)\n                # Contains the zergling that is closest to the target marine\n\n        :param position:\"\"\"\n        assert self, \"Units object is empty\"\n        if isinstance(position, Unit):\n            return min(\n                (unit1 for unit1 in self),\n                key=lambda unit2: self._bot_object._distance_squared_unit_to_unit(unit2, position),\n            )\n\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        return min(((unit, dist) for unit, dist in zip(self, distances)), key=lambda my_tuple: my_tuple[1])[0]",
  "def furthest_to(self, position: Union[Unit, Point2, Point3]) -> Unit:\n        \"\"\"\n        Returns the furhest unit (from this Units object) to the target unit or position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                furthest_zergling = enemy_zerglings.furthest_to(my_marine)\n                # Contains the zergling that is furthest away to the target marine\n\n        :param position:\"\"\"\n        assert self, \"Units object is empty\"\n        if isinstance(position, Unit):\n            return max(\n                (unit1 for unit1 in self),\n                key=lambda unit2: self._bot_object._distance_squared_unit_to_unit(unit2, position),\n            )\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        return max(((unit, dist) for unit, dist in zip(self, distances)), key=lambda my_tuple: my_tuple[1])[0]",
  "def closer_than(self, distance: Union[int, float], position: Union[Unit, Point2, Point3]) -> Units:\n        \"\"\"\n        Returns all units (from this Units object) that are closer than 'distance' away from target unit or position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                close_zerglings = enemy_zerglings.closer_than(3, my_marine)\n                # Contains all zerglings that are distance 3 or less away from the marine (does not include unit radius in calculation)\n\n        :param distance:\n        :param position:\n        \"\"\"\n        if not self:\n            return self\n        if isinstance(position, Unit):\n            distance_squared = distance**2\n            return self.subgroup(\n                unit for unit in self\n                if self._bot_object._distance_squared_unit_to_unit(unit, position) < distance_squared\n            )\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        return self.subgroup(unit for unit, dist in zip(self, distances) if dist < distance)",
  "def further_than(self, distance: Union[int, float], position: Union[Unit, Point2, Point3]) -> Units:\n        \"\"\"\n        Returns all units (from this Units object) that are further than 'distance' away from target unit or position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                far_zerglings = enemy_zerglings.further_than(3, my_marine)\n                # Contains all zerglings that are distance 3 or more away from the marine (does not include unit radius in calculation)\n\n        :param distance:\n        :param position:\n        \"\"\"\n        if not self:\n            return self\n        if isinstance(position, Unit):\n            distance_squared = distance**2\n            return self.subgroup(\n                unit for unit in self\n                if distance_squared < self._bot_object._distance_squared_unit_to_unit(unit, position)\n            )\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        return self.subgroup(unit for unit, dist in zip(self, distances) if distance < dist)",
  "def in_distance_between(\n        self, position: Union[Unit, Point2, Tuple[float, float]], distance1: float, distance2: float\n    ) -> Units:\n        \"\"\"\n        Returns units that are further than distance1 and closer than distance2 to unit or position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                zerglings_filtered = enemy_zerglings.in_distance_between(my_marine, 3, 5)\n                # Contains all zerglings that are between distance 3 and 5 away from the marine (does not include unit radius in calculation)\n\n        :param position:\n        :param distance1:\n        :param distance2:\n        \"\"\"\n        if not self:\n            return self\n        if isinstance(position, Unit):\n            distance1_squared = distance1**2\n            distance2_squared = distance2**2\n            return self.subgroup(\n                unit for unit in self if\n                distance1_squared < self._bot_object._distance_squared_unit_to_unit(unit, position) < distance2_squared\n            )\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        return self.subgroup(unit for unit, dist in zip(self, distances) if distance1 < dist < distance2)",
  "def closest_n_units(self, position: Union[Unit, Point2], n: int) -> Units:\n        \"\"\"\n        Returns the n closest units in distance to position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                zerglings_filtered = enemy_zerglings.closest_n_units(my_marine, 5)\n                # Contains 5 zerglings that are the closest to the marine\n\n        :param position:\n        :param n:\n        \"\"\"\n        if not self:\n            return self\n        return self.subgroup(self._list_sorted_by_distance_to(position)[:n])",
  "def furthest_n_units(self, position: Union[Unit, Point2, np.ndarray], n: int) -> Units:\n        \"\"\"\n        Returns the n furhest units in distance to position.\n\n        Example::\n\n            enemy_zerglings = self.enemy_units(UnitTypeId.ZERGLING)\n            my_marine = next((unit for unit in self.units if unit.type_id == UnitTypeId.MARINE), None)\n            if my_marine:\n                zerglings_filtered = enemy_zerglings.furthest_n_units(my_marine, 5)\n                # Contains 5 zerglings that are the furthest to the marine\n\n        :param position:\n        :param n:\n        \"\"\"\n        if not self:\n            return self\n        return self.subgroup(self._list_sorted_by_distance_to(position)[-n:])",
  "def in_distance_of_group(self, other_units: Units, distance: float) -> Units:\n        \"\"\"Returns units that are closer than distance from any unit in the other units object.\n\n        :param other_units:\n        :param distance:\n        \"\"\"\n        assert other_units, \"Other units object is empty\"\n        # Return self because there are no enemies\n        if not self:\n            return self\n        distance_squared = distance**2\n        if len(self) == 1:\n            if any(\n                self._bot_object._distance_squared_unit_to_unit(self[0], target) < distance_squared\n                for target in other_units\n            ):\n                return self\n            else:\n                return self.subgroup([])\n\n        return self.subgroup(\n            self_unit for self_unit in self if any(\n                self._bot_object._distance_squared_unit_to_unit(self_unit, other_unit) < distance_squared\n                for other_unit in other_units\n            )\n        )",
  "def in_closest_distance_to_group(self, other_units: Units) -> Unit:\n        \"\"\"\n        Returns unit in shortest distance from any unit in self to any unit in group.\n\n        Loops over all units in self, then loops over all units in other_units and calculates the shortest distance. Returns the units that is closest to any unit of 'other_units'.\n\n        :param other_units:\"\"\"\n        assert self, \"Units object is empty\"\n        assert other_units, \"Given units object is empty\"\n        return min(\n            self,\n            key=lambda self_unit:\n            min(self._bot_object._distance_squared_unit_to_unit(self_unit, other_unit) for other_unit in other_units),\n        )",
  "def _list_sorted_closest_to_distance(self, position: Union[Unit, Point2], distance: float) -> List[Unit]:\n        \"\"\" This function should be a bit faster than using units.sorted(key=lambda u: u.distance_to(position)) \"\"\"\n        if isinstance(position, Unit):\n            return sorted(\n                self,\n                key=lambda unit: abs(self._bot_object._distance_squared_unit_to_unit(unit, position) - distance),\n                reverse=True,\n            )\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        unit_dist_dict = {unit.tag: dist for unit, dist in zip(self, distances)}\n        return sorted(self, key=lambda unit2: abs(unit_dist_dict[unit2.tag] - distance), reverse=True)",
  "def n_closest_to_distance(self, position: Union[Point2, np.ndarray], distance: Union[int, float], n: int) -> Units:\n        \"\"\"Returns n units that are the closest to distance away.\n        For example if the distance is set to 5 and you want 3 units, from units with distance [3, 4, 5, 6, 7] to position,\n        the units with distance [4, 5, 6] will be returned\"\"\"\n        return self.subgroup(self._list_sorted_closest_to_distance(position=position, distance=distance)[:n])",
  "def n_furthest_to_distance(self, position: Union[Point2, np.ndarray], distance: Union[int, float], n: int) -> Units:\n        \"\"\" Inverse of the function 'n_closest_to_distance', returns the furthest units instead \"\"\"\n        return self.subgroup(self._list_sorted_closest_to_distance(position=position, distance=distance)[-n:])",
  "def subgroup(self, units):\n        \"\"\"\n        Creates a new mutable Units object from Units or list object.\n\n        :param units:\"\"\"\n        return Units(units, self._bot_object)",
  "def filter(self, pred: callable) -> Units:\n        \"\"\"\n        Filters the current Units object and returns a new Units object.\n\n        Example::\n\n            from sc2.ids.unit_typeid import UnitTypeId\n            my_marines = self.units.filter(lambda unit: unit.type_id == UnitTypeId.MARINE)\n\n            completed_structures = self.structures.filter(lambda structure: structure.is_ready)\n\n            queens_with_energy_to_inject = self.units.filter(lambda unit: unit.type_id == UnitTypeId.QUEEN and unit.energy >= 25)\n\n            orbitals_with_energy_to_mule = self.structures.filter(lambda structure: structure.type_id == UnitTypeId.ORBITALCOMMAND and structure.energy >= 50)\n\n            my_units_that_can_shoot_up = self.units.filter(lambda unit: unit.can_attack_air)\n\n        See more unit properties in unit.py\n\n        :param pred:\n        \"\"\"\n        assert callable(pred), \"Function is not callable\"\n        return self.subgroup(filter(pred, self))",
  "def sorted(self, key: callable, reverse: bool = False) -> Units:\n        return self.subgroup(sorted(self, key=key, reverse=reverse))",
  "def _list_sorted_by_distance_to(self, position: Union[Unit, Point2], reverse: bool = False) -> List[Unit]:\n        \"\"\" This function should be a bit faster than using units.sorted(key=lambda u: u.distance_to(position)) \"\"\"\n        if isinstance(position, Unit):\n            return sorted(\n                self, key=lambda unit: self._bot_object._distance_squared_unit_to_unit(unit, position), reverse=reverse\n            )\n        distances = self._bot_object._distance_units_to_pos(self, position)\n        unit_dist_dict = {unit.tag: dist for unit, dist in zip(self, distances)}\n        return sorted(self, key=lambda unit2: unit_dist_dict[unit2.tag], reverse=reverse)",
  "def sorted_by_distance_to(self, position: Union[Unit, Point2], reverse: bool = False) -> Units:\n        \"\"\" This function should be a bit faster than using units.sorted(key=lambda u: u.distance_to(position)) \"\"\"\n        return self.subgroup(self._list_sorted_by_distance_to(position, reverse=reverse))",
  "def tags_in(self, other: Union[Set[int], List[int], Dict[int, Any]]) -> Units:\n        \"\"\"Filters all units that have their tags in the 'other' set/list/dict\n\n        Example::\n\n            my_inject_queens = self.units.tags_in(self.queen_tags_assigned_to_do_injects)\n\n            # Do not use the following as it is slower because it first loops over all units to filter out if they are queens and loops over those again to check if their tags are in the list/set\n            my_inject_queens_slow = self.units(QUEEN).tags_in(self.queen_tags_assigned_to_do_injects)\n\n        :param other:\n        \"\"\"\n        return self.filter(lambda unit: unit.tag in other)",
  "def tags_not_in(self, other: Union[Set[int], List[int], Dict[int, Any]]) -> Units:\n        \"\"\"\n        Filters all units that have their tags not in the 'other' set/list/dict\n\n        Example::\n\n            my_non_inject_queens = self.units.tags_not_in(self.queen_tags_assigned_to_do_injects)\n\n            # Do not use the following as it is slower because it first loops over all units to filter out if they are queens and loops over those again to check if their tags are in the list/set\n            my_non_inject_queens_slow = self.units(QUEEN).tags_not_in(self.queen_tags_assigned_to_do_injects)\n\n        :param other:\n        \"\"\"\n        return self.filter(lambda unit: unit.tag not in other)",
  "def of_type(self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]) -> Units:\n        \"\"\"\n        Filters all units that are of a specific type\n\n        Example::\n\n            # Use a set instead of lists in the argument\n            some_attack_units = self.units.of_type({ZERGLING, ROACH, HYDRALISK, BROODLORD})\n\n        :param other:\"\"\"\n        if isinstance(other, UnitTypeId):\n            other = {other}\n        elif isinstance(other, list):\n            other = set(other)\n        return self.filter(lambda unit: unit.type_id in other)",
  "def exclude_type(self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]) -> Units:\n        \"\"\"\n        Filters all units that are not of a specific type\n\n        Example::\n\n            # Use a set instead of lists in the argument\n            ignore_units = self.enemy_units.exclude_type({LARVA, EGG, OVERLORD})\n\n        :param other:\"\"\"\n        if isinstance(other, UnitTypeId):\n            other = {other}\n        elif isinstance(other, list):\n            other = set(other)\n        return self.filter(lambda unit: unit.type_id not in other)",
  "def same_tech(self, other: Set[UnitTypeId]) -> Units:\n        \"\"\"\n        Returns all structures that have the same base structure.\n\n        Untested: This should return the equivalents for WarpPrism, Observer, Overseer, SupplyDepot and others\n\n        Example::\n\n            # All command centers, flying command centers, orbital commands, flying orbital commands, planetary fortress\n            terran_townhalls = self.townhalls.same_tech(UnitTypeId.COMMANDCENTER)\n\n            # All hatcheries, lairs and hives\n            zerg_townhalls = self.townhalls.same_tech({UnitTypeId.HATCHERY})\n\n            # All spires and greater spires\n            spires = self.townhalls.same_tech({UnitTypeId.SPIRE})\n            # The following returns the same\n            spires = self.townhalls.same_tech({UnitTypeId.GREATERSPIRE})\n\n            # This also works with multiple unit types\n            zerg_townhalls_and_spires = self.structures.same_tech({UnitTypeId.HATCHERY, UnitTypeId.SPIRE})\n\n        :param other:\n        \"\"\"\n        assert isinstance(other, set), (\n            f\"Please use a set as this filter function is already fairly slow. For example\" +\n            \" 'self.units.same_tech({UnitTypeId.LAIR})'\"\n        )\n        tech_alias_types: Set[int] = {u.value for u in other}\n        unit_data = self._bot_object._game_data.units\n        for unitType in other:\n            for same in unit_data[unitType.value]._proto.tech_alias:\n                tech_alias_types.add(same)\n        return self.filter(\n            lambda unit: unit._proto.unit_type in tech_alias_types or\n            any(same in tech_alias_types for same in unit._type_data._proto.tech_alias)\n        )",
  "def same_unit(self, other: Union[UnitTypeId, Set[UnitTypeId], List[UnitTypeId], Dict[UnitTypeId, Any]]) -> Units:\n        \"\"\"\n        Returns all units that have the same base unit while being in different modes.\n\n        Untested: This should return the equivalents for WarpPrism, Observer, Overseer, SupplyDepot and other units that have different modes but still act as the same unit\n\n        Example::\n\n            # All command centers on the ground and flying\n            ccs = self.townhalls.same_unit(UnitTypeId.COMMANDCENTER)\n\n            # All orbital commands on the ground and flying\n            ocs = self.townhalls.same_unit(UnitTypeId.ORBITALCOMMAND)\n\n            # All roaches and burrowed roaches\n            roaches = self.units.same_unit(UnitTypeId.ROACH)\n            # This is useful because roach has a different type id when burrowed\n            burrowed_roaches = self.units(UnitTypeId.ROACHBURROWED)\n\n        :param other:\n        \"\"\"\n        if isinstance(other, UnitTypeId):\n            other = {other}\n        unit_alias_types: Set[int] = {u.value for u in other}\n        unit_data = self._bot_object._game_data.units\n        for unitType in other:\n            unit_alias_types.add(unit_data[unitType.value]._proto.unit_alias)\n        unit_alias_types.discard(0)\n        return self.filter(\n            lambda unit: unit._proto.unit_type in unit_alias_types or unit._type_data._proto.unit_alias in\n            unit_alias_types\n        )",
  "def center(self) -> Point2:\n        \"\"\" Returns the central position of all units. \"\"\"\n        assert self, f\"Units object is empty\"\n        amount = self.amount\n        return Point2(\n            (\n                sum(unit._proto.pos.x for unit in self) / amount,\n                sum(unit._proto.pos.y for unit in self) / amount,\n            )\n        )",
  "def selected(self) -> Units:\n        \"\"\" Returns all units that are selected by the human player. \"\"\"\n        return self.filter(lambda unit: unit.is_selected)",
  "def tags(self) -> Set[int]:\n        \"\"\" Returns all unit tags as a set. \"\"\"\n        return {unit.tag for unit in self}",
  "def ready(self) -> Units:\n        \"\"\" Returns all structures that are ready (construction complete). \"\"\"\n        return self.filter(lambda unit: unit.is_ready)",
  "def not_ready(self) -> Units:\n        \"\"\" Returns all structures that are not ready (construction not complete). \"\"\"\n        return self.filter(lambda unit: not unit.is_ready)",
  "def idle(self) -> Units:\n        \"\"\" Returns all units or structures that are doing nothing (unit is standing still, structure is doing nothing). \"\"\"\n        return self.filter(lambda unit: unit.is_idle)",
  "def owned(self) -> Units:\n        \"\"\" Deprecated: All your units. \"\"\"\n        return self.filter(lambda unit: unit.is_mine)",
  "def enemy(self) -> Units:\n        \"\"\" Deprecated: All enemy units.\"\"\"\n        return self.filter(lambda unit: unit.is_enemy)",
  "def flying(self) -> Units:\n        \"\"\" Returns all units that are flying. \"\"\"\n        return self.filter(lambda unit: unit.is_flying)",
  "def not_flying(self) -> Units:\n        \"\"\" Returns all units that not are flying. \"\"\"\n        return self.filter(lambda unit: not unit.is_flying)",
  "def structure(self) -> Units:\n        \"\"\" Deprecated: All structures. \"\"\"\n        return self.filter(lambda unit: unit.is_structure)",
  "def not_structure(self) -> Units:\n        \"\"\" Deprecated: All units that are not structures. \"\"\"\n        return self.filter(lambda unit: not unit.is_structure)",
  "def gathering(self) -> Units:\n        \"\"\" Returns all workers that are mining minerals or vespene (gather command). \"\"\"\n        return self.filter(lambda unit: unit.is_gathering)",
  "def returning(self) -> Units:\n        \"\"\" Returns all workers that are carrying minerals or vespene and are returning to a townhall. \"\"\"\n        return self.filter(lambda unit: unit.is_returning)",
  "def collecting(self) -> Units:\n        \"\"\" Returns all workers that are mining or returning resources. \"\"\"\n        return self.filter(lambda unit: unit.is_collecting)",
  "def visible(self) -> Units:\n        \"\"\"Returns all units or structures that are visible.\n        TODO: add proper description on which units are exactly visible (not snapshots?)\"\"\"\n        return self.filter(lambda unit: unit.is_visible)",
  "def mineral_field(self) -> Units:\n        \"\"\" Returns all units that are mineral fields. \"\"\"\n        return self.filter(lambda unit: unit.is_mineral_field)",
  "def vespene_geyser(self) -> Units:\n        \"\"\" Returns all units that are vespene geysers. \"\"\"\n        return self.filter(lambda unit: unit.is_vespene_geyser)",
  "def prefer_idle(self) -> Units:\n        \"\"\" Sorts units based on if they are idle. Idle units come first. \"\"\"\n        return self.sorted(lambda unit: unit.is_idle, reverse=True)",
  "def __init__(self, parent, selection=None):\n        if isinstance(selection, (UnitTypeId)):\n            super().__init__((unit for unit in parent if unit.type_id == selection), parent._bot_object)\n        elif isinstance(selection, set):\n            assert all(isinstance(t, UnitTypeId) for t in selection), f\"Not all ids in selection are of type UnitTypeId\"\n            super().__init__((unit for unit in parent if unit.type_id in selection), parent._bot_object)\n        elif selection is None:\n            super().__init__((unit for unit in parent), parent._bot_object)\n        else:\n            assert isinstance(\n                selection, (UnitTypeId, set)\n            ), f\"selection is not None or of type UnitTypeId or Set[UnitTypeId]\"",
  "class BotAI(DistanceCalculation):\n    \"\"\"Base class for bots.\"\"\"\n\n    EXPANSION_GAP_THRESHOLD = 15\n\n    def _initialize_variables(self):\n        \"\"\" Called from main.py internally \"\"\"\n        DistanceCalculation.__init__(self)\n        # Specific opponent bot ID used in sc2ai ladder games http://sc2ai.net/ and on ai arena https://aiarena.net\n        # The bot ID will stay the same each game so your bot can \"adapt\" to the opponent\n        if not hasattr(self, \"opponent_id\"):\n            # Prevent overwriting the opponent_id which is set here https://github.com/Hannessa/python-sc2-ladderbot/blob/master/__init__.py#L40\n            # otherwise set it to None\n            self.opponent_id: str = None\n        # Select distance calculation method, see distances.py: _distances_override_functions function\n        if not hasattr(self, \"distance_calculation_method\"):\n            self.distance_calculation_method: int = 2\n        # Select if the Unit.command should return UnitCommand objects. Set this to True if your bot uses 'self.do(unit(ability, target))'\n        if not hasattr(self, \"unit_command_uses_self_do\"):\n            self.unit_command_uses_self_do: bool = False\n        # This value will be set to True by main.py in self._prepare_start if game is played in realtime (if true, the bot will have limited time per step)\n        self.realtime: bool = False\n        self.base_build: int = -1\n        self.all_units: Units = Units([], self)\n        self.units: Units = Units([], self)\n        self.workers: Units = Units([], self)\n        self.larva: Units = Units([], self)\n        self.structures: Units = Units([], self)\n        self.townhalls: Units = Units([], self)\n        self.gas_buildings: Units = Units([], self)\n        self.all_own_units: Units = Units([], self)\n        self.enemy_units: Units = Units([], self)\n        self.enemy_structures: Units = Units([], self)\n        self.all_enemy_units: Units = Units([], self)\n        self.resources: Units = Units([], self)\n        self.destructables: Units = Units([], self)\n        self.watchtowers: Units = Units([], self)\n        self.mineral_field: Units = Units([], self)\n        self.vespene_geyser: Units = Units([], self)\n        self.placeholders: Units = Units([], self)\n        self.techlab_tags: Set[int] = set()\n        self.reactor_tags: Set[int] = set()\n        self.minerals: int = 50\n        self.vespene: int = 0\n        self.supply_army: float = 0\n        self.supply_workers: float = 12  # Doesn't include workers in production\n        self.supply_cap: float = 15\n        self.supply_used: float = 12\n        self.supply_left: float = 3\n        self.idle_worker_count: int = 0\n        self.army_count: int = 0\n        self.warp_gate_count: int = 0\n        self.actions: List[UnitCommand] = []\n        self.blips: Set[Blip] = set()\n        self.race: Race = None\n        self.enemy_race: Race = None\n        self._units_created: Counter = Counter()\n        self._unit_tags_seen_this_game: Set[int] = set()\n        self._units_previous_map: Dict[int, Unit] = {}\n        self._structures_previous_map: Dict[int, Unit] = {}\n        self._enemy_units_previous_map: Dict[int, Unit] = {}\n        self._enemy_structures_previous_map: Dict[int, Unit] = {}\n        self._all_units_previous_map: Dict[int, Unit] = {}\n        self._previous_upgrades: Set[UpgradeId] = set()\n        self._expansion_positions_list: List[Point2] = []\n        self._resource_location_to_expansion_position_dict: Dict[Point2, Point2] = {}\n        self._time_before_step: float = None\n        self._time_after_step: float = None\n        self._min_step_time: float = math.inf\n        self._max_step_time: float = 0\n        self._last_step_step_time: float = 0\n        self._total_time_in_on_step: float = 0\n        self._total_steps_iterations: int = 0\n        # Internally used to keep track which units received an action in this frame, so that self.train() function does not give the same larva two orders - cleared every frame\n        self.unit_tags_received_action: Set[int] = set()\n\n    @property\n    def time(self) -> float:\n        \"\"\" Returns time in seconds, assumes the game is played on 'faster' \"\"\"\n        return self.state.game_loop / 22.4  # / (1/1.4) * (1/16)\n\n    @property\n    def time_formatted(self) -> str:\n        \"\"\" Returns time as string in min:sec format \"\"\"\n        t = self.time\n        return f\"{int(t // 60):02}:{int(t % 60):02}\"\n\n    @property\n    def step_time(self) -> Tuple[float, float, float, float]:\n        \"\"\"Returns a tuple of step duration in milliseconds.\n        First value is the minimum step duration - the shortest the bot ever took\n        Second value is the average step duration\n        Third value is the maximum step duration - the longest the bot ever took (including on_start())\n        Fourth value is the step duration the bot took last iteration\n        If called in the first iteration, it returns (inf, 0, 0, 0)\"\"\"\n        avg_step_duration = (\n            (self._total_time_in_on_step / self._total_steps_iterations) if self._total_steps_iterations else 0\n        )\n        return (\n            self._min_step_time * 1000,\n            avg_step_duration * 1000,\n            self._max_step_time * 1000,\n            self._last_step_step_time * 1000,\n        )\n\n    @property\n    def game_info(self) -> GameInfo:\n        \"\"\" See game_info.py \"\"\"\n        return self._game_info\n\n    @property\n    def game_data(self) -> GameData:\n        \"\"\" See game_data.py \"\"\"\n        return self._game_data\n\n    @property\n    def client(self) -> Client:\n        \"\"\" See client.py \"\"\"\n        return self._client\n\n    @property\n    def larva_count(self):\n        \"\"\" Replacement for self.state.common.larva_count https://github.com/Blizzard/s2client-proto/blob/d3d18392f9d7c646067d447df0c936a8ca57d587/s2clientprotocol/sc2api.proto#L614 \"\"\"\n        warnings.warn(\n            \"self.larva_count will be removed soon, please use len(self.larva) or self.larva.amount instead\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return len(self.larva)\n\n    def alert(self, alert_code: Alert) -> bool:\n        \"\"\"\n        Check if alert is triggered in the current step.\n        Possible alerts are listed here https://github.com/Blizzard/s2client-proto/blob/e38efed74c03bec90f74b330ea1adda9215e655f/s2clientprotocol/sc2api.proto#L679-L702\n\n        Example use::\n\n            from sc2.data import Alert\n            if self.alert(Alert.AddOnComplete):\n                print(\"Addon Complete\")\n\n        Alert codes::\n\n            AlertError\n            AddOnComplete\n            BuildingComplete\n            BuildingUnderAttack\n            LarvaHatched\n            MergeComplete\n            MineralsExhausted\n            MorphComplete\n            MothershipComplete\n            MULEExpired\n            NuclearLaunchDetected\n            NukeComplete\n            NydusWormDetected\n            ResearchComplete\n            TrainError\n            TrainUnitComplete\n            TrainWorkerComplete\n            TransformationComplete\n            UnitUnderAttack\n            UpgradeComplete\n            VespeneExhausted\n            WarpInComplete\n\n        :param alert_code:\n        \"\"\"\n        assert isinstance(alert_code, Alert), f\"alert_code {alert_code} is no Alert\"\n        return alert_code.value in self.state.alerts\n\n    @property\n    def start_location(self) -> Point2:\n        \"\"\"\n        Returns the spawn location of the bot, using the position of the first created townhall.\n        This will be None if the bot is run on an arcade or custom map that does not feature townhalls at game start.\n        \"\"\"\n        return self._game_info.player_start_location\n\n    @property\n    def enemy_start_locations(self) -> List[Point2]:\n        \"\"\"Possible start locations for enemies.\"\"\"\n        return self._game_info.start_locations\n\n    @property\n    def main_base_ramp(self) -> Ramp:\n        \"\"\"Returns the Ramp instance of the closest main-ramp to start location.\n        Look in game_info.py for more information about the Ramp class\n\n        Example: See terran ramp wall bot\n        \"\"\"\n        if hasattr(self, \"cached_main_base_ramp\"):\n            return self.cached_main_base_ramp\n        # The reason for len(ramp.upper) in {2, 5} is:\n        # ParaSite map has 5 upper points, and most other maps have 2 upper points at the main ramp.\n        # The map Acolyte has 4 upper points at the wrong ramp (which is closest to the start position).\n        try:\n            self.cached_main_base_ramp = min(\n                (ramp for ramp in self.game_info.map_ramps if len(ramp.upper) in {2, 5}),\n                key=lambda r: self.start_location.distance_to(r.top_center),\n            )\n        except ValueError:\n            # Hardcoded hotfix for Honorgrounds LE map, as that map has a large main base ramp with inbase natural\n            self.cached_main_base_ramp = min(\n                (ramp for ramp in self.game_info.map_ramps if len(ramp.upper) in {4, 9}),\n                key=lambda r: self.start_location.distance_to(r.top_center),\n            )\n        return self.cached_main_base_ramp\n\n    @property_cache_once_per_frame\n    def expansion_locations_list(self) -> List[Point2]:\n        \"\"\" Returns a list of expansion positions, not sorted in any way. \"\"\"\n        assert (\n            self._expansion_positions_list\n        ), f\"self._find_expansion_locations() has not been run yet, so accessing the list of expansion locations is pointless.\"\n        return self._expansion_positions_list\n\n    @property_cache_once_per_frame\n    def expansion_locations_dict(self) -> Dict[Point2, Units]:\n        \"\"\"\n        Returns dict with the correct expansion position Point2 object as key,\n        resources as Units (mineral fields and vespene geysers) as value.\n\n        Caution: This function is slow. If you only need the expansion locations, use the property above.\n        \"\"\"\n        assert (\n            self._expansion_positions_list\n        ), f\"self._find_expansion_locations() has not been run yet, so accessing the list of expansion locations is pointless.\"\n        expansion_locations: Dict[Point2, Units] = {pos: Units([], self) for pos in self._expansion_positions_list}\n        for resource in self.resources:\n            # It may be that some resources are not mapped to an expansion location\n            exp_position: Point2 = self._resource_location_to_expansion_position_dict.get(resource.position, None)\n            if exp_position:\n                assert exp_position in expansion_locations\n                expansion_locations[exp_position].append(resource)\n        return expansion_locations\n\n    # Deprecated\n    @property_cache_once_per_frame\n    def expansion_locations(self) -> Dict[Point2, Units]:\n        \"\"\" Same as the function above. \"\"\"\n        assert (\n            self._expansion_positions_list\n        ), f\"self._find_expansion_locations() has not been run yet, so accessing the list of expansion locations is pointless.\"\n        warnings.warn(\n            f\"You are using 'self.expansion_locations', please use 'self.expansion_locations_list' (fast) or 'self.expansion_locations_dict' (slow) instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.expansion_locations_dict\n\n    def _find_expansion_locations(self):\n        \"\"\" Ran once at the start of the game to calculate expansion locations. \"\"\"\n        # Idea: create a group for every resource, then merge these groups if\n        # any resource in a group is closer than a threshold to any resource of another group\n\n        # Distance we group resources by\n        resource_spread_threshold: float = 8.5\n        geysers: Units = self.vespene_geyser\n        # Create a group for every resource\n        resource_groups: List[List[Unit]] = [\n            [resource] for resource in self.resources\n            if resource.name != \"MineralField450\"  # dont use low mineral count patches\n        ]\n        # Loop the merging process as long as we change something\n        merged_group = True\n        while merged_group:\n            merged_group = False\n            # Check every combination of two groups\n            for group_a, group_b in itertools.combinations(resource_groups, 2):\n                # Check if any pair of resource of these groups is closer than threshold together\n                if any(\n                    resource_a.distance_to(resource_b) <= resource_spread_threshold\n                    for resource_a, resource_b in itertools.product(group_a, group_b)\n                ):\n                    # Remove the single groups and add the merged group\n                    resource_groups.remove(group_a)\n                    resource_groups.remove(group_b)\n                    resource_groups.append(group_a + group_b)\n                    merged_group = True\n                    break\n        # Distance offsets we apply to center of each resource group to find expansion position\n        offset_range = 7\n        offsets = [\n            (x, y) for x, y in itertools.product(range(-offset_range, offset_range + 1), repeat=2)\n            if 4 < math.hypot(x, y) <= 8\n        ]\n        # Dict we want to return\n        centers = {}\n        # For every resource group:\n        for resources in resource_groups:\n            # Possible expansion points\n            amount = len(resources)\n            # Calculate center, round and add 0.5 because expansion location will have (x.5, y.5)\n            # coordinates because bases have size 5.\n            center_x = int(sum(resource.position.x for resource in resources) / amount) + 0.5\n            center_y = int(sum(resource.position.y for resource in resources) / amount) + 0.5\n            possible_points = (Point2((offset[0] + center_x, offset[1] + center_y)) for offset in offsets)\n            # Filter out points that are too near\n            possible_points = (\n                point for point in possible_points\n                # Check if point can be built on\n                if self._game_info.placement_grid[point.rounded] == 1\n                # Check if all resources have enough space to point\n                and all(\n                    point.distance_to(resource) >= (7 if resource._proto.unit_type in geyser_ids else 6)\n                    for resource in resources\n                )\n            )\n            # Choose best fitting point\n            result: Point2 = min(\n                possible_points, key=lambda point: sum(point.distance_to(resource) for resource in resources)\n            )\n            centers[result] = resources\n            # Put all expansion locations in a list\n            self._expansion_positions_list.append(result)\n            # Maps all resource positions to the expansion position\n            for resource in resources:\n                self._resource_location_to_expansion_position_dict[resource.position] = result\n\n    @property\n    def units_created(self) -> Counter:\n        \"\"\"Returns a Counter for all your units and buildings you have created so far.\n\n        This may be used for statistics (at the end of the game) or for strategic decision making.\n\n        CAUTION: This does not properly work at the moment for morphing units and structures. Please use the 'on_unit_type_changed' event to add these morphing unit types manually to 'self._units_created'.\n        Issues would arrise in e.g. siege tank morphing to sieged tank, and then morphing back (suddenly the counter counts 2 tanks have been created).\n\n        Examples::\n\n            # Give attack command to enemy base every time 10 marines have been trained\n            async def on_unit_created(self, unit: Unit):\n                if unit.type_id == UnitTypeId.MARINE:\n                    if self.units_created[MARINE] % 10 == 0:\n                        for marine in self.units(UnitTypeId.MARINE):\n                            marine.attack(self.enemy_start_locations[0])\n        \"\"\"\n        return self._units_created\n\n    def _correct_zerg_supply(self):\n        \"\"\"The client incorrectly rounds zerg supply down instead of up (see\n        https://github.com/Blizzard/s2client-proto/issues/123), so self.supply_used\n        and friends return the wrong value when there are an odd number of zerglings\n        and banelings. This function corrects the bad values.\"\"\"\n        # TODO: remove when Blizzard/sc2client-proto#123 gets fixed.\n        half_supply_units = {\n            UnitTypeId.ZERGLING,\n            UnitTypeId.ZERGLINGBURROWED,\n            UnitTypeId.BANELING,\n            UnitTypeId.BANELINGBURROWED,\n            UnitTypeId.BANELINGCOCOON,\n        }\n        correction = self.units(half_supply_units).amount % 2\n        self.supply_used += correction\n        self.supply_army += correction\n        self.supply_left -= correction\n\n    async def get_available_abilities(\n        self, units: Union[List[Unit], Units], ignore_resource_requirements: bool = False\n    ) -> List[List[AbilityId]]:\n        \"\"\"Returns available abilities of one or more units. Right now only checks cooldown, energy cost, and whether the ability has been researched.\n\n        Examples::\n\n            units_abilities = await self.get_available_abilities(self.units)\n\n        or::\n\n            units_abilities = await self.get_available_abilities([self.units.random])\n\n        :param units:\n        :param ignore_resource_requirements:\"\"\"\n        return await self._client.query_available_abilities(units, ignore_resource_requirements)\n\n    async def expand_now(\n        self, building: UnitTypeId = None, max_distance: float = 10, location: Optional[Point2] = None\n    ):\n        \"\"\"Finds the next possible expansion via 'self.get_next_expansion()'. If the target expansion is blocked (e.g. an enemy unit), it will misplace the expansion.\n\n        :param building:\n        :param max_distance:\n        :param location:\"\"\"\n\n        if not building:\n            # self.race is never Race.Random\n            start_townhall_type = {\n                Race.Protoss: UnitTypeId.NEXUS,\n                Race.Terran: UnitTypeId.COMMANDCENTER,\n                Race.Zerg: UnitTypeId.HATCHERY,\n            }\n            building = start_townhall_type[self.race]\n\n        assert isinstance(building, UnitTypeId), f\"{building} is no UnitTypeId\"\n\n        if not location:\n            location = await self.get_next_expansion()\n        if not location:\n            # All expansions are used up or mined out\n            logger.warning(\"Trying to expand_now() but bot is out of locations to expand to\")\n            return\n        await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)\n\n    async def get_next_expansion(self) -> Optional[Point2]:\n        \"\"\"Find next expansion location.\"\"\"\n\n        closest = None\n        distance = math.inf\n        for el in self.expansion_locations_list:\n\n            def is_near_to_expansion(t):\n                return t.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\n\n            if any(map(is_near_to_expansion, self.townhalls)):\n                # already taken\n                continue\n\n            startp = self._game_info.player_start_location\n            d = await self._client.query_pathing(startp, el)\n            if d is None:\n                continue\n\n            if d < distance:\n                distance = d\n                closest = el\n\n        return closest\n\n    async def distribute_workers(self, resource_ratio: float = 2):\n        \"\"\"\n        Distributes workers across all the bases taken.\n        Keyword `resource_ratio` takes a float. If the current minerals to gas\n        ratio is bigger than `resource_ratio`, this function prefer filling gas_buildings\n        first, if it is lower, it will prefer sending workers to minerals first.\n\n        NOTE: This function is far from optimal, if you really want to have\n        refined worker control, you should write your own distribution function.\n        For example long distance mining control and moving workers if a base was killed\n        are not being handled.\n\n        WARNING: This is quite slow when there are lots of workers or multiple bases.\n\n        :param resource_ratio:\"\"\"\n        if not self.mineral_field or not self.workers or not self.townhalls.ready:\n            return\n        worker_pool = [worker for worker in self.workers.idle]\n        bases = self.townhalls.ready\n        gas_buildings = self.gas_buildings.ready\n\n        # list of places that need more workers\n        deficit_mining_places = []\n\n        for mining_place in bases | gas_buildings:\n            difference = mining_place.surplus_harvesters\n            # perfect amount of workers, skip mining place\n            if not difference:\n                continue\n            if mining_place.has_vespene:\n                # get all workers that target the gas extraction site\n                # or are on their way back from it\n                local_workers = self.workers.filter(\n                    lambda unit: unit.order_target == mining_place.tag or\n                    (unit.is_carrying_vespene and unit.order_target == bases.closest_to(mining_place).tag)\n                )\n            else:\n                # get tags of minerals around expansion\n                local_minerals_tags = {\n                    mineral.tag\n                    for mineral in self.mineral_field if mineral.distance_to(mining_place) <= 8\n                }\n                # get all target tags a worker can have\n                # tags of the minerals he could mine at that base\n                # get workers that work at that gather site\n                local_workers = self.workers.filter(\n                    lambda unit: unit.order_target in local_minerals_tags or\n                    (unit.is_carrying_minerals and unit.order_target == mining_place.tag)\n                )\n            # too many workers\n            if difference > 0:\n                for worker in local_workers[:difference]:\n                    worker_pool.append(worker)\n            # too few workers\n            # add mining place to deficit bases for every missing worker\n            else:\n                deficit_mining_places += [mining_place for _ in range(-difference)]\n\n        # prepare all minerals near a base if we have too many workers\n        # and need to send them to the closest patch\n        if len(worker_pool) > len(deficit_mining_places):\n            all_minerals_near_base = [\n                mineral for mineral in self.mineral_field\n                if any(mineral.distance_to(base) <= 8 for base in self.townhalls.ready)\n            ]\n        # distribute every worker in the pool\n        for worker in worker_pool:\n            # as long as have workers and mining places\n            if deficit_mining_places:\n                # choose only mineral fields first if current mineral to gas ratio is less than target ratio\n                if self.vespene and self.minerals / self.vespene < resource_ratio:\n                    possible_mining_places = [place for place in deficit_mining_places if not place.vespene_contents]\n                # else prefer gas\n                else:\n                    possible_mining_places = [place for place in deficit_mining_places if place.vespene_contents]\n                # if preferred type is not available any more, get all other places\n                if not possible_mining_places:\n                    possible_mining_places = deficit_mining_places\n                # find closest mining place\n                current_place = min(deficit_mining_places, key=lambda place: place.distance_to(worker))\n                # remove it from the list\n                deficit_mining_places.remove(current_place)\n                # if current place is a gas extraction site, go there\n                if current_place.vespene_contents:\n                    worker.gather(current_place)\n                # if current place is a gas extraction site,\n                # go to the mineral field that is near and has the most minerals left\n                else:\n                    local_minerals = (\n                        mineral for mineral in self.mineral_field if mineral.distance_to(current_place) <= 8\n                    )\n                    # local_minerals can be empty if townhall is misplaced\n                    target_mineral = max(local_minerals, key=lambda mineral: mineral.mineral_contents, default=None)\n                    if target_mineral:\n                        worker.gather(target_mineral)\n            # more workers to distribute than free mining spots\n            # send to closest if worker is doing nothing\n            elif worker.is_idle and all_minerals_near_base:\n                target_mineral = min(all_minerals_near_base, key=lambda mineral: mineral.distance_to(worker))\n                worker.gather(target_mineral)\n            else:\n                # there are no deficit mining places and worker is not idle\n                # so dont move him\n                pass\n\n    @property\n    def owned_expansions(self) -> Dict[Point2, Unit]:\n        \"\"\"List of expansions owned by the player.\"\"\"\n        owned = {}\n        for el in self.expansion_locations_list:\n\n            def is_near_to_expansion(t):\n                return t.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\n\n            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\n            if th:\n                owned[el] = th\n        return owned\n\n    def calculate_supply_cost(self, unit_type: UnitTypeId) -> float:\n        \"\"\"\n        This function calculates the required supply to train or morph a unit.\n        The total supply of a baneling is 0.5, but a zergling already uses up 0.5 supply, so the morph supply cost is 0.\n        The total supply of a ravager is 3, but a roach already uses up 2 supply, so the morph supply cost is 1.\n        The required supply to build zerglings is 1 because they pop in pairs, so this function returns 1 because the larva morph command requires 1 free supply.\n\n        Example::\n\n            roach_supply_cost = self.calculate_supply_cost(UnitTypeId.ROACH) # Is 2\n            ravager_supply_cost = self.calculate_supply_cost(UnitTypeId.RAVAGER) # Is 1\n            baneling_supply_cost = self.calculate_supply_cost(UnitTypeId.BANELING) # Is 0\n\n        :param unit_type:\"\"\"\n        if unit_type in {UnitTypeId.ZERGLING}:\n            return 1\n        unit_supply_cost = self._game_data.units[unit_type.value]._proto.food_required\n        if unit_supply_cost > 0 and unit_type in UNIT_TRAINED_FROM and len(UNIT_TRAINED_FROM[unit_type]) == 1:\n            producer: UnitTypeId\n            for producer in UNIT_TRAINED_FROM[unit_type]:\n                producer_unit_data = self.game_data.units[producer.value]\n                if producer_unit_data._proto.food_required <= unit_supply_cost:\n                    producer_supply_cost = producer_unit_data._proto.food_required\n                    unit_supply_cost -= producer_supply_cost\n        return unit_supply_cost\n\n    def can_feed(self, unit_type: UnitTypeId) -> bool:\n        \"\"\"Checks if you have enough free supply to build the unit\n\n        Example::\n\n            cc = self.townhalls.idle.random_or(None)\n            # self.townhalls can be empty or there are no idle townhalls\n            if cc and self.can_feed(UnitTypeId.SCV):\n                cc.train(UnitTypeId.SCV)\n\n        :param unit_type:\"\"\"\n        required = self.calculate_supply_cost(unit_type)\n        # \"required <= 0\" in case self.supply_left is negative\n        return required <= 0 or self.supply_left >= required\n\n    def calculate_unit_value(self, unit_type: UnitTypeId) -> Cost:\n        \"\"\"\n        Unlike the function below, this function returns the value of a unit given by the API (e.g. the resources lost value on kill).\n\n        Examples::\n\n            self.calculate_value(UnitTypeId.ORBITALCOMMAND) == Cost(550, 0)\n            self.calculate_value(UnitTypeId.RAVAGER) == Cost(100, 100)\n            self.calculate_value(UnitTypeId.ARCHON) == Cost(175, 275)\n\n        :param unit_type:\n        \"\"\"\n        unit_data = self.game_data.units[unit_type.value]\n        return Cost(unit_data._proto.mineral_cost, unit_data._proto.vespene_cost)\n\n    def calculate_cost(self, item_id: Union[UnitTypeId, UpgradeId, AbilityId]) -> Cost:\n        \"\"\"\n        Calculate the required build, train or morph cost of a unit. It is recommended to use the UnitTypeId instead of the ability to create the unit.\n        The total cost to create a ravager is 100/100, but the actual morph cost from roach to ravager is only 25/75, so this function returns 25/75.\n\n        It is adviced to use the UnitTypeId instead of the AbilityId. Instead of::\n\n            self.calculate_cost(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND)\n\n        use::\n\n            self.calculate_cost(UnitTypeId.ORBITALCOMMAND)\n\n        More examples::\n\n            from sc2.game_data import Cost\n\n            self.calculate_cost(UnitTypeId.BROODLORD) == Cost(150, 150)\n            self.calculate_cost(UnitTypeId.RAVAGER) == Cost(25, 75)\n            self.calculate_cost(UnitTypeId.BANELING) == Cost(25, 25)\n            self.calculate_cost(UnitTypeId.ORBITALCOMMAND) == Cost(150, 0)\n            self.calculate_cost(UnitTypeId.REACTOR) == Cost(50, 50)\n            self.calculate_cost(UnitTypeId.TECHLAB) == Cost(50, 25)\n            self.calculate_cost(UnitTypeId.QUEEN) == Cost(150, 0)\n            self.calculate_cost(UnitTypeId.HATCHERY) == Cost(300, 0)\n            self.calculate_cost(UnitTypeId.LAIR) == Cost(150, 100)\n            self.calculate_cost(UnitTypeId.HIVE) == Cost(200, 150)\n\n        :param item_id:\n        \"\"\"\n        if isinstance(item_id, UnitTypeId):\n            # Fix cost for reactor and techlab where the API returns 0 for both\n            if item_id in {UnitTypeId.REACTOR, UnitTypeId.TECHLAB, UnitTypeId.ARCHON}:\n                if item_id == UnitTypeId.REACTOR:\n                    return Cost(50, 50)\n                elif item_id == UnitTypeId.TECHLAB:\n                    return Cost(50, 25)\n                elif item_id == UnitTypeId.ARCHON:\n                    return self.calculate_unit_value(UnitTypeId.ARCHON)\n            unit_data = self._game_data.units[item_id.value]\n            # Cost of morphs is automatically correctly calculated by 'calculate_ability_cost'\n            return self._game_data.calculate_ability_cost(unit_data.creation_ability)\n\n        elif isinstance(item_id, UpgradeId):\n            cost = self._game_data.upgrades[item_id.value].cost\n        else:\n            # Is already AbilityId\n            cost = self._game_data.calculate_ability_cost(item_id)\n        return cost\n\n    def can_afford(self, item_id: Union[UnitTypeId, UpgradeId, AbilityId], check_supply_cost: bool = True) -> bool:\n        \"\"\"Tests if the player has enough resources to build a unit or structure.\n\n        Example::\n\n            cc = self.townhalls.idle.random_or(None)\n            # self.townhalls can be empty or there are no idle townhalls\n            if cc and self.can_afford(UnitTypeId.SCV):\n                cc.train(UnitTypeId.SCV)\n\n        Example::\n\n            # Current state: we have 150 minerals and one command center and a barracks\n            can_afford_morph = self.can_afford(UnitTypeId.ORBITALCOMMAND, check_supply_cost=False)\n            # Will be 'True' although the API reports that an orbital is worth 550 minerals, but the morph cost is only 150 minerals\n\n        :param item_id:\n        :param check_supply_cost:\"\"\"\n        cost = self.calculate_cost(item_id)\n        if cost.minerals > self.minerals or cost.vespene > self.vespene:\n            return False\n        if check_supply_cost and isinstance(item_id, UnitTypeId):\n            supply_cost = self.calculate_supply_cost(item_id)\n            if supply_cost and supply_cost > self.supply_left:\n                return False\n        return True\n\n    async def can_cast(\n        self,\n        unit: Unit,\n        ability_id: AbilityId,\n        target: Optional[Union[Unit, Point2]] = None,\n        only_check_energy_and_cooldown: bool = False,\n        cached_abilities_of_unit: List[AbilityId] = None,\n    ) -> bool:\n        \"\"\"Tests if a unit has an ability available and enough energy to cast it.\n\n        Example::\n\n            stalkers = self.units(UnitTypeId.STALKER)\n            stalkers_that_can_blink = stalkers.filter(lambda unit: unit.type_id == UnitTypeId.STALKER and (await self.can_cast(unit, AbilityId.EFFECT_BLINK_STALKER, only_check_energy_and_cooldown=True)))\n\n        See data_pb2.py (line 161) for the numbers 1-5 to make sense\n\n        :param unit:\n        :param ability_id:\n        :param target:\n        :param only_check_energy_and_cooldown:\n        :param cached_abilities_of_unit:\"\"\"\n        assert isinstance(unit, Unit), f\"{unit} is no Unit object\"\n        assert isinstance(ability_id, AbilityId), f\"{ability_id} is no AbilityId\"\n        assert isinstance(target, (type(None), Unit, Point2))\n        # check if unit has enough energy to cast or if ability is on cooldown\n        if cached_abilities_of_unit:\n            abilities = cached_abilities_of_unit\n        else:\n            abilities = (await self.get_available_abilities([unit], ignore_resource_requirements=False))[0]\n\n        if ability_id in abilities:\n            if only_check_energy_and_cooldown:\n                return True\n            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\n            ability_target = self._game_data.abilities[ability_id.value]._proto.target\n            # Check if target is in range (or is a self cast like stimpack)\n            if (\n                ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, Point2)\n                and unit.distance_to(target) <= unit.radius + target.radius + cast_range\n            ):  # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\n                return True\n            # Check if able to use ability on a unit\n            elif (\n                ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit)\n                and unit.distance_to(target) <= unit.radius + target.radius + cast_range\n            ):\n                return True\n            # Check if able to use ability on a position\n            elif (\n                ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, Point2)\n                and unit.distance_to(target) <= unit.radius + cast_range\n            ):\n                return True\n        return False\n\n    def select_build_worker(self, pos: Union[Unit, Point2], force: bool = False) -> Optional[Unit]:\n        \"\"\"Select a worker to build a building with.\n\n        Example::\n\n            barracks_placement_position = self.main_base_ramp.barracks_correct_placement\n            worker = self.select_build_worker(barracks_placement_position)\n            # Can return None\n            if worker:\n                worker.build(UnitTypeId.BARRACKS, barracks_placement_position)\n\n        :param pos:\n        :param force:\"\"\"\n        workers = (\n            self.workers.filter(lambda w: (w.is_gathering or w.is_idle) and w.distance_to(pos) < 20) or self.workers\n        )\n        if workers:\n            for worker in workers.sorted_by_distance_to(pos).prefer_idle:\n                if (\n                    worker not in self.unit_tags_received_action and not worker.orders or len(worker.orders) == 1\n                    and worker.orders[0].ability.id in {AbilityId.MOVE, AbilityId.HARVEST_GATHER}\n                ):\n                    return worker\n\n            return workers.random if force else None\n\n    async def can_place_single(self, building: Union[AbilityId, UnitTypeId], position: Point2) -> bool:\n        \"\"\" Checks the placement for only one position. \"\"\"\n        if isinstance(building, UnitTypeId):\n            creation_ability = self._game_data.units[building.value].creation_ability.id\n            return (await self._client._query_building_placement_fast(creation_ability, [position]))[0]\n        return (await self._client._query_building_placement_fast(building, [position]))[0]\n\n    async def can_place(self, building: Union[AbilityData, AbilityId, UnitTypeId],\n                        positions: List[Point2]) -> List[bool]:\n        \"\"\"Tests if a building can be placed in the given locations.\n\n        Example::\n\n            barracks_placement_position = self.main_base_ramp.barracks_correct_placement\n            worker = self.select_build_worker(barracks_placement_position)\n            # Can return None\n            if worker and (await self.can_place(UnitTypeId.BARRACKS, [barracks_placement_position])[0]:\n                worker.build(UnitTypeId.BARRACKS, barracks_placement_position)\n\n        :param building:\n        :param position:\"\"\"\n        building_type = type(building)\n        assert type(building) in {AbilityData, AbilityId, UnitTypeId}, f\"{building}, {building_type}\"\n        if building_type == UnitTypeId:\n            building = self._game_data.units[building.value].creation_ability.id\n        elif building_type == AbilityData:\n            warnings.warn(\n                \"Using AbilityData is deprecated and may be removed soon. Please use AbilityId or UnitTypeId instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            building = building_type.id\n\n        if isinstance(positions, (Point2, tuple)):\n            warnings.warn(\n                \"The support for querying single entries will be removed soon. Please use either 'await self.can_place_single(building, position)' or 'await (self.can_place(building, [position]))[0]\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            return await self.can_place_single(building, positions)\n        else:\n            assert isinstance(positions, list), f\"Expected an iterable (list, tuple), but was: {positions}\"\n            assert isinstance(\n                positions[0], Point2\n            ), f\"List is expected to have Point2, but instead had: {positions[0]} {type(positions[0])}\"\n\n        return await self._client._query_building_placement_fast(building, positions)\n\n    async def find_placement(\n        self,\n        building: Union[UnitTypeId, AbilityId],\n        near: Point2,\n        max_distance: int = 20,\n        random_alternative: bool = True,\n        placement_step: int = 2,\n        addon_place: bool = False,\n    ) -> Optional[Point2]:\n        \"\"\"Finds a placement location for building.\n\n        Example::\n\n            if self.townhalls:\n                cc = self.townhalls[0]\n                depot_position = await self.find_placement(UnitTypeId.SUPPLYDEPOT, near=cc)\n\n        :param building:\n        :param near:\n        :param max_distance:\n        :param random_alternative:\n        :param placement_step:\n        :param addon_place:\"\"\"\n\n        assert isinstance(building, (AbilityId, UnitTypeId))\n        assert isinstance(near, Point2), f\"{near} is no Point2 object\"\n\n        if isinstance(building, UnitTypeId):\n            building = self._game_data.units[building.value].creation_ability.id\n\n        if await self.can_place_single(\n            building, near\n        ) and (not addon_place or await self.can_place_single(UnitTypeId.SUPPLYDEPOT, near.offset((2.5, -0.5)))):\n            return near\n\n        if max_distance == 0:\n            return None\n\n        for distance in range(placement_step, max_distance, placement_step):\n            possible_positions = [\n                Point2(p).offset(near).to2 for p in (\n                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\n                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\n                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\n                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\n                )\n            ]\n            res = await self._client._query_building_placement_fast(building, possible_positions)\n            # Filter all positions if building can be placed\n            possible = [p for r, p in zip(res, possible_positions) if r]\n\n            if addon_place:\n                # Filter remaining positions if addon can be placed\n                res = await self._client._query_building_placement_fast(\n                    AbilityId.TERRANBUILDDROP_SUPPLYDEPOTDROP,\n                    [p.offset((2.5, -0.5)) for p in possible],\n                )\n                possible = [p for r, p in zip(res, possible) if r]\n\n            if not possible:\n                continue\n\n            if random_alternative:\n                return random.choice(possible)\n            else:\n                return min(possible, key=lambda p: p.distance_to_point2(near))\n        return None\n\n    # TODO: improve using cache per frame\n    def already_pending_upgrade(self, upgrade_type: UpgradeId) -> float:\n        \"\"\"Check if an upgrade is being researched\n\n        Returns values are::\n\n            0 # not started\n            0 < x < 1 # researching\n            1 # completed\n\n        Example::\n\n            stim_completion_percentage = self.already_pending_upgrade(UpgradeId.STIMPACK)\n\n        :param upgrade_type:\n        \"\"\"\n        assert isinstance(upgrade_type, UpgradeId), f\"{upgrade_type} is no UpgradeId\"\n        if upgrade_type in self.state.upgrades:\n            return 1\n        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.exact_id\n        for structure in self.structures.filter(lambda unit: unit.is_ready):\n            for order in structure.orders:\n                if order.ability.exact_id == creationAbilityID:\n                    return order.progress\n        return 0\n\n    @property_cache_once_per_frame_no_copy\n    def _abilities_all_units(self) -> Tuple[Counter, Dict[UnitTypeId, float]]:\n        \"\"\"Cache for the already_pending function, includes protoss units warping in,\n        all units in production and all structures, and all morphs\"\"\"\n        abilities_amount = Counter()\n        max_build_progress: Dict[UnitTypeId, float] = {}\n        unit: Unit\n        for unit in self.units + self.structures:\n            for order in unit.orders:\n                abilities_amount[order.ability] += 1\n            if not unit.is_ready:\n                if self.race != Race.Terran or not unit.is_structure:\n                    # If an SCV is constructing a building, already_pending would count this structure twice\n                    # (once from the SCV order, and once from \"not structure.is_ready\")\n                    creation_ability: AbilityData = self._game_data.units[unit.type_id.value].creation_ability\n                    abilities_amount[creation_ability] += 1\n                    max_build_progress[creation_ability] = max(\n                        max_build_progress.get(creation_ability, 0), unit.build_progress\n                    )\n\n        return abilities_amount, max_build_progress\n\n    def structure_type_build_progress(self, structure_type: Union[UnitTypeId, int]) -> float:\n        \"\"\"\n        Returns the build progress of a structure type.\n\n        Return range: 0 <= x <= 1 where\n            0: no such structure exists\n            0 < x < 1: at least one structure is under construction, returns the progress of the one with the highest progress\n            1: we have at least one such structure complete\n\n        Example::\n\n            # Assuming you have one barracks building at 0.5 build progress:\n            progress = self.structure_type_build_progress(UnitTypeId.BARRACKS)\n            print(progress)\n            # This prints out 0.5\n\n            # If you want to save up money for mutalisks, you can now save up once the spire is nearly completed:\n            spire_almost_completed: bool = self.structure_type_build_progress(UnitTypeId.SPIRE) > 0.75\n\n            # If you have a Hive completed but no lair, this function returns 1.0 for the following:\n            self.structure_type_build_progress(UnitTypeId.LAIR)\n\n            # Assume you have 2 command centers in production, one has 0.5 build_progress and the other 0.2, the following returns 0.5\n            highest_progress_of_command_center: float = self.structure_type_build_progress(UnitTypeId.COMMANDCENTER)\n\n        :param structure_type:\n        \"\"\"\n        assert isinstance(\n            structure_type, (int, UnitTypeId)\n        ), f\"Needs to be int or UnitTypeId, but was: {type(structure_type)}\"\n        if isinstance(structure_type, int):\n            structure_type_value: int = structure_type\n            structure_type = UnitTypeId(structure_type_value)\n        else:\n            structure_type_value = structure_type.value\n        assert structure_type_value, f\"structure_type can not be 0 or NOTAUNIT, but was: {structure_type_value}\"\n        equiv_values: Set[int] = {structure_type_value} | {\n            s_type.value\n            for s_type in EQUIVALENTS_FOR_TECH_PROGRESS.get(structure_type, set())\n        }\n        # SUPPLYDEPOTDROP is not in self._game_data.units, so bot_ai should not check the build progress via creation ability (worker abilities)\n        if structure_type_value not in self._game_data.units:\n            return max([s.build_progress for s in self.structures if s._proto.unit_type in equiv_values], default=0)\n        creation_ability: AbilityData = self._game_data.units[structure_type_value].creation_ability\n        max_value = max(\n            [s.build_progress for s in self.structures if s._proto.unit_type in equiv_values] +\n            [self._abilities_all_units[1].get(creation_ability, 0)],\n            default=0,\n        )\n        return max_value\n\n    def tech_requirement_progress(self, structure_type: UnitTypeId) -> float:\n        \"\"\"Returns the tech requirement progress for a specific building\n\n        Example::\n\n            # Current state: supply depot is at 50% completion\n            tech_requirement = self.tech_requirement_progress(UnitTypeId.BARRACKS)\n            print(tech_requirement) # Prints 0.5 because supply depot is half way done\n\n        Example::\n\n            # Current state: your bot has one hive, no lair\n            tech_requirement = self.tech_requirement_progress(UnitTypeId.HYDRALISKDEN)\n            print(tech_requirement) # Prints 1 because a hive exists even though only a lair is required\n\n        Example::\n\n            # Current state: One factory is flying and one is half way done\n            tech_requirement = self.tech_requirement_progress(UnitTypeId.STARPORT)\n            print(tech_requirement) # Prints 1 because even though the type id of the flying factory is different, it still has build progress of 1 and thus tech requirement is completed\n\n        :param structure_type:\"\"\"\n        race_dict = {\n            Race.Protoss: PROTOSS_TECH_REQUIREMENT,\n            Race.Terran: TERRAN_TECH_REQUIREMENT,\n            Race.Zerg: ZERG_TECH_REQUIREMENT,\n        }\n        unit_info_id = race_dict[self.race][structure_type]\n        unit_info_id_value = unit_info_id.value\n        # The following commented out line is unreliable for ghost / thor as they return 0 which is incorrect\n        # unit_info_id_value = self._game_data.units[structure_type.value]._proto.tech_requirement\n        if not unit_info_id_value:  # Equivalent to \"if unit_info_id_value == 0:\"\n            return 1\n        progresses: List[float] = [self.structure_type_build_progress(unit_info_id_value)]\n        for equiv_structure in EQUIVALENTS_FOR_TECH_PROGRESS.get(unit_info_id, []):\n            progresses.append(self.structure_type_build_progress(equiv_structure.value))\n        return max(progresses)\n\n    def already_pending(self, unit_type: Union[UpgradeId, UnitTypeId]) -> float:\n        \"\"\"\n        Returns a number of buildings or units already in progress, or if a\n        worker is en route to build it. This also includes queued orders for\n        workers and build queues of buildings.\n\n        Example::\n\n            amount_of_scv_in_production: int = self.already_pending(UnitTypeId.SCV)\n            amount_of_CCs_in_queue_and_production: int = self.already_pending(UnitTypeId.COMMANDCENTER)\n            amount_of_lairs_morphing: int = self.already_pending(UnitTypeId.LAIR)\n\n\n        :param unit_type:\n        \"\"\"\n        if isinstance(unit_type, UpgradeId):\n            return self.already_pending_upgrade(unit_type)\n        ability = self._game_data.units[unit_type.value].creation_ability\n        return self._abilities_all_units[0][ability]\n\n    @property_cache_once_per_frame_no_copy\n    def _worker_orders(self) -> Counter:\n        \"\"\" This function is used internally, do not use! It is to store all worker abilities. \"\"\"\n        abilities_amount = Counter()\n        structures_in_production: Set[Union[Point2, int]] = set()\n        for structure in self.structures:\n            if structure.type_id in TERRAN_STRUCTURES_REQUIRE_SCV:\n                structures_in_production.add(structure.position)\n                structures_in_production.add(structure.tag)\n        for worker in self.workers:\n            for order in worker.orders:\n                # Skip if the SCV is constructing (not isinstance(order.target, int))\n                # or resuming construction (isinstance(order.target, int))\n                is_int = isinstance(order.target, int)\n                if (\n                    is_int and order.target in structures_in_production\n                    or not is_int and Point2.from_proto(order.target) in structures_in_production\n                ):\n                    continue\n                abilities_amount[order.ability] += 1\n        return abilities_amount\n\n    def worker_en_route_to_build(self, unit_type: UnitTypeId) -> float:\n        \"\"\"This function counts how many workers are on the way to start the construction a building.\n        Warning: this function may change its name in the future!\n        New function. Please report any bugs!\n\n        :param unit_type:\"\"\"\n        ability = self._game_data.units[unit_type.value].creation_ability\n        return self._worker_orders[ability]\n\n    @property_cache_once_per_frame\n    def structures_without_construction_SCVs(self) -> Units:\n        \"\"\"Returns all structures that do not have an SCV constructing it.\n        Warning: this function may move to become a Units filter.\n        New function. Please report any bugs!\"\"\"\n        worker_targets: Set[Union[int, Point2]] = set()\n        for worker in self.workers:\n            # Ignore repairing workers\n            if not worker.is_constructing_scv:\n                continue\n            for order in worker.orders:\n                # When a construction is resumed, the worker.orders[0].target is the tag of the structure, else it is a Point2\n                target = order.target\n                if isinstance(target, int):\n                    worker_targets.add(target)\n                else:\n                    worker_targets.add(Point2.from_proto(target))\n        return self.structures.filter(\n            lambda structure: structure.build_progress < 1\n            # Redundant check?\n            and structure.type_id in TERRAN_STRUCTURES_REQUIRE_SCV and structure.position not in worker_targets and\n            structure.tag not in worker_targets and structure.tag in self._structures_previous_map and self.\n            _structures_previous_map[structure.tag].build_progress == structure.build_progress\n        )\n\n    async def build(\n        self,\n        building: UnitTypeId,\n        near: Union[Unit, Point2],\n        max_distance: int = 20,\n        build_worker: Optional[Unit] = None,\n        random_alternative: bool = True,\n        placement_step: int = 2,\n    ) -> bool:\n        \"\"\"Not recommended as this function checks many positions if it \"can place\" on them until it found a valid\n        position. Also if the given position is not placeable, this function tries to find a nearby position to place\n        the structure. Then uses 'self.do' to give the worker the order to start the construction.\n\n        :param building:\n        :param near:\n        :param max_distance:\n        :param build_worker:\n        :param random_alternative:\n        :param placement_step:\"\"\"\n\n        assert isinstance(near, (Unit, Point2))\n        if not self.can_afford(building):\n            return False\n        p = None\n        gas_buildings = {UnitTypeId.EXTRACTOR, UnitTypeId.ASSIMILATOR, UnitTypeId.REFINERY}\n        if isinstance(near, Unit) and building not in gas_buildings:\n            near = near.position\n        if isinstance(near, Point2):\n            near = near.to2\n        if isinstance(near, Point2):\n            p = await self.find_placement(building, near, max_distance, random_alternative, placement_step)\n            if p is None:\n                return False\n        builder = build_worker or self.select_build_worker(near)\n        if builder is None:\n            return False\n        if building in gas_buildings:\n            builder.build_gas(near)\n            return True\n        self.do(builder.build(building, p), subtract_cost=True, ignore_warning=True)\n        return True\n\n    def train(\n        self,\n        unit_type: UnitTypeId,\n        amount: int = 1,\n        closest_to: Point2 = None,\n        train_only_idle_buildings: bool = True\n    ) -> int:\n        \"\"\"Trains a specified number of units. Trains only one if amount is not specified.\n        Warning: currently has issues with warp gate warp ins\n\n        New function. Please report any bugs!\n\n        Example Zerg::\n\n            self.train(UnitTypeId.QUEEN, 5)\n            # This should queue 5 queens in 5 different townhalls if you have enough townhalls, enough minerals and enough free supply left\n\n        Example Terran::\n\n            # Assuming you have 2 idle barracks with reactors, one barracks without addon and one with techlab\n            # It should only queue 4 marines in the 2 idle barracks with reactors\n            self.train(UnitTypeId.MARINE, 4)\n\n        Example distance to::\n\n            # If you want to train based on distance to a certain point, you can use \"closest_to\"\n            self.train(UnitTypeId.MARINE, 4, closest_to = self.game_info.map_center)\n\n\n        :param unit_type:\n        :param amount:\n        :param closest_to:\n        :param train_only_idle_buildings:\"\"\"\n        # Tech requirement not met\n        if self.tech_requirement_progress(unit_type) < 1:\n            race_dict = {\n                Race.Protoss: PROTOSS_TECH_REQUIREMENT,\n                Race.Terran: TERRAN_TECH_REQUIREMENT,\n                Race.Zerg: ZERG_TECH_REQUIREMENT,\n            }\n            unit_info_id = race_dict[self.race][unit_type]\n            logger.warning(\n                \"{} Trying to produce unit {} in self.train() but tech requirement is not met: {}\".format(\n                    self.time_formatted, unit_type, unit_info_id\n                )\n            )\n            return 0\n\n        # Not affordable\n        if not self.can_afford(unit_type):\n            return 0\n\n        trained_amount = 0\n        # All train structure types: queen can made from hatchery, lair, hive\n        train_structure_type: Set[UnitTypeId] = UNIT_TRAINED_FROM[unit_type]\n        train_structures = self.structures if self.race != Race.Zerg else self.structures | self.larva\n        requires_techlab = any(\n            TRAIN_INFO[structure_type][unit_type].get(\"requires_techlab\", False)\n            for structure_type in train_structure_type\n        )\n        is_protoss = self.race == Race.Protoss\n        is_terran = self.race == Race.Terran\n        can_have_addons = any(\n            u in train_structure_type for u in {UnitTypeId.BARRACKS, UnitTypeId.FACTORY, UnitTypeId.STARPORT}\n        )\n        # Sort structures closest to a point\n        if closest_to is not None:\n            train_structures = train_structures.sorted_by_distance_to(closest_to)\n        elif can_have_addons:\n            # This should sort the structures in ascending order: first structures with reactor, then naked, then with techlab\n            train_structures = train_structures.sorted(\n                key=lambda structure: -1 * (structure.add_on_tag in self.reactor_tags) + 1 *\n                (structure.add_on_tag in self.techlab_tags)\n            )\n\n        structure: Unit\n        for structure in train_structures:\n            # Exit early if we can't afford\n            if not self.can_afford(unit_type):\n                return trained_amount\n            if (\n                # If structure hasn't received an action/order this frame\n                structure.tag not in self.unit_tags_received_action\n                # If structure can train this unit at all\n                and structure.type_id in train_structure_type\n                # Structure has to be completed to be able to train\n                and structure.build_progress == 1\n                # If structure is protoss, it needs to be powered to train\n                and (not is_protoss or structure.is_powered or structure.type_id == UnitTypeId.NEXUS)\n                # Either parameter \"train_only_idle_buildings\" is False or structure is idle or structure has less than 2 orders and has reactor\n                and (\n                    not train_only_idle_buildings\n                    or len(structure.orders) < 1 + int(structure.add_on_tag in self.reactor_tags)\n                )\n                # If structure type_id does not accept addons, it cant require a techlab\n                # Else we have to check if building has techlab as addon\n                and (not requires_techlab or structure.add_on_tag in self.techlab_tags)\n            ):\n                # Warp in at location\n                # TODO: find fast warp in locations either random location or closest to the given parameter \"closest_to\"\n                # TODO: find out which pylons have fast warp in by checking distance to nexus and warpgates.ready\n                if structure.type_id == UnitTypeId.WARPGATE:\n                    pylons = self.structures(UnitTypeId.PYLON)\n                    location = pylons.random.position.random_on_distance(4)\n                    successfully_trained = structure.warp_in(unit_type, location)\n                else:\n                    # Normal train a unit from larva or inside a structure\n                    successfully_trained = self.do(\n                        structure.train(unit_type), subtract_cost=True, subtract_supply=True, ignore_warning=True\n                    )\n                    # Check if structure has reactor: queue same unit again\n                    if (\n                        # Only terran can have reactors\n                        is_terran\n                        # Check if we have enough cost or supply for this unit type\n                        and self.can_afford(unit_type)\n                        # Structure needs to be idle in the current frame\n                        and not structure.orders\n                        # We are at least 2 away from goal\n                        and trained_amount + 1 < amount\n                        # Unit type does not require techlab\n                        and not requires_techlab\n                        # Train structure has reactor\n                        and structure.add_on_tag in self.reactor_tags\n                    ):\n                        trained_amount += 1\n                        # With one command queue=False and one queue=True, you can queue 2 marines in a reactored barracks in one frame\n                        successfully_trained = self.do(\n                            structure.train(unit_type, queue=True),\n                            subtract_cost=True,\n                            subtract_supply=True,\n                            ignore_warning=True,\n                        )\n\n                if successfully_trained:\n                    trained_amount += 1\n                    if trained_amount == amount:\n                        # Target unit train amount reached\n                        return trained_amount\n                else:\n                    # Some error occured and we couldn't train the unit\n                    return trained_amount\n        return trained_amount\n\n    def research(self, upgrade_type: UpgradeId) -> bool:\n        \"\"\"\n        Researches an upgrade from a structure that can research it, if it is idle and powered (protoss).\n        Returns True if the research was started.\n        Return False if the requirement was not met, or the bot did not have enough resources to start the upgrade,\n        or the building to research the upgrade was missing or not idle.\n\n        New function. Please report any bugs!\n\n        Example::\n\n            # Try to research zergling movement speed if we can afford it\n            # and if at least one pool is at build_progress == 1\n            # and we are not researching it yet\n            if self.already_pending_upgrade(UpgradeId.ZERGLINGMOVEMENTSPEED) == 0 and self.can_afford(UpgradeId.ZERGLINGMOVEMENTSPEED):\n                spawning_pools_ready = self.structures(UnitTypeId.SPAWNINGPOOL).ready\n                if spawning_pools_ready:\n                    self.research(UpgradeId.ZERGLINGMOVEMENTSPEED)\n\n        :param upgrade_type:\n        \"\"\"\n        assert (\n            upgrade_type in UPGRADE_RESEARCHED_FROM\n        ), f\"Could not find upgrade {upgrade_type} in 'research from'-dictionary\"\n\n        # Not affordable\n        if not self.can_afford(upgrade_type):\n            return False\n\n        research_structure_types: UnitTypeId = UPGRADE_RESEARCHED_FROM[upgrade_type]\n        required_tech_building: Optional[UnitTypeId] = RESEARCH_INFO[research_structure_types][upgrade_type].get(\n            \"required_building\", None\n        )\n\n        requirement_met = (\n            required_tech_building is None or self.structure_type_build_progress(required_tech_building) == 1\n        )\n        if not requirement_met:\n            return False\n\n        is_protoss = self.race == Race.Protoss\n\n        # All upgrades right now that can be researched in spire and hatch can also be researched in their morphs\n        equiv_structures = {\n            UnitTypeId.SPIRE: {UnitTypeId.SPIRE, UnitTypeId.GREATERSPIRE},\n            UnitTypeId.GREATERSPIRE: {UnitTypeId.SPIRE, UnitTypeId.GREATERSPIRE},\n            UnitTypeId.HATCHERY: {UnitTypeId.HATCHERY, UnitTypeId.LAIR, UnitTypeId.HIVE},\n            UnitTypeId.LAIR: {UnitTypeId.HATCHERY, UnitTypeId.LAIR, UnitTypeId.HIVE},\n            UnitTypeId.HIVE: {UnitTypeId.HATCHERY, UnitTypeId.LAIR, UnitTypeId.HIVE},\n        }\n        # Convert to a set, or equivalent structures are chosen\n        # Overlord speed upgrade can be researched from hatchery, lair or hive\n        research_structure_types: Set[UnitTypeId] = equiv_structures.get(\n            research_structure_types, {research_structure_types}\n        )\n\n        structure: Unit\n        for structure in self.structures:\n            if (\n                # Structure can research this upgrade\n                structure.type_id in research_structure_types\n                # If structure hasn't received an action/order this frame\n                and structure.tag not in self.unit_tags_received_action\n                # Structure is idle\n                and structure.is_idle\n                # Structure belongs to protoss and is powered (near pylon)\n                and (not is_protoss or structure.is_powered)\n            ):\n                # Can_afford check was already done earlier in this function\n                successful_action: bool = self.do(\n                    structure.research(upgrade_type), subtract_cost=True, ignore_warning=True\n                )\n                return successful_action\n        return False\n\n    def do(\n        self,\n        action: UnitCommand,\n        subtract_cost: bool = False,\n        subtract_supply: bool = False,\n        can_afford_check: bool = False,\n        ignore_warning: bool = False,\n    ) -> bool:\n        \"\"\"Adds a unit action to the 'self.actions' list which is then executed at the end of the frame.\n\n        Training a unit::\n\n            # Train an SCV from a random idle command center\n            cc = self.townhalls.idle.random_or(None)\n            # self.townhalls can be empty or there are no idle townhalls\n            if cc and self.can_afford(UnitTypeId.SCV):\n                cc.train(UnitTypeId.SCV)\n\n        Building a building::\n\n            # Building a barracks at the main ramp, requires 150 minerals and a depot\n            worker = self.workers.random_or(None)\n            barracks_placement_position = self.main_base_ramp.barracks_correct_placement\n            if worker and self.can_afford(UnitTypeId.BARRACKS):\n                worker.build(UnitTypeId.BARRACKS, barracks_placement_position)\n\n        Moving a unit::\n\n            # Move a random worker to the center of the map\n            worker = self.workers.random_or(None)\n            # worker can be None if all are dead\n            if worker:\n                worker.move(self.game_info.map_center)\n\n        :param action:\n        :param subtract_cost:\n        :param subtract_supply:\n        :param can_afford_check:\n        \"\"\"\n        if not self.unit_command_uses_self_do and isinstance(action, bool):\n            if not ignore_warning:\n                warnings.warn(\n                    \"You have used self.do(). Please consider putting 'self.unit_command_uses_self_do = True' in your bot __init__() function or removing self.do().\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n            return action\n\n        assert isinstance(\n            action, UnitCommand\n        ), f\"Given unit command is not a command, but instead of type {type(action)}\"\n        if subtract_cost:\n            cost: Cost = self._game_data.calculate_ability_cost(action.ability)\n            if can_afford_check and not (self.minerals >= cost.minerals and self.vespene >= cost.vespene):\n                # Dont do action if can't afford\n                return False\n            self.minerals -= cost.minerals\n            self.vespene -= cost.vespene\n        if subtract_supply and action.ability in abilityid_to_unittypeid:\n            unit_type = abilityid_to_unittypeid[action.ability]\n            required_supply = self.calculate_supply_cost(unit_type)\n            # Overlord has -8\n            if required_supply > 0:\n                self.supply_used += required_supply\n                self.supply_left -= required_supply\n        self.actions.append(action)\n        self.unit_tags_received_action.add(action.unit.tag)\n        return True\n\n    # TODO remove again, because you can just use 'self.do()' and execute '_do_actions' and 'self.actions.clear()' afterwards?\n    async def synchronous_do(self, action: UnitCommand):\n        \"\"\"\n        Not recommended. Use self.do instead to reduce lag.\n        This function is only useful for realtime=True in the first frame of the game to instantly produce a worker\n        and split workers on the mineral patches.\n        \"\"\"\n        assert isinstance(\n            action, UnitCommand\n        ), f\"Given unit command is not a command, but instead of type {type(action)}\"\n        if not self.can_afford(action.ability):\n            logger.warning(f\"Cannot afford action {action}\")\n            return ActionResult.Error\n        r = await self._client.actions(action)\n        if not r:  # success\n            cost = self._game_data.calculate_ability_cost(action.ability)\n            self.minerals -= cost.minerals\n            self.vespene -= cost.vespene\n            self.unit_tags_received_action.add(action.unit.tag)\n        else:\n            logger.error(f\"Error: {r} (action: {action})\")\n        return r\n\n    async def _do_actions(self, actions: List[UnitCommand], prevent_double: bool = True):\n        \"\"\"Used internally by main.py automatically, use self.do() instead!\n\n        :param actions:\n        :param prevent_double:\"\"\"\n        if not actions:\n            return None\n        if prevent_double:\n            actions = list(filter(self.prevent_double_actions, actions))\n        result = await self._client.actions(actions)\n        return result\n\n    def prevent_double_actions(self, action) -> bool:\n        \"\"\"\n        :param action:\n        \"\"\"\n        # Always add actions if queued\n        if action.queue:\n            return True\n        if action.unit.orders:\n            # action: UnitCommand\n            # current_action: UnitOrder\n            current_action = action.unit.orders[0]\n            if current_action.ability.id != action.ability and current_action.ability.exact_id != action.ability:\n                # Different action, return True\n                return True\n            with suppress(AttributeError):\n                if current_action.target == action.target.tag:\n                    # Same action, remove action if same target unit\n                    return False\n            with suppress(AttributeError):\n                if action.target.x == current_action.target.x and action.target.y == current_action.target.y:\n                    # Same action, remove action if same target position\n                    return False\n            return True\n        return True\n\n    async def chat_send(self, message: str, team_only: bool = False):\n        \"\"\"Send a chat message to the SC2 Client.\n\n        Example::\n\n            await self.chat_send(\"Hello, this is a message from my bot!\")\n\n        :param message:\n        :param team_only:\"\"\"\n        assert isinstance(message, str), f\"{message} is not a string\"\n        await self._client.chat_send(message, team_only)\n\n    def in_map_bounds(self, pos: Union[Point2, tuple, list]) -> bool:\n        \"\"\"Tests if a 2 dimensional point is within the map boundaries of the pixelmaps.\n        :param pos:\"\"\"\n        return (\n            self._game_info.playable_area.x <= pos[0] <\n            self._game_info.playable_area.x + self.game_info.playable_area.width and self._game_info.playable_area.y <=\n            pos[1] < self._game_info.playable_area.y + self.game_info.playable_area.height\n        )\n\n    # For the functions below, make sure you are inside the boundaries of the map size.\n    def get_terrain_height(self, pos: Union[Point2, Unit]) -> int:\n        \"\"\"Returns terrain height at a position.\n        Caution: terrain height is different from a unit's z-coordinate.\n\n        :param pos:\"\"\"\n        assert isinstance(pos, (Point2, Unit)), f\"pos is not of type Point2 or Unit\"\n        pos = pos.position.rounded\n        return self._game_info.terrain_height[pos]\n\n    def get_terrain_z_height(self, pos: Union[Point2, Unit]) -> float:\n        \"\"\"Returns terrain z-height at a position.\n\n        :param pos:\"\"\"\n        assert isinstance(pos, (Point2, Unit)), f\"pos is not of type Point2 or Unit\"\n        pos = pos.position.rounded\n        return -16 + 32 * self._game_info.terrain_height[pos] / 255\n\n    def in_placement_grid(self, pos: Union[Point2, Unit]) -> bool:\n        \"\"\"Returns True if you can place something at a position.\n        Remember, buildings usually use 2x2, 3x3 or 5x5 of these grid points.\n        Caution: some x and y offset might be required, see ramp code in game_info.py\n\n        :param pos:\"\"\"\n        assert isinstance(pos, (Point2, Unit)), f\"pos is not of type Point2 or Unit\"\n        pos = pos.position.rounded\n        return self._game_info.placement_grid[pos] == 1\n\n    def in_pathing_grid(self, pos: Union[Point2, Unit]) -> bool:\n        \"\"\"Returns True if a ground unit can pass through a grid point.\n\n        :param pos:\"\"\"\n        assert isinstance(pos, (Point2, Unit)), f\"pos is not of type Point2 or Unit\"\n        pos = pos.position.rounded\n        return self._game_info.pathing_grid[pos] == 1\n\n    def is_visible(self, pos: Union[Point2, Unit]) -> bool:\n        \"\"\"Returns True if you have vision on a grid point.\n\n        :param pos:\"\"\"\n        # more info: https://github.com/Blizzard/s2client-proto/blob/9906df71d6909511907d8419b33acc1a3bd51ec0/s2clientprotocol/spatial.proto#L19\n        assert isinstance(pos, (Point2, Unit)), f\"pos is not of type Point2 or Unit\"\n        pos = pos.position.rounded\n        return self.state.visibility[pos] == 2\n\n    def has_creep(self, pos: Union[Point2, Unit]) -> bool:\n        \"\"\"Returns True if there is creep on the grid point.\n\n        :param pos:\"\"\"\n        assert isinstance(pos, (Point2, Unit)), f\"pos is not of type Point2 or Unit\"\n        pos = pos.position.rounded\n        return self.state.creep[pos] == 1\n\n    def _prepare_start(self, client, player_id, game_info, game_data, realtime: bool = False, base_build: int = -1):\n        \"\"\"\n        Ran until game start to set game and player data.\n\n        :param client:\n        :param player_id:\n        :param game_info:\n        :param game_data:\n        :param realtime:\n        \"\"\"\n        self._client: Client = client\n        self.player_id: int = player_id\n        self._game_info: GameInfo = game_info\n        self._game_data: GameData = game_data\n        self.realtime: bool = realtime\n        self.base_build: int = base_build\n\n        self.race: Race = Race(self._game_info.player_races[self.player_id])\n\n        if len(self._game_info.player_races) == 2:\n            self.enemy_race: Race = Race(self._game_info.player_races[3 - self.player_id])\n\n        self._distances_override_functions(self.distance_calculation_method)\n\n    def _prepare_first_step(self):\n        \"\"\"First step extra preparations. Must not be called before _prepare_step.\"\"\"\n        if self.townhalls:\n            self._game_info.player_start_location = self.townhalls.first.position\n            # Calculate and cache expansion locations forever inside 'self._cache_expansion_locations', this is done to prevent a bug when this is run and cached later in the game\n            _ = self._find_expansion_locations()\n        self._game_info.map_ramps, self._game_info.vision_blockers = self._game_info._find_ramps_and_vision_blockers()\n        self._time_before_step: float = time.perf_counter()\n\n    def _prepare_step(self, state, proto_game_info):\n        \"\"\"\n        :param state:\n        :param proto_game_info:\n        \"\"\"\n        # Set attributes from new state before on_step.\"\"\"\n        self.state: GameState = state  # See game_state.py\n        # update pathing grid, which unfortunately is in GameInfo instead of GameState\n        self._game_info.pathing_grid: PixelMap = PixelMap(\n            proto_game_info.game_info.start_raw.pathing_grid, in_bits=True, mirrored=False\n        )\n        # Required for events, needs to be before self.units are initialized so the old units are stored\n        self._units_previous_map: Dict[int, Unit] = {unit.tag: unit for unit in self.units}\n        self._structures_previous_map: Dict[int, Unit] = {structure.tag: structure for structure in self.structures}\n        self._enemy_units_previous_map: Dict[int, Unit] = {unit.tag: unit for unit in self.enemy_units}\n        self._enemy_structures_previous_map: Dict[int, Unit] = {\n            structure.tag: structure\n            for structure in self.enemy_structures\n        }\n        self._all_units_previous_map: Dict[int, Unit] = {unit.tag: unit for unit in self.all_units}\n\n        self._prepare_units()\n        self.minerals: int = state.common.minerals\n        self.vespene: int = state.common.vespene\n        self.supply_army: int = state.common.food_army\n        self.supply_workers: int = state.common.food_workers  # Doesn't include workers in production\n        self.supply_cap: int = state.common.food_cap\n        self.supply_used: int = state.common.food_used\n        self.supply_left: int = self.supply_cap - self.supply_used\n\n        if self.race == Race.Zerg:\n            # Workaround Zerg supply rounding bug\n            self._correct_zerg_supply()\n        elif self.race == Race.Protoss:\n            self.warp_gate_count: int = state.common.warp_gate_count\n\n        self.idle_worker_count: int = state.common.idle_worker_count\n        self.army_count: int = state.common.army_count\n        self._time_before_step: float = time.perf_counter()\n\n        if self.enemy_race == Race.Random and self.all_enemy_units:\n            self.enemy_race = Race(self.all_enemy_units.first.race)\n\n    def _prepare_units(self):\n        # Set of enemy units detected by own sensor tower, as blips have less unit information than normal visible units\n        self.blips: Set[Blip] = set()\n        self.all_units: Units = Units([], self)\n        self.units: Units = Units([], self)\n        self.workers: Units = Units([], self)\n        self.larva: Units = Units([], self)\n        self.structures: Units = Units([], self)\n        self.townhalls: Units = Units([], self)\n        self.gas_buildings: Units = Units([], self)\n        self.all_own_units: Units = Units([], self)\n        self.enemy_units: Units = Units([], self)\n        self.enemy_structures: Units = Units([], self)\n        self.all_enemy_units: Units = Units([], self)\n        self.resources: Units = Units([], self)\n        self.destructables: Units = Units([], self)\n        self.watchtowers: Units = Units([], self)\n        self.mineral_field: Units = Units([], self)\n        self.vespene_geyser: Units = Units([], self)\n        self.placeholders: Units = Units([], self)\n        self.techlab_tags: Set[int] = set()\n        self.reactor_tags: Set[int] = set()\n\n        worker_types: Set[UnitTypeId] = {UnitTypeId.DRONE, UnitTypeId.DRONEBURROWED, UnitTypeId.SCV, UnitTypeId.PROBE}\n\n        index: int = 0\n        for unit in self.state.observation_raw.units:\n            if unit.is_blip:\n                self.blips.add(Blip(unit))\n            else:\n                unit_type: int = unit.unit_type\n                # Convert these units to effects: reaper grenade, parasitic bomb dummy, forcefield\n                if unit_type in FakeEffectID:\n                    self.state.effects.add(EffectData(unit, fake=True))\n                    continue\n                unit_obj = Unit(unit, self, distance_calculation_index=index, base_build=self.base_build)\n                index += 1\n                self.all_units.append(unit_obj)\n                if unit.display_type == IS_PLACEHOLDER:\n                    self.placeholders.append(unit_obj)\n                    continue\n                alliance = unit.alliance\n                # Alliance.Neutral.value = 3\n                if alliance == 3:\n                    # XELNAGATOWER = 149\n                    if unit_type == 149:\n                        self.watchtowers.append(unit_obj)\n                    # mineral field enums\n                    elif unit_type in mineral_ids:\n                        self.mineral_field.append(unit_obj)\n                        self.resources.append(unit_obj)\n                    # geyser enums\n                    elif unit_type in geyser_ids:\n                        self.vespene_geyser.append(unit_obj)\n                        self.resources.append(unit_obj)\n                    # all destructable rocks\n                    else:\n                        self.destructables.append(unit_obj)\n                # Alliance.Self.value = 1\n                elif alliance == 1:\n                    self.all_own_units.append(unit_obj)\n                    unit_id = unit_obj.type_id\n                    if unit_obj.is_structure:\n                        self.structures.append(unit_obj)\n                        if unit_id in race_townhalls[self.race]:\n                            self.townhalls.append(unit_obj)\n                        elif unit_id in ALL_GAS or unit_obj.vespene_contents:\n                            # TODO: remove \"or unit_obj.vespene_contents\" when a new linux client newer than version 4.10.0 is released\n                            self.gas_buildings.append(unit_obj)\n                        elif unit_id in {\n                            UnitTypeId.TECHLAB,\n                            UnitTypeId.BARRACKSTECHLAB,\n                            UnitTypeId.FACTORYTECHLAB,\n                            UnitTypeId.STARPORTTECHLAB,\n                        }:\n                            self.techlab_tags.add(unit_obj.tag)\n                        elif unit_id in {\n                            UnitTypeId.REACTOR,\n                            UnitTypeId.BARRACKSREACTOR,\n                            UnitTypeId.FACTORYREACTOR,\n                            UnitTypeId.STARPORTREACTOR,\n                        }:\n                            self.reactor_tags.add(unit_obj.tag)\n                    else:\n                        self.units.append(unit_obj)\n                        if unit_id in worker_types:\n                            self.workers.append(unit_obj)\n                        elif unit_id == UnitTypeId.LARVA:\n                            self.larva.append(unit_obj)\n                # Alliance.Enemy.value = 4\n                elif alliance == 4:\n                    self.all_enemy_units.append(unit_obj)\n                    if unit_obj.is_structure:\n                        self.enemy_structures.append(unit_obj)\n                    else:\n                        self.enemy_units.append(unit_obj)\n\n        # Force distance calculation and caching on all units using scipy pdist or cdist\n        if self.distance_calculation_method == 1:\n            _ = self._pdist\n        elif self.distance_calculation_method in {2, 3}:\n            _ = self._cdist\n\n    async def _after_step(self) -> int:\n        \"\"\" Executed by main.py after each on_step function. \"\"\"\n        # Keep track of the bot on_step duration\n        self._time_after_step: float = time.perf_counter()\n        step_duration = self._time_after_step - self._time_before_step\n        self._min_step_time = min(step_duration, self._min_step_time)\n        self._max_step_time = max(step_duration, self._max_step_time)\n        self._last_step_step_time = step_duration\n        self._total_time_in_on_step += step_duration\n        self._total_steps_iterations += 1\n        # Commit and clear bot actions\n        if self.actions:\n            await self._do_actions(self.actions)\n            self.actions.clear()\n        # Clear set of unit tags that were given an order this frame by self.do()\n        self.unit_tags_received_action.clear()\n        # Commit debug queries\n        await self._client._send_debug()\n\n        return self.state.game_loop\n\n    async def _advance_steps(self, steps: int):\n        \"\"\"Advances the game loop by amount of 'steps'. This function is meant to be used as a debugging and testing tool only.\n        If you are using this, please be aware of the consequences, e.g. 'self.units' will be filled with completely new data.\"\"\"\n        await self._after_step()\n        # Advance simulation by exactly \"steps\" frames\n        await self.client.step(steps)\n        state = await self.client.observation()\n        gs = GameState(state.observation)\n        proto_game_info = await self.client._execute(game_info=sc_pb.RequestGameInfo())\n        self._prepare_step(gs, proto_game_info)\n        await self.issue_events()\n        # await self.on_step(-1)\n\n    async def issue_events(self):\n        \"\"\"This function will be automatically run from main.py and triggers the following functions:\n        - on_unit_created\n        - on_unit_destroyed\n        - on_building_construction_started\n        - on_building_construction_complete\n        - on_upgrade_complete\n        \"\"\"\n        await self._issue_unit_dead_events()\n        await self._issue_unit_added_events()\n        await self._issue_building_events()\n        await self._issue_upgrade_events()\n        await self._issue_vision_events()\n\n    async def _issue_unit_added_events(self):\n        for unit in self.units:\n            if unit.tag not in self._units_previous_map and unit.tag not in self._unit_tags_seen_this_game:\n                self._unit_tags_seen_this_game.add(unit.tag)\n                self._units_created[unit.type_id] += 1\n                await self.on_unit_created(unit)\n            elif unit.tag in self._units_previous_map:\n                previous_frame_unit: Unit = self._units_previous_map[unit.tag]\n                # Check if a unit took damage this frame and then trigger event\n                if unit.health < previous_frame_unit.health or unit.shield < previous_frame_unit.shield:\n                    damage_amount = previous_frame_unit.health - unit.health + previous_frame_unit.shield - unit.shield\n                    await self.on_unit_took_damage(unit, damage_amount)\n                # Check if a unit type has changed\n                if previous_frame_unit.type_id != unit.type_id:\n                    await self.on_unit_type_changed(unit, previous_frame_unit.type_id)\n\n    async def _issue_upgrade_events(self):\n        difference = self.state.upgrades - self._previous_upgrades\n        for upgrade_completed in difference:\n            await self.on_upgrade_complete(upgrade_completed)\n        self._previous_upgrades = self.state.upgrades\n\n    async def _issue_building_events(self):\n        for structure in self.structures:\n            if structure.tag not in self._structures_previous_map:\n                if structure.build_progress < 1:\n                    await self.on_building_construction_started(structure)\n                else:\n                    # Include starting townhall\n                    self._units_created[structure.type_id] += 1\n                    await self.on_building_construction_complete(structure)\n            elif structure.tag in self._structures_previous_map:\n                # Check if a structure took damage this frame and then trigger event\n                previous_frame_structure: Unit = self._structures_previous_map[structure.tag]\n                if (\n                    structure.health < previous_frame_structure.health\n                    or structure.shield < previous_frame_structure.shield\n                ):\n                    damage_amount = (\n                        previous_frame_structure.health - structure.health + previous_frame_structure.shield -\n                        structure.shield\n                    )\n                    await self.on_unit_took_damage(structure, damage_amount)\n                # Check if a structure changed its type\n                if previous_frame_structure.type_id != structure.type_id:\n                    await self.on_unit_type_changed(structure, previous_frame_structure.type_id)\n                # Check if structure completed\n                if structure.build_progress == 1 and previous_frame_structure.build_progress < 1:\n                    self._units_created[structure.type_id] += 1\n                    await self.on_building_construction_complete(structure)\n\n    async def _issue_vision_events(self):\n        # Call events for enemy unit entered vision\n        for enemy_unit in self.enemy_units:\n            if enemy_unit.tag not in self._enemy_units_previous_map:\n                await self.on_enemy_unit_entered_vision(enemy_unit)\n        for enemy_structure in self.enemy_structures:\n            if enemy_structure.tag not in self._enemy_structures_previous_map:\n                await self.on_enemy_unit_entered_vision(enemy_structure)\n\n        # Call events for enemy unit left vision\n        enemy_units_left_vision: Set[int] = set(self._enemy_units_previous_map.keys()) - self.enemy_units.tags\n        for enemy_unit_tag in enemy_units_left_vision:\n            await self.on_enemy_unit_left_vision(enemy_unit_tag)\n        enemy_structures_left_vision: Set[int] = (\n            set(self._enemy_structures_previous_map.keys()) - self.enemy_structures.tags\n        )\n        for enemy_structure_tag in enemy_structures_left_vision:\n            await self.on_enemy_unit_left_vision(enemy_structure_tag)\n\n    async def _issue_unit_dead_events(self):\n        for unit_tag in self.state.dead_units & set(self._all_units_previous_map.keys()):\n            await self.on_unit_destroyed(unit_tag)\n\n    async def on_unit_destroyed(self, unit_tag: int):\n        \"\"\"\n        Override this in your bot class.\n        Note that this function uses unit tags and not the unit objects\n        because the unit does not exist any more.\n        This will event will be called when a unit (or structure, friendly or enemy) dies.\n        For enemy units, this only works if the enemy unit was in vision on death.\n\n        :param unit_tag:\n        \"\"\"\n\n    async def on_unit_created(self, unit: Unit):\n        \"\"\"Override this in your bot class. This function is called when a unit is created.\n\n        :param unit:\"\"\"\n\n    async def on_unit_type_changed(self, unit: Unit, previous_type: UnitTypeId):\n        \"\"\"Override this in your bot class. This function is called when a unit type has changed. To get the current UnitTypeId of the unit, use 'unit.type_id'\n\n        This may happen when a larva morphed to an egg, siege tank sieged, a zerg unit burrowed, a hatchery morphed to lair,\n        a corruptor morphed to broodlordcocoon, etc..\n\n        Examples::\n\n            print(f\"My unit changed type: {unit} from {previous_type} to {unit.type_id}\")\n\n        :param unit:\n        :param previous_type:\n        \"\"\"\n\n    async def on_building_construction_started(self, unit: Unit):\n        \"\"\"\n        Override this in your bot class.\n        This function is called when a building construction has started.\n\n        :param unit:\n        \"\"\"\n\n    async def on_building_construction_complete(self, unit: Unit):\n        \"\"\"\n        Override this in your bot class. This function is called when a building\n        construction is completed.\n\n        :param unit:\n        \"\"\"\n\n    async def on_upgrade_complete(self, upgrade: UpgradeId):\n        \"\"\"\n        Override this in your bot class. This function is called with the upgrade id of an upgrade that was not finished last step and is now.\n\n        :param upgrade:\n        \"\"\"\n\n    async def on_unit_took_damage(self, unit: Unit, amount_damage_taken: float):\n        \"\"\"\n        Override this in your bot class. This function is called when your own unit (unit or structure) took damage.\n        It will not be called if the unit died this frame.\n\n        This may be called frequently for terran structures that are burning down, or zerg buildings that are off creep,\n        or terran bio units that just used stimpack ability.\n        TODO: If there is a demand for it, then I can add a similar event for when enemy units took damage\n\n        Examples::\n\n            print(f\"My unit took damage: {unit} took {amount_damage_taken} damage\")\n\n        :param unit:\n        \"\"\"\n\n    async def on_enemy_unit_entered_vision(self, unit: Unit):\n        \"\"\"\n        Override this in your bot class. This function is called when an enemy unit (unit or structure) entered vision (which was not visible last frame).\n\n        :param unit:\n        \"\"\"\n\n    async def on_enemy_unit_left_vision(self, unit_tag: int):\n        \"\"\"\n        Override this in your bot class. This function is called when an enemy unit (unit or structure) left vision (which was visible last frame).\n        Same as the self.on_unit_destroyed event, this function is called with the unit's tag because the unit is no longer visible anymore.\n        If you want to store a snapshot of the unit, use self._enemy_units_previous_map[unit_tag] for units or self._enemy_structures_previous_map[unit_tag] for structures.\n\n        Examples::\n\n            last_known_unit = self._enemy_units_previous_map.get(unit_tag, None) or self._enemy_structures_previous_map[unit_tag]\n            print(f\"Enemy unit left vision, last known location: {last_known_unit.position}\")\n\n        :param unit_tag:\n        \"\"\"\n\n    async def on_before_start(self):\n        \"\"\"\n        Override this in your bot class. This function is called before \"on_start\"\n        and before \"prepare_first_step\" that calculates expansion locations.\n        Not all data is available yet.\n        This function is useful in realtime=True mode to split your workers or start producing the first worker.\n        \"\"\"\n\n    async def on_start(self):\n        \"\"\"\n        Override this in your bot class.\n        At this point, game_data, game_info and the first iteration of game_state (self.state) are available.\n        \"\"\"\n\n    async def on_step(self, iteration: int):\n        \"\"\"\n        You need to implement this function!\n        Override this in your bot class.\n        This function is called on every game step (looped in realtime mode).\n\n        :param iteration:\n        \"\"\"\n        raise NotImplementedError\n\n    async def on_end(self, game_result: Result):\n        \"\"\"Override this in your bot class. This function is called at the end of a game.\n        Unsure if this function will be called on the laddermanager client as the bot process may forcefully be terminated.\n\n        :param game_result:\"\"\"",
  "def _initialize_variables(self):\n        \"\"\" Called from main.py internally \"\"\"\n        DistanceCalculation.__init__(self)\n        # Specific opponent bot ID used in sc2ai ladder games http://sc2ai.net/ and on ai arena https://aiarena.net\n        # The bot ID will stay the same each game so your bot can \"adapt\" to the opponent\n        if not hasattr(self, \"opponent_id\"):\n            # Prevent overwriting the opponent_id which is set here https://github.com/Hannessa/python-sc2-ladderbot/blob/master/__init__.py#L40\n            # otherwise set it to None\n            self.opponent_id: str = None\n        # Select distance calculation method, see distances.py: _distances_override_functions function\n        if not hasattr(self, \"distance_calculation_method\"):\n            self.distance_calculation_method: int = 2\n        # Select if the Unit.command should return UnitCommand objects. Set this to True if your bot uses 'self.do(unit(ability, target))'\n        if not hasattr(self, \"unit_command_uses_self_do\"):\n            self.unit_command_uses_self_do: bool = False\n        # This value will be set to True by main.py in self._prepare_start if game is played in realtime (if true, the bot will have limited time per step)\n        self.realtime: bool = False\n        self.base_build: int = -1\n        self.all_units: Units = Units([], self)\n        self.units: Units = Units([], self)\n        self.workers: Units = Units([], self)\n        self.larva: Units = Units([], self)\n        self.structures: Units = Units([], self)\n        self.townhalls: Units = Units([], self)\n        self.gas_buildings: Units = Units([], self)\n        self.all_own_units: Units = Units([], self)\n        self.enemy_units: Units = Units([], self)\n        self.enemy_structures: Units = Units([], self)\n        self.all_enemy_units: Units = Units([], self)\n        self.resources: Units = Units([], self)\n        self.destructables: Units = Units([], self)\n        self.watchtowers: Units = Units([], self)\n        self.mineral_field: Units = Units([], self)\n        self.vespene_geyser: Units = Units([], self)\n        self.placeholders: Units = Units([], self)\n        self.techlab_tags: Set[int] = set()\n        self.reactor_tags: Set[int] = set()\n        self.minerals: int = 50\n        self.vespene: int = 0\n        self.supply_army: float = 0\n        self.supply_workers: float = 12  # Doesn't include workers in production\n        self.supply_cap: float = 15\n        self.supply_used: float = 12\n        self.supply_left: float = 3\n        self.idle_worker_count: int = 0\n        self.army_count: int = 0\n        self.warp_gate_count: int = 0\n        self.actions: List[UnitCommand] = []\n        self.blips: Set[Blip] = set()\n        self.race: Race = None\n        self.enemy_race: Race = None\n        self._units_created: Counter = Counter()\n        self._unit_tags_seen_this_game: Set[int] = set()\n        self._units_previous_map: Dict[int, Unit] = {}\n        self._structures_previous_map: Dict[int, Unit] = {}\n        self._enemy_units_previous_map: Dict[int, Unit] = {}\n        self._enemy_structures_previous_map: Dict[int, Unit] = {}\n        self._all_units_previous_map: Dict[int, Unit] = {}\n        self._previous_upgrades: Set[UpgradeId] = set()\n        self._expansion_positions_list: List[Point2] = []\n        self._resource_location_to_expansion_position_dict: Dict[Point2, Point2] = {}\n        self._time_before_step: float = None\n        self._time_after_step: float = None\n        self._min_step_time: float = math.inf\n        self._max_step_time: float = 0\n        self._last_step_step_time: float = 0\n        self._total_time_in_on_step: float = 0\n        self._total_steps_iterations: int = 0\n        # Internally used to keep track which units received an action in this frame, so that self.train() function does not give the same larva two orders - cleared every frame\n        self.unit_tags_received_action: Set[int] = set()",
  "def time(self) -> float:\n        \"\"\" Returns time in seconds, assumes the game is played on 'faster' \"\"\"\n        return self.state.game_loop / 22.4",
  "def time_formatted(self) -> str:\n        \"\"\" Returns time as string in min:sec format \"\"\"\n        t = self.time\n        return f\"{int(t // 60):02}:{int(t % 60):02}\"",
  "def step_time(self) -> Tuple[float, float, float, float]:\n        \"\"\"Returns a tuple of step duration in milliseconds.\n        First value is the minimum step duration - the shortest the bot ever took\n        Second value is the average step duration\n        Third value is the maximum step duration - the longest the bot ever took (including on_start())\n        Fourth value is the step duration the bot took last iteration\n        If called in the first iteration, it returns (inf, 0, 0, 0)\"\"\"\n        avg_step_duration = (\n            (self._total_time_in_on_step / self._total_steps_iterations) if self._total_steps_iterations else 0\n        )\n        return (\n            self._min_step_time * 1000,\n            avg_step_duration * 1000,\n            self._max_step_time * 1000,\n            self._last_step_step_time * 1000,\n        )",
  "def game_info(self) -> GameInfo:\n        \"\"\" See game_info.py \"\"\"\n        return self._game_info",
  "def game_data(self) -> GameData:\n        \"\"\" See game_data.py \"\"\"\n        return self._game_data",
  "def client(self) -> Client:\n        \"\"\" See client.py \"\"\"\n        return self._client",
  "def larva_count(self):\n        \"\"\" Replacement for self.state.common.larva_count https://github.com/Blizzard/s2client-proto/blob/d3d18392f9d7c646067d447df0c936a8ca57d587/s2clientprotocol/sc2api.proto#L614 \"\"\"\n        warnings.warn(\n            \"self.larva_count will be removed soon, please use len(self.larva) or self.larva.amount instead\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return len(self.larva)",
  "def alert(self, alert_code: Alert) -> bool:\n        \"\"\"\n        Check if alert is triggered in the current step.\n        Possible alerts are listed here https://github.com/Blizzard/s2client-proto/blob/e38efed74c03bec90f74b330ea1adda9215e655f/s2clientprotocol/sc2api.proto#L679-L702\n\n        Example use::\n\n            from sc2.data import Alert\n            if self.alert(Alert.AddOnComplete):\n                print(\"Addon Complete\")\n\n        Alert codes::\n\n            AlertError\n            AddOnComplete\n            BuildingComplete\n            BuildingUnderAttack\n            LarvaHatched\n            MergeComplete\n            MineralsExhausted\n            MorphComplete\n            MothershipComplete\n            MULEExpired\n            NuclearLaunchDetected\n            NukeComplete\n            NydusWormDetected\n            ResearchComplete\n            TrainError\n            TrainUnitComplete\n            TrainWorkerComplete\n            TransformationComplete\n            UnitUnderAttack\n            UpgradeComplete\n            VespeneExhausted\n            WarpInComplete\n\n        :param alert_code:\n        \"\"\"\n        assert isinstance(alert_code, Alert), f\"alert_code {alert_code} is no Alert\"\n        return alert_code.value in self.state.alerts",
  "def start_location(self) -> Point2:\n        \"\"\"\n        Returns the spawn location of the bot, using the position of the first created townhall.\n        This will be None if the bot is run on an arcade or custom map that does not feature townhalls at game start.\n        \"\"\"\n        return self._game_info.player_start_location",
  "def enemy_start_locations(self) -> List[Point2]:\n        \"\"\"Possible start locations for enemies.\"\"\"\n        return self._game_info.start_locations",
  "def main_base_ramp(self) -> Ramp:\n        \"\"\"Returns the Ramp instance of the closest main-ramp to start location.\n        Look in game_info.py for more information about the Ramp class\n\n        Example: See terran ramp wall bot\n        \"\"\"\n        if hasattr(self, \"cached_main_base_ramp\"):\n            return self.cached_main_base_ramp\n        # The reason for len(ramp.upper) in {2, 5} is:\n        # ParaSite map has 5 upper points, and most other maps have 2 upper points at the main ramp.\n        # The map Acolyte has 4 upper points at the wrong ramp (which is closest to the start position).\n        try:\n            self.cached_main_base_ramp = min(\n                (ramp for ramp in self.game_info.map_ramps if len(ramp.upper) in {2, 5}),\n                key=lambda r: self.start_location.distance_to(r.top_center),\n            )\n        except ValueError:\n            # Hardcoded hotfix for Honorgrounds LE map, as that map has a large main base ramp with inbase natural\n            self.cached_main_base_ramp = min(\n                (ramp for ramp in self.game_info.map_ramps if len(ramp.upper) in {4, 9}),\n                key=lambda r: self.start_location.distance_to(r.top_center),\n            )\n        return self.cached_main_base_ramp",
  "def expansion_locations_list(self) -> List[Point2]:\n        \"\"\" Returns a list of expansion positions, not sorted in any way. \"\"\"\n        assert (\n            self._expansion_positions_list\n        ), f\"self._find_expansion_locations() has not been run yet, so accessing the list of expansion locations is pointless.\"\n        return self._expansion_positions_list",
  "def expansion_locations_dict(self) -> Dict[Point2, Units]:\n        \"\"\"\n        Returns dict with the correct expansion position Point2 object as key,\n        resources as Units (mineral fields and vespene geysers) as value.\n\n        Caution: This function is slow. If you only need the expansion locations, use the property above.\n        \"\"\"\n        assert (\n            self._expansion_positions_list\n        ), f\"self._find_expansion_locations() has not been run yet, so accessing the list of expansion locations is pointless.\"\n        expansion_locations: Dict[Point2, Units] = {pos: Units([], self) for pos in self._expansion_positions_list}\n        for resource in self.resources:\n            # It may be that some resources are not mapped to an expansion location\n            exp_position: Point2 = self._resource_location_to_expansion_position_dict.get(resource.position, None)\n            if exp_position:\n                assert exp_position in expansion_locations\n                expansion_locations[exp_position].append(resource)\n        return expansion_locations",
  "def expansion_locations(self) -> Dict[Point2, Units]:\n        \"\"\" Same as the function above. \"\"\"\n        assert (\n            self._expansion_positions_list\n        ), f\"self._find_expansion_locations() has not been run yet, so accessing the list of expansion locations is pointless.\"\n        warnings.warn(\n            f\"You are using 'self.expansion_locations', please use 'self.expansion_locations_list' (fast) or 'self.expansion_locations_dict' (slow) instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.expansion_locations_dict",
  "def _find_expansion_locations(self):\n        \"\"\" Ran once at the start of the game to calculate expansion locations. \"\"\"\n        # Idea: create a group for every resource, then merge these groups if\n        # any resource in a group is closer than a threshold to any resource of another group\n\n        # Distance we group resources by\n        resource_spread_threshold: float = 8.5\n        geysers: Units = self.vespene_geyser\n        # Create a group for every resource\n        resource_groups: List[List[Unit]] = [\n            [resource] for resource in self.resources\n            if resource.name != \"MineralField450\"  # dont use low mineral count patches\n        ]\n        # Loop the merging process as long as we change something\n        merged_group = True\n        while merged_group:\n            merged_group = False\n            # Check every combination of two groups\n            for group_a, group_b in itertools.combinations(resource_groups, 2):\n                # Check if any pair of resource of these groups is closer than threshold together\n                if any(\n                    resource_a.distance_to(resource_b) <= resource_spread_threshold\n                    for resource_a, resource_b in itertools.product(group_a, group_b)\n                ):\n                    # Remove the single groups and add the merged group\n                    resource_groups.remove(group_a)\n                    resource_groups.remove(group_b)\n                    resource_groups.append(group_a + group_b)\n                    merged_group = True\n                    break\n        # Distance offsets we apply to center of each resource group to find expansion position\n        offset_range = 7\n        offsets = [\n            (x, y) for x, y in itertools.product(range(-offset_range, offset_range + 1), repeat=2)\n            if 4 < math.hypot(x, y) <= 8\n        ]\n        # Dict we want to return\n        centers = {}\n        # For every resource group:\n        for resources in resource_groups:\n            # Possible expansion points\n            amount = len(resources)\n            # Calculate center, round and add 0.5 because expansion location will have (x.5, y.5)\n            # coordinates because bases have size 5.\n            center_x = int(sum(resource.position.x for resource in resources) / amount) + 0.5\n            center_y = int(sum(resource.position.y for resource in resources) / amount) + 0.5\n            possible_points = (Point2((offset[0] + center_x, offset[1] + center_y)) for offset in offsets)\n            # Filter out points that are too near\n            possible_points = (\n                point for point in possible_points\n                # Check if point can be built on\n                if self._game_info.placement_grid[point.rounded] == 1\n                # Check if all resources have enough space to point\n                and all(\n                    point.distance_to(resource) >= (7 if resource._proto.unit_type in geyser_ids else 6)\n                    for resource in resources\n                )\n            )\n            # Choose best fitting point\n            result: Point2 = min(\n                possible_points, key=lambda point: sum(point.distance_to(resource) for resource in resources)\n            )\n            centers[result] = resources\n            # Put all expansion locations in a list\n            self._expansion_positions_list.append(result)\n            # Maps all resource positions to the expansion position\n            for resource in resources:\n                self._resource_location_to_expansion_position_dict[resource.position] = result",
  "def units_created(self) -> Counter:\n        \"\"\"Returns a Counter for all your units and buildings you have created so far.\n\n        This may be used for statistics (at the end of the game) or for strategic decision making.\n\n        CAUTION: This does not properly work at the moment for morphing units and structures. Please use the 'on_unit_type_changed' event to add these morphing unit types manually to 'self._units_created'.\n        Issues would arrise in e.g. siege tank morphing to sieged tank, and then morphing back (suddenly the counter counts 2 tanks have been created).\n\n        Examples::\n\n            # Give attack command to enemy base every time 10 marines have been trained\n            async def on_unit_created(self, unit: Unit):\n                if unit.type_id == UnitTypeId.MARINE:\n                    if self.units_created[MARINE] % 10 == 0:\n                        for marine in self.units(UnitTypeId.MARINE):\n                            marine.attack(self.enemy_start_locations[0])\n        \"\"\"\n        return self._units_created",
  "def _correct_zerg_supply(self):\n        \"\"\"The client incorrectly rounds zerg supply down instead of up (see\n        https://github.com/Blizzard/s2client-proto/issues/123), so self.supply_used\n        and friends return the wrong value when there are an odd number of zerglings\n        and banelings. This function corrects the bad values.\"\"\"\n        # TODO: remove when Blizzard/sc2client-proto#123 gets fixed.\n        half_supply_units = {\n            UnitTypeId.ZERGLING,\n            UnitTypeId.ZERGLINGBURROWED,\n            UnitTypeId.BANELING,\n            UnitTypeId.BANELINGBURROWED,\n            UnitTypeId.BANELINGCOCOON,\n        }\n        correction = self.units(half_supply_units).amount % 2\n        self.supply_used += correction\n        self.supply_army += correction\n        self.supply_left -= correction",
  "async def get_available_abilities(\n        self, units: Union[List[Unit], Units], ignore_resource_requirements: bool = False\n    ) -> List[List[AbilityId]]:\n        \"\"\"Returns available abilities of one or more units. Right now only checks cooldown, energy cost, and whether the ability has been researched.\n\n        Examples::\n\n            units_abilities = await self.get_available_abilities(self.units)\n\n        or::\n\n            units_abilities = await self.get_available_abilities([self.units.random])\n\n        :param units:\n        :param ignore_resource_requirements:\"\"\"\n        return await self._client.query_available_abilities(units, ignore_resource_requirements)",
  "async def expand_now(\n        self, building: UnitTypeId = None, max_distance: float = 10, location: Optional[Point2] = None\n    ):\n        \"\"\"Finds the next possible expansion via 'self.get_next_expansion()'. If the target expansion is blocked (e.g. an enemy unit), it will misplace the expansion.\n\n        :param building:\n        :param max_distance:\n        :param location:\"\"\"\n\n        if not building:\n            # self.race is never Race.Random\n            start_townhall_type = {\n                Race.Protoss: UnitTypeId.NEXUS,\n                Race.Terran: UnitTypeId.COMMANDCENTER,\n                Race.Zerg: UnitTypeId.HATCHERY,\n            }\n            building = start_townhall_type[self.race]\n\n        assert isinstance(building, UnitTypeId), f\"{building} is no UnitTypeId\"\n\n        if not location:\n            location = await self.get_next_expansion()\n        if not location:\n            # All expansions are used up or mined out\n            logger.warning(\"Trying to expand_now() but bot is out of locations to expand to\")\n            return\n        await self.build(building, near=location, max_distance=max_distance, random_alternative=False, placement_step=1)",
  "async def get_next_expansion(self) -> Optional[Point2]:\n        \"\"\"Find next expansion location.\"\"\"\n\n        closest = None\n        distance = math.inf\n        for el in self.expansion_locations_list:\n\n            def is_near_to_expansion(t):\n                return t.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\n\n            if any(map(is_near_to_expansion, self.townhalls)):\n                # already taken\n                continue\n\n            startp = self._game_info.player_start_location\n            d = await self._client.query_pathing(startp, el)\n            if d is None:\n                continue\n\n            if d < distance:\n                distance = d\n                closest = el\n\n        return closest",
  "async def distribute_workers(self, resource_ratio: float = 2):\n        \"\"\"\n        Distributes workers across all the bases taken.\n        Keyword `resource_ratio` takes a float. If the current minerals to gas\n        ratio is bigger than `resource_ratio`, this function prefer filling gas_buildings\n        first, if it is lower, it will prefer sending workers to minerals first.\n\n        NOTE: This function is far from optimal, if you really want to have\n        refined worker control, you should write your own distribution function.\n        For example long distance mining control and moving workers if a base was killed\n        are not being handled.\n\n        WARNING: This is quite slow when there are lots of workers or multiple bases.\n\n        :param resource_ratio:\"\"\"\n        if not self.mineral_field or not self.workers or not self.townhalls.ready:\n            return\n        worker_pool = [worker for worker in self.workers.idle]\n        bases = self.townhalls.ready\n        gas_buildings = self.gas_buildings.ready\n\n        # list of places that need more workers\n        deficit_mining_places = []\n\n        for mining_place in bases | gas_buildings:\n            difference = mining_place.surplus_harvesters\n            # perfect amount of workers, skip mining place\n            if not difference:\n                continue\n            if mining_place.has_vespene:\n                # get all workers that target the gas extraction site\n                # or are on their way back from it\n                local_workers = self.workers.filter(\n                    lambda unit: unit.order_target == mining_place.tag or\n                    (unit.is_carrying_vespene and unit.order_target == bases.closest_to(mining_place).tag)\n                )\n            else:\n                # get tags of minerals around expansion\n                local_minerals_tags = {\n                    mineral.tag\n                    for mineral in self.mineral_field if mineral.distance_to(mining_place) <= 8\n                }\n                # get all target tags a worker can have\n                # tags of the minerals he could mine at that base\n                # get workers that work at that gather site\n                local_workers = self.workers.filter(\n                    lambda unit: unit.order_target in local_minerals_tags or\n                    (unit.is_carrying_minerals and unit.order_target == mining_place.tag)\n                )\n            # too many workers\n            if difference > 0:\n                for worker in local_workers[:difference]:\n                    worker_pool.append(worker)\n            # too few workers\n            # add mining place to deficit bases for every missing worker\n            else:\n                deficit_mining_places += [mining_place for _ in range(-difference)]\n\n        # prepare all minerals near a base if we have too many workers\n        # and need to send them to the closest patch\n        if len(worker_pool) > len(deficit_mining_places):\n            all_minerals_near_base = [\n                mineral for mineral in self.mineral_field\n                if any(mineral.distance_to(base) <= 8 for base in self.townhalls.ready)\n            ]\n        # distribute every worker in the pool\n        for worker in worker_pool:\n            # as long as have workers and mining places\n            if deficit_mining_places:\n                # choose only mineral fields first if current mineral to gas ratio is less than target ratio\n                if self.vespene and self.minerals / self.vespene < resource_ratio:\n                    possible_mining_places = [place for place in deficit_mining_places if not place.vespene_contents]\n                # else prefer gas\n                else:\n                    possible_mining_places = [place for place in deficit_mining_places if place.vespene_contents]\n                # if preferred type is not available any more, get all other places\n                if not possible_mining_places:\n                    possible_mining_places = deficit_mining_places\n                # find closest mining place\n                current_place = min(deficit_mining_places, key=lambda place: place.distance_to(worker))\n                # remove it from the list\n                deficit_mining_places.remove(current_place)\n                # if current place is a gas extraction site, go there\n                if current_place.vespene_contents:\n                    worker.gather(current_place)\n                # if current place is a gas extraction site,\n                # go to the mineral field that is near and has the most minerals left\n                else:\n                    local_minerals = (\n                        mineral for mineral in self.mineral_field if mineral.distance_to(current_place) <= 8\n                    )\n                    # local_minerals can be empty if townhall is misplaced\n                    target_mineral = max(local_minerals, key=lambda mineral: mineral.mineral_contents, default=None)\n                    if target_mineral:\n                        worker.gather(target_mineral)\n            # more workers to distribute than free mining spots\n            # send to closest if worker is doing nothing\n            elif worker.is_idle and all_minerals_near_base:\n                target_mineral = min(all_minerals_near_base, key=lambda mineral: mineral.distance_to(worker))\n                worker.gather(target_mineral)\n            else:\n                # there are no deficit mining places and worker is not idle\n                # so dont move him\n                pass",
  "def owned_expansions(self) -> Dict[Point2, Unit]:\n        \"\"\"List of expansions owned by the player.\"\"\"\n        owned = {}\n        for el in self.expansion_locations_list:\n\n            def is_near_to_expansion(t):\n                return t.distance_to(el) < self.EXPANSION_GAP_THRESHOLD\n\n            th = next((x for x in self.townhalls if is_near_to_expansion(x)), None)\n            if th:\n                owned[el] = th\n        return owned",
  "def calculate_supply_cost(self, unit_type: UnitTypeId) -> float:\n        \"\"\"\n        This function calculates the required supply to train or morph a unit.\n        The total supply of a baneling is 0.5, but a zergling already uses up 0.5 supply, so the morph supply cost is 0.\n        The total supply of a ravager is 3, but a roach already uses up 2 supply, so the morph supply cost is 1.\n        The required supply to build zerglings is 1 because they pop in pairs, so this function returns 1 because the larva morph command requires 1 free supply.\n\n        Example::\n\n            roach_supply_cost = self.calculate_supply_cost(UnitTypeId.ROACH) # Is 2\n            ravager_supply_cost = self.calculate_supply_cost(UnitTypeId.RAVAGER) # Is 1\n            baneling_supply_cost = self.calculate_supply_cost(UnitTypeId.BANELING) # Is 0\n\n        :param unit_type:\"\"\"\n        if unit_type in {UnitTypeId.ZERGLING}:\n            return 1\n        unit_supply_cost = self._game_data.units[unit_type.value]._proto.food_required\n        if unit_supply_cost > 0 and unit_type in UNIT_TRAINED_FROM and len(UNIT_TRAINED_FROM[unit_type]) == 1:\n            producer: UnitTypeId\n            for producer in UNIT_TRAINED_FROM[unit_type]:\n                producer_unit_data = self.game_data.units[producer.value]\n                if producer_unit_data._proto.food_required <= unit_supply_cost:\n                    producer_supply_cost = producer_unit_data._proto.food_required\n                    unit_supply_cost -= producer_supply_cost\n        return unit_supply_cost",
  "def can_feed(self, unit_type: UnitTypeId) -> bool:\n        \"\"\"Checks if you have enough free supply to build the unit\n\n        Example::\n\n            cc = self.townhalls.idle.random_or(None)\n            # self.townhalls can be empty or there are no idle townhalls\n            if cc and self.can_feed(UnitTypeId.SCV):\n                cc.train(UnitTypeId.SCV)\n\n        :param unit_type:\"\"\"\n        required = self.calculate_supply_cost(unit_type)\n        # \"required <= 0\" in case self.supply_left is negative\n        return required <= 0 or self.supply_left >= required",
  "def calculate_unit_value(self, unit_type: UnitTypeId) -> Cost:\n        \"\"\"\n        Unlike the function below, this function returns the value of a unit given by the API (e.g. the resources lost value on kill).\n\n        Examples::\n\n            self.calculate_value(UnitTypeId.ORBITALCOMMAND) == Cost(550, 0)\n            self.calculate_value(UnitTypeId.RAVAGER) == Cost(100, 100)\n            self.calculate_value(UnitTypeId.ARCHON) == Cost(175, 275)\n\n        :param unit_type:\n        \"\"\"\n        unit_data = self.game_data.units[unit_type.value]\n        return Cost(unit_data._proto.mineral_cost, unit_data._proto.vespene_cost)",
  "def calculate_cost(self, item_id: Union[UnitTypeId, UpgradeId, AbilityId]) -> Cost:\n        \"\"\"\n        Calculate the required build, train or morph cost of a unit. It is recommended to use the UnitTypeId instead of the ability to create the unit.\n        The total cost to create a ravager is 100/100, but the actual morph cost from roach to ravager is only 25/75, so this function returns 25/75.\n\n        It is adviced to use the UnitTypeId instead of the AbilityId. Instead of::\n\n            self.calculate_cost(AbilityId.UPGRADETOORBITAL_ORBITALCOMMAND)\n\n        use::\n\n            self.calculate_cost(UnitTypeId.ORBITALCOMMAND)\n\n        More examples::\n\n            from sc2.game_data import Cost\n\n            self.calculate_cost(UnitTypeId.BROODLORD) == Cost(150, 150)\n            self.calculate_cost(UnitTypeId.RAVAGER) == Cost(25, 75)\n            self.calculate_cost(UnitTypeId.BANELING) == Cost(25, 25)\n            self.calculate_cost(UnitTypeId.ORBITALCOMMAND) == Cost(150, 0)\n            self.calculate_cost(UnitTypeId.REACTOR) == Cost(50, 50)\n            self.calculate_cost(UnitTypeId.TECHLAB) == Cost(50, 25)\n            self.calculate_cost(UnitTypeId.QUEEN) == Cost(150, 0)\n            self.calculate_cost(UnitTypeId.HATCHERY) == Cost(300, 0)\n            self.calculate_cost(UnitTypeId.LAIR) == Cost(150, 100)\n            self.calculate_cost(UnitTypeId.HIVE) == Cost(200, 150)\n\n        :param item_id:\n        \"\"\"\n        if isinstance(item_id, UnitTypeId):\n            # Fix cost for reactor and techlab where the API returns 0 for both\n            if item_id in {UnitTypeId.REACTOR, UnitTypeId.TECHLAB, UnitTypeId.ARCHON}:\n                if item_id == UnitTypeId.REACTOR:\n                    return Cost(50, 50)\n                elif item_id == UnitTypeId.TECHLAB:\n                    return Cost(50, 25)\n                elif item_id == UnitTypeId.ARCHON:\n                    return self.calculate_unit_value(UnitTypeId.ARCHON)\n            unit_data = self._game_data.units[item_id.value]\n            # Cost of morphs is automatically correctly calculated by 'calculate_ability_cost'\n            return self._game_data.calculate_ability_cost(unit_data.creation_ability)\n\n        elif isinstance(item_id, UpgradeId):\n            cost = self._game_data.upgrades[item_id.value].cost\n        else:\n            # Is already AbilityId\n            cost = self._game_data.calculate_ability_cost(item_id)\n        return cost",
  "def can_afford(self, item_id: Union[UnitTypeId, UpgradeId, AbilityId], check_supply_cost: bool = True) -> bool:\n        \"\"\"Tests if the player has enough resources to build a unit or structure.\n\n        Example::\n\n            cc = self.townhalls.idle.random_or(None)\n            # self.townhalls can be empty or there are no idle townhalls\n            if cc and self.can_afford(UnitTypeId.SCV):\n                cc.train(UnitTypeId.SCV)\n\n        Example::\n\n            # Current state: we have 150 minerals and one command center and a barracks\n            can_afford_morph = self.can_afford(UnitTypeId.ORBITALCOMMAND, check_supply_cost=False)\n            # Will be 'True' although the API reports that an orbital is worth 550 minerals, but the morph cost is only 150 minerals\n\n        :param item_id:\n        :param check_supply_cost:\"\"\"\n        cost = self.calculate_cost(item_id)\n        if cost.minerals > self.minerals or cost.vespene > self.vespene:\n            return False\n        if check_supply_cost and isinstance(item_id, UnitTypeId):\n            supply_cost = self.calculate_supply_cost(item_id)\n            if supply_cost and supply_cost > self.supply_left:\n                return False\n        return True",
  "async def can_cast(\n        self,\n        unit: Unit,\n        ability_id: AbilityId,\n        target: Optional[Union[Unit, Point2]] = None,\n        only_check_energy_and_cooldown: bool = False,\n        cached_abilities_of_unit: List[AbilityId] = None,\n    ) -> bool:\n        \"\"\"Tests if a unit has an ability available and enough energy to cast it.\n\n        Example::\n\n            stalkers = self.units(UnitTypeId.STALKER)\n            stalkers_that_can_blink = stalkers.filter(lambda unit: unit.type_id == UnitTypeId.STALKER and (await self.can_cast(unit, AbilityId.EFFECT_BLINK_STALKER, only_check_energy_and_cooldown=True)))\n\n        See data_pb2.py (line 161) for the numbers 1-5 to make sense\n\n        :param unit:\n        :param ability_id:\n        :param target:\n        :param only_check_energy_and_cooldown:\n        :param cached_abilities_of_unit:\"\"\"\n        assert isinstance(unit, Unit), f\"{unit} is no Unit object\"\n        assert isinstance(ability_id, AbilityId), f\"{ability_id} is no AbilityId\"\n        assert isinstance(target, (type(None), Unit, Point2))\n        # check if unit has enough energy to cast or if ability is on cooldown\n        if cached_abilities_of_unit:\n            abilities = cached_abilities_of_unit\n        else:\n            abilities = (await self.get_available_abilities([unit], ignore_resource_requirements=False))[0]\n\n        if ability_id in abilities:\n            if only_check_energy_and_cooldown:\n                return True\n            cast_range = self._game_data.abilities[ability_id.value]._proto.cast_range\n            ability_target = self._game_data.abilities[ability_id.value]._proto.target\n            # Check if target is in range (or is a self cast like stimpack)\n            if (\n                ability_target == 1 or ability_target == Target.PointOrNone.value and isinstance(target, Point2)\n                and unit.distance_to(target) <= unit.radius + target.radius + cast_range\n            ):  # cant replace 1 with \"Target.None.value\" because \".None\" doesnt seem to be a valid enum name\n                return True\n            # Check if able to use ability on a unit\n            elif (\n                ability_target in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit)\n                and unit.distance_to(target) <= unit.radius + target.radius + cast_range\n            ):\n                return True\n            # Check if able to use ability on a position\n            elif (\n                ability_target in {Target.Point.value, Target.PointOrUnit.value} and isinstance(target, Point2)\n                and unit.distance_to(target) <= unit.radius + cast_range\n            ):\n                return True\n        return False",
  "def select_build_worker(self, pos: Union[Unit, Point2], force: bool = False) -> Optional[Unit]:\n        \"\"\"Select a worker to build a building with.\n\n        Example::\n\n            barracks_placement_position = self.main_base_ramp.barracks_correct_placement\n            worker = self.select_build_worker(barracks_placement_position)\n            # Can return None\n            if worker:\n                worker.build(UnitTypeId.BARRACKS, barracks_placement_position)\n\n        :param pos:\n        :param force:\"\"\"\n        workers = (\n            self.workers.filter(lambda w: (w.is_gathering or w.is_idle) and w.distance_to(pos) < 20) or self.workers\n        )\n        if workers:\n            for worker in workers.sorted_by_distance_to(pos).prefer_idle:\n                if (\n                    worker not in self.unit_tags_received_action and not worker.orders or len(worker.orders) == 1\n                    and worker.orders[0].ability.id in {AbilityId.MOVE, AbilityId.HARVEST_GATHER}\n                ):\n                    return worker\n\n            return workers.random if force else None",
  "async def can_place_single(self, building: Union[AbilityId, UnitTypeId], position: Point2) -> bool:\n        \"\"\" Checks the placement for only one position. \"\"\"\n        if isinstance(building, UnitTypeId):\n            creation_ability = self._game_data.units[building.value].creation_ability.id\n            return (await self._client._query_building_placement_fast(creation_ability, [position]))[0]\n        return (await self._client._query_building_placement_fast(building, [position]))[0]",
  "async def can_place(self, building: Union[AbilityData, AbilityId, UnitTypeId],\n                        positions: List[Point2]) -> List[bool]:\n        \"\"\"Tests if a building can be placed in the given locations.\n\n        Example::\n\n            barracks_placement_position = self.main_base_ramp.barracks_correct_placement\n            worker = self.select_build_worker(barracks_placement_position)\n            # Can return None\n            if worker and (await self.can_place(UnitTypeId.BARRACKS, [barracks_placement_position])[0]:\n                worker.build(UnitTypeId.BARRACKS, barracks_placement_position)\n\n        :param building:\n        :param position:\"\"\"\n        building_type = type(building)\n        assert type(building) in {AbilityData, AbilityId, UnitTypeId}, f\"{building}, {building_type}\"\n        if building_type == UnitTypeId:\n            building = self._game_data.units[building.value].creation_ability.id\n        elif building_type == AbilityData:\n            warnings.warn(\n                \"Using AbilityData is deprecated and may be removed soon. Please use AbilityId or UnitTypeId instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            building = building_type.id\n\n        if isinstance(positions, (Point2, tuple)):\n            warnings.warn(\n                \"The support for querying single entries will be removed soon. Please use either 'await self.can_place_single(building, position)' or 'await (self.can_place(building, [position]))[0]\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            return await self.can_place_single(building, positions)\n        else:\n            assert isinstance(positions, list), f\"Expected an iterable (list, tuple), but was: {positions}\"\n            assert isinstance(\n                positions[0], Point2\n            ), f\"List is expected to have Point2, but instead had: {positions[0]} {type(positions[0])}\"\n\n        return await self._client._query_building_placement_fast(building, positions)",
  "async def find_placement(\n        self,\n        building: Union[UnitTypeId, AbilityId],\n        near: Point2,\n        max_distance: int = 20,\n        random_alternative: bool = True,\n        placement_step: int = 2,\n        addon_place: bool = False,\n    ) -> Optional[Point2]:\n        \"\"\"Finds a placement location for building.\n\n        Example::\n\n            if self.townhalls:\n                cc = self.townhalls[0]\n                depot_position = await self.find_placement(UnitTypeId.SUPPLYDEPOT, near=cc)\n\n        :param building:\n        :param near:\n        :param max_distance:\n        :param random_alternative:\n        :param placement_step:\n        :param addon_place:\"\"\"\n\n        assert isinstance(building, (AbilityId, UnitTypeId))\n        assert isinstance(near, Point2), f\"{near} is no Point2 object\"\n\n        if isinstance(building, UnitTypeId):\n            building = self._game_data.units[building.value].creation_ability.id\n\n        if await self.can_place_single(\n            building, near\n        ) and (not addon_place or await self.can_place_single(UnitTypeId.SUPPLYDEPOT, near.offset((2.5, -0.5)))):\n            return near\n\n        if max_distance == 0:\n            return None\n\n        for distance in range(placement_step, max_distance, placement_step):\n            possible_positions = [\n                Point2(p).offset(near).to2 for p in (\n                    [(dx, -distance) for dx in range(-distance, distance + 1, placement_step)] +\n                    [(dx, distance) for dx in range(-distance, distance + 1, placement_step)] +\n                    [(-distance, dy) for dy in range(-distance, distance + 1, placement_step)] +\n                    [(distance, dy) for dy in range(-distance, distance + 1, placement_step)]\n                )\n            ]\n            res = await self._client._query_building_placement_fast(building, possible_positions)\n            # Filter all positions if building can be placed\n            possible = [p for r, p in zip(res, possible_positions) if r]\n\n            if addon_place:\n                # Filter remaining positions if addon can be placed\n                res = await self._client._query_building_placement_fast(\n                    AbilityId.TERRANBUILDDROP_SUPPLYDEPOTDROP,\n                    [p.offset((2.5, -0.5)) for p in possible],\n                )\n                possible = [p for r, p in zip(res, possible) if r]\n\n            if not possible:\n                continue\n\n            if random_alternative:\n                return random.choice(possible)\n            else:\n                return min(possible, key=lambda p: p.distance_to_point2(near))\n        return None",
  "def already_pending_upgrade(self, upgrade_type: UpgradeId) -> float:\n        \"\"\"Check if an upgrade is being researched\n\n        Returns values are::\n\n            0 # not started\n            0 < x < 1 # researching\n            1 # completed\n\n        Example::\n\n            stim_completion_percentage = self.already_pending_upgrade(UpgradeId.STIMPACK)\n\n        :param upgrade_type:\n        \"\"\"\n        assert isinstance(upgrade_type, UpgradeId), f\"{upgrade_type} is no UpgradeId\"\n        if upgrade_type in self.state.upgrades:\n            return 1\n        creationAbilityID = self._game_data.upgrades[upgrade_type.value].research_ability.exact_id\n        for structure in self.structures.filter(lambda unit: unit.is_ready):\n            for order in structure.orders:\n                if order.ability.exact_id == creationAbilityID:\n                    return order.progress\n        return 0",
  "def _abilities_all_units(self) -> Tuple[Counter, Dict[UnitTypeId, float]]:\n        \"\"\"Cache for the already_pending function, includes protoss units warping in,\n        all units in production and all structures, and all morphs\"\"\"\n        abilities_amount = Counter()\n        max_build_progress: Dict[UnitTypeId, float] = {}\n        unit: Unit\n        for unit in self.units + self.structures:\n            for order in unit.orders:\n                abilities_amount[order.ability] += 1\n            if not unit.is_ready:\n                if self.race != Race.Terran or not unit.is_structure:\n                    # If an SCV is constructing a building, already_pending would count this structure twice\n                    # (once from the SCV order, and once from \"not structure.is_ready\")\n                    creation_ability: AbilityData = self._game_data.units[unit.type_id.value].creation_ability\n                    abilities_amount[creation_ability] += 1\n                    max_build_progress[creation_ability] = max(\n                        max_build_progress.get(creation_ability, 0), unit.build_progress\n                    )\n\n        return abilities_amount, max_build_progress",
  "def structure_type_build_progress(self, structure_type: Union[UnitTypeId, int]) -> float:\n        \"\"\"\n        Returns the build progress of a structure type.\n\n        Return range: 0 <= x <= 1 where\n            0: no such structure exists\n            0 < x < 1: at least one structure is under construction, returns the progress of the one with the highest progress\n            1: we have at least one such structure complete\n\n        Example::\n\n            # Assuming you have one barracks building at 0.5 build progress:\n            progress = self.structure_type_build_progress(UnitTypeId.BARRACKS)\n            print(progress)\n            # This prints out 0.5\n\n            # If you want to save up money for mutalisks, you can now save up once the spire is nearly completed:\n            spire_almost_completed: bool = self.structure_type_build_progress(UnitTypeId.SPIRE) > 0.75\n\n            # If you have a Hive completed but no lair, this function returns 1.0 for the following:\n            self.structure_type_build_progress(UnitTypeId.LAIR)\n\n            # Assume you have 2 command centers in production, one has 0.5 build_progress and the other 0.2, the following returns 0.5\n            highest_progress_of_command_center: float = self.structure_type_build_progress(UnitTypeId.COMMANDCENTER)\n\n        :param structure_type:\n        \"\"\"\n        assert isinstance(\n            structure_type, (int, UnitTypeId)\n        ), f\"Needs to be int or UnitTypeId, but was: {type(structure_type)}\"\n        if isinstance(structure_type, int):\n            structure_type_value: int = structure_type\n            structure_type = UnitTypeId(structure_type_value)\n        else:\n            structure_type_value = structure_type.value\n        assert structure_type_value, f\"structure_type can not be 0 or NOTAUNIT, but was: {structure_type_value}\"\n        equiv_values: Set[int] = {structure_type_value} | {\n            s_type.value\n            for s_type in EQUIVALENTS_FOR_TECH_PROGRESS.get(structure_type, set())\n        }\n        # SUPPLYDEPOTDROP is not in self._game_data.units, so bot_ai should not check the build progress via creation ability (worker abilities)\n        if structure_type_value not in self._game_data.units:\n            return max([s.build_progress for s in self.structures if s._proto.unit_type in equiv_values], default=0)\n        creation_ability: AbilityData = self._game_data.units[structure_type_value].creation_ability\n        max_value = max(\n            [s.build_progress for s in self.structures if s._proto.unit_type in equiv_values] +\n            [self._abilities_all_units[1].get(creation_ability, 0)],\n            default=0,\n        )\n        return max_value",
  "def tech_requirement_progress(self, structure_type: UnitTypeId) -> float:\n        \"\"\"Returns the tech requirement progress for a specific building\n\n        Example::\n\n            # Current state: supply depot is at 50% completion\n            tech_requirement = self.tech_requirement_progress(UnitTypeId.BARRACKS)\n            print(tech_requirement) # Prints 0.5 because supply depot is half way done\n\n        Example::\n\n            # Current state: your bot has one hive, no lair\n            tech_requirement = self.tech_requirement_progress(UnitTypeId.HYDRALISKDEN)\n            print(tech_requirement) # Prints 1 because a hive exists even though only a lair is required\n\n        Example::\n\n            # Current state: One factory is flying and one is half way done\n            tech_requirement = self.tech_requirement_progress(UnitTypeId.STARPORT)\n            print(tech_requirement) # Prints 1 because even though the type id of the flying factory is different, it still has build progress of 1 and thus tech requirement is completed\n\n        :param structure_type:\"\"\"\n        race_dict = {\n            Race.Protoss: PROTOSS_TECH_REQUIREMENT,\n            Race.Terran: TERRAN_TECH_REQUIREMENT,\n            Race.Zerg: ZERG_TECH_REQUIREMENT,\n        }\n        unit_info_id = race_dict[self.race][structure_type]\n        unit_info_id_value = unit_info_id.value\n        # The following commented out line is unreliable for ghost / thor as they return 0 which is incorrect\n        # unit_info_id_value = self._game_data.units[structure_type.value]._proto.tech_requirement\n        if not unit_info_id_value:  # Equivalent to \"if unit_info_id_value == 0:\"\n            return 1\n        progresses: List[float] = [self.structure_type_build_progress(unit_info_id_value)]\n        for equiv_structure in EQUIVALENTS_FOR_TECH_PROGRESS.get(unit_info_id, []):\n            progresses.append(self.structure_type_build_progress(equiv_structure.value))\n        return max(progresses)",
  "def already_pending(self, unit_type: Union[UpgradeId, UnitTypeId]) -> float:\n        \"\"\"\n        Returns a number of buildings or units already in progress, or if a\n        worker is en route to build it. This also includes queued orders for\n        workers and build queues of buildings.\n\n        Example::\n\n            amount_of_scv_in_production: int = self.already_pending(UnitTypeId.SCV)\n            amount_of_CCs_in_queue_and_production: int = self.already_pending(UnitTypeId.COMMANDCENTER)\n            amount_of_lairs_morphing: int = self.already_pending(UnitTypeId.LAIR)\n\n\n        :param unit_type:\n        \"\"\"\n        if isinstance(unit_type, UpgradeId):\n            return self.already_pending_upgrade(unit_type)\n        ability = self._game_data.units[unit_type.value].creation_ability\n        return self._abilities_all_units[0][ability]",
  "def _worker_orders(self) -> Counter:\n        \"\"\" This function is used internally, do not use! It is to store all worker abilities. \"\"\"\n        abilities_amount = Counter()\n        structures_in_production: Set[Union[Point2, int]] = set()\n        for structure in self.structures:\n            if structure.type_id in TERRAN_STRUCTURES_REQUIRE_SCV:\n                structures_in_production.add(structure.position)\n                structures_in_production.add(structure.tag)\n        for worker in self.workers:\n            for order in worker.orders:\n                # Skip if the SCV is constructing (not isinstance(order.target, int))\n                # or resuming construction (isinstance(order.target, int))\n                is_int = isinstance(order.target, int)\n                if (\n                    is_int and order.target in structures_in_production\n                    or not is_int and Point2.from_proto(order.target) in structures_in_production\n                ):\n                    continue\n                abilities_amount[order.ability] += 1\n        return abilities_amount",
  "def worker_en_route_to_build(self, unit_type: UnitTypeId) -> float:\n        \"\"\"This function counts how many workers are on the way to start the construction a building.\n        Warning: this function may change its name in the future!\n        New function. Please report any bugs!\n\n        :param unit_type:\"\"\"\n        ability = self._game_data.units[unit_type.value].creation_ability\n        return self._worker_orders[ability]",
  "def structures_without_construction_SCVs(self) -> Units:\n        \"\"\"Returns all structures that do not have an SCV constructing it.\n        Warning: this function may move to become a Units filter.\n        New function. Please report any bugs!\"\"\"\n        worker_targets: Set[Union[int, Point2]] = set()\n        for worker in self.workers:\n            # Ignore repairing workers\n            if not worker.is_constructing_scv:\n                continue\n            for order in worker.orders:\n                # When a construction is resumed, the worker.orders[0].target is the tag of the structure, else it is a Point2\n                target = order.target\n                if isinstance(target, int):\n                    worker_targets.add(target)\n                else:\n                    worker_targets.add(Point2.from_proto(target))\n        return self.structures.filter(\n            lambda structure: structure.build_progress < 1\n            # Redundant check?\n            and structure.type_id in TERRAN_STRUCTURES_REQUIRE_SCV and structure.position not in worker_targets and\n            structure.tag not in worker_targets and structure.tag in self._structures_previous_map and self.\n            _structures_previous_map[structure.tag].build_progress == structure.build_progress\n        )",
  "async def build(\n        self,\n        building: UnitTypeId,\n        near: Union[Unit, Point2],\n        max_distance: int = 20,\n        build_worker: Optional[Unit] = None,\n        random_alternative: bool = True,\n        placement_step: int = 2,\n    ) -> bool:\n        \"\"\"Not recommended as this function checks many positions if it \"can place\" on them until it found a valid\n        position. Also if the given position is not placeable, this function tries to find a nearby position to place\n        the structure. Then uses 'self.do' to give the worker the order to start the construction.\n\n        :param building:\n        :param near:\n        :param max_distance:\n        :param build_worker:\n        :param random_alternative:\n        :param placement_step:\"\"\"\n\n        assert isinstance(near, (Unit, Point2))\n        if not self.can_afford(building):\n            return False\n        p = None\n        gas_buildings = {UnitTypeId.EXTRACTOR, UnitTypeId.ASSIMILATOR, UnitTypeId.REFINERY}\n        if isinstance(near, Unit) and building not in gas_buildings:\n            near = near.position\n        if isinstance(near, Point2):\n            near = near.to2\n        if isinstance(near, Point2):\n            p = await self.find_placement(building, near, max_distance, random_alternative, placement_step)\n            if p is None:\n                return False\n        builder = build_worker or self.select_build_worker(near)\n        if builder is None:\n            return False\n        if building in gas_buildings:\n            builder.build_gas(near)\n            return True\n        self.do(builder.build(building, p), subtract_cost=True, ignore_warning=True)\n        return True",
  "def train(\n        self,\n        unit_type: UnitTypeId,\n        amount: int = 1,\n        closest_to: Point2 = None,\n        train_only_idle_buildings: bool = True\n    ) -> int:\n        \"\"\"Trains a specified number of units. Trains only one if amount is not specified.\n        Warning: currently has issues with warp gate warp ins\n\n        New function. Please report any bugs!\n\n        Example Zerg::\n\n            self.train(UnitTypeId.QUEEN, 5)\n            # This should queue 5 queens in 5 different townhalls if you have enough townhalls, enough minerals and enough free supply left\n\n        Example Terran::\n\n            # Assuming you have 2 idle barracks with reactors, one barracks without addon and one with techlab\n            # It should only queue 4 marines in the 2 idle barracks with reactors\n            self.train(UnitTypeId.MARINE, 4)\n\n        Example distance to::\n\n            # If you want to train based on distance to a certain point, you can use \"closest_to\"\n            self.train(UnitTypeId.MARINE, 4, closest_to = self.game_info.map_center)\n\n\n        :param unit_type:\n        :param amount:\n        :param closest_to:\n        :param train_only_idle_buildings:\"\"\"\n        # Tech requirement not met\n        if self.tech_requirement_progress(unit_type) < 1:\n            race_dict = {\n                Race.Protoss: PROTOSS_TECH_REQUIREMENT,\n                Race.Terran: TERRAN_TECH_REQUIREMENT,\n                Race.Zerg: ZERG_TECH_REQUIREMENT,\n            }\n            unit_info_id = race_dict[self.race][unit_type]\n            logger.warning(\n                \"{} Trying to produce unit {} in self.train() but tech requirement is not met: {}\".format(\n                    self.time_formatted, unit_type, unit_info_id\n                )\n            )\n            return 0\n\n        # Not affordable\n        if not self.can_afford(unit_type):\n            return 0\n\n        trained_amount = 0\n        # All train structure types: queen can made from hatchery, lair, hive\n        train_structure_type: Set[UnitTypeId] = UNIT_TRAINED_FROM[unit_type]\n        train_structures = self.structures if self.race != Race.Zerg else self.structures | self.larva\n        requires_techlab = any(\n            TRAIN_INFO[structure_type][unit_type].get(\"requires_techlab\", False)\n            for structure_type in train_structure_type\n        )\n        is_protoss = self.race == Race.Protoss\n        is_terran = self.race == Race.Terran\n        can_have_addons = any(\n            u in train_structure_type for u in {UnitTypeId.BARRACKS, UnitTypeId.FACTORY, UnitTypeId.STARPORT}\n        )\n        # Sort structures closest to a point\n        if closest_to is not None:\n            train_structures = train_structures.sorted_by_distance_to(closest_to)\n        elif can_have_addons:\n            # This should sort the structures in ascending order: first structures with reactor, then naked, then with techlab\n            train_structures = train_structures.sorted(\n                key=lambda structure: -1 * (structure.add_on_tag in self.reactor_tags) + 1 *\n                (structure.add_on_tag in self.techlab_tags)\n            )\n\n        structure: Unit\n        for structure in train_structures:\n            # Exit early if we can't afford\n            if not self.can_afford(unit_type):\n                return trained_amount\n            if (\n                # If structure hasn't received an action/order this frame\n                structure.tag not in self.unit_tags_received_action\n                # If structure can train this unit at all\n                and structure.type_id in train_structure_type\n                # Structure has to be completed to be able to train\n                and structure.build_progress == 1\n                # If structure is protoss, it needs to be powered to train\n                and (not is_protoss or structure.is_powered or structure.type_id == UnitTypeId.NEXUS)\n                # Either parameter \"train_only_idle_buildings\" is False or structure is idle or structure has less than 2 orders and has reactor\n                and (\n                    not train_only_idle_buildings\n                    or len(structure.orders) < 1 + int(structure.add_on_tag in self.reactor_tags)\n                )\n                # If structure type_id does not accept addons, it cant require a techlab\n                # Else we have to check if building has techlab as addon\n                and (not requires_techlab or structure.add_on_tag in self.techlab_tags)\n            ):\n                # Warp in at location\n                # TODO: find fast warp in locations either random location or closest to the given parameter \"closest_to\"\n                # TODO: find out which pylons have fast warp in by checking distance to nexus and warpgates.ready\n                if structure.type_id == UnitTypeId.WARPGATE:\n                    pylons = self.structures(UnitTypeId.PYLON)\n                    location = pylons.random.position.random_on_distance(4)\n                    successfully_trained = structure.warp_in(unit_type, location)\n                else:\n                    # Normal train a unit from larva or inside a structure\n                    successfully_trained = self.do(\n                        structure.train(unit_type), subtract_cost=True, subtract_supply=True, ignore_warning=True\n                    )\n                    # Check if structure has reactor: queue same unit again\n                    if (\n                        # Only terran can have reactors\n                        is_terran\n                        # Check if we have enough cost or supply for this unit type\n                        and self.can_afford(unit_type)\n                        # Structure needs to be idle in the current frame\n                        and not structure.orders\n                        # We are at least 2 away from goal\n                        and trained_amount + 1 < amount\n                        # Unit type does not require techlab\n                        and not requires_techlab\n                        # Train structure has reactor\n                        and structure.add_on_tag in self.reactor_tags\n                    ):\n                        trained_amount += 1\n                        # With one command queue=False and one queue=True, you can queue 2 marines in a reactored barracks in one frame\n                        successfully_trained = self.do(\n                            structure.train(unit_type, queue=True),\n                            subtract_cost=True,\n                            subtract_supply=True,\n                            ignore_warning=True,\n                        )\n\n                if successfully_trained:\n                    trained_amount += 1\n                    if trained_amount == amount:\n                        # Target unit train amount reached\n                        return trained_amount\n                else:\n                    # Some error occured and we couldn't train the unit\n                    return trained_amount\n        return trained_amount",
  "def research(self, upgrade_type: UpgradeId) -> bool:\n        \"\"\"\n        Researches an upgrade from a structure that can research it, if it is idle and powered (protoss).\n        Returns True if the research was started.\n        Return False if the requirement was not met, or the bot did not have enough resources to start the upgrade,\n        or the building to research the upgrade was missing or not idle.\n\n        New function. Please report any bugs!\n\n        Example::\n\n            # Try to research zergling movement speed if we can afford it\n            # and if at least one pool is at build_progress == 1\n            # and we are not researching it yet\n            if self.already_pending_upgrade(UpgradeId.ZERGLINGMOVEMENTSPEED) == 0 and self.can_afford(UpgradeId.ZERGLINGMOVEMENTSPEED):\n                spawning_pools_ready = self.structures(UnitTypeId.SPAWNINGPOOL).ready\n                if spawning_pools_ready:\n                    self.research(UpgradeId.ZERGLINGMOVEMENTSPEED)\n\n        :param upgrade_type:\n        \"\"\"\n        assert (\n            upgrade_type in UPGRADE_RESEARCHED_FROM\n        ), f\"Could not find upgrade {upgrade_type} in 'research from'-dictionary\"\n\n        # Not affordable\n        if not self.can_afford(upgrade_type):\n            return False\n\n        research_structure_types: UnitTypeId = UPGRADE_RESEARCHED_FROM[upgrade_type]\n        required_tech_building: Optional[UnitTypeId] = RESEARCH_INFO[research_structure_types][upgrade_type].get(\n            \"required_building\", None\n        )\n\n        requirement_met = (\n            required_tech_building is None or self.structure_type_build_progress(required_tech_building) == 1\n        )\n        if not requirement_met:\n            return False\n\n        is_protoss = self.race == Race.Protoss\n\n        # All upgrades right now that can be researched in spire and hatch can also be researched in their morphs\n        equiv_structures = {\n            UnitTypeId.SPIRE: {UnitTypeId.SPIRE, UnitTypeId.GREATERSPIRE},\n            UnitTypeId.GREATERSPIRE: {UnitTypeId.SPIRE, UnitTypeId.GREATERSPIRE},\n            UnitTypeId.HATCHERY: {UnitTypeId.HATCHERY, UnitTypeId.LAIR, UnitTypeId.HIVE},\n            UnitTypeId.LAIR: {UnitTypeId.HATCHERY, UnitTypeId.LAIR, UnitTypeId.HIVE},\n            UnitTypeId.HIVE: {UnitTypeId.HATCHERY, UnitTypeId.LAIR, UnitTypeId.HIVE},\n        }\n        # Convert to a set, or equivalent structures are chosen\n        # Overlord speed upgrade can be researched from hatchery, lair or hive\n        research_structure_types: Set[UnitTypeId] = equiv_structures.get(\n            research_structure_types, {research_structure_types}\n        )\n\n        structure: Unit\n        for structure in self.structures:\n            if (\n                # Structure can research this upgrade\n                structure.type_id in research_structure_types\n                # If structure hasn't received an action/order this frame\n                and structure.tag not in self.unit_tags_received_action\n                # Structure is idle\n                and structure.is_idle\n                # Structure belongs to protoss and is powered (near pylon)\n                and (not is_protoss or structure.is_powered)\n            ):\n                # Can_afford check was already done earlier in this function\n                successful_action: bool = self.do(\n                    structure.research(upgrade_type), subtract_cost=True, ignore_warning=True\n                )\n                return successful_action\n        return False",
  "def do(\n        self,\n        action: UnitCommand,\n        subtract_cost: bool = False,\n        subtract_supply: bool = False,\n        can_afford_check: bool = False,\n        ignore_warning: bool = False,\n    ) -> bool:\n        \"\"\"Adds a unit action to the 'self.actions' list which is then executed at the end of the frame.\n\n        Training a unit::\n\n            # Train an SCV from a random idle command center\n            cc = self.townhalls.idle.random_or(None)\n            # self.townhalls can be empty or there are no idle townhalls\n            if cc and self.can_afford(UnitTypeId.SCV):\n                cc.train(UnitTypeId.SCV)\n\n        Building a building::\n\n            # Building a barracks at the main ramp, requires 150 minerals and a depot\n            worker = self.workers.random_or(None)\n            barracks_placement_position = self.main_base_ramp.barracks_correct_placement\n            if worker and self.can_afford(UnitTypeId.BARRACKS):\n                worker.build(UnitTypeId.BARRACKS, barracks_placement_position)\n\n        Moving a unit::\n\n            # Move a random worker to the center of the map\n            worker = self.workers.random_or(None)\n            # worker can be None if all are dead\n            if worker:\n                worker.move(self.game_info.map_center)\n\n        :param action:\n        :param subtract_cost:\n        :param subtract_supply:\n        :param can_afford_check:\n        \"\"\"\n        if not self.unit_command_uses_self_do and isinstance(action, bool):\n            if not ignore_warning:\n                warnings.warn(\n                    \"You have used self.do(). Please consider putting 'self.unit_command_uses_self_do = True' in your bot __init__() function or removing self.do().\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n            return action\n\n        assert isinstance(\n            action, UnitCommand\n        ), f\"Given unit command is not a command, but instead of type {type(action)}\"\n        if subtract_cost:\n            cost: Cost = self._game_data.calculate_ability_cost(action.ability)\n            if can_afford_check and not (self.minerals >= cost.minerals and self.vespene >= cost.vespene):\n                # Dont do action if can't afford\n                return False\n            self.minerals -= cost.minerals\n            self.vespene -= cost.vespene\n        if subtract_supply and action.ability in abilityid_to_unittypeid:\n            unit_type = abilityid_to_unittypeid[action.ability]\n            required_supply = self.calculate_supply_cost(unit_type)\n            # Overlord has -8\n            if required_supply > 0:\n                self.supply_used += required_supply\n                self.supply_left -= required_supply\n        self.actions.append(action)\n        self.unit_tags_received_action.add(action.unit.tag)\n        return True",
  "async def synchronous_do(self, action: UnitCommand):\n        \"\"\"\n        Not recommended. Use self.do instead to reduce lag.\n        This function is only useful for realtime=True in the first frame of the game to instantly produce a worker\n        and split workers on the mineral patches.\n        \"\"\"\n        assert isinstance(\n            action, UnitCommand\n        ), f\"Given unit command is not a command, but instead of type {type(action)}\"\n        if not self.can_afford(action.ability):\n            logger.warning(f\"Cannot afford action {action}\")\n            return ActionResult.Error\n        r = await self._client.actions(action)\n        if not r:  # success\n            cost = self._game_data.calculate_ability_cost(action.ability)\n            self.minerals -= cost.minerals\n            self.vespene -= cost.vespene\n            self.unit_tags_received_action.add(action.unit.tag)\n        else:\n            logger.error(f\"Error: {r} (action: {action})\")\n        return r",
  "async def _do_actions(self, actions: List[UnitCommand], prevent_double: bool = True):\n        \"\"\"Used internally by main.py automatically, use self.do() instead!\n\n        :param actions:\n        :param prevent_double:\"\"\"\n        if not actions:\n            return None\n        if prevent_double:\n            actions = list(filter(self.prevent_double_actions, actions))\n        result = await self._client.actions(actions)\n        return result",
  "def prevent_double_actions(self, action) -> bool:\n        \"\"\"\n        :param action:\n        \"\"\"\n        # Always add actions if queued\n        if action.queue:\n            return True\n        if action.unit.orders:\n            # action: UnitCommand\n            # current_action: UnitOrder\n            current_action = action.unit.orders[0]\n            if current_action.ability.id != action.ability and current_action.ability.exact_id != action.ability:\n                # Different action, return True\n                return True\n            with suppress(AttributeError):\n                if current_action.target == action.target.tag:\n                    # Same action, remove action if same target unit\n                    return False\n            with suppress(AttributeError):\n                if action.target.x == current_action.target.x and action.target.y == current_action.target.y:\n                    # Same action, remove action if same target position\n                    return False\n            return True\n        return True",
  "async def chat_send(self, message: str, team_only: bool = False):\n        \"\"\"Send a chat message to the SC2 Client.\n\n        Example::\n\n            await self.chat_send(\"Hello, this is a message from my bot!\")\n\n        :param message:\n        :param team_only:\"\"\"\n        assert isinstance(message, str), f\"{message} is not a string\"\n        await self._client.chat_send(message, team_only)",
  "def in_map_bounds(self, pos: Union[Point2, tuple, list]) -> bool:\n        \"\"\"Tests if a 2 dimensional point is within the map boundaries of the pixelmaps.\n        :param pos:\"\"\"\n        return (\n            self._game_info.playable_area.x <= pos[0] <\n            self._game_info.playable_area.x + self.game_info.playable_area.width and self._game_info.playable_area.y <=\n            pos[1] < self._game_info.playable_area.y + self.game_info.playable_area.height\n        )",
  "def get_terrain_height(self, pos: Union[Point2, Unit]) -> int:\n        \"\"\"Returns terrain height at a position.\n        Caution: terrain height is different from a unit's z-coordinate.\n\n        :param pos:\"\"\"\n        assert isinstance(pos, (Point2, Unit)), f\"pos is not of type Point2 or Unit\"\n        pos = pos.position.rounded\n        return self._game_info.terrain_height[pos]",
  "def get_terrain_z_height(self, pos: Union[Point2, Unit]) -> float:\n        \"\"\"Returns terrain z-height at a position.\n\n        :param pos:\"\"\"\n        assert isinstance(pos, (Point2, Unit)), f\"pos is not of type Point2 or Unit\"\n        pos = pos.position.rounded\n        return -16 + 32 * self._game_info.terrain_height[pos] / 255",
  "def in_placement_grid(self, pos: Union[Point2, Unit]) -> bool:\n        \"\"\"Returns True if you can place something at a position.\n        Remember, buildings usually use 2x2, 3x3 or 5x5 of these grid points.\n        Caution: some x and y offset might be required, see ramp code in game_info.py\n\n        :param pos:\"\"\"\n        assert isinstance(pos, (Point2, Unit)), f\"pos is not of type Point2 or Unit\"\n        pos = pos.position.rounded\n        return self._game_info.placement_grid[pos] == 1",
  "def in_pathing_grid(self, pos: Union[Point2, Unit]) -> bool:\n        \"\"\"Returns True if a ground unit can pass through a grid point.\n\n        :param pos:\"\"\"\n        assert isinstance(pos, (Point2, Unit)), f\"pos is not of type Point2 or Unit\"\n        pos = pos.position.rounded\n        return self._game_info.pathing_grid[pos] == 1",
  "def is_visible(self, pos: Union[Point2, Unit]) -> bool:\n        \"\"\"Returns True if you have vision on a grid point.\n\n        :param pos:\"\"\"\n        # more info: https://github.com/Blizzard/s2client-proto/blob/9906df71d6909511907d8419b33acc1a3bd51ec0/s2clientprotocol/spatial.proto#L19\n        assert isinstance(pos, (Point2, Unit)), f\"pos is not of type Point2 or Unit\"\n        pos = pos.position.rounded\n        return self.state.visibility[pos] == 2",
  "def has_creep(self, pos: Union[Point2, Unit]) -> bool:\n        \"\"\"Returns True if there is creep on the grid point.\n\n        :param pos:\"\"\"\n        assert isinstance(pos, (Point2, Unit)), f\"pos is not of type Point2 or Unit\"\n        pos = pos.position.rounded\n        return self.state.creep[pos] == 1",
  "def _prepare_start(self, client, player_id, game_info, game_data, realtime: bool = False, base_build: int = -1):\n        \"\"\"\n        Ran until game start to set game and player data.\n\n        :param client:\n        :param player_id:\n        :param game_info:\n        :param game_data:\n        :param realtime:\n        \"\"\"\n        self._client: Client = client\n        self.player_id: int = player_id\n        self._game_info: GameInfo = game_info\n        self._game_data: GameData = game_data\n        self.realtime: bool = realtime\n        self.base_build: int = base_build\n\n        self.race: Race = Race(self._game_info.player_races[self.player_id])\n\n        if len(self._game_info.player_races) == 2:\n            self.enemy_race: Race = Race(self._game_info.player_races[3 - self.player_id])\n\n        self._distances_override_functions(self.distance_calculation_method)",
  "def _prepare_first_step(self):\n        \"\"\"First step extra preparations. Must not be called before _prepare_step.\"\"\"\n        if self.townhalls:\n            self._game_info.player_start_location = self.townhalls.first.position\n            # Calculate and cache expansion locations forever inside 'self._cache_expansion_locations', this is done to prevent a bug when this is run and cached later in the game\n            _ = self._find_expansion_locations()\n        self._game_info.map_ramps, self._game_info.vision_blockers = self._game_info._find_ramps_and_vision_blockers()\n        self._time_before_step: float = time.perf_counter()",
  "def _prepare_step(self, state, proto_game_info):\n        \"\"\"\n        :param state:\n        :param proto_game_info:\n        \"\"\"\n        # Set attributes from new state before on_step.\"\"\"\n        self.state: GameState = state  # See game_state.py\n        # update pathing grid, which unfortunately is in GameInfo instead of GameState\n        self._game_info.pathing_grid: PixelMap = PixelMap(\n            proto_game_info.game_info.start_raw.pathing_grid, in_bits=True, mirrored=False\n        )\n        # Required for events, needs to be before self.units are initialized so the old units are stored\n        self._units_previous_map: Dict[int, Unit] = {unit.tag: unit for unit in self.units}\n        self._structures_previous_map: Dict[int, Unit] = {structure.tag: structure for structure in self.structures}\n        self._enemy_units_previous_map: Dict[int, Unit] = {unit.tag: unit for unit in self.enemy_units}\n        self._enemy_structures_previous_map: Dict[int, Unit] = {\n            structure.tag: structure\n            for structure in self.enemy_structures\n        }\n        self._all_units_previous_map: Dict[int, Unit] = {unit.tag: unit for unit in self.all_units}\n\n        self._prepare_units()\n        self.minerals: int = state.common.minerals\n        self.vespene: int = state.common.vespene\n        self.supply_army: int = state.common.food_army\n        self.supply_workers: int = state.common.food_workers  # Doesn't include workers in production\n        self.supply_cap: int = state.common.food_cap\n        self.supply_used: int = state.common.food_used\n        self.supply_left: int = self.supply_cap - self.supply_used\n\n        if self.race == Race.Zerg:\n            # Workaround Zerg supply rounding bug\n            self._correct_zerg_supply()\n        elif self.race == Race.Protoss:\n            self.warp_gate_count: int = state.common.warp_gate_count\n\n        self.idle_worker_count: int = state.common.idle_worker_count\n        self.army_count: int = state.common.army_count\n        self._time_before_step: float = time.perf_counter()\n\n        if self.enemy_race == Race.Random and self.all_enemy_units:\n            self.enemy_race = Race(self.all_enemy_units.first.race)",
  "def _prepare_units(self):\n        # Set of enemy units detected by own sensor tower, as blips have less unit information than normal visible units\n        self.blips: Set[Blip] = set()\n        self.all_units: Units = Units([], self)\n        self.units: Units = Units([], self)\n        self.workers: Units = Units([], self)\n        self.larva: Units = Units([], self)\n        self.structures: Units = Units([], self)\n        self.townhalls: Units = Units([], self)\n        self.gas_buildings: Units = Units([], self)\n        self.all_own_units: Units = Units([], self)\n        self.enemy_units: Units = Units([], self)\n        self.enemy_structures: Units = Units([], self)\n        self.all_enemy_units: Units = Units([], self)\n        self.resources: Units = Units([], self)\n        self.destructables: Units = Units([], self)\n        self.watchtowers: Units = Units([], self)\n        self.mineral_field: Units = Units([], self)\n        self.vespene_geyser: Units = Units([], self)\n        self.placeholders: Units = Units([], self)\n        self.techlab_tags: Set[int] = set()\n        self.reactor_tags: Set[int] = set()\n\n        worker_types: Set[UnitTypeId] = {UnitTypeId.DRONE, UnitTypeId.DRONEBURROWED, UnitTypeId.SCV, UnitTypeId.PROBE}\n\n        index: int = 0\n        for unit in self.state.observation_raw.units:\n            if unit.is_blip:\n                self.blips.add(Blip(unit))\n            else:\n                unit_type: int = unit.unit_type\n                # Convert these units to effects: reaper grenade, parasitic bomb dummy, forcefield\n                if unit_type in FakeEffectID:\n                    self.state.effects.add(EffectData(unit, fake=True))\n                    continue\n                unit_obj = Unit(unit, self, distance_calculation_index=index, base_build=self.base_build)\n                index += 1\n                self.all_units.append(unit_obj)\n                if unit.display_type == IS_PLACEHOLDER:\n                    self.placeholders.append(unit_obj)\n                    continue\n                alliance = unit.alliance\n                # Alliance.Neutral.value = 3\n                if alliance == 3:\n                    # XELNAGATOWER = 149\n                    if unit_type == 149:\n                        self.watchtowers.append(unit_obj)\n                    # mineral field enums\n                    elif unit_type in mineral_ids:\n                        self.mineral_field.append(unit_obj)\n                        self.resources.append(unit_obj)\n                    # geyser enums\n                    elif unit_type in geyser_ids:\n                        self.vespene_geyser.append(unit_obj)\n                        self.resources.append(unit_obj)\n                    # all destructable rocks\n                    else:\n                        self.destructables.append(unit_obj)\n                # Alliance.Self.value = 1\n                elif alliance == 1:\n                    self.all_own_units.append(unit_obj)\n                    unit_id = unit_obj.type_id\n                    if unit_obj.is_structure:\n                        self.structures.append(unit_obj)\n                        if unit_id in race_townhalls[self.race]:\n                            self.townhalls.append(unit_obj)\n                        elif unit_id in ALL_GAS or unit_obj.vespene_contents:\n                            # TODO: remove \"or unit_obj.vespene_contents\" when a new linux client newer than version 4.10.0 is released\n                            self.gas_buildings.append(unit_obj)\n                        elif unit_id in {\n                            UnitTypeId.TECHLAB,\n                            UnitTypeId.BARRACKSTECHLAB,\n                            UnitTypeId.FACTORYTECHLAB,\n                            UnitTypeId.STARPORTTECHLAB,\n                        }:\n                            self.techlab_tags.add(unit_obj.tag)\n                        elif unit_id in {\n                            UnitTypeId.REACTOR,\n                            UnitTypeId.BARRACKSREACTOR,\n                            UnitTypeId.FACTORYREACTOR,\n                            UnitTypeId.STARPORTREACTOR,\n                        }:\n                            self.reactor_tags.add(unit_obj.tag)\n                    else:\n                        self.units.append(unit_obj)\n                        if unit_id in worker_types:\n                            self.workers.append(unit_obj)\n                        elif unit_id == UnitTypeId.LARVA:\n                            self.larva.append(unit_obj)\n                # Alliance.Enemy.value = 4\n                elif alliance == 4:\n                    self.all_enemy_units.append(unit_obj)\n                    if unit_obj.is_structure:\n                        self.enemy_structures.append(unit_obj)\n                    else:\n                        self.enemy_units.append(unit_obj)\n\n        # Force distance calculation and caching on all units using scipy pdist or cdist\n        if self.distance_calculation_method == 1:\n            _ = self._pdist\n        elif self.distance_calculation_method in {2, 3}:\n            _ = self._cdist",
  "async def _after_step(self) -> int:\n        \"\"\" Executed by main.py after each on_step function. \"\"\"\n        # Keep track of the bot on_step duration\n        self._time_after_step: float = time.perf_counter()\n        step_duration = self._time_after_step - self._time_before_step\n        self._min_step_time = min(step_duration, self._min_step_time)\n        self._max_step_time = max(step_duration, self._max_step_time)\n        self._last_step_step_time = step_duration\n        self._total_time_in_on_step += step_duration\n        self._total_steps_iterations += 1\n        # Commit and clear bot actions\n        if self.actions:\n            await self._do_actions(self.actions)\n            self.actions.clear()\n        # Clear set of unit tags that were given an order this frame by self.do()\n        self.unit_tags_received_action.clear()\n        # Commit debug queries\n        await self._client._send_debug()\n\n        return self.state.game_loop",
  "async def _advance_steps(self, steps: int):\n        \"\"\"Advances the game loop by amount of 'steps'. This function is meant to be used as a debugging and testing tool only.\n        If you are using this, please be aware of the consequences, e.g. 'self.units' will be filled with completely new data.\"\"\"\n        await self._after_step()\n        # Advance simulation by exactly \"steps\" frames\n        await self.client.step(steps)\n        state = await self.client.observation()\n        gs = GameState(state.observation)\n        proto_game_info = await self.client._execute(game_info=sc_pb.RequestGameInfo())\n        self._prepare_step(gs, proto_game_info)\n        await self.issue_events()",
  "async def issue_events(self):\n        \"\"\"This function will be automatically run from main.py and triggers the following functions:\n        - on_unit_created\n        - on_unit_destroyed\n        - on_building_construction_started\n        - on_building_construction_complete\n        - on_upgrade_complete\n        \"\"\"\n        await self._issue_unit_dead_events()\n        await self._issue_unit_added_events()\n        await self._issue_building_events()\n        await self._issue_upgrade_events()\n        await self._issue_vision_events()",
  "async def _issue_unit_added_events(self):\n        for unit in self.units:\n            if unit.tag not in self._units_previous_map and unit.tag not in self._unit_tags_seen_this_game:\n                self._unit_tags_seen_this_game.add(unit.tag)\n                self._units_created[unit.type_id] += 1\n                await self.on_unit_created(unit)\n            elif unit.tag in self._units_previous_map:\n                previous_frame_unit: Unit = self._units_previous_map[unit.tag]\n                # Check if a unit took damage this frame and then trigger event\n                if unit.health < previous_frame_unit.health or unit.shield < previous_frame_unit.shield:\n                    damage_amount = previous_frame_unit.health - unit.health + previous_frame_unit.shield - unit.shield\n                    await self.on_unit_took_damage(unit, damage_amount)\n                # Check if a unit type has changed\n                if previous_frame_unit.type_id != unit.type_id:\n                    await self.on_unit_type_changed(unit, previous_frame_unit.type_id)",
  "async def _issue_upgrade_events(self):\n        difference = self.state.upgrades - self._previous_upgrades\n        for upgrade_completed in difference:\n            await self.on_upgrade_complete(upgrade_completed)\n        self._previous_upgrades = self.state.upgrades",
  "async def _issue_building_events(self):\n        for structure in self.structures:\n            if structure.tag not in self._structures_previous_map:\n                if structure.build_progress < 1:\n                    await self.on_building_construction_started(structure)\n                else:\n                    # Include starting townhall\n                    self._units_created[structure.type_id] += 1\n                    await self.on_building_construction_complete(structure)\n            elif structure.tag in self._structures_previous_map:\n                # Check if a structure took damage this frame and then trigger event\n                previous_frame_structure: Unit = self._structures_previous_map[structure.tag]\n                if (\n                    structure.health < previous_frame_structure.health\n                    or structure.shield < previous_frame_structure.shield\n                ):\n                    damage_amount = (\n                        previous_frame_structure.health - structure.health + previous_frame_structure.shield -\n                        structure.shield\n                    )\n                    await self.on_unit_took_damage(structure, damage_amount)\n                # Check if a structure changed its type\n                if previous_frame_structure.type_id != structure.type_id:\n                    await self.on_unit_type_changed(structure, previous_frame_structure.type_id)\n                # Check if structure completed\n                if structure.build_progress == 1 and previous_frame_structure.build_progress < 1:\n                    self._units_created[structure.type_id] += 1\n                    await self.on_building_construction_complete(structure)",
  "async def _issue_vision_events(self):\n        # Call events for enemy unit entered vision\n        for enemy_unit in self.enemy_units:\n            if enemy_unit.tag not in self._enemy_units_previous_map:\n                await self.on_enemy_unit_entered_vision(enemy_unit)\n        for enemy_structure in self.enemy_structures:\n            if enemy_structure.tag not in self._enemy_structures_previous_map:\n                await self.on_enemy_unit_entered_vision(enemy_structure)\n\n        # Call events for enemy unit left vision\n        enemy_units_left_vision: Set[int] = set(self._enemy_units_previous_map.keys()) - self.enemy_units.tags\n        for enemy_unit_tag in enemy_units_left_vision:\n            await self.on_enemy_unit_left_vision(enemy_unit_tag)\n        enemy_structures_left_vision: Set[int] = (\n            set(self._enemy_structures_previous_map.keys()) - self.enemy_structures.tags\n        )\n        for enemy_structure_tag in enemy_structures_left_vision:\n            await self.on_enemy_unit_left_vision(enemy_structure_tag)",
  "async def _issue_unit_dead_events(self):\n        for unit_tag in self.state.dead_units & set(self._all_units_previous_map.keys()):\n            await self.on_unit_destroyed(unit_tag)",
  "async def on_unit_destroyed(self, unit_tag: int):\n        \"\"\"\n        Override this in your bot class.\n        Note that this function uses unit tags and not the unit objects\n        because the unit does not exist any more.\n        This will event will be called when a unit (or structure, friendly or enemy) dies.\n        For enemy units, this only works if the enemy unit was in vision on death.\n\n        :param unit_tag:\n        \"\"\"",
  "async def on_unit_created(self, unit: Unit):\n        \"\"\"Override this in your bot class. This function is called when a unit is created.\n\n        :param unit:\"\"\"",
  "async def on_unit_type_changed(self, unit: Unit, previous_type: UnitTypeId):\n        \"\"\"Override this in your bot class. This function is called when a unit type has changed. To get the current UnitTypeId of the unit, use 'unit.type_id'\n\n        This may happen when a larva morphed to an egg, siege tank sieged, a zerg unit burrowed, a hatchery morphed to lair,\n        a corruptor morphed to broodlordcocoon, etc..\n\n        Examples::\n\n            print(f\"My unit changed type: {unit} from {previous_type} to {unit.type_id}\")\n\n        :param unit:\n        :param previous_type:\n        \"\"\"",
  "async def on_building_construction_started(self, unit: Unit):\n        \"\"\"\n        Override this in your bot class.\n        This function is called when a building construction has started.\n\n        :param unit:\n        \"\"\"",
  "async def on_building_construction_complete(self, unit: Unit):\n        \"\"\"\n        Override this in your bot class. This function is called when a building\n        construction is completed.\n\n        :param unit:\n        \"\"\"",
  "async def on_upgrade_complete(self, upgrade: UpgradeId):\n        \"\"\"\n        Override this in your bot class. This function is called with the upgrade id of an upgrade that was not finished last step and is now.\n\n        :param upgrade:\n        \"\"\"",
  "async def on_unit_took_damage(self, unit: Unit, amount_damage_taken: float):\n        \"\"\"\n        Override this in your bot class. This function is called when your own unit (unit or structure) took damage.\n        It will not be called if the unit died this frame.\n\n        This may be called frequently for terran structures that are burning down, or zerg buildings that are off creep,\n        or terran bio units that just used stimpack ability.\n        TODO: If there is a demand for it, then I can add a similar event for when enemy units took damage\n\n        Examples::\n\n            print(f\"My unit took damage: {unit} took {amount_damage_taken} damage\")\n\n        :param unit:\n        \"\"\"",
  "async def on_enemy_unit_entered_vision(self, unit: Unit):\n        \"\"\"\n        Override this in your bot class. This function is called when an enemy unit (unit or structure) entered vision (which was not visible last frame).\n\n        :param unit:\n        \"\"\"",
  "async def on_enemy_unit_left_vision(self, unit_tag: int):\n        \"\"\"\n        Override this in your bot class. This function is called when an enemy unit (unit or structure) left vision (which was visible last frame).\n        Same as the self.on_unit_destroyed event, this function is called with the unit's tag because the unit is no longer visible anymore.\n        If you want to store a snapshot of the unit, use self._enemy_units_previous_map[unit_tag] for units or self._enemy_structures_previous_map[unit_tag] for structures.\n\n        Examples::\n\n            last_known_unit = self._enemy_units_previous_map.get(unit_tag, None) or self._enemy_structures_previous_map[unit_tag]\n            print(f\"Enemy unit left vision, last known location: {last_known_unit.position}\")\n\n        :param unit_tag:\n        \"\"\"",
  "async def on_before_start(self):\n        \"\"\"\n        Override this in your bot class. This function is called before \"on_start\"\n        and before \"prepare_first_step\" that calculates expansion locations.\n        Not all data is available yet.\n        This function is useful in realtime=True mode to split your workers or start producing the first worker.\n        \"\"\"",
  "async def on_start(self):\n        \"\"\"\n        Override this in your bot class.\n        At this point, game_data, game_info and the first iteration of game_state (self.state) are available.\n        \"\"\"",
  "async def on_step(self, iteration: int):\n        \"\"\"\n        You need to implement this function!\n        Override this in your bot class.\n        This function is called on every game step (looped in realtime mode).\n\n        :param iteration:\n        \"\"\"\n        raise NotImplementedError",
  "async def on_end(self, game_result: Result):\n        \"\"\"Override this in your bot class. This function is called at the end of a game.\n        Unsure if this function will be called on the laddermanager client as the bot process may forcefully be terminated.\n\n        :param game_result:\"\"\"",
  "def is_near_to_expansion(t):\n                return t.distance_to(el) < self.EXPANSION_GAP_THRESHOLD",
  "def is_near_to_expansion(t):\n                return t.distance_to(el) < self.EXPANSION_GAP_THRESHOLD",
  "def get(name=None):\n    maps = []\n    for mapdir in (p for p in Paths.MAPS.iterdir()):\n        if mapdir.is_dir():\n            for mapfile in (p for p in mapdir.iterdir() if p.is_file()):\n                if mapfile.suffix == \".SC2Map\":\n                    maps.append(Map(mapfile))\n        elif mapdir.is_file():\n            if mapdir.suffix == \".SC2Map\":\n                maps.append(Map(mapdir))\n\n    if name is None:\n        return maps\n\n    for m in maps:\n        if m.matches(name):\n            return m\n\n    raise KeyError(f\"Map '{name}' was not found. Please put the map file in \\\"/StarCraft II/Maps/\\\".\")",
  "class Map:\n\n    def __init__(self, path):\n        self.path = path\n\n        if self.path.is_absolute():\n            try:\n                self.relative_path = self.path.relative_to(Paths.MAPS)\n            except ValueError:  # path not relative to basedir\n                logger.warning(f\"Using absolute path: {self.path}\")\n                self.relative_path = self.path\n        else:\n            self.relative_path = self.path\n\n    @property\n    def name(self):\n        return self.path.stem\n\n    @property\n    def data(self):\n        with open(self.path, \"rb\") as f:\n            return f.read()\n\n    def matches(self, name):\n        return self.name.lower().replace(\" \", \"\") == name.lower().replace(\" \", \"\")\n\n    def __repr__(self):\n        return f\"Map({self.path})\"",
  "def __init__(self, path):\n        self.path = path\n\n        if self.path.is_absolute():\n            try:\n                self.relative_path = self.path.relative_to(Paths.MAPS)\n            except ValueError:  # path not relative to basedir\n                logger.warning(f\"Using absolute path: {self.path}\")\n                self.relative_path = self.path\n        else:\n            self.relative_path = self.path",
  "def name(self):\n        return self.path.stem",
  "def data(self):\n        with open(self.path, \"rb\") as f:\n            return f.read()",
  "def matches(self, name):\n        return self.name.lower().replace(\" \", \"\") == name.lower().replace(\" \", \"\")",
  "def __repr__(self):\n        return f\"Map({self.path})\"",
  "def return_NOTAUNIT() -> UnitTypeId:\n    # NOTAUNIT = 0\n    return UnitTypeId.NOTAUNIT",
  "class UnitOrder:\n\n    @classmethod\n    def from_proto(cls, proto, bot_object: BotAI):\n        return cls(\n            bot_object._game_data.abilities[proto.ability_id],\n            (proto.target_world_space_pos if proto.HasField(\"target_world_space_pos\") else proto.target_unit_tag),\n            proto.progress,\n        )\n\n    def __init__(self, ability: AbilityData, target, progress: float = None):\n        \"\"\"\n        :param ability:\n        :param target:\n        :param progress:\n        \"\"\"\n        self.ability: AbilityData = ability\n        # This can be an int (if target is unit) or proto Point2 object, which needs to be converted using 'Point2.from_proto(target)'\n        self.target = target\n        self.progress: float = progress\n\n    def __repr__(self) -> str:\n        return f\"UnitOrder({self.ability}, {self.target}, {self.progress})\"",
  "class Unit:\n\n    def __init__(self, proto_data, bot_object: BotAI, distance_calculation_index: int = -1, base_build: int = -1):\n        \"\"\"\n        :param proto_data:\n        :param bot_object:\n        \"\"\"\n        self._proto = proto_data\n        self._bot_object: BotAI = bot_object\n        # Used by property_immutable_cache\n        self.cache = {}\n        self.game_loop: int = bot_object.state.game_loop\n        self.base_build = base_build\n        # Index used in the 2D numpy array to access the 2D distance between two units\n        self.distance_calculation_index: int = distance_calculation_index\n\n    def __repr__(self) -> str:\n        \"\"\" Returns string of this form: Unit(name='SCV', tag=4396941328). \"\"\"\n        return f\"Unit(name={self.name !r}, tag={self.tag})\"\n\n    @property_immutable_cache\n    def type_id(self) -> UnitTypeId:\n        \"\"\"UnitTypeId found in sc2/ids/unit_typeid.\n        Caches all type_ids of the same unit type.\"\"\"\n        unit_type = self._proto.unit_type\n        if unit_type not in self._bot_object._game_data.unit_types:\n            self._bot_object._game_data.unit_types[unit_type] = UnitTypeId(unit_type)\n        return self._bot_object._game_data.unit_types[unit_type]\n\n    @property_immutable_cache\n    def _type_data(self) -> UnitTypeData:\n        \"\"\" Provides the unit type data. \"\"\"\n        return self._bot_object._game_data.units[self._proto.unit_type]\n\n    @property_immutable_cache\n    def _creation_ability(self) -> AbilityData:\n        \"\"\" Provides the AbilityData of the creation ability of this unit. \"\"\"\n        return self._bot_object._game_data.units[self._proto.unit_type].creation_ability\n\n    @property\n    def name(self) -> str:\n        \"\"\" Returns the name of the unit. \"\"\"\n        return self._type_data.name\n\n    @property\n    def race(self) -> Race:\n        \"\"\" Returns the race of the unit \"\"\"\n        return Race(self._type_data._proto.race)\n\n    @property\n    def tag(self) -> int:\n        \"\"\" Returns the unique tag of the unit. \"\"\"\n        return self._proto.tag\n\n    @property\n    def is_structure(self) -> bool:\n        \"\"\" Checks if the unit is a structure. \"\"\"\n        return IS_STRUCTURE in self._type_data.attributes\n\n    @property\n    def is_light(self) -> bool:\n        \"\"\" Checks if the unit has the 'light' attribute. \"\"\"\n        return IS_LIGHT in self._type_data.attributes\n\n    @property\n    def is_armored(self) -> bool:\n        \"\"\" Checks if the unit has the 'armored' attribute. \"\"\"\n        return IS_ARMORED in self._type_data.attributes\n\n    @property\n    def is_biological(self) -> bool:\n        \"\"\" Checks if the unit has the 'biological' attribute. \"\"\"\n        return IS_BIOLOGICAL in self._type_data.attributes\n\n    @property\n    def is_mechanical(self) -> bool:\n        \"\"\" Checks if the unit has the 'mechanical' attribute. \"\"\"\n        return IS_MECHANICAL in self._type_data.attributes\n\n    @property\n    def is_massive(self) -> bool:\n        \"\"\" Checks if the unit has the 'massive' attribute. \"\"\"\n        return IS_MASSIVE in self._type_data.attributes\n\n    @property\n    def is_psionic(self) -> bool:\n        \"\"\" Checks if the unit has the 'psionic' attribute. \"\"\"\n        return IS_PSIONIC in self._type_data.attributes\n\n    @property\n    def tech_alias(self) -> Optional[List[UnitTypeId]]:\n        \"\"\"Building tech equality, e.g. OrbitalCommand is the same as CommandCenter\n        For Hive, this returns [UnitTypeId.Hatchery, UnitTypeId.Lair]\n        For SCV, this returns None\"\"\"\n        return self._type_data.tech_alias\n\n    @property\n    def unit_alias(self) -> Optional[UnitTypeId]:\n        \"\"\"Building type equality, e.g. FlyingOrbitalCommand is the same as OrbitalCommand\n        For flying OrbitalCommand, this returns UnitTypeId.OrbitalCommand\n        For SCV, this returns None\"\"\"\n        return self._type_data.unit_alias\n\n    @property_immutable_cache\n    def _weapons(self):\n        \"\"\" Returns the weapons of the unit. \"\"\"\n        try:\n            return self._type_data._proto.weapons\n        except:\n            return None\n\n    @property_immutable_cache\n    def can_attack(self) -> bool:\n        \"\"\" Checks if the unit can attack at all. \"\"\"\n        # TODO BATTLECRUISER doesnt have weapons in proto?!\n        return bool(self._weapons) or self.type_id in {UNIT_BATTLECRUISER, UNIT_ORACLE}\n\n    @property_immutable_cache\n    def can_attack_both(self) -> bool:\n        \"\"\" Checks if the unit can attack both ground and air units. \"\"\"\n        return self.can_attack_ground and self.can_attack_air\n\n    @property_immutable_cache\n    def can_attack_ground(self) -> bool:\n        \"\"\" Checks if the unit can attack ground units. \"\"\"\n        if self.type_id in {UNIT_BATTLECRUISER, UNIT_ORACLE}:\n            return True\n        if self._weapons:\n            return any(weapon.type in TARGET_GROUND for weapon in self._weapons)\n        return False\n\n    @property_immutable_cache\n    def ground_dps(self) -> float:\n        \"\"\" Returns the dps against ground units. Does not include upgrades. \"\"\"\n        if self.can_attack_ground:\n            weapon = next((weapon for weapon in self._weapons if weapon.type in TARGET_GROUND), None)\n            if weapon:\n                return (weapon.damage * weapon.attacks) / weapon.speed\n        return 0\n\n    @property_immutable_cache\n    def ground_range(self) -> float:\n        \"\"\" Returns the range against ground units. Does not include upgrades. \"\"\"\n        if self.type_id == UNIT_ORACLE:\n            return 4\n        if self.type_id == UNIT_BATTLECRUISER:\n            return 6\n        if self.can_attack_ground:\n            weapon = next((weapon for weapon in self._weapons if weapon.type in TARGET_GROUND), None)\n            if weapon:\n                return weapon.range\n        return 0\n\n    @property_immutable_cache\n    def can_attack_air(self) -> bool:\n        \"\"\" Checks if the unit can air attack at all. Does not include upgrades. \"\"\"\n        if self.type_id == UNIT_BATTLECRUISER:\n            return True\n        if self._weapons:\n            return any(weapon.type in TARGET_AIR for weapon in self._weapons)\n        return False\n\n    @property_immutable_cache\n    def air_dps(self) -> float:\n        \"\"\" Returns the dps against air units. Does not include upgrades. \"\"\"\n        if self.can_attack_air:\n            weapon = next((weapon for weapon in self._weapons if weapon.type in TARGET_AIR), None)\n            if weapon:\n                return (weapon.damage * weapon.attacks) / weapon.speed\n        return 0\n\n    @property_immutable_cache\n    def air_range(self) -> float:\n        \"\"\" Returns the range against air units. Does not include upgrades. \"\"\"\n        if self.type_id == UNIT_BATTLECRUISER:\n            return 6\n        if self.can_attack_air:\n            weapon = next((weapon for weapon in self._weapons if weapon.type in TARGET_AIR), None)\n            if weapon:\n                return weapon.range\n        return 0\n\n    @property_immutable_cache\n    def bonus_damage(self):\n        \"\"\"Returns a tuple of form '(bonus damage, armor type)' if unit does 'bonus damage' against 'armor type'.\n        Possible armor typs are: 'Light', 'Armored', 'Biological', 'Mechanical', 'Psionic', 'Massive', 'Structure'.\"\"\"\n        # TODO: Consider units with ability attacks (Oracle, Baneling) or multiple attacks (Thor).\n        if self._weapons:\n            for weapon in self._weapons:\n                if weapon.damage_bonus:\n                    b = weapon.damage_bonus[0]\n                    return (b.bonus, Attribute(b.attribute).name)\n        else:\n            return None\n\n    @property\n    def armor(self) -> float:\n        \"\"\" Returns the armor of the unit. Does not include upgrades \"\"\"\n        return self._type_data._proto.armor\n\n    @property\n    def sight_range(self) -> float:\n        \"\"\" Returns the sight range of the unit. \"\"\"\n        return self._type_data._proto.sight_range\n\n    @property\n    def movement_speed(self) -> float:\n        \"\"\"Returns the movement speed of the unit.\n        This is the unit movement speed on game speed 'normal'. To convert it to 'faster' movement speed, multiply it by a factor of '1.4'. E.g. reaper movement speed is listed here as 3.75, but should actually be 5.25.\n        Does not include upgrades or buffs.\"\"\"\n        return self._type_data._proto.movement_speed\n\n    @property\n    def real_speed(self) -> float:\n        \"\"\" See 'calculate_speed'. \"\"\"\n        return self.calculate_speed()\n\n    def calculate_speed(self, upgrades: Set[UpgradeId] = None) -> float:\n        \"\"\"Calculates the movement speed of the unit including buffs and upgrades.\n        Note: Upgrades only work with own units. Use \"upgrades\" param to set expected enemy upgrades.\n\n        :param upgrades:\"\"\"\n        speed: float = self.movement_speed\n        unit_type: UnitTypeId = self.type_id\n\n        # ---- Upgrades ----\n        if upgrades is None and self.is_mine:\n            upgrades = self._bot_object.state.upgrades\n\n        if upgrades and unit_type in SPEED_UPGRADE_DICT:\n            upgrade_id: UpgradeId = SPEED_UPGRADE_DICT.get(unit_type, None)\n            if upgrade_id and upgrade_id in upgrades:\n                speed *= SPEED_INCREASE_DICT.get(unit_type, 1)\n\n        # ---- Creep ----\n        if unit_type in SPEED_INCREASE_ON_CREEP_DICT or unit_type in OFF_CREEP_SPEED_UPGRADE_DICT:\n            # On creep\n            x, y = self.position_tuple\n            if self._bot_object.state.creep[(int(x), int(y))]:\n                speed *= SPEED_INCREASE_ON_CREEP_DICT.get(unit_type, 1)\n\n            # Off creep upgrades\n            elif upgrades:\n                upgrade_id: UpgradeId = OFF_CREEP_SPEED_UPGRADE_DICT.get(unit_type, None)\n                if upgrade_id:\n                    speed *= OFF_CREEP_SPEED_INCREASE_DICT[unit_type]\n\n            # Ultralisk has passive ability \"Frenzied\" which makes it immune to speed altering buffs\n            if unit_type == UnitTypeId.ULTRALISK:\n                return speed\n\n        # ---- Buffs ----\n        # Hard reset movement speed: medivac boost, void ray charge\n        if self.buffs and unit_type in {UnitTypeId.MEDIVAC, UnitTypeId.VOIDRAY}:\n            if BuffId.MEDIVACSPEEDBOOST in self.buffs:\n                speed = self.movement_speed * 1.7\n            elif BuffId.VOIDRAYSWARMDAMAGEBOOST in self.buffs:\n                speed = self.movement_speed * 0.75\n\n        # Speed altering buffs, e.g. stimpack, zealot charge, concussive shell, time warp, fungal growth, inhibitor zone\n        for buff in self.buffs:\n            speed *= SPEED_ALTERING_BUFFS.get(buff, 1)\n        return speed\n\n    @property\n    def distance_per_step(self) -> float:\n        \"\"\"The distance a unit can move in one step. This does not take acceleration into account.\n        Useful for micro-retreat/pathfinding\"\"\"\n        return (self.real_speed / 22.4) * self._bot_object.client.game_step\n\n    @property\n    def distance_to_weapon_ready(self) -> float:\n        \"\"\" Distance a unit can travel before it's weapon is ready to be fired again.\"\"\"\n        return (self.real_speed / 22.4) * self.weapon_cooldown\n\n    @property\n    def is_mineral_field(self) -> bool:\n        \"\"\" Checks if the unit is a mineral field. \"\"\"\n        return self._type_data.has_minerals\n\n    @property\n    def is_vespene_geyser(self) -> bool:\n        \"\"\" Checks if the unit is a non-empty vespene geyser or gas extraction building. \"\"\"\n        return self._type_data.has_vespene\n\n    @property\n    def health(self) -> float:\n        \"\"\" Returns the health of the unit. Does not include shields. \"\"\"\n        return self._proto.health\n\n    @property\n    def health_max(self) -> float:\n        \"\"\" Returns the maximum health of the unit. Does not include shields. \"\"\"\n        return self._proto.health_max\n\n    @property\n    def health_percentage(self) -> float:\n        \"\"\" Returns the percentage of health the unit has. Does not include shields. \"\"\"\n        if not self._proto.health_max:\n            return 0\n        return self._proto.health / self._proto.health_max\n\n    @property\n    def shield(self) -> float:\n        \"\"\" Returns the shield points the unit has. Returns 0 for non-protoss units. \"\"\"\n        return self._proto.shield\n\n    @property\n    def shield_max(self) -> float:\n        \"\"\" Returns the maximum shield points the unit can have. Returns 0 for non-protoss units. \"\"\"\n        return self._proto.shield_max\n\n    @property\n    def shield_percentage(self) -> float:\n        \"\"\" Returns the percentage of shield points the unit has. Returns 0 for non-protoss units. \"\"\"\n        if not self._proto.shield_max:\n            return 0\n        return self._proto.shield / self._proto.shield_max\n\n    @property_immutable_cache\n    def shield_health_percentage(self) -> float:\n        \"\"\"Returns the percentage of combined shield + hp points the unit has.\n        Also takes build progress into account.\"\"\"\n        max_ = (self._proto.shield_max + self._proto.health_max) * self.build_progress\n        if not max_:\n            return 0\n        return (self._proto.shield + self._proto.health) / max_\n\n    @property\n    def energy(self) -> float:\n        \"\"\" Returns the amount of energy the unit has. Returns 0 for units without energy. \"\"\"\n        return self._proto.energy\n\n    @property\n    def energy_max(self) -> float:\n        \"\"\" Returns the maximum amount of energy the unit can have. Returns 0 for units without energy. \"\"\"\n        return self._proto.energy_max\n\n    @property\n    def energy_percentage(self) -> float:\n        \"\"\" Returns the percentage of amount of energy the unit has. Returns 0 for units without energy. \"\"\"\n        if not self._proto.energy_max:\n            return 0\n        return self._proto.energy / self._proto.energy_max\n\n    @property\n    def age_in_frames(self) -> int:\n        \"\"\" Returns how old the unit object data is (in game frames). This age does not reflect the unit was created / trained / morphed! \"\"\"\n        return self._bot_object.state.game_loop - self.game_loop\n\n    @property\n    def age(self) -> float:\n        \"\"\" Returns how old the unit object data is (in game seconds). This age does not reflect when the unit was created / trained / morphed! \"\"\"\n        return (self._bot_object.state.game_loop - self.game_loop) / 22.4\n\n    @property\n    def is_memory(self) -> bool:\n        \"\"\" Returns True if this Unit object is referenced from the future and is outdated. \"\"\"\n        return self.game_loop != self._bot_object.state.game_loop\n\n    @property_immutable_cache\n    def is_snapshot(self) -> bool:\n        \"\"\"Checks if the unit is only available as a snapshot for the bot.\n        Enemy buildings that have been scouted and are in the fog of war or\n        attacking enemy units on higher, not visible ground appear this way.\"\"\"\n        if self.base_build >= 82457:\n            return self._proto.display_type == IS_SNAPSHOT\n        # TODO: Fixed in version 5.0.4, remove if a new linux binary is released: https://github.com/Blizzard/s2client-proto/issues/167\n        position = self.position.rounded\n        return self._bot_object.state.visibility.data_numpy[position[1], position[0]] != 2\n\n    @property_immutable_cache\n    def is_visible(self) -> bool:\n        \"\"\"Checks if the unit is visible for the bot.\n        NOTE: This means the bot has vision of the position of the unit!\n        It does not give any information about the cloak status of the unit.\"\"\"\n        if self.base_build >= 82457:\n            return self._proto.display_type == IS_VISIBLE\n        # TODO: Remove when a new linux binary (5.0.4 or newer) is released\n        return self._proto.display_type == IS_VISIBLE and not self.is_snapshot\n\n    @property_immutable_cache\n    def is_placeholder(self) -> bool:\n        \"\"\"Checks if the unit is a placerholder for the bot.\n        Raw information about placeholders:\n            display_type: Placeholder\n            alliance: Self\n            unit_type: 86\n            owner: 1\n            pos {\n              x: 29.5\n              y: 53.5\n              z: 7.98828125\n            }\n            radius: 2.75\n            is_on_screen: false\n        \"\"\"\n        return self._proto.display_type == IS_PLACEHOLDER\n\n    @property\n    def alliance(self) -> Alliance:\n        \"\"\" Returns the team the unit belongs to. \"\"\"\n        return self._proto.alliance\n\n    @property\n    def is_mine(self) -> bool:\n        \"\"\" Checks if the unit is controlled by the bot. \"\"\"\n        return self._proto.alliance == IS_MINE\n\n    @property\n    def is_enemy(self) -> bool:\n        \"\"\" Checks if the unit is hostile. \"\"\"\n        return self._proto.alliance == IS_ENEMY\n\n    @property\n    def owner_id(self) -> int:\n        \"\"\" Returns the owner of the unit. This is a value of 1 or 2 in a two player game. \"\"\"\n        return self._proto.owner\n\n    @property\n    def position_tuple(self) -> Tuple[float, float]:\n        \"\"\" Returns the 2d position of the unit as tuple without conversion to Point2. \"\"\"\n        return self._proto.pos.x, self._proto.pos.y\n\n    @property_immutable_cache\n    def position(self) -> Point2:\n        \"\"\" Returns the 2d position of the unit. \"\"\"\n        return Point2.from_proto(self._proto.pos)\n\n    @property_immutable_cache\n    def position3d(self) -> Point3:\n        \"\"\" Returns the 3d position of the unit. \"\"\"\n        return Point3.from_proto(self._proto.pos)\n\n    def distance_to(self, p: Union[Unit, Point2, Point3]) -> float:\n        \"\"\"Using the 2d distance between self and p.\n        To calculate the 3d distance, use unit.position3d.distance_to(p)\n\n        :param p:\"\"\"\n        if isinstance(p, Unit):\n            return self._bot_object._distance_squared_unit_to_unit(self, p)**0.5\n        return self._bot_object.distance_math_hypot(self.position_tuple, p)\n\n    def distance_to_squared(self, p: Union[Unit, Point2, Point3]) -> float:\n        \"\"\"Using the 2d distance squared between self and p. Slightly faster than distance_to, so when filtering a lot of units, this function is recommended to be used.\n        To calculate the 3d distance, use unit.position3d.distance_to(p)\n\n        :param p:\"\"\"\n        if isinstance(p, Unit):\n            return self._bot_object._distance_squared_unit_to_unit(self, p)\n        return self._bot_object.distance_math_hypot_squared(self.position_tuple, p)\n\n    def target_in_range(self, target: Unit, bonus_distance: float = 0) -> bool:\n        \"\"\"Checks if the target is in range.\n        Includes the target's radius when calculating distance to target.\n\n        :param target:\n        :param bonus_distance:\"\"\"\n        # TODO: Fix this because immovable units (sieged tank, planetary fortress etc.) have a little lower range than this formula\n        if self.can_attack_ground and not target.is_flying:\n            unit_attack_range = self.ground_range\n        elif self.can_attack_air and (target.is_flying or target.type_id == UNIT_COLOSSUS):\n            unit_attack_range = self.air_range\n        else:\n            return False\n        return (\n            self._bot_object._distance_squared_unit_to_unit(self, target) <=\n            (self.radius + target.radius + unit_attack_range + bonus_distance)**2\n        )\n\n    def in_ability_cast_range(\n        self, ability_id: AbilityId, target: Union[Unit, Point2], bonus_distance: float = 0\n    ) -> bool:\n        \"\"\"Test if a unit is able to cast an ability on the target without checking ability cooldown (like stalker blink) or if ability is made available through research (like HT storm).\n\n        :param ability_id:\n        :param target:\n        :param bonus_distance:\"\"\"\n        cast_range = self._bot_object._game_data.abilities[ability_id.value]._proto.cast_range\n        assert cast_range > 0, f\"Checking for an ability ({ability_id}) that has no cast range\"\n        ability_target_type = self._bot_object._game_data.abilities[ability_id.value]._proto.target\n        # For casting abilities that target other units, like transfuse, feedback, snipe, yamato\n        if ability_target_type in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit):\n            return (\n                self._bot_object._distance_squared_unit_to_unit(self, target) <=\n                (cast_range + self.radius + target.radius + bonus_distance)**2\n            )\n        # For casting abilities on the ground, like queen creep tumor, ravager bile, HT storm\n        if ability_target_type in {Target.Point.value, Target.PointOrUnit.value\n                                   } and isinstance(target, (Point2, tuple)):\n            return (\n                self._bot_object._distance_pos_to_pos(self.position_tuple, target) <=\n                cast_range + self.radius + bonus_distance\n            )\n        return False\n\n    def calculate_damage_vs_target(\n        self,\n        target: Unit,\n        ignore_armor: bool = False,\n        include_overkill_damage: bool = True\n    ) -> Tuple[float, float, float]:\n        \"\"\"\n        Returns a tuple of: [potential damage against target, attack speed, attack range]\n        Returns the properly calculated damage per full-attack against the target unit.\n        Returns (0, 0, 0) if this unit can't attack the target unit.\n\n        If 'include_overkill_damage=True' and the unit deals 10 damage, the target unit has 5 hp and 0 armor,\n        the target unit would result in -5hp, so the returning damage would be 10.\n        For 'include_overkill_damage=False' this function would return 5.\n\n        If 'ignore_armor=False' and the unit deals 10 damage, the target unit has 20 hp and 5 armor,\n        the target unit would result in 15hp, so the returning damage would be 5.\n        For 'ignore_armor=True' this function would return 10.\n\n        :param target:\n        :param ignore_armor:\n        :param include_overkill_damage:\n        \"\"\"\n        if self.type_id not in {UnitTypeId.BATTLECRUISER, UnitTypeId.BUNKER}:\n            if not self.can_attack:\n                return 0, 0, 0\n            if target.type_id != UnitTypeId.COLOSSUS:\n                if not self.can_attack_ground and not target.is_flying:\n                    return 0, 0, 0\n                if not self.can_attack_air and target.is_flying:\n                    return 0, 0, 0\n        # Structures that are not completed can't attack\n        if not self.is_ready:\n            return 0, 0, 0\n        target_has_guardian_shield: bool = False\n        if ignore_armor:\n            enemy_armor: float = 0\n            enemy_shield_armor: float = 0\n        else:\n            # TODO: enemy is under influence of anti armor missile -> reduce armor and shield armor\n            enemy_armor: float = target.armor + target.armor_upgrade_level\n            enemy_shield_armor: float = target.shield_upgrade_level\n            # Ultralisk armor upgrade, only works if target belongs to the bot calling this function\n            if (\n                target.type_id in {UnitTypeId.ULTRALISK, UnitTypeId.ULTRALISKBURROWED} and target.is_mine\n                and UpgradeId.CHITINOUSPLATING in target._bot_object.state.upgrades\n            ):\n                enemy_armor += 2\n            # Guardian shield adds 2 armor\n            if BuffId.GUARDIANSHIELD in target.buffs:\n                target_has_guardian_shield = True\n            # Anti armor missile of raven\n            if BuffId.RAVENSHREDDERMISSILETINT in target.buffs:\n                enemy_armor -= 2\n                enemy_shield_armor -= 2\n\n        # Hard coded return for battlecruiser because they have no weapon in the API\n        if self.type_id == UnitTypeId.BATTLECRUISER:\n            if target_has_guardian_shield:\n                enemy_armor += 2\n                enemy_shield_armor += 2\n            weapon_damage = (5 if target.is_flying else 8) + self.attack_upgrade_level\n            weapon_damage = weapon_damage - enemy_shield_armor if target.shield else weapon_damage - enemy_armor\n            return weapon_damage, 0.224, 6\n\n        # Fast return for bunkers, since they don't have a weapon similar to BCs\n        if self.type_id == UnitTypeId.BUNKER:\n            if self.is_enemy:\n                if self.is_active:\n                    # Expect fully loaded bunker with marines\n                    return (24, 0.854, 6)\n                return (0, 0, 0)\n            else:\n                # TODO if bunker belongs to us, use passengers and upgrade level to calculate damage\n                pass\n\n        required_target_type: Set[int] = (\n            TARGET_BOTH\n            if target.type_id == UnitTypeId.COLOSSUS else TARGET_GROUND if not target.is_flying else TARGET_AIR\n        )\n        # Contains total damage, attack speed and attack range\n        damages: List[Tuple[float, float, float]] = []\n        for weapon in self._weapons:\n            if weapon.type not in required_target_type:\n                continue\n            enemy_health: float = target.health\n            enemy_shield: float = target.shield\n            total_attacks: int = weapon.attacks\n            weapon_speed: float = weapon.speed\n            weapon_range: float = weapon.range\n            bonus_damage_per_upgrade = (\n                0 if not self.attack_upgrade_level else\n                DAMAGE_BONUS_PER_UPGRADE.get(self.type_id, {}).get(weapon.type, {}).get(None, 1)\n            )\n            damage_per_attack: float = weapon.damage + self.attack_upgrade_level * bonus_damage_per_upgrade\n            # Remaining damage after all damage is dealt to shield\n            remaining_damage: float = 0\n\n            # Calculate bonus damage against target\n            boni: List[float] = []\n            # TODO: hardcode hellbats when they have blueflame or attack upgrades\n            for bonus in weapon.damage_bonus:\n                # More about damage bonus https://github.com/Blizzard/s2client-proto/blob/b73eb59ac7f2c52b2ca585db4399f2d3202e102a/s2clientprotocol/data.proto#L55\n                if bonus.attribute in target._type_data.attributes:\n                    bonus_damage_per_upgrade = (\n                        0 if not self.attack_upgrade_level else\n                        DAMAGE_BONUS_PER_UPGRADE.get(self.type_id, {}).get(weapon.type, {}).get(bonus.attribute, 0)\n                    )\n                    # Hardcode blueflame damage bonus from hellions\n                    if (\n                        bonus.attribute == IS_LIGHT and self.type_id == UnitTypeId.HELLION\n                        and UpgradeId.HIGHCAPACITYBARRELS in self._bot_object.state.upgrades\n                    ):\n                        bonus_damage_per_upgrade += 5\n                    # TODO buffs e.g. void ray charge beam vs armored\n                    boni.append(bonus.bonus + self.attack_upgrade_level * bonus_damage_per_upgrade)\n            if boni:\n                damage_per_attack += max(boni)\n\n            # Subtract enemy unit's shield\n            if target.shield > 0:\n                # Fix for ranged units + guardian shield\n                enemy_shield_armor_temp = (\n                    enemy_shield_armor + 2 if target_has_guardian_shield and weapon_range >= 2 else enemy_shield_armor\n                )\n                # Shield-armor has to be applied\n                while total_attacks > 0 and enemy_shield > 0:\n                    # Guardian shield correction\n                    enemy_shield -= max(0.5, damage_per_attack - enemy_shield_armor_temp)\n                    total_attacks -= 1\n                if enemy_shield < 0:\n                    remaining_damage = -enemy_shield\n                    enemy_shield = 0\n\n            # TODO roach and hydra in melee range are not affected by guardian shield\n            # Fix for ranged units if enemy has guardian shield buff\n            enemy_armor_temp = enemy_armor + 2 if target_has_guardian_shield and weapon_range >= 2 else enemy_armor\n            # Subtract enemy unit's HP\n            if remaining_damage > 0:\n                enemy_health -= max(0.5, remaining_damage - enemy_armor_temp)\n            while total_attacks > 0 and (include_overkill_damage or enemy_health > 0):\n                # Guardian shield correction\n                enemy_health -= max(0.5, damage_per_attack - enemy_armor_temp)\n                total_attacks -= 1\n\n            # Calculate the final damage\n            if not include_overkill_damage:\n                enemy_health = max(0, enemy_health)\n                enemy_shield = max(0, enemy_shield)\n            total_damage_dealt = target.health + target.shield - enemy_health - enemy_shield\n            # Unit modifiers: buffs and upgrades that affect weapon speed and weapon range\n            if self.type_id in {\n                UnitTypeId.ZERGLING,\n                UnitTypeId.MARINE,\n                UnitTypeId.MARAUDER,\n                UnitTypeId.ADEPT,\n                UnitTypeId.HYDRALISK,\n                UnitTypeId.PHOENIX,\n                UnitTypeId.PLANETARYFORTRESS,\n                UnitTypeId.MISSILETURRET,\n                UnitTypeId.AUTOTURRET,\n            }:\n                upgrades: Set[UpgradeId] = self._bot_object.state.upgrades\n                if (\n                    self.type_id == UnitTypeId.ZERGLING\n                    # Attack speed calculation only works for our unit\n                    and self.is_mine and UpgradeId.ZERGLINGATTACKSPEED in upgrades\n                ):\n                    # 0.696044921875 for zerglings divided through 1.4 equals (+40% attack speed bonus from the upgrade):\n                    weapon_speed /= 1.4\n                elif (\n                    # Adept ereceive 45% attack speed bonus from glaives\n                    self.type_id == UnitTypeId.ADEPT and self.is_mine and UpgradeId.ADEPTPIERCINGATTACK in upgrades\n                ):\n                    # TODO next patch: if self.type_id is adept: check if attack speed buff is active, instead of upgrade\n                    weapon_speed /= 1.45\n                elif self.type_id == UnitTypeId.MARINE and BuffId.STIMPACK in self.buffs:\n                    # Marine and marauder receive 50% attack speed bonus from stim\n                    weapon_speed /= 1.5\n                elif self.type_id == UnitTypeId.MARAUDER and BuffId.STIMPACKMARAUDER in self.buffs:\n                    weapon_speed /= 1.5\n                elif (\n                    # TODO always assume that the enemy has the range upgrade researched\n                    self.type_id == UnitTypeId.HYDRALISK and self.is_mine and UpgradeId.EVOLVEGROOVEDSPINES in upgrades\n                ):\n                    weapon_range += 1\n                elif self.type_id == UnitTypeId.PHOENIX and self.is_mine and UpgradeId.PHOENIXRANGEUPGRADE in upgrades:\n                    weapon_range += 2\n                elif (\n                    self.type_id in {UnitTypeId.PLANETARYFORTRESS, UnitTypeId.MISSILETURRET, UnitTypeId.AUTOTURRET}\n                    and self.is_mine and UpgradeId.HISECAUTOTRACKING in upgrades\n                ):\n                    weapon_range += 1\n\n            # Append it to the list of damages, e.g. both thor and queen attacks work on colossus\n            damages.append((total_damage_dealt, weapon_speed, weapon_range))\n\n        # If no attack was found, return (0, 0, 0)\n        if not damages:\n            return 0, 0, 0\n        # Returns: total potential damage, attack speed, attack range\n        return max(damages, key=lambda damage_tuple: damage_tuple[0])\n\n    def calculate_dps_vs_target(\n        self, target: Unit, ignore_armor: bool = False, include_overkill_damage: bool = True\n    ) -> float:\n        \"\"\" Returns the DPS against the given target. \"\"\"\n        calc_tuple: Tuple[float, float,\n                          float] = self.calculate_damage_vs_target(target, ignore_armor, include_overkill_damage)\n        # TODO fix for real time? The result may have to be multiplied by 1.4 because of game_speed=normal\n        if calc_tuple[1] == 0:\n            return 0\n        return calc_tuple[0] / calc_tuple[1]\n\n    @property\n    def facing(self) -> float:\n        \"\"\" Returns direction the unit is facing as a float in range [0,2\u03c0). 0 is in direction of x axis.\"\"\"\n        return self._proto.facing\n\n    def is_facing(self, other_unit: Unit, angle_error: float = 0.05) -> bool:\n        \"\"\"Check if this unit is facing the target unit. If you make angle_error too small, there might be rounding errors. If you make angle_error too big, this function might return false positives.\n\n        :param other_unit:\n        :param angle_error:\"\"\"\n        # TODO perhaps return default True for units that cannot 'face' another unit? e.g. structures (planetary fortress, bunker, missile turret, photon cannon, spine, spore) or sieged tanks\n        angle = math.atan2(\n            other_unit.position_tuple[1] - self.position_tuple[1], other_unit.position_tuple[0] - self.position_tuple[0]\n        )\n        if angle < 0:\n            angle += math.pi * 2\n        angle_difference = math.fabs(angle - self.facing)\n        return angle_difference < angle_error\n\n    @property\n    def footprint_radius(self) -> Optional[float]:\n        \"\"\"For structures only.\n        For townhalls this returns 2.5\n        For barracks, spawning pool, gateway, this returns 1.5\n        For supply depot, this returns 1\n        For sensor tower, creep tumor, this return 0.5\n\n        NOTE: This can be None if a building doesn't have a creation ability.\n        For rich vespene buildings, flying terran buildings, this returns None\"\"\"\n        return self._bot_object._game_data.units[self._proto.unit_type].footprint_radius\n\n    @property\n    def radius(self) -> float:\n        \"\"\" Half of unit size. See https://liquipedia.net/starcraft2/Unit_Statistics_(Legacy_of_the_Void) \"\"\"\n        return self._proto.radius\n\n    @property\n    def build_progress(self) -> float:\n        \"\"\" Returns completion in range [0,1].\"\"\"\n        return self._proto.build_progress\n\n    @property\n    def is_ready(self) -> bool:\n        \"\"\" Checks if the unit is completed. \"\"\"\n        return self.build_progress == 1\n\n    @property\n    def cloak(self) -> CloakState:\n        \"\"\"Returns cloak state.\n        See https://github.com/Blizzard/s2client-api/blob/d9ba0a33d6ce9d233c2a4ee988360c188fbe9dbf/include/sc2api/sc2_unit.h#L95\"\"\"\n        return self._proto.cloak\n\n    @property\n    def is_cloaked(self) -> bool:\n        \"\"\" Checks if the unit is cloaked. \"\"\"\n        return self._proto.cloak in IS_CLOAKED\n\n    @property\n    def is_revealed(self) -> bool:\n        \"\"\" Checks if the unit is revealed. \"\"\"\n        return self._proto.cloak is IS_REVEALED\n\n    @property\n    def can_be_attacked(self) -> bool:\n        \"\"\" Checks if the unit is revealed or not cloaked and therefore can be attacked. \"\"\"\n        return self._proto.cloak in CAN_BE_ATTACKED\n\n    @property_immutable_cache\n    def buffs(self) -> Set:\n        \"\"\" Returns the set of current buffs the unit has. \"\"\"\n        return {BuffId(buff_id) for buff_id in self._proto.buff_ids}\n\n    @property_immutable_cache\n    def is_carrying_minerals(self) -> bool:\n        \"\"\" Checks if a worker or MULE is carrying (gold-)minerals. \"\"\"\n        return not IS_CARRYING_MINERALS.isdisjoint(self.buffs)\n\n    @property_immutable_cache\n    def is_carrying_vespene(self) -> bool:\n        \"\"\" Checks if a worker is carrying vespene gas. \"\"\"\n        return not IS_CARRYING_VESPENE.isdisjoint(self.buffs)\n\n    @property_immutable_cache\n    def is_carrying_resource(self) -> bool:\n        \"\"\" Checks if a worker is carrying a resource. \"\"\"\n        return not IS_CARRYING_RESOURCES.isdisjoint(self.buffs)\n\n    @property\n    def detect_range(self) -> float:\n        \"\"\" Returns the detection distance of the unit. \"\"\"\n        return self._proto.detect_range\n\n    @property_immutable_cache\n    def is_detector(self) -> bool:\n        \"\"\"Checks if the unit is a detector. Has to be completed\n        in order to detect and Photoncannons also need to be powered.\"\"\"\n        return self.is_ready and (self.type_id in IS_DETECTOR or self.type_id == UNIT_PHOTONCANNON and self.is_powered)\n\n    @property\n    def radar_range(self) -> float:\n        return self._proto.radar_range\n\n    @property\n    def is_selected(self) -> bool:\n        \"\"\" Checks if the unit is currently selected. \"\"\"\n        return self._proto.is_selected\n\n    @property\n    def is_on_screen(self) -> bool:\n        \"\"\" Checks if the unit is on the screen. \"\"\"\n        return self._proto.is_on_screen\n\n    @property\n    def is_blip(self) -> bool:\n        \"\"\" Checks if the unit is detected by a sensor tower. \"\"\"\n        return self._proto.is_blip\n\n    @property\n    def is_powered(self) -> bool:\n        \"\"\" Checks if the unit is powered by a pylon or warppism. \"\"\"\n        return self._proto.is_powered\n\n    @property\n    def is_active(self) -> bool:\n        \"\"\" Checks if the unit has an order (e.g. unit is currently moving or attacking, structure is currently training or researching). \"\"\"\n        return self._proto.is_active\n\n    # PROPERTIES BELOW THIS COMMENT ARE NOT POPULATED FOR SNAPSHOTS\n\n    @property\n    def mineral_contents(self) -> int:\n        \"\"\" Returns the amount of minerals remaining in a mineral field. \"\"\"\n        return self._proto.mineral_contents\n\n    @property\n    def vespene_contents(self) -> int:\n        \"\"\" Returns the amount of gas remaining in a geyser. \"\"\"\n        return self._proto.vespene_contents\n\n    @property\n    def has_vespene(self) -> bool:\n        \"\"\"Checks if a geyser has any gas remaining.\n        You can't build extractors on empty geysers.\"\"\"\n        return bool(self._proto.vespene_contents)\n\n    @property\n    def is_flying(self) -> bool:\n        \"\"\" Checks if the unit is flying. \"\"\"\n        return self._proto.is_flying or self.has_buff(BuffId.GRAVITONBEAM)\n\n    @property\n    def is_burrowed(self) -> bool:\n        \"\"\" Checks if the unit is burrowed. \"\"\"\n        return self._proto.is_burrowed\n\n    @property\n    def is_hallucination(self) -> bool:\n        \"\"\" Returns True if the unit is your own hallucination or detected. \"\"\"\n        return self._proto.is_hallucination\n\n    @property\n    def attack_upgrade_level(self) -> int:\n        \"\"\"Returns the upgrade level of the units attack.\n        # NOTE: Returns 0 for units without a weapon.\"\"\"\n        return self._proto.attack_upgrade_level\n\n    @property\n    def armor_upgrade_level(self) -> int:\n        \"\"\" Returns the upgrade level of the units armor. \"\"\"\n        return self._proto.armor_upgrade_level\n\n    @property\n    def shield_upgrade_level(self) -> int:\n        \"\"\"Returns the upgrade level of the units shield.\n        # NOTE: Returns 0 for units without a shield.\"\"\"\n        return self._proto.shield_upgrade_level\n\n    @property\n    def buff_duration_remain(self) -> int:\n        \"\"\"Returns the amount of remaining frames of the visible timer bar.\n        # NOTE: Returns 0 for units without a timer bar.\"\"\"\n        return self._proto.buff_duration_remain\n\n    @property\n    def buff_duration_max(self) -> int:\n        \"\"\"Returns the maximum amount of frames of the visible timer bar.\n        # NOTE: Returns 0 for units without a timer bar.\"\"\"\n        return self._proto.buff_duration_max\n\n    # PROPERTIES BELOW THIS COMMENT ARE NOT POPULATED FOR ENEMIES\n\n    @property_mutable_cache\n    def orders(self) -> List[UnitOrder]:\n        \"\"\" Returns the a list of the current orders. \"\"\"\n        # TODO: add examples on how to use unit orders\n        return [UnitOrder.from_proto(order, self._bot_object) for order in self._proto.orders]\n\n    @property_immutable_cache\n    def order_target(self) -> Optional[Union[int, Point2]]:\n        \"\"\"Returns the target tag (if it is a Unit) or Point2 (if it is a Position)\n        from the first order, returns None if the unit is idle\"\"\"\n        if self.orders:\n            target = self.orders[0].target\n            if isinstance(target, int):\n                return target\n            else:\n                return Point2.from_proto(target)\n        return None\n\n    @property\n    def noqueue(self) -> bool:\n        \"\"\" Checks if the unit is idle. \"\"\"\n        warnings.warn(\"noqueue will be removed soon, please use is_idle instead\", DeprecationWarning, stacklevel=2)\n        return self.is_idle\n\n    @property\n    def is_idle(self) -> bool:\n        \"\"\" Checks if unit is idle. \"\"\"\n        return not self._proto.orders\n\n    def is_using_ability(self, abilities: Union[AbilityId, Set[AbilityId]]) -> bool:\n        \"\"\"Check if the unit is using one of the given abilities.\n        Only works for own units.\"\"\"\n        if not self.orders:\n            return False\n        if isinstance(abilities, AbilityId):\n            abilities = {abilities}\n        return self.orders[0].ability.id in abilities\n\n    @property_immutable_cache\n    def is_moving(self) -> bool:\n        \"\"\"Checks if the unit is moving.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(AbilityId.MOVE)\n\n    @property_immutable_cache\n    def is_attacking(self) -> bool:\n        \"\"\"Checks if the unit is attacking.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_ATTACKING)\n\n    @property_immutable_cache\n    def is_patrolling(self) -> bool:\n        \"\"\"Checks if a unit is patrolling.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_PATROLLING)\n\n    @property_immutable_cache\n    def is_gathering(self) -> bool:\n        \"\"\"Checks if a unit is on its way to a mineral field or vespene geyser to mine.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_GATHERING)\n\n    @property_immutable_cache\n    def is_returning(self) -> bool:\n        \"\"\"Checks if a unit is returning from mineral field or vespene geyser to deliver resources to townhall.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_RETURNING)\n\n    @property_immutable_cache\n    def is_collecting(self) -> bool:\n        \"\"\"Checks if a unit is gathering or returning.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_COLLECTING)\n\n    @property_immutable_cache\n    def is_constructing_scv(self) -> bool:\n        \"\"\"Checks if the unit is an SCV that is currently building.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_CONSTRUCTING_SCV)\n\n    @property_immutable_cache\n    def is_transforming(self) -> bool:\n        \"\"\"Checks if the unit transforming.\n        Only works for own units.\"\"\"\n        return self.type_id in transforming and self.is_using_ability(transforming[self.type_id])\n\n    @property_immutable_cache\n    def is_repairing(self) -> bool:\n        \"\"\"Checks if the unit is an SCV or MULE that is currently repairing.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_REPAIRING)\n\n    @property\n    def add_on_tag(self) -> int:\n        \"\"\" Returns the tag of the addon of unit. If the unit has no addon, returns 0. \"\"\"\n        return self._proto.add_on_tag\n\n    @property\n    def has_add_on(self) -> bool:\n        \"\"\" Checks if unit has an addon attached. \"\"\"\n        return bool(self._proto.add_on_tag)\n\n    @property_immutable_cache\n    def has_techlab(self) -> bool:\n        \"\"\" Check if a structure is connected to a techlab addon. This should only ever return True for BARRACKS, FACTORY, STARPORT. \"\"\"\n        return self.add_on_tag in self._bot_object.techlab_tags\n\n    @property_immutable_cache\n    def has_reactor(self) -> bool:\n        \"\"\" Check if a structure is connected to a reactor addon. This should only ever return True for BARRACKS, FACTORY, STARPORT. \"\"\"\n        return self.add_on_tag in self._bot_object.reactor_tags\n\n    @property_immutable_cache\n    def add_on_land_position(self) -> Point2:\n        \"\"\"\n        If this unit is an addon (techlab, reactor), returns the position\n        where a terran building (BARRACKS, FACTORY, STARPORT) has to land to connect to this addon.\n\n        Why offset (-2.5, 0.5)? See description in 'add_on_position'\n        \"\"\"\n        return self.position.offset(Point2((-2.5, 0.5)))\n\n    @property_immutable_cache\n    def add_on_position(self) -> Point2:\n        \"\"\"\n        If this unit is a terran production building (BARRACKS, FACTORY, STARPORT),\n        this property returns the position of where the addon should be, if it should build one or has one attached.\n\n        Why offset (2.5, -0.5)?\n        A barracks is of size 3x3. The distance from the center to the edge is 1.5.\n        An addon is 2x2 and the distance from the edge to center is 1.\n        The total distance from center to center on the x-axis is 2.5.\n        The distance from center to center on the y-axis is -0.5.\n        \"\"\"\n        return self.position.offset(Point2((2.5, -0.5)))\n\n    @property_mutable_cache\n    def passengers(self) -> Set[Unit]:\n        \"\"\" Returns the units inside a Bunker, CommandCenter, PlanetaryFortress, Medivac, Nydus, Overlord or WarpPrism. \"\"\"\n        return {Unit(unit, self._bot_object) for unit in self._proto.passengers}\n\n    @property_mutable_cache\n    def passengers_tags(self) -> Set[int]:\n        \"\"\" Returns the tags of the units inside a Bunker, CommandCenter, PlanetaryFortress, Medivac, Nydus, Overlord or WarpPrism. \"\"\"\n        return {unit.tag for unit in self._proto.passengers}\n\n    @property\n    def cargo_used(self) -> Union[float, int]:\n        \"\"\"Returns how much cargo space is currently used in the unit.\n        Note that some units take up more than one space.\"\"\"\n        return self._proto.cargo_space_taken\n\n    @property\n    def has_cargo(self) -> bool:\n        \"\"\" Checks if this unit has any units loaded. \"\"\"\n        return bool(self._proto.cargo_space_taken)\n\n    @property\n    def cargo_size(self) -> Union[float, int]:\n        \"\"\" Returns the amount of cargo space the unit needs. \"\"\"\n        return self._type_data.cargo_size\n\n    @property\n    def cargo_max(self) -> Union[float, int]:\n        \"\"\" How much cargo space is available at maximum. \"\"\"\n        return self._proto.cargo_space_max\n\n    @property\n    def cargo_left(self) -> Union[float, int]:\n        \"\"\" Returns how much cargo space is currently left in the unit. \"\"\"\n        return self._proto.cargo_space_max - self._proto.cargo_space_taken\n\n    @property\n    def assigned_harvesters(self) -> int:\n        \"\"\" Returns the number of workers currently gathering resources at a geyser or mining base.\"\"\"\n        return self._proto.assigned_harvesters\n\n    @property\n    def ideal_harvesters(self) -> int:\n        \"\"\"Returns the ideal harverster count for unit.\n        3 for gas buildings, 2*n for n mineral patches on that base.\"\"\"\n        return self._proto.ideal_harvesters\n\n    @property\n    def surplus_harvesters(self) -> int:\n        \"\"\"Returns a positive int if unit has too many harvesters mining,\n        a negative int if it has too few mining.\n        Will only works on townhalls, and gas buildings.\n        \"\"\"\n        return self._proto.assigned_harvesters - self._proto.ideal_harvesters\n\n    @property_immutable_cache\n    def weapon_cooldown(self) -> float:\n        \"\"\"Returns the time until the unit can fire again,\n        returns -1 for units that can't attack.\n        Usage:\n        if unit.weapon_cooldown == 0:\n            unit.attack(target)\n        elif unit.weapon_cooldown < 0:\n            unit.move(closest_allied_unit_because_cant_attack)\n        else:\n            unit.move(retreatPosition)\"\"\"\n        if self.can_attack:\n            return self._proto.weapon_cooldown\n        return -1\n\n    @property\n    def weapon_ready(self) -> bool:\n        \"\"\" Checks if the weapon is ready to be fired. \"\"\"\n        return self.weapon_cooldown == 0\n\n    @property\n    def engaged_target_tag(self) -> int:\n        # TODO What does this do?\n        return self._proto.engaged_target_tag\n\n    # TODO: Add rally targets https://github.com/Blizzard/s2client-proto/commit/80484692fa9e0ea6e7be04e728e4f5995c64daa3#diff-3b331650a4f7c9271a579b31cf771ed5R88-R92\n\n    # Unit functions\n\n    def has_buff(self, buff: BuffId) -> bool:\n        \"\"\" Checks if unit has buff 'buff'. \"\"\"\n        assert isinstance(buff, BuffId), f\"{buff} is no BuffId\"\n        return buff in self.buffs\n\n    def train(self, unit: UnitTypeId, queue: bool = False, can_afford_check: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders unit to train another 'unit'.\n        Usage: COMMANDCENTER.train(SCV)\n\n        :param unit:\n        :param queue:\"\"\"\n        return self(\n            self._bot_object._game_data.units[unit.value].creation_ability.id,\n            queue=queue,\n            subtract_cost=True,\n            can_afford_check=can_afford_check,\n        )\n\n    def build(\n        self,\n        unit: UnitTypeId,\n        position: Union[Point2, Point3] = None,\n        queue: bool = False,\n        can_afford_check: bool = False,\n    ) -> Union[UnitCommand, bool]:\n        \"\"\"Orders unit to build another 'unit' at 'position'.\n        Usage::\n\n            SCV.build(COMMANDCENTER, position)\n            # Target for refinery, assimilator and extractor needs to be the vespene geysir unit, not its position\n            SCV.build(REFINERY, target_vespene_geysir)\n\n        :param unit:\n        :param position:\n        :param queue:\n        \"\"\"\n        if unit in {UnitTypeId.EXTRACTOR, UnitTypeId.ASSIMILATOR, UnitTypeId.REFINERY}:\n            assert isinstance(\n                position, Unit\n            ), f\"When building the gas structure, the target needs to be a unit (the vespene geysir) not the position of the vespene geysir.\"\n        return self(\n            self._bot_object._game_data.units[unit.value].creation_ability.id,\n            target=position,\n            queue=queue,\n            subtract_cost=True,\n            can_afford_check=can_afford_check,\n        )\n\n    def build_gas(self,\n                  target_geysir: Unit,\n                  queue: bool = False,\n                  can_afford_check: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders unit to build another 'unit' at 'position'.\n        Usage::\n\n            # Target for refinery, assimilator and extractor needs to be the vespene geysir unit, not its position\n            SCV.build_gas(target_vespene_geysir)\n\n        :param target_geysir:\n        :param queue:\n        \"\"\"\n        gas_structure_type_id: UnitTypeId = race_gas[self._bot_object.race]\n        assert isinstance(\n            target_geysir, Unit\n        ), f\"When building the gas structure, the target needs to be a unit (the vespene geysir) not the position of the vespene geysir.\"\n        return self(\n            self._bot_object._game_data.units[gas_structure_type_id.value].creation_ability.id,\n            target=target_geysir,\n            queue=queue,\n            subtract_cost=True,\n            can_afford_check=can_afford_check,\n        )\n\n    def research(self,\n                 upgrade: UpgradeId,\n                 queue: bool = False,\n                 can_afford_check: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders unit to research 'upgrade'.\n        Requires UpgradeId to be passed instead of AbilityId.\n\n        :param upgrade:\n        :param queue:\n        \"\"\"\n        return self(\n            self._bot_object._game_data.upgrades[upgrade.value].research_ability.exact_id,\n            queue=queue,\n            subtract_cost=True,\n            can_afford_check=can_afford_check,\n        )\n\n    def warp_in(self,\n                unit: UnitTypeId,\n                position: Union[Point2, Point3],\n                can_afford_check: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders Warpgate to warp in 'unit' at 'position'.\n\n        :param unit:\n        :param queue:\n        \"\"\"\n        normal_creation_ability = self._bot_object._game_data.units[unit.value].creation_ability.id\n        return self(\n            warpgate_abilities[normal_creation_ability],\n            target=position,\n            subtract_cost=True,\n            subtract_supply=True,\n            can_afford_check=can_afford_check,\n        )\n\n    def attack(self, target: Union[Unit, Point2, Point3], queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders unit to attack. Target can be a Unit or Point2.\n        Attacking a position will make the unit move there and attack everything on its way.\n\n        :param target:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.ATTACK, target=target, queue=queue)\n\n    def smart(self, target: Union[Unit, Point2, Point3], queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders the smart command. Equivalent to a right-click order.\n\n        :param target:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.SMART, target=target, queue=queue)\n\n    def gather(self, target: Unit, queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders a unit to gather minerals or gas.\n        'Target' must be a mineral patch or a gas extraction building.\n\n        :param target:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.HARVEST_GATHER, target=target, queue=queue)\n\n    def return_resource(self, target: Unit = None, queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders the unit to return resource. Does not need a 'target'.\n\n        :param target:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.HARVEST_RETURN, target=target, queue=queue)\n\n    def move(self, position: Union[Unit, Point2, Point3], queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders the unit to move to 'position'.\n        Target can be a Unit (to follow that unit) or Point2.\n\n        :param position:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.MOVE_MOVE, target=position, queue=queue)\n\n    def scan_move(self, *args, **kwargs) -> Union[UnitCommand, bool]:\n        \"\"\" Deprecated: This ability redirects to 'AbilityId.ATTACK' \"\"\"\n        return self(AbilityId.SCAN_MOVE, *args, **kwargs)\n\n    def hold_position(self, queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders a unit to stop moving. It will not move until it gets new orders.\n\n        :param queue:\n        \"\"\"\n        return self(AbilityId.HOLDPOSITION, queue=queue)\n\n    def stop(self, queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders a unit to stop, but can start to move on its own\n        if it is attacked, enemy unit is in range or other friendly\n        units need the space.\n\n        :param queue:\n        \"\"\"\n        return self(AbilityId.STOP, queue=queue)\n\n    def patrol(self, position: Union[Point2, Point3], queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders a unit to patrol between position it has when the command starts and the target position.\n        Can be queued up to seven patrol points. If the last point is the same as the starting\n        point, the unit will patrol in a circle.\n\n        :param position:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.PATROL, target=position, queue=queue)\n\n    def repair(self, repair_target: Unit, queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Order an SCV or MULE to repair.\n\n        :param repair_target:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.EFFECT_REPAIR, target=repair_target, queue=queue)\n\n    def __hash__(self):\n        return self.tag\n\n    def __eq__(self, other):\n        try:\n            return self.tag == other.tag\n        except:\n            return False\n\n    def __call__(\n        self,\n        ability: AbilityId,\n        target: Optional[Union[Point2, Unit]] = None,\n        queue: bool = False,\n        subtract_cost: bool = False,\n        subtract_supply: bool = False,\n        can_afford_check: bool = False,\n    ) -> Union[UnitCommand, bool]:\n        \"\"\" Deprecated: Stop using self.do() - This may be removed in the future. \"\"\"\n        if self._bot_object.unit_command_uses_self_do:\n            return UnitCommand(ability, self, target=target, queue=queue)\n        expected_target: int = self._bot_object.game_data.abilities[ability.value]._proto.target\n        # 1: None, 2: Point, 3: Unit, 4: PointOrUnit, 5: PointOrNone\n        if target is None and expected_target not in {1, 5}:\n            warnings.warn(\n                f\"{self} got {ability} with no target but expected {TARGET_HELPER[expected_target]}\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n        elif isinstance(target, Point2) and expected_target not in {2, 4, 5}:\n            warnings.warn(\n                f\"{self} got {ability} with Point2 as target but expected {TARGET_HELPER[expected_target]}\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n        elif isinstance(target, Unit) and expected_target not in {3, 4}:\n            warnings.warn(\n                f\"{self} got {ability} with Unit as target but expected {TARGET_HELPER[expected_target]}\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n        return self._bot_object.do(\n            UnitCommand(ability, self, target=target, queue=queue),\n            subtract_cost=subtract_cost,\n            subtract_supply=subtract_supply,\n            can_afford_check=can_afford_check,\n        )",
  "def from_proto(cls, proto, bot_object: BotAI):\n        return cls(\n            bot_object._game_data.abilities[proto.ability_id],\n            (proto.target_world_space_pos if proto.HasField(\"target_world_space_pos\") else proto.target_unit_tag),\n            proto.progress,\n        )",
  "def __init__(self, ability: AbilityData, target, progress: float = None):\n        \"\"\"\n        :param ability:\n        :param target:\n        :param progress:\n        \"\"\"\n        self.ability: AbilityData = ability\n        # This can be an int (if target is unit) or proto Point2 object, which needs to be converted using 'Point2.from_proto(target)'\n        self.target = target\n        self.progress: float = progress",
  "def __repr__(self) -> str:\n        return f\"UnitOrder({self.ability}, {self.target}, {self.progress})\"",
  "def __init__(self, proto_data, bot_object: BotAI, distance_calculation_index: int = -1, base_build: int = -1):\n        \"\"\"\n        :param proto_data:\n        :param bot_object:\n        \"\"\"\n        self._proto = proto_data\n        self._bot_object: BotAI = bot_object\n        # Used by property_immutable_cache\n        self.cache = {}\n        self.game_loop: int = bot_object.state.game_loop\n        self.base_build = base_build\n        # Index used in the 2D numpy array to access the 2D distance between two units\n        self.distance_calculation_index: int = distance_calculation_index",
  "def __repr__(self) -> str:\n        \"\"\" Returns string of this form: Unit(name='SCV', tag=4396941328). \"\"\"\n        return f\"Unit(name={self.name !r}, tag={self.tag})\"",
  "def type_id(self) -> UnitTypeId:\n        \"\"\"UnitTypeId found in sc2/ids/unit_typeid.\n        Caches all type_ids of the same unit type.\"\"\"\n        unit_type = self._proto.unit_type\n        if unit_type not in self._bot_object._game_data.unit_types:\n            self._bot_object._game_data.unit_types[unit_type] = UnitTypeId(unit_type)\n        return self._bot_object._game_data.unit_types[unit_type]",
  "def _type_data(self) -> UnitTypeData:\n        \"\"\" Provides the unit type data. \"\"\"\n        return self._bot_object._game_data.units[self._proto.unit_type]",
  "def _creation_ability(self) -> AbilityData:\n        \"\"\" Provides the AbilityData of the creation ability of this unit. \"\"\"\n        return self._bot_object._game_data.units[self._proto.unit_type].creation_ability",
  "def name(self) -> str:\n        \"\"\" Returns the name of the unit. \"\"\"\n        return self._type_data.name",
  "def race(self) -> Race:\n        \"\"\" Returns the race of the unit \"\"\"\n        return Race(self._type_data._proto.race)",
  "def tag(self) -> int:\n        \"\"\" Returns the unique tag of the unit. \"\"\"\n        return self._proto.tag",
  "def is_structure(self) -> bool:\n        \"\"\" Checks if the unit is a structure. \"\"\"\n        return IS_STRUCTURE in self._type_data.attributes",
  "def is_light(self) -> bool:\n        \"\"\" Checks if the unit has the 'light' attribute. \"\"\"\n        return IS_LIGHT in self._type_data.attributes",
  "def is_armored(self) -> bool:\n        \"\"\" Checks if the unit has the 'armored' attribute. \"\"\"\n        return IS_ARMORED in self._type_data.attributes",
  "def is_biological(self) -> bool:\n        \"\"\" Checks if the unit has the 'biological' attribute. \"\"\"\n        return IS_BIOLOGICAL in self._type_data.attributes",
  "def is_mechanical(self) -> bool:\n        \"\"\" Checks if the unit has the 'mechanical' attribute. \"\"\"\n        return IS_MECHANICAL in self._type_data.attributes",
  "def is_massive(self) -> bool:\n        \"\"\" Checks if the unit has the 'massive' attribute. \"\"\"\n        return IS_MASSIVE in self._type_data.attributes",
  "def is_psionic(self) -> bool:\n        \"\"\" Checks if the unit has the 'psionic' attribute. \"\"\"\n        return IS_PSIONIC in self._type_data.attributes",
  "def tech_alias(self) -> Optional[List[UnitTypeId]]:\n        \"\"\"Building tech equality, e.g. OrbitalCommand is the same as CommandCenter\n        For Hive, this returns [UnitTypeId.Hatchery, UnitTypeId.Lair]\n        For SCV, this returns None\"\"\"\n        return self._type_data.tech_alias",
  "def unit_alias(self) -> Optional[UnitTypeId]:\n        \"\"\"Building type equality, e.g. FlyingOrbitalCommand is the same as OrbitalCommand\n        For flying OrbitalCommand, this returns UnitTypeId.OrbitalCommand\n        For SCV, this returns None\"\"\"\n        return self._type_data.unit_alias",
  "def _weapons(self):\n        \"\"\" Returns the weapons of the unit. \"\"\"\n        try:\n            return self._type_data._proto.weapons\n        except:\n            return None",
  "def can_attack(self) -> bool:\n        \"\"\" Checks if the unit can attack at all. \"\"\"\n        # TODO BATTLECRUISER doesnt have weapons in proto?!\n        return bool(self._weapons) or self.type_id in {UNIT_BATTLECRUISER, UNIT_ORACLE}",
  "def can_attack_both(self) -> bool:\n        \"\"\" Checks if the unit can attack both ground and air units. \"\"\"\n        return self.can_attack_ground and self.can_attack_air",
  "def can_attack_ground(self) -> bool:\n        \"\"\" Checks if the unit can attack ground units. \"\"\"\n        if self.type_id in {UNIT_BATTLECRUISER, UNIT_ORACLE}:\n            return True\n        if self._weapons:\n            return any(weapon.type in TARGET_GROUND for weapon in self._weapons)\n        return False",
  "def ground_dps(self) -> float:\n        \"\"\" Returns the dps against ground units. Does not include upgrades. \"\"\"\n        if self.can_attack_ground:\n            weapon = next((weapon for weapon in self._weapons if weapon.type in TARGET_GROUND), None)\n            if weapon:\n                return (weapon.damage * weapon.attacks) / weapon.speed\n        return 0",
  "def ground_range(self) -> float:\n        \"\"\" Returns the range against ground units. Does not include upgrades. \"\"\"\n        if self.type_id == UNIT_ORACLE:\n            return 4\n        if self.type_id == UNIT_BATTLECRUISER:\n            return 6\n        if self.can_attack_ground:\n            weapon = next((weapon for weapon in self._weapons if weapon.type in TARGET_GROUND), None)\n            if weapon:\n                return weapon.range\n        return 0",
  "def can_attack_air(self) -> bool:\n        \"\"\" Checks if the unit can air attack at all. Does not include upgrades. \"\"\"\n        if self.type_id == UNIT_BATTLECRUISER:\n            return True\n        if self._weapons:\n            return any(weapon.type in TARGET_AIR for weapon in self._weapons)\n        return False",
  "def air_dps(self) -> float:\n        \"\"\" Returns the dps against air units. Does not include upgrades. \"\"\"\n        if self.can_attack_air:\n            weapon = next((weapon for weapon in self._weapons if weapon.type in TARGET_AIR), None)\n            if weapon:\n                return (weapon.damage * weapon.attacks) / weapon.speed\n        return 0",
  "def air_range(self) -> float:\n        \"\"\" Returns the range against air units. Does not include upgrades. \"\"\"\n        if self.type_id == UNIT_BATTLECRUISER:\n            return 6\n        if self.can_attack_air:\n            weapon = next((weapon for weapon in self._weapons if weapon.type in TARGET_AIR), None)\n            if weapon:\n                return weapon.range\n        return 0",
  "def bonus_damage(self):\n        \"\"\"Returns a tuple of form '(bonus damage, armor type)' if unit does 'bonus damage' against 'armor type'.\n        Possible armor typs are: 'Light', 'Armored', 'Biological', 'Mechanical', 'Psionic', 'Massive', 'Structure'.\"\"\"\n        # TODO: Consider units with ability attacks (Oracle, Baneling) or multiple attacks (Thor).\n        if self._weapons:\n            for weapon in self._weapons:\n                if weapon.damage_bonus:\n                    b = weapon.damage_bonus[0]\n                    return (b.bonus, Attribute(b.attribute).name)\n        else:\n            return None",
  "def armor(self) -> float:\n        \"\"\" Returns the armor of the unit. Does not include upgrades \"\"\"\n        return self._type_data._proto.armor",
  "def sight_range(self) -> float:\n        \"\"\" Returns the sight range of the unit. \"\"\"\n        return self._type_data._proto.sight_range",
  "def movement_speed(self) -> float:\n        \"\"\"Returns the movement speed of the unit.\n        This is the unit movement speed on game speed 'normal'. To convert it to 'faster' movement speed, multiply it by a factor of '1.4'. E.g. reaper movement speed is listed here as 3.75, but should actually be 5.25.\n        Does not include upgrades or buffs.\"\"\"\n        return self._type_data._proto.movement_speed",
  "def real_speed(self) -> float:\n        \"\"\" See 'calculate_speed'. \"\"\"\n        return self.calculate_speed()",
  "def calculate_speed(self, upgrades: Set[UpgradeId] = None) -> float:\n        \"\"\"Calculates the movement speed of the unit including buffs and upgrades.\n        Note: Upgrades only work with own units. Use \"upgrades\" param to set expected enemy upgrades.\n\n        :param upgrades:\"\"\"\n        speed: float = self.movement_speed\n        unit_type: UnitTypeId = self.type_id\n\n        # ---- Upgrades ----\n        if upgrades is None and self.is_mine:\n            upgrades = self._bot_object.state.upgrades\n\n        if upgrades and unit_type in SPEED_UPGRADE_DICT:\n            upgrade_id: UpgradeId = SPEED_UPGRADE_DICT.get(unit_type, None)\n            if upgrade_id and upgrade_id in upgrades:\n                speed *= SPEED_INCREASE_DICT.get(unit_type, 1)\n\n        # ---- Creep ----\n        if unit_type in SPEED_INCREASE_ON_CREEP_DICT or unit_type in OFF_CREEP_SPEED_UPGRADE_DICT:\n            # On creep\n            x, y = self.position_tuple\n            if self._bot_object.state.creep[(int(x), int(y))]:\n                speed *= SPEED_INCREASE_ON_CREEP_DICT.get(unit_type, 1)\n\n            # Off creep upgrades\n            elif upgrades:\n                upgrade_id: UpgradeId = OFF_CREEP_SPEED_UPGRADE_DICT.get(unit_type, None)\n                if upgrade_id:\n                    speed *= OFF_CREEP_SPEED_INCREASE_DICT[unit_type]\n\n            # Ultralisk has passive ability \"Frenzied\" which makes it immune to speed altering buffs\n            if unit_type == UnitTypeId.ULTRALISK:\n                return speed\n\n        # ---- Buffs ----\n        # Hard reset movement speed: medivac boost, void ray charge\n        if self.buffs and unit_type in {UnitTypeId.MEDIVAC, UnitTypeId.VOIDRAY}:\n            if BuffId.MEDIVACSPEEDBOOST in self.buffs:\n                speed = self.movement_speed * 1.7\n            elif BuffId.VOIDRAYSWARMDAMAGEBOOST in self.buffs:\n                speed = self.movement_speed * 0.75\n\n        # Speed altering buffs, e.g. stimpack, zealot charge, concussive shell, time warp, fungal growth, inhibitor zone\n        for buff in self.buffs:\n            speed *= SPEED_ALTERING_BUFFS.get(buff, 1)\n        return speed",
  "def distance_per_step(self) -> float:\n        \"\"\"The distance a unit can move in one step. This does not take acceleration into account.\n        Useful for micro-retreat/pathfinding\"\"\"\n        return (self.real_speed / 22.4) * self._bot_object.client.game_step",
  "def distance_to_weapon_ready(self) -> float:\n        \"\"\" Distance a unit can travel before it's weapon is ready to be fired again.\"\"\"\n        return (self.real_speed / 22.4) * self.weapon_cooldown",
  "def is_mineral_field(self) -> bool:\n        \"\"\" Checks if the unit is a mineral field. \"\"\"\n        return self._type_data.has_minerals",
  "def is_vespene_geyser(self) -> bool:\n        \"\"\" Checks if the unit is a non-empty vespene geyser or gas extraction building. \"\"\"\n        return self._type_data.has_vespene",
  "def health(self) -> float:\n        \"\"\" Returns the health of the unit. Does not include shields. \"\"\"\n        return self._proto.health",
  "def health_max(self) -> float:\n        \"\"\" Returns the maximum health of the unit. Does not include shields. \"\"\"\n        return self._proto.health_max",
  "def health_percentage(self) -> float:\n        \"\"\" Returns the percentage of health the unit has. Does not include shields. \"\"\"\n        if not self._proto.health_max:\n            return 0\n        return self._proto.health / self._proto.health_max",
  "def shield(self) -> float:\n        \"\"\" Returns the shield points the unit has. Returns 0 for non-protoss units. \"\"\"\n        return self._proto.shield",
  "def shield_max(self) -> float:\n        \"\"\" Returns the maximum shield points the unit can have. Returns 0 for non-protoss units. \"\"\"\n        return self._proto.shield_max",
  "def shield_percentage(self) -> float:\n        \"\"\" Returns the percentage of shield points the unit has. Returns 0 for non-protoss units. \"\"\"\n        if not self._proto.shield_max:\n            return 0\n        return self._proto.shield / self._proto.shield_max",
  "def shield_health_percentage(self) -> float:\n        \"\"\"Returns the percentage of combined shield + hp points the unit has.\n        Also takes build progress into account.\"\"\"\n        max_ = (self._proto.shield_max + self._proto.health_max) * self.build_progress\n        if not max_:\n            return 0\n        return (self._proto.shield + self._proto.health) / max_",
  "def energy(self) -> float:\n        \"\"\" Returns the amount of energy the unit has. Returns 0 for units without energy. \"\"\"\n        return self._proto.energy",
  "def energy_max(self) -> float:\n        \"\"\" Returns the maximum amount of energy the unit can have. Returns 0 for units without energy. \"\"\"\n        return self._proto.energy_max",
  "def energy_percentage(self) -> float:\n        \"\"\" Returns the percentage of amount of energy the unit has. Returns 0 for units without energy. \"\"\"\n        if not self._proto.energy_max:\n            return 0\n        return self._proto.energy / self._proto.energy_max",
  "def age_in_frames(self) -> int:\n        \"\"\" Returns how old the unit object data is (in game frames). This age does not reflect the unit was created / trained / morphed! \"\"\"\n        return self._bot_object.state.game_loop - self.game_loop",
  "def age(self) -> float:\n        \"\"\" Returns how old the unit object data is (in game seconds). This age does not reflect when the unit was created / trained / morphed! \"\"\"\n        return (self._bot_object.state.game_loop - self.game_loop) / 22.4",
  "def is_memory(self) -> bool:\n        \"\"\" Returns True if this Unit object is referenced from the future and is outdated. \"\"\"\n        return self.game_loop != self._bot_object.state.game_loop",
  "def is_snapshot(self) -> bool:\n        \"\"\"Checks if the unit is only available as a snapshot for the bot.\n        Enemy buildings that have been scouted and are in the fog of war or\n        attacking enemy units on higher, not visible ground appear this way.\"\"\"\n        if self.base_build >= 82457:\n            return self._proto.display_type == IS_SNAPSHOT\n        # TODO: Fixed in version 5.0.4, remove if a new linux binary is released: https://github.com/Blizzard/s2client-proto/issues/167\n        position = self.position.rounded\n        return self._bot_object.state.visibility.data_numpy[position[1], position[0]] != 2",
  "def is_visible(self) -> bool:\n        \"\"\"Checks if the unit is visible for the bot.\n        NOTE: This means the bot has vision of the position of the unit!\n        It does not give any information about the cloak status of the unit.\"\"\"\n        if self.base_build >= 82457:\n            return self._proto.display_type == IS_VISIBLE\n        # TODO: Remove when a new linux binary (5.0.4 or newer) is released\n        return self._proto.display_type == IS_VISIBLE and not self.is_snapshot",
  "def is_placeholder(self) -> bool:\n        \"\"\"Checks if the unit is a placerholder for the bot.\n        Raw information about placeholders:\n            display_type: Placeholder\n            alliance: Self\n            unit_type: 86\n            owner: 1\n            pos {\n              x: 29.5\n              y: 53.5\n              z: 7.98828125\n            }\n            radius: 2.75\n            is_on_screen: false\n        \"\"\"\n        return self._proto.display_type == IS_PLACEHOLDER",
  "def alliance(self) -> Alliance:\n        \"\"\" Returns the team the unit belongs to. \"\"\"\n        return self._proto.alliance",
  "def is_mine(self) -> bool:\n        \"\"\" Checks if the unit is controlled by the bot. \"\"\"\n        return self._proto.alliance == IS_MINE",
  "def is_enemy(self) -> bool:\n        \"\"\" Checks if the unit is hostile. \"\"\"\n        return self._proto.alliance == IS_ENEMY",
  "def owner_id(self) -> int:\n        \"\"\" Returns the owner of the unit. This is a value of 1 or 2 in a two player game. \"\"\"\n        return self._proto.owner",
  "def position_tuple(self) -> Tuple[float, float]:\n        \"\"\" Returns the 2d position of the unit as tuple without conversion to Point2. \"\"\"\n        return self._proto.pos.x, self._proto.pos.y",
  "def position(self) -> Point2:\n        \"\"\" Returns the 2d position of the unit. \"\"\"\n        return Point2.from_proto(self._proto.pos)",
  "def position3d(self) -> Point3:\n        \"\"\" Returns the 3d position of the unit. \"\"\"\n        return Point3.from_proto(self._proto.pos)",
  "def distance_to(self, p: Union[Unit, Point2, Point3]) -> float:\n        \"\"\"Using the 2d distance between self and p.\n        To calculate the 3d distance, use unit.position3d.distance_to(p)\n\n        :param p:\"\"\"\n        if isinstance(p, Unit):\n            return self._bot_object._distance_squared_unit_to_unit(self, p)**0.5\n        return self._bot_object.distance_math_hypot(self.position_tuple, p)",
  "def distance_to_squared(self, p: Union[Unit, Point2, Point3]) -> float:\n        \"\"\"Using the 2d distance squared between self and p. Slightly faster than distance_to, so when filtering a lot of units, this function is recommended to be used.\n        To calculate the 3d distance, use unit.position3d.distance_to(p)\n\n        :param p:\"\"\"\n        if isinstance(p, Unit):\n            return self._bot_object._distance_squared_unit_to_unit(self, p)\n        return self._bot_object.distance_math_hypot_squared(self.position_tuple, p)",
  "def target_in_range(self, target: Unit, bonus_distance: float = 0) -> bool:\n        \"\"\"Checks if the target is in range.\n        Includes the target's radius when calculating distance to target.\n\n        :param target:\n        :param bonus_distance:\"\"\"\n        # TODO: Fix this because immovable units (sieged tank, planetary fortress etc.) have a little lower range than this formula\n        if self.can_attack_ground and not target.is_flying:\n            unit_attack_range = self.ground_range\n        elif self.can_attack_air and (target.is_flying or target.type_id == UNIT_COLOSSUS):\n            unit_attack_range = self.air_range\n        else:\n            return False\n        return (\n            self._bot_object._distance_squared_unit_to_unit(self, target) <=\n            (self.radius + target.radius + unit_attack_range + bonus_distance)**2\n        )",
  "def in_ability_cast_range(\n        self, ability_id: AbilityId, target: Union[Unit, Point2], bonus_distance: float = 0\n    ) -> bool:\n        \"\"\"Test if a unit is able to cast an ability on the target without checking ability cooldown (like stalker blink) or if ability is made available through research (like HT storm).\n\n        :param ability_id:\n        :param target:\n        :param bonus_distance:\"\"\"\n        cast_range = self._bot_object._game_data.abilities[ability_id.value]._proto.cast_range\n        assert cast_range > 0, f\"Checking for an ability ({ability_id}) that has no cast range\"\n        ability_target_type = self._bot_object._game_data.abilities[ability_id.value]._proto.target\n        # For casting abilities that target other units, like transfuse, feedback, snipe, yamato\n        if ability_target_type in {Target.Unit.value, Target.PointOrUnit.value} and isinstance(target, Unit):\n            return (\n                self._bot_object._distance_squared_unit_to_unit(self, target) <=\n                (cast_range + self.radius + target.radius + bonus_distance)**2\n            )\n        # For casting abilities on the ground, like queen creep tumor, ravager bile, HT storm\n        if ability_target_type in {Target.Point.value, Target.PointOrUnit.value\n                                   } and isinstance(target, (Point2, tuple)):\n            return (\n                self._bot_object._distance_pos_to_pos(self.position_tuple, target) <=\n                cast_range + self.radius + bonus_distance\n            )\n        return False",
  "def calculate_damage_vs_target(\n        self,\n        target: Unit,\n        ignore_armor: bool = False,\n        include_overkill_damage: bool = True\n    ) -> Tuple[float, float, float]:\n        \"\"\"\n        Returns a tuple of: [potential damage against target, attack speed, attack range]\n        Returns the properly calculated damage per full-attack against the target unit.\n        Returns (0, 0, 0) if this unit can't attack the target unit.\n\n        If 'include_overkill_damage=True' and the unit deals 10 damage, the target unit has 5 hp and 0 armor,\n        the target unit would result in -5hp, so the returning damage would be 10.\n        For 'include_overkill_damage=False' this function would return 5.\n\n        If 'ignore_armor=False' and the unit deals 10 damage, the target unit has 20 hp and 5 armor,\n        the target unit would result in 15hp, so the returning damage would be 5.\n        For 'ignore_armor=True' this function would return 10.\n\n        :param target:\n        :param ignore_armor:\n        :param include_overkill_damage:\n        \"\"\"\n        if self.type_id not in {UnitTypeId.BATTLECRUISER, UnitTypeId.BUNKER}:\n            if not self.can_attack:\n                return 0, 0, 0\n            if target.type_id != UnitTypeId.COLOSSUS:\n                if not self.can_attack_ground and not target.is_flying:\n                    return 0, 0, 0\n                if not self.can_attack_air and target.is_flying:\n                    return 0, 0, 0\n        # Structures that are not completed can't attack\n        if not self.is_ready:\n            return 0, 0, 0\n        target_has_guardian_shield: bool = False\n        if ignore_armor:\n            enemy_armor: float = 0\n            enemy_shield_armor: float = 0\n        else:\n            # TODO: enemy is under influence of anti armor missile -> reduce armor and shield armor\n            enemy_armor: float = target.armor + target.armor_upgrade_level\n            enemy_shield_armor: float = target.shield_upgrade_level\n            # Ultralisk armor upgrade, only works if target belongs to the bot calling this function\n            if (\n                target.type_id in {UnitTypeId.ULTRALISK, UnitTypeId.ULTRALISKBURROWED} and target.is_mine\n                and UpgradeId.CHITINOUSPLATING in target._bot_object.state.upgrades\n            ):\n                enemy_armor += 2\n            # Guardian shield adds 2 armor\n            if BuffId.GUARDIANSHIELD in target.buffs:\n                target_has_guardian_shield = True\n            # Anti armor missile of raven\n            if BuffId.RAVENSHREDDERMISSILETINT in target.buffs:\n                enemy_armor -= 2\n                enemy_shield_armor -= 2\n\n        # Hard coded return for battlecruiser because they have no weapon in the API\n        if self.type_id == UnitTypeId.BATTLECRUISER:\n            if target_has_guardian_shield:\n                enemy_armor += 2\n                enemy_shield_armor += 2\n            weapon_damage = (5 if target.is_flying else 8) + self.attack_upgrade_level\n            weapon_damage = weapon_damage - enemy_shield_armor if target.shield else weapon_damage - enemy_armor\n            return weapon_damage, 0.224, 6\n\n        # Fast return for bunkers, since they don't have a weapon similar to BCs\n        if self.type_id == UnitTypeId.BUNKER:\n            if self.is_enemy:\n                if self.is_active:\n                    # Expect fully loaded bunker with marines\n                    return (24, 0.854, 6)\n                return (0, 0, 0)\n            else:\n                # TODO if bunker belongs to us, use passengers and upgrade level to calculate damage\n                pass\n\n        required_target_type: Set[int] = (\n            TARGET_BOTH\n            if target.type_id == UnitTypeId.COLOSSUS else TARGET_GROUND if not target.is_flying else TARGET_AIR\n        )\n        # Contains total damage, attack speed and attack range\n        damages: List[Tuple[float, float, float]] = []\n        for weapon in self._weapons:\n            if weapon.type not in required_target_type:\n                continue\n            enemy_health: float = target.health\n            enemy_shield: float = target.shield\n            total_attacks: int = weapon.attacks\n            weapon_speed: float = weapon.speed\n            weapon_range: float = weapon.range\n            bonus_damage_per_upgrade = (\n                0 if not self.attack_upgrade_level else\n                DAMAGE_BONUS_PER_UPGRADE.get(self.type_id, {}).get(weapon.type, {}).get(None, 1)\n            )\n            damage_per_attack: float = weapon.damage + self.attack_upgrade_level * bonus_damage_per_upgrade\n            # Remaining damage after all damage is dealt to shield\n            remaining_damage: float = 0\n\n            # Calculate bonus damage against target\n            boni: List[float] = []\n            # TODO: hardcode hellbats when they have blueflame or attack upgrades\n            for bonus in weapon.damage_bonus:\n                # More about damage bonus https://github.com/Blizzard/s2client-proto/blob/b73eb59ac7f2c52b2ca585db4399f2d3202e102a/s2clientprotocol/data.proto#L55\n                if bonus.attribute in target._type_data.attributes:\n                    bonus_damage_per_upgrade = (\n                        0 if not self.attack_upgrade_level else\n                        DAMAGE_BONUS_PER_UPGRADE.get(self.type_id, {}).get(weapon.type, {}).get(bonus.attribute, 0)\n                    )\n                    # Hardcode blueflame damage bonus from hellions\n                    if (\n                        bonus.attribute == IS_LIGHT and self.type_id == UnitTypeId.HELLION\n                        and UpgradeId.HIGHCAPACITYBARRELS in self._bot_object.state.upgrades\n                    ):\n                        bonus_damage_per_upgrade += 5\n                    # TODO buffs e.g. void ray charge beam vs armored\n                    boni.append(bonus.bonus + self.attack_upgrade_level * bonus_damage_per_upgrade)\n            if boni:\n                damage_per_attack += max(boni)\n\n            # Subtract enemy unit's shield\n            if target.shield > 0:\n                # Fix for ranged units + guardian shield\n                enemy_shield_armor_temp = (\n                    enemy_shield_armor + 2 if target_has_guardian_shield and weapon_range >= 2 else enemy_shield_armor\n                )\n                # Shield-armor has to be applied\n                while total_attacks > 0 and enemy_shield > 0:\n                    # Guardian shield correction\n                    enemy_shield -= max(0.5, damage_per_attack - enemy_shield_armor_temp)\n                    total_attacks -= 1\n                if enemy_shield < 0:\n                    remaining_damage = -enemy_shield\n                    enemy_shield = 0\n\n            # TODO roach and hydra in melee range are not affected by guardian shield\n            # Fix for ranged units if enemy has guardian shield buff\n            enemy_armor_temp = enemy_armor + 2 if target_has_guardian_shield and weapon_range >= 2 else enemy_armor\n            # Subtract enemy unit's HP\n            if remaining_damage > 0:\n                enemy_health -= max(0.5, remaining_damage - enemy_armor_temp)\n            while total_attacks > 0 and (include_overkill_damage or enemy_health > 0):\n                # Guardian shield correction\n                enemy_health -= max(0.5, damage_per_attack - enemy_armor_temp)\n                total_attacks -= 1\n\n            # Calculate the final damage\n            if not include_overkill_damage:\n                enemy_health = max(0, enemy_health)\n                enemy_shield = max(0, enemy_shield)\n            total_damage_dealt = target.health + target.shield - enemy_health - enemy_shield\n            # Unit modifiers: buffs and upgrades that affect weapon speed and weapon range\n            if self.type_id in {\n                UnitTypeId.ZERGLING,\n                UnitTypeId.MARINE,\n                UnitTypeId.MARAUDER,\n                UnitTypeId.ADEPT,\n                UnitTypeId.HYDRALISK,\n                UnitTypeId.PHOENIX,\n                UnitTypeId.PLANETARYFORTRESS,\n                UnitTypeId.MISSILETURRET,\n                UnitTypeId.AUTOTURRET,\n            }:\n                upgrades: Set[UpgradeId] = self._bot_object.state.upgrades\n                if (\n                    self.type_id == UnitTypeId.ZERGLING\n                    # Attack speed calculation only works for our unit\n                    and self.is_mine and UpgradeId.ZERGLINGATTACKSPEED in upgrades\n                ):\n                    # 0.696044921875 for zerglings divided through 1.4 equals (+40% attack speed bonus from the upgrade):\n                    weapon_speed /= 1.4\n                elif (\n                    # Adept ereceive 45% attack speed bonus from glaives\n                    self.type_id == UnitTypeId.ADEPT and self.is_mine and UpgradeId.ADEPTPIERCINGATTACK in upgrades\n                ):\n                    # TODO next patch: if self.type_id is adept: check if attack speed buff is active, instead of upgrade\n                    weapon_speed /= 1.45\n                elif self.type_id == UnitTypeId.MARINE and BuffId.STIMPACK in self.buffs:\n                    # Marine and marauder receive 50% attack speed bonus from stim\n                    weapon_speed /= 1.5\n                elif self.type_id == UnitTypeId.MARAUDER and BuffId.STIMPACKMARAUDER in self.buffs:\n                    weapon_speed /= 1.5\n                elif (\n                    # TODO always assume that the enemy has the range upgrade researched\n                    self.type_id == UnitTypeId.HYDRALISK and self.is_mine and UpgradeId.EVOLVEGROOVEDSPINES in upgrades\n                ):\n                    weapon_range += 1\n                elif self.type_id == UnitTypeId.PHOENIX and self.is_mine and UpgradeId.PHOENIXRANGEUPGRADE in upgrades:\n                    weapon_range += 2\n                elif (\n                    self.type_id in {UnitTypeId.PLANETARYFORTRESS, UnitTypeId.MISSILETURRET, UnitTypeId.AUTOTURRET}\n                    and self.is_mine and UpgradeId.HISECAUTOTRACKING in upgrades\n                ):\n                    weapon_range += 1\n\n            # Append it to the list of damages, e.g. both thor and queen attacks work on colossus\n            damages.append((total_damage_dealt, weapon_speed, weapon_range))\n\n        # If no attack was found, return (0, 0, 0)\n        if not damages:\n            return 0, 0, 0\n        # Returns: total potential damage, attack speed, attack range\n        return max(damages, key=lambda damage_tuple: damage_tuple[0])",
  "def calculate_dps_vs_target(\n        self, target: Unit, ignore_armor: bool = False, include_overkill_damage: bool = True\n    ) -> float:\n        \"\"\" Returns the DPS against the given target. \"\"\"\n        calc_tuple: Tuple[float, float,\n                          float] = self.calculate_damage_vs_target(target, ignore_armor, include_overkill_damage)\n        # TODO fix for real time? The result may have to be multiplied by 1.4 because of game_speed=normal\n        if calc_tuple[1] == 0:\n            return 0\n        return calc_tuple[0] / calc_tuple[1]",
  "def facing(self) -> float:\n        \"\"\" Returns direction the unit is facing as a float in range [0,2\u03c0). 0 is in direction of x axis.\"\"\"\n        return self._proto.facing",
  "def is_facing(self, other_unit: Unit, angle_error: float = 0.05) -> bool:\n        \"\"\"Check if this unit is facing the target unit. If you make angle_error too small, there might be rounding errors. If you make angle_error too big, this function might return false positives.\n\n        :param other_unit:\n        :param angle_error:\"\"\"\n        # TODO perhaps return default True for units that cannot 'face' another unit? e.g. structures (planetary fortress, bunker, missile turret, photon cannon, spine, spore) or sieged tanks\n        angle = math.atan2(\n            other_unit.position_tuple[1] - self.position_tuple[1], other_unit.position_tuple[0] - self.position_tuple[0]\n        )\n        if angle < 0:\n            angle += math.pi * 2\n        angle_difference = math.fabs(angle - self.facing)\n        return angle_difference < angle_error",
  "def footprint_radius(self) -> Optional[float]:\n        \"\"\"For structures only.\n        For townhalls this returns 2.5\n        For barracks, spawning pool, gateway, this returns 1.5\n        For supply depot, this returns 1\n        For sensor tower, creep tumor, this return 0.5\n\n        NOTE: This can be None if a building doesn't have a creation ability.\n        For rich vespene buildings, flying terran buildings, this returns None\"\"\"\n        return self._bot_object._game_data.units[self._proto.unit_type].footprint_radius",
  "def radius(self) -> float:\n        \"\"\" Half of unit size. See https://liquipedia.net/starcraft2/Unit_Statistics_(Legacy_of_the_Void) \"\"\"\n        return self._proto.radius",
  "def build_progress(self) -> float:\n        \"\"\" Returns completion in range [0,1].\"\"\"\n        return self._proto.build_progress",
  "def is_ready(self) -> bool:\n        \"\"\" Checks if the unit is completed. \"\"\"\n        return self.build_progress == 1",
  "def cloak(self) -> CloakState:\n        \"\"\"Returns cloak state.\n        See https://github.com/Blizzard/s2client-api/blob/d9ba0a33d6ce9d233c2a4ee988360c188fbe9dbf/include/sc2api/sc2_unit.h#L95\"\"\"\n        return self._proto.cloak",
  "def is_cloaked(self) -> bool:\n        \"\"\" Checks if the unit is cloaked. \"\"\"\n        return self._proto.cloak in IS_CLOAKED",
  "def is_revealed(self) -> bool:\n        \"\"\" Checks if the unit is revealed. \"\"\"\n        return self._proto.cloak is IS_REVEALED",
  "def can_be_attacked(self) -> bool:\n        \"\"\" Checks if the unit is revealed or not cloaked and therefore can be attacked. \"\"\"\n        return self._proto.cloak in CAN_BE_ATTACKED",
  "def buffs(self) -> Set:\n        \"\"\" Returns the set of current buffs the unit has. \"\"\"\n        return {BuffId(buff_id) for buff_id in self._proto.buff_ids}",
  "def is_carrying_minerals(self) -> bool:\n        \"\"\" Checks if a worker or MULE is carrying (gold-)minerals. \"\"\"\n        return not IS_CARRYING_MINERALS.isdisjoint(self.buffs)",
  "def is_carrying_vespene(self) -> bool:\n        \"\"\" Checks if a worker is carrying vespene gas. \"\"\"\n        return not IS_CARRYING_VESPENE.isdisjoint(self.buffs)",
  "def is_carrying_resource(self) -> bool:\n        \"\"\" Checks if a worker is carrying a resource. \"\"\"\n        return not IS_CARRYING_RESOURCES.isdisjoint(self.buffs)",
  "def detect_range(self) -> float:\n        \"\"\" Returns the detection distance of the unit. \"\"\"\n        return self._proto.detect_range",
  "def is_detector(self) -> bool:\n        \"\"\"Checks if the unit is a detector. Has to be completed\n        in order to detect and Photoncannons also need to be powered.\"\"\"\n        return self.is_ready and (self.type_id in IS_DETECTOR or self.type_id == UNIT_PHOTONCANNON and self.is_powered)",
  "def radar_range(self) -> float:\n        return self._proto.radar_range",
  "def is_selected(self) -> bool:\n        \"\"\" Checks if the unit is currently selected. \"\"\"\n        return self._proto.is_selected",
  "def is_on_screen(self) -> bool:\n        \"\"\" Checks if the unit is on the screen. \"\"\"\n        return self._proto.is_on_screen",
  "def is_blip(self) -> bool:\n        \"\"\" Checks if the unit is detected by a sensor tower. \"\"\"\n        return self._proto.is_blip",
  "def is_powered(self) -> bool:\n        \"\"\" Checks if the unit is powered by a pylon or warppism. \"\"\"\n        return self._proto.is_powered",
  "def is_active(self) -> bool:\n        \"\"\" Checks if the unit has an order (e.g. unit is currently moving or attacking, structure is currently training or researching). \"\"\"\n        return self._proto.is_active",
  "def mineral_contents(self) -> int:\n        \"\"\" Returns the amount of minerals remaining in a mineral field. \"\"\"\n        return self._proto.mineral_contents",
  "def vespene_contents(self) -> int:\n        \"\"\" Returns the amount of gas remaining in a geyser. \"\"\"\n        return self._proto.vespene_contents",
  "def has_vespene(self) -> bool:\n        \"\"\"Checks if a geyser has any gas remaining.\n        You can't build extractors on empty geysers.\"\"\"\n        return bool(self._proto.vespene_contents)",
  "def is_flying(self) -> bool:\n        \"\"\" Checks if the unit is flying. \"\"\"\n        return self._proto.is_flying or self.has_buff(BuffId.GRAVITONBEAM)",
  "def is_burrowed(self) -> bool:\n        \"\"\" Checks if the unit is burrowed. \"\"\"\n        return self._proto.is_burrowed",
  "def is_hallucination(self) -> bool:\n        \"\"\" Returns True if the unit is your own hallucination or detected. \"\"\"\n        return self._proto.is_hallucination",
  "def attack_upgrade_level(self) -> int:\n        \"\"\"Returns the upgrade level of the units attack.\n        # NOTE: Returns 0 for units without a weapon.\"\"\"\n        return self._proto.attack_upgrade_level",
  "def armor_upgrade_level(self) -> int:\n        \"\"\" Returns the upgrade level of the units armor. \"\"\"\n        return self._proto.armor_upgrade_level",
  "def shield_upgrade_level(self) -> int:\n        \"\"\"Returns the upgrade level of the units shield.\n        # NOTE: Returns 0 for units without a shield.\"\"\"\n        return self._proto.shield_upgrade_level",
  "def buff_duration_remain(self) -> int:\n        \"\"\"Returns the amount of remaining frames of the visible timer bar.\n        # NOTE: Returns 0 for units without a timer bar.\"\"\"\n        return self._proto.buff_duration_remain",
  "def buff_duration_max(self) -> int:\n        \"\"\"Returns the maximum amount of frames of the visible timer bar.\n        # NOTE: Returns 0 for units without a timer bar.\"\"\"\n        return self._proto.buff_duration_max",
  "def orders(self) -> List[UnitOrder]:\n        \"\"\" Returns the a list of the current orders. \"\"\"\n        # TODO: add examples on how to use unit orders\n        return [UnitOrder.from_proto(order, self._bot_object) for order in self._proto.orders]",
  "def order_target(self) -> Optional[Union[int, Point2]]:\n        \"\"\"Returns the target tag (if it is a Unit) or Point2 (if it is a Position)\n        from the first order, returns None if the unit is idle\"\"\"\n        if self.orders:\n            target = self.orders[0].target\n            if isinstance(target, int):\n                return target\n            else:\n                return Point2.from_proto(target)\n        return None",
  "def noqueue(self) -> bool:\n        \"\"\" Checks if the unit is idle. \"\"\"\n        warnings.warn(\"noqueue will be removed soon, please use is_idle instead\", DeprecationWarning, stacklevel=2)\n        return self.is_idle",
  "def is_idle(self) -> bool:\n        \"\"\" Checks if unit is idle. \"\"\"\n        return not self._proto.orders",
  "def is_using_ability(self, abilities: Union[AbilityId, Set[AbilityId]]) -> bool:\n        \"\"\"Check if the unit is using one of the given abilities.\n        Only works for own units.\"\"\"\n        if not self.orders:\n            return False\n        if isinstance(abilities, AbilityId):\n            abilities = {abilities}\n        return self.orders[0].ability.id in abilities",
  "def is_moving(self) -> bool:\n        \"\"\"Checks if the unit is moving.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(AbilityId.MOVE)",
  "def is_attacking(self) -> bool:\n        \"\"\"Checks if the unit is attacking.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_ATTACKING)",
  "def is_patrolling(self) -> bool:\n        \"\"\"Checks if a unit is patrolling.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_PATROLLING)",
  "def is_gathering(self) -> bool:\n        \"\"\"Checks if a unit is on its way to a mineral field or vespene geyser to mine.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_GATHERING)",
  "def is_returning(self) -> bool:\n        \"\"\"Checks if a unit is returning from mineral field or vespene geyser to deliver resources to townhall.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_RETURNING)",
  "def is_collecting(self) -> bool:\n        \"\"\"Checks if a unit is gathering or returning.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_COLLECTING)",
  "def is_constructing_scv(self) -> bool:\n        \"\"\"Checks if the unit is an SCV that is currently building.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_CONSTRUCTING_SCV)",
  "def is_transforming(self) -> bool:\n        \"\"\"Checks if the unit transforming.\n        Only works for own units.\"\"\"\n        return self.type_id in transforming and self.is_using_ability(transforming[self.type_id])",
  "def is_repairing(self) -> bool:\n        \"\"\"Checks if the unit is an SCV or MULE that is currently repairing.\n        Only works for own units.\"\"\"\n        return self.is_using_ability(IS_REPAIRING)",
  "def add_on_tag(self) -> int:\n        \"\"\" Returns the tag of the addon of unit. If the unit has no addon, returns 0. \"\"\"\n        return self._proto.add_on_tag",
  "def has_add_on(self) -> bool:\n        \"\"\" Checks if unit has an addon attached. \"\"\"\n        return bool(self._proto.add_on_tag)",
  "def has_techlab(self) -> bool:\n        \"\"\" Check if a structure is connected to a techlab addon. This should only ever return True for BARRACKS, FACTORY, STARPORT. \"\"\"\n        return self.add_on_tag in self._bot_object.techlab_tags",
  "def has_reactor(self) -> bool:\n        \"\"\" Check if a structure is connected to a reactor addon. This should only ever return True for BARRACKS, FACTORY, STARPORT. \"\"\"\n        return self.add_on_tag in self._bot_object.reactor_tags",
  "def add_on_land_position(self) -> Point2:\n        \"\"\"\n        If this unit is an addon (techlab, reactor), returns the position\n        where a terran building (BARRACKS, FACTORY, STARPORT) has to land to connect to this addon.\n\n        Why offset (-2.5, 0.5)? See description in 'add_on_position'\n        \"\"\"\n        return self.position.offset(Point2((-2.5, 0.5)))",
  "def add_on_position(self) -> Point2:\n        \"\"\"\n        If this unit is a terran production building (BARRACKS, FACTORY, STARPORT),\n        this property returns the position of where the addon should be, if it should build one or has one attached.\n\n        Why offset (2.5, -0.5)?\n        A barracks is of size 3x3. The distance from the center to the edge is 1.5.\n        An addon is 2x2 and the distance from the edge to center is 1.\n        The total distance from center to center on the x-axis is 2.5.\n        The distance from center to center on the y-axis is -0.5.\n        \"\"\"\n        return self.position.offset(Point2((2.5, -0.5)))",
  "def passengers(self) -> Set[Unit]:\n        \"\"\" Returns the units inside a Bunker, CommandCenter, PlanetaryFortress, Medivac, Nydus, Overlord or WarpPrism. \"\"\"\n        return {Unit(unit, self._bot_object) for unit in self._proto.passengers}",
  "def passengers_tags(self) -> Set[int]:\n        \"\"\" Returns the tags of the units inside a Bunker, CommandCenter, PlanetaryFortress, Medivac, Nydus, Overlord or WarpPrism. \"\"\"\n        return {unit.tag for unit in self._proto.passengers}",
  "def cargo_used(self) -> Union[float, int]:\n        \"\"\"Returns how much cargo space is currently used in the unit.\n        Note that some units take up more than one space.\"\"\"\n        return self._proto.cargo_space_taken",
  "def has_cargo(self) -> bool:\n        \"\"\" Checks if this unit has any units loaded. \"\"\"\n        return bool(self._proto.cargo_space_taken)",
  "def cargo_size(self) -> Union[float, int]:\n        \"\"\" Returns the amount of cargo space the unit needs. \"\"\"\n        return self._type_data.cargo_size",
  "def cargo_max(self) -> Union[float, int]:\n        \"\"\" How much cargo space is available at maximum. \"\"\"\n        return self._proto.cargo_space_max",
  "def cargo_left(self) -> Union[float, int]:\n        \"\"\" Returns how much cargo space is currently left in the unit. \"\"\"\n        return self._proto.cargo_space_max - self._proto.cargo_space_taken",
  "def assigned_harvesters(self) -> int:\n        \"\"\" Returns the number of workers currently gathering resources at a geyser or mining base.\"\"\"\n        return self._proto.assigned_harvesters",
  "def ideal_harvesters(self) -> int:\n        \"\"\"Returns the ideal harverster count for unit.\n        3 for gas buildings, 2*n for n mineral patches on that base.\"\"\"\n        return self._proto.ideal_harvesters",
  "def surplus_harvesters(self) -> int:\n        \"\"\"Returns a positive int if unit has too many harvesters mining,\n        a negative int if it has too few mining.\n        Will only works on townhalls, and gas buildings.\n        \"\"\"\n        return self._proto.assigned_harvesters - self._proto.ideal_harvesters",
  "def weapon_cooldown(self) -> float:\n        \"\"\"Returns the time until the unit can fire again,\n        returns -1 for units that can't attack.\n        Usage:\n        if unit.weapon_cooldown == 0:\n            unit.attack(target)\n        elif unit.weapon_cooldown < 0:\n            unit.move(closest_allied_unit_because_cant_attack)\n        else:\n            unit.move(retreatPosition)\"\"\"\n        if self.can_attack:\n            return self._proto.weapon_cooldown\n        return -1",
  "def weapon_ready(self) -> bool:\n        \"\"\" Checks if the weapon is ready to be fired. \"\"\"\n        return self.weapon_cooldown == 0",
  "def engaged_target_tag(self) -> int:\n        # TODO What does this do?\n        return self._proto.engaged_target_tag",
  "def has_buff(self, buff: BuffId) -> bool:\n        \"\"\" Checks if unit has buff 'buff'. \"\"\"\n        assert isinstance(buff, BuffId), f\"{buff} is no BuffId\"\n        return buff in self.buffs",
  "def train(self, unit: UnitTypeId, queue: bool = False, can_afford_check: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders unit to train another 'unit'.\n        Usage: COMMANDCENTER.train(SCV)\n\n        :param unit:\n        :param queue:\"\"\"\n        return self(\n            self._bot_object._game_data.units[unit.value].creation_ability.id,\n            queue=queue,\n            subtract_cost=True,\n            can_afford_check=can_afford_check,\n        )",
  "def build(\n        self,\n        unit: UnitTypeId,\n        position: Union[Point2, Point3] = None,\n        queue: bool = False,\n        can_afford_check: bool = False,\n    ) -> Union[UnitCommand, bool]:\n        \"\"\"Orders unit to build another 'unit' at 'position'.\n        Usage::\n\n            SCV.build(COMMANDCENTER, position)\n            # Target for refinery, assimilator and extractor needs to be the vespene geysir unit, not its position\n            SCV.build(REFINERY, target_vespene_geysir)\n\n        :param unit:\n        :param position:\n        :param queue:\n        \"\"\"\n        if unit in {UnitTypeId.EXTRACTOR, UnitTypeId.ASSIMILATOR, UnitTypeId.REFINERY}:\n            assert isinstance(\n                position, Unit\n            ), f\"When building the gas structure, the target needs to be a unit (the vespene geysir) not the position of the vespene geysir.\"\n        return self(\n            self._bot_object._game_data.units[unit.value].creation_ability.id,\n            target=position,\n            queue=queue,\n            subtract_cost=True,\n            can_afford_check=can_afford_check,\n        )",
  "def build_gas(self,\n                  target_geysir: Unit,\n                  queue: bool = False,\n                  can_afford_check: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders unit to build another 'unit' at 'position'.\n        Usage::\n\n            # Target for refinery, assimilator and extractor needs to be the vespene geysir unit, not its position\n            SCV.build_gas(target_vespene_geysir)\n\n        :param target_geysir:\n        :param queue:\n        \"\"\"\n        gas_structure_type_id: UnitTypeId = race_gas[self._bot_object.race]\n        assert isinstance(\n            target_geysir, Unit\n        ), f\"When building the gas structure, the target needs to be a unit (the vespene geysir) not the position of the vespene geysir.\"\n        return self(\n            self._bot_object._game_data.units[gas_structure_type_id.value].creation_ability.id,\n            target=target_geysir,\n            queue=queue,\n            subtract_cost=True,\n            can_afford_check=can_afford_check,\n        )",
  "def research(self,\n                 upgrade: UpgradeId,\n                 queue: bool = False,\n                 can_afford_check: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders unit to research 'upgrade'.\n        Requires UpgradeId to be passed instead of AbilityId.\n\n        :param upgrade:\n        :param queue:\n        \"\"\"\n        return self(\n            self._bot_object._game_data.upgrades[upgrade.value].research_ability.exact_id,\n            queue=queue,\n            subtract_cost=True,\n            can_afford_check=can_afford_check,\n        )",
  "def warp_in(self,\n                unit: UnitTypeId,\n                position: Union[Point2, Point3],\n                can_afford_check: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders Warpgate to warp in 'unit' at 'position'.\n\n        :param unit:\n        :param queue:\n        \"\"\"\n        normal_creation_ability = self._bot_object._game_data.units[unit.value].creation_ability.id\n        return self(\n            warpgate_abilities[normal_creation_ability],\n            target=position,\n            subtract_cost=True,\n            subtract_supply=True,\n            can_afford_check=can_afford_check,\n        )",
  "def attack(self, target: Union[Unit, Point2, Point3], queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders unit to attack. Target can be a Unit or Point2.\n        Attacking a position will make the unit move there and attack everything on its way.\n\n        :param target:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.ATTACK, target=target, queue=queue)",
  "def smart(self, target: Union[Unit, Point2, Point3], queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders the smart command. Equivalent to a right-click order.\n\n        :param target:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.SMART, target=target, queue=queue)",
  "def gather(self, target: Unit, queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders a unit to gather minerals or gas.\n        'Target' must be a mineral patch or a gas extraction building.\n\n        :param target:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.HARVEST_GATHER, target=target, queue=queue)",
  "def return_resource(self, target: Unit = None, queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders the unit to return resource. Does not need a 'target'.\n\n        :param target:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.HARVEST_RETURN, target=target, queue=queue)",
  "def move(self, position: Union[Unit, Point2, Point3], queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders the unit to move to 'position'.\n        Target can be a Unit (to follow that unit) or Point2.\n\n        :param position:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.MOVE_MOVE, target=position, queue=queue)",
  "def scan_move(self, *args, **kwargs) -> Union[UnitCommand, bool]:\n        \"\"\" Deprecated: This ability redirects to 'AbilityId.ATTACK' \"\"\"\n        return self(AbilityId.SCAN_MOVE, *args, **kwargs)",
  "def hold_position(self, queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders a unit to stop moving. It will not move until it gets new orders.\n\n        :param queue:\n        \"\"\"\n        return self(AbilityId.HOLDPOSITION, queue=queue)",
  "def stop(self, queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders a unit to stop, but can start to move on its own\n        if it is attacked, enemy unit is in range or other friendly\n        units need the space.\n\n        :param queue:\n        \"\"\"\n        return self(AbilityId.STOP, queue=queue)",
  "def patrol(self, position: Union[Point2, Point3], queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Orders a unit to patrol between position it has when the command starts and the target position.\n        Can be queued up to seven patrol points. If the last point is the same as the starting\n        point, the unit will patrol in a circle.\n\n        :param position:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.PATROL, target=position, queue=queue)",
  "def repair(self, repair_target: Unit, queue: bool = False) -> Union[UnitCommand, bool]:\n        \"\"\"Order an SCV or MULE to repair.\n\n        :param repair_target:\n        :param queue:\n        \"\"\"\n        return self(AbilityId.EFFECT_REPAIR, target=repair_target, queue=queue)",
  "def __hash__(self):\n        return self.tag",
  "def __eq__(self, other):\n        try:\n            return self.tag == other.tag\n        except:\n            return False",
  "def __call__(\n        self,\n        ability: AbilityId,\n        target: Optional[Union[Point2, Unit]] = None,\n        queue: bool = False,\n        subtract_cost: bool = False,\n        subtract_supply: bool = False,\n        can_afford_check: bool = False,\n    ) -> Union[UnitCommand, bool]:\n        \"\"\" Deprecated: Stop using self.do() - This may be removed in the future. \"\"\"\n        if self._bot_object.unit_command_uses_self_do:\n            return UnitCommand(ability, self, target=target, queue=queue)\n        expected_target: int = self._bot_object.game_data.abilities[ability.value]._proto.target\n        # 1: None, 2: Point, 3: Unit, 4: PointOrUnit, 5: PointOrNone\n        if target is None and expected_target not in {1, 5}:\n            warnings.warn(\n                f\"{self} got {ability} with no target but expected {TARGET_HELPER[expected_target]}\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n        elif isinstance(target, Point2) and expected_target not in {2, 4, 5}:\n            warnings.warn(\n                f\"{self} got {ability} with Point2 as target but expected {TARGET_HELPER[expected_target]}\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n        elif isinstance(target, Unit) and expected_target not in {3, 4}:\n            warnings.warn(\n                f\"{self} got {ability} with Unit as target but expected {TARGET_HELPER[expected_target]}\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n        return self._bot_object.do(\n            UnitCommand(ability, self, target=target, queue=queue),\n            subtract_cost=subtract_cost,\n            subtract_supply=subtract_supply,\n            can_afford_check=can_afford_check,\n        )",
  "class DistanceCalculation:\n\n    def __init__(self):\n        self.state: GameState = None\n        # self._generated_frame = -100\n        self._generated_frame2 = -100\n        # Pdist condensed vector generated by scipy pdist, half the size of the cdist matrix as 1d array\n        self._cached_pdist: np.ndarray = None\n        self._cached_cdist: np.ndarray = None\n\n    @property\n    def _units_count(self) -> int:\n        return len(self.all_units)\n\n    @property\n    def _pdist(self) -> np.ndarray:\n        \"\"\" As property, so it will be recalculated each time it is called, or return from cache if it is called multiple times in teh same game_loop. \"\"\"\n        if self._generated_frame2 != self.state.game_loop:\n            return self.calculate_distances()\n        return self._cached_pdist\n\n    @property\n    def _cdist(self) -> np.ndarray:\n        \"\"\" As property, so it will be recalculated each time it is called, or return from cache if it is called multiple times in teh same game_loop. \"\"\"\n        if self._generated_frame2 != self.state.game_loop:\n            return self.calculate_distances()\n        return self._cached_cdist\n\n    def _calculate_distances_method1(self) -> np.ndarray:\n        self._generated_frame2 = self.state.game_loop\n        # Converts tuple [(1, 2), (3, 4)] to flat list like [1, 2, 3, 4]\n        flat_positions = (coord for unit in self.all_units for coord in unit.position_tuple)\n        # Converts to numpy array, then converts the flat array back to shape (n, 2): [[1, 2], [3, 4]]\n        positions_array: np.ndarray = np.fromiter(flat_positions, dtype=np.float,\n                                                  count=2 * self._units_count).reshape((self._units_count, 2))\n        assert len(positions_array) == self._units_count\n        # See performance benchmarks\n        self._cached_pdist = pdist(positions_array, \"sqeuclidean\")\n\n        return self._cached_pdist\n\n    def _calculate_distances_method2(self) -> np.ndarray:\n        self._generated_frame2 = self.state.game_loop\n        # Converts tuple [(1, 2), (3, 4)] to flat list like [1, 2, 3, 4]\n        flat_positions = (coord for unit in self.all_units for coord in unit.position_tuple)\n        # Converts to numpy array, then converts the flat array back to shape (n, 2): [[1, 2], [3, 4]]\n        positions_array: np.ndarray = np.fromiter(flat_positions, dtype=np.float,\n                                                  count=2 * self._units_count).reshape((self._units_count, 2))\n        assert len(positions_array) == self._units_count\n        # See performance benchmarks\n        self._cached_cdist = cdist(positions_array, positions_array, \"sqeuclidean\")\n\n        return self._cached_cdist\n\n    def _calculate_distances_method3(self) -> np.ndarray:\n        \"\"\" Nearly same as above, but without asserts\"\"\"\n        self._generated_frame2 = self.state.game_loop\n        flat_positions = (coord for unit in self.all_units for coord in unit.position_tuple)\n        positions_array: np.ndarray = np.fromiter(flat_positions, dtype=np.float,\n                                                  count=2 * self._units_count).reshape((-1, 2))\n        # See performance benchmarks\n        self._cached_cdist = cdist(positions_array, positions_array, \"sqeuclidean\")\n\n        return self._cached_cdist\n\n    # Helper functions\n\n    def square_to_condensed(self, i, j) -> int:\n        # Converts indices of a square matrix to condensed matrix\n        # https://stackoverflow.com/a/36867493/10882657\n        assert i != j, \"No diagonal elements in condensed matrix! Diagonal elements are zero\"\n        if i < j:\n            i, j = j, i\n        return self._units_count * j - j * (j + 1) // 2 + i - 1 - j\n\n    def convert_tuple_to_numpy_array(self, pos: Tuple[float, float]) -> np.ndarray:\n        \"\"\" Converts a single position to a 2d numpy array with 1 row and 2 columns. \"\"\"\n        return np.fromiter(pos, dtype=float, count=2).reshape((1, 2))\n\n    # Fast and simple calculation functions\n\n    def distance_math_hypot(self, p1: Tuple[float, float], p2: Tuple[float, float]):\n        return math.hypot(p1[0] - p2[0], p1[1] - p2[1])\n\n    def distance_math_hypot_squared(self, p1: Tuple[float, float], p2: Tuple[float, float]):\n        return pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2)\n\n    def _distance_squared_unit_to_unit_method0(self, unit1: Unit, unit2: Unit) -> float:\n        return self.distance_math_hypot_squared(unit1.position_tuple, unit2.position_tuple)\n\n    # Distance calculation using the pre-calculated matrix above\n\n    def _distance_squared_unit_to_unit_method1(self, unit1: Unit, unit2: Unit) -> float:\n        # If checked on units if they have the same tag, return distance 0 as these are not in the 1 dimensional pdist array - would result in an error otherwise\n        if unit1.tag == unit2.tag:\n            return 0\n        # Calculate index, needs to be after pdist has been calculated and cached\n        condensed_index = self.square_to_condensed(unit1.distance_calculation_index, unit2.distance_calculation_index)\n        assert condensed_index < len(\n            self._cached_pdist\n        ), f\"Condensed index is larger than amount of calculated distances: {condensed_index} < {len(self._cached_pdist)}, units that caused the assert error: {unit1} and {unit2}\"\n        distance = self._pdist[condensed_index]\n        return distance\n\n    def _distance_squared_unit_to_unit_method2(self, unit1: Unit, unit2: Unit) -> float:\n        # Calculate index, needs to be after cdist has been calculated and cached\n        return self._cdist[unit1.distance_calculation_index, unit2.distance_calculation_index]\n\n    # Distance calculation using the fastest distance calculation functions\n\n    def _distance_pos_to_pos(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:\n        return self.distance_math_hypot(pos1, pos2)\n\n    def _distance_units_to_pos(self, units: Units, pos: Tuple[float, float]) -> Generator[float, None, None]:\n        \"\"\" This function does not scale well, if len(units) > 100 it gets fairly slow \"\"\"\n        return (self.distance_math_hypot(u.position_tuple, pos) for u in units)\n\n    def _distance_unit_to_points(self, unit: Unit, points: Iterable[Tuple[float,\n                                                                          float]]) -> Generator[float, None, None]:\n        \"\"\" This function does not scale well, if len(points) > 100 it gets fairly slow \"\"\"\n        pos = unit.position_tuple\n        return (self.distance_math_hypot(p, pos) for p in points)\n\n    def _distances_override_functions(self, method: int = 0):\n        \"\"\"Overrides the internal distance calculation functions at game start in bot_ai.py self._prepare_start() function\n        method 0: Use python's math.hypot\n        The following methods calculate the distances between all units once:\n        method 1: Use scipy's pdist condensed matrix (1d array)\n        method 2: Use scipy's cidst square matrix (2d array)\n        method 3: Use scipy's cidst square matrix (2d array) without asserts (careful: very weird error messages, but maybe slightly faster)\"\"\"\n        assert 0 <= method <= 3, f\"Selected method was: {method}\"\n        if method == 0:\n            self._distance_squared_unit_to_unit = self._distance_squared_unit_to_unit_method0\n        elif method == 1:\n            self._distance_squared_unit_to_unit = self._distance_squared_unit_to_unit_method1\n            self.calculate_distances = self._calculate_distances_method1\n        elif method == 2:\n            self._distance_squared_unit_to_unit = self._distance_squared_unit_to_unit_method2\n            self.calculate_distances = self._calculate_distances_method2\n        elif method == 3:\n            self._distance_squared_unit_to_unit = self._distance_squared_unit_to_unit_method2\n            self.calculate_distances = self._calculate_distances_method3",
  "def __init__(self):\n        self.state: GameState = None\n        # self._generated_frame = -100\n        self._generated_frame2 = -100\n        # Pdist condensed vector generated by scipy pdist, half the size of the cdist matrix as 1d array\n        self._cached_pdist: np.ndarray = None\n        self._cached_cdist: np.ndarray = None",
  "def _units_count(self) -> int:\n        return len(self.all_units)",
  "def _pdist(self) -> np.ndarray:\n        \"\"\" As property, so it will be recalculated each time it is called, or return from cache if it is called multiple times in teh same game_loop. \"\"\"\n        if self._generated_frame2 != self.state.game_loop:\n            return self.calculate_distances()\n        return self._cached_pdist",
  "def _cdist(self) -> np.ndarray:\n        \"\"\" As property, so it will be recalculated each time it is called, or return from cache if it is called multiple times in teh same game_loop. \"\"\"\n        if self._generated_frame2 != self.state.game_loop:\n            return self.calculate_distances()\n        return self._cached_cdist",
  "def _calculate_distances_method1(self) -> np.ndarray:\n        self._generated_frame2 = self.state.game_loop\n        # Converts tuple [(1, 2), (3, 4)] to flat list like [1, 2, 3, 4]\n        flat_positions = (coord for unit in self.all_units for coord in unit.position_tuple)\n        # Converts to numpy array, then converts the flat array back to shape (n, 2): [[1, 2], [3, 4]]\n        positions_array: np.ndarray = np.fromiter(flat_positions, dtype=np.float,\n                                                  count=2 * self._units_count).reshape((self._units_count, 2))\n        assert len(positions_array) == self._units_count\n        # See performance benchmarks\n        self._cached_pdist = pdist(positions_array, \"sqeuclidean\")\n\n        return self._cached_pdist",
  "def _calculate_distances_method2(self) -> np.ndarray:\n        self._generated_frame2 = self.state.game_loop\n        # Converts tuple [(1, 2), (3, 4)] to flat list like [1, 2, 3, 4]\n        flat_positions = (coord for unit in self.all_units for coord in unit.position_tuple)\n        # Converts to numpy array, then converts the flat array back to shape (n, 2): [[1, 2], [3, 4]]\n        positions_array: np.ndarray = np.fromiter(flat_positions, dtype=np.float,\n                                                  count=2 * self._units_count).reshape((self._units_count, 2))\n        assert len(positions_array) == self._units_count\n        # See performance benchmarks\n        self._cached_cdist = cdist(positions_array, positions_array, \"sqeuclidean\")\n\n        return self._cached_cdist",
  "def _calculate_distances_method3(self) -> np.ndarray:\n        \"\"\" Nearly same as above, but without asserts\"\"\"\n        self._generated_frame2 = self.state.game_loop\n        flat_positions = (coord for unit in self.all_units for coord in unit.position_tuple)\n        positions_array: np.ndarray = np.fromiter(flat_positions, dtype=np.float,\n                                                  count=2 * self._units_count).reshape((-1, 2))\n        # See performance benchmarks\n        self._cached_cdist = cdist(positions_array, positions_array, \"sqeuclidean\")\n\n        return self._cached_cdist",
  "def square_to_condensed(self, i, j) -> int:\n        # Converts indices of a square matrix to condensed matrix\n        # https://stackoverflow.com/a/36867493/10882657\n        assert i != j, \"No diagonal elements in condensed matrix! Diagonal elements are zero\"\n        if i < j:\n            i, j = j, i\n        return self._units_count * j - j * (j + 1) // 2 + i - 1 - j",
  "def convert_tuple_to_numpy_array(self, pos: Tuple[float, float]) -> np.ndarray:\n        \"\"\" Converts a single position to a 2d numpy array with 1 row and 2 columns. \"\"\"\n        return np.fromiter(pos, dtype=float, count=2).reshape((1, 2))",
  "def distance_math_hypot(self, p1: Tuple[float, float], p2: Tuple[float, float]):\n        return math.hypot(p1[0] - p2[0], p1[1] - p2[1])",
  "def distance_math_hypot_squared(self, p1: Tuple[float, float], p2: Tuple[float, float]):\n        return pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2)",
  "def _distance_squared_unit_to_unit_method0(self, unit1: Unit, unit2: Unit) -> float:\n        return self.distance_math_hypot_squared(unit1.position_tuple, unit2.position_tuple)",
  "def _distance_squared_unit_to_unit_method1(self, unit1: Unit, unit2: Unit) -> float:\n        # If checked on units if they have the same tag, return distance 0 as these are not in the 1 dimensional pdist array - would result in an error otherwise\n        if unit1.tag == unit2.tag:\n            return 0\n        # Calculate index, needs to be after pdist has been calculated and cached\n        condensed_index = self.square_to_condensed(unit1.distance_calculation_index, unit2.distance_calculation_index)\n        assert condensed_index < len(\n            self._cached_pdist\n        ), f\"Condensed index is larger than amount of calculated distances: {condensed_index} < {len(self._cached_pdist)}, units that caused the assert error: {unit1} and {unit2}\"\n        distance = self._pdist[condensed_index]\n        return distance",
  "def _distance_squared_unit_to_unit_method2(self, unit1: Unit, unit2: Unit) -> float:\n        # Calculate index, needs to be after cdist has been calculated and cached\n        return self._cdist[unit1.distance_calculation_index, unit2.distance_calculation_index]",
  "def _distance_pos_to_pos(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:\n        return self.distance_math_hypot(pos1, pos2)",
  "def _distance_units_to_pos(self, units: Units, pos: Tuple[float, float]) -> Generator[float, None, None]:\n        \"\"\" This function does not scale well, if len(units) > 100 it gets fairly slow \"\"\"\n        return (self.distance_math_hypot(u.position_tuple, pos) for u in units)",
  "def _distance_unit_to_points(self, unit: Unit, points: Iterable[Tuple[float,\n                                                                          float]]) -> Generator[float, None, None]:\n        \"\"\" This function does not scale well, if len(points) > 100 it gets fairly slow \"\"\"\n        pos = unit.position_tuple\n        return (self.distance_math_hypot(p, pos) for p in points)",
  "def _distances_override_functions(self, method: int = 0):\n        \"\"\"Overrides the internal distance calculation functions at game start in bot_ai.py self._prepare_start() function\n        method 0: Use python's math.hypot\n        The following methods calculate the distances between all units once:\n        method 1: Use scipy's pdist condensed matrix (1d array)\n        method 2: Use scipy's cidst square matrix (2d array)\n        method 3: Use scipy's cidst square matrix (2d array) without asserts (careful: very weird error messages, but maybe slightly faster)\"\"\"\n        assert 0 <= method <= 3, f\"Selected method was: {method}\"\n        if method == 0:\n            self._distance_squared_unit_to_unit = self._distance_squared_unit_to_unit_method0\n        elif method == 1:\n            self._distance_squared_unit_to_unit = self._distance_squared_unit_to_unit_method1\n            self.calculate_distances = self._calculate_distances_method1\n        elif method == 2:\n            self._distance_squared_unit_to_unit = self._distance_squared_unit_to_unit_method2\n            self.calculate_distances = self._calculate_distances_method2\n        elif method == 3:\n            self._distance_squared_unit_to_unit = self._distance_squared_unit_to_unit_method2\n            self.calculate_distances = self._calculate_distances_method3",
  "class GameData:\n\n    def __init__(self, data):\n        \"\"\"\n        :param data:\n        \"\"\"\n        ids = set(a.value for a in AbilityId if a.value != 0)\n        self.abilities = {a.ability_id: AbilityData(self, a) for a in data.abilities if a.ability_id in ids}\n        self.units = {u.unit_id: UnitTypeData(self, u) for u in data.units if u.available}\n        self.upgrades = {u.upgrade_id: UpgradeData(self, u) for u in data.upgrades}\n        # Cached UnitTypeIds so that conversion does not take long. This needs to be moved elsewhere if a new GameData object is created multiple times per game\n        self.unit_types: Dict[int, UnitTypeId] = {}\n\n    @lru_cache(maxsize=256)\n    def calculate_ability_cost(self, ability) -> Cost:\n        if isinstance(ability, AbilityId):\n            ability = self.abilities[ability.value]\n        elif isinstance(ability, UnitCommand):\n            ability = self.abilities[ability.ability.value]\n\n        assert isinstance(ability, AbilityData), f\"C: {ability}\"\n\n        for unit in self.units.values():\n            if unit.creation_ability is None:\n                continue\n\n            if not AbilityData.id_exists(unit.creation_ability.id.value):\n                continue\n\n            if unit.creation_ability.is_free_morph:\n                continue\n\n            if unit.creation_ability == ability:\n                if unit.id == UnitTypeId.ZERGLING:\n                    # HARD CODED: zerglings are generated in pairs\n                    return Cost(unit.cost.minerals * 2, unit.cost.vespene * 2, unit.cost.time)\n                # Correction for morphing units, e.g. orbital would return 550/0 instead of actual 150/0\n                morph_cost = unit.morph_cost\n                if morph_cost:  # can be None\n                    return morph_cost\n                # Correction for zerg structures without morph: Extractor would return 75 instead of actual 25\n                return unit.cost_zerg_corrected\n\n        for upgrade in self.upgrades.values():\n            if upgrade.research_ability == ability:\n                return upgrade.cost\n\n        return Cost(0, 0)",
  "class AbilityData:\n\n    ability_ids: List[int] = [ability_id.value for ability_id in AbilityId][1:]  # sorted list\n\n    @classmethod\n    def id_exists(cls, ability_id):\n        assert isinstance(ability_id, int), f\"Wrong type: {ability_id} is not int\"\n        if ability_id == 0:\n            return False\n        i = bisect_left(cls.ability_ids, ability_id)  # quick binary search\n        return i != len(cls.ability_ids) and cls.ability_ids[i] == ability_id\n\n    def __init__(self, game_data, proto):\n        self._game_data = game_data\n        self._proto = proto\n\n        # What happens if we comment this out? Should this not be commented out? What is its purpose?\n        assert self.id != 0\n\n    def __repr__(self) -> str:\n        return f\"AbilityData(name={self._proto.button_name})\"\n\n    @property\n    def id(self) -> AbilityId:\n        \"\"\" Returns the generic remap ID. See sc2/dicts/generic_redirect_abilities.py \"\"\"\n        if self._proto.remaps_to_ability_id:\n            return AbilityId(self._proto.remaps_to_ability_id)\n        return AbilityId(self._proto.ability_id)\n\n    @property\n    def exact_id(self) -> AbilityId:\n        \"\"\" Returns the exact ID of the ability \"\"\"\n        return AbilityId(self._proto.ability_id)\n\n    @property\n    def link_name(self) -> str:\n        \"\"\" For Stimpack this returns 'BarracksTechLabResearch' \"\"\"\n        return self._proto.link_name\n\n    @property\n    def button_name(self) -> str:\n        \"\"\" For Stimpack this returns 'Stimpack' \"\"\"\n        return self._proto.button_name\n\n    @property\n    def friendly_name(self) -> str:\n        \"\"\" For Stimpack this returns 'Research Stimpack' \"\"\"\n        return self._proto.friendly_name\n\n    @property\n    def is_free_morph(self) -> bool:\n        if any(free in self._proto.link_name for free in FREE_ABILITIES):\n            return True\n        return False\n\n    @property\n    def cost(self) -> Cost:\n        return self._game_data.calculate_ability_cost(self.id)",
  "class UnitTypeData:\n\n    def __init__(self, game_data: GameData, proto):\n        \"\"\"\n        :param game_data:\n        :param proto:\n        \"\"\"\n        # The ability_id for lurkers is\n        # LURKERASPECTMPFROMHYDRALISKBURROWED_LURKERMPFROMHYDRALISKBURROWED\n        # instead of the correct MORPH_LURKER.\n        if proto.unit_id == UnitTypeId.LURKERMP.value:\n            proto.ability_id = AbilityId.MORPH_LURKER.value\n\n        self._game_data = game_data\n        self._proto = proto\n\n    def __repr__(self) -> str:\n        return f\"UnitTypeData(name={self.name})\"\n\n    @property\n    def id(self) -> UnitTypeId:\n        return UnitTypeId(self._proto.unit_id)\n\n    @property\n    def name(self) -> str:\n        return self._proto.name\n\n    @property\n    def creation_ability(self) -> Optional[AbilityData]:\n        if self._proto.ability_id == 0:\n            return None\n        if self._proto.ability_id not in self._game_data.abilities:\n            return None\n        return self._game_data.abilities[self._proto.ability_id]\n\n    @property\n    def footprint_radius(self) -> Optional[float]:\n        \"\"\" See unit.py footprint_radius \"\"\"\n        if self.creation_ability is None:\n            return None\n        return self.creation_ability._proto.footprint_radius\n\n    @property\n    def attributes(self) -> List[Attribute]:\n        return self._proto.attributes\n\n    def has_attribute(self, attr) -> bool:\n        assert isinstance(attr, Attribute)\n        return attr in self.attributes\n\n    @property\n    def has_minerals(self) -> bool:\n        return self._proto.has_minerals\n\n    @property\n    def has_vespene(self) -> bool:\n        return self._proto.has_vespene\n\n    @property\n    def cargo_size(self) -> int:\n        \"\"\" How much cargo this unit uses up in cargo_space \"\"\"\n        return self._proto.cargo_size\n\n    @property\n    def tech_requirement(self) -> Optional[UnitTypeId]:\n        \"\"\" Tech-building requirement of buildings - may work for units but unreliably \"\"\"\n        if self._proto.tech_requirement == 0:\n            return None\n        if self._proto.tech_requirement not in self._game_data.units:\n            return None\n        return UnitTypeId(self._proto.tech_requirement)\n\n    @property\n    def tech_alias(self) -> Optional[List[UnitTypeId]]:\n        \"\"\"Building tech equality, e.g. OrbitalCommand is the same as CommandCenter\n        Building tech equality, e.g. Hive is the same as Lair and Hatchery\n        For Hive, this returns [UnitTypeId.Hatchery, UnitTypeId.Lair]\n        For SCV, this returns None\"\"\"\n        return_list = [\n            UnitTypeId(tech_alias) for tech_alias in self._proto.tech_alias if tech_alias in self._game_data.units\n        ]\n        return return_list if return_list else None\n\n    @property\n    def unit_alias(self) -> Optional[UnitTypeId]:\n        \"\"\" Building type equality, e.g. FlyingOrbitalCommand is the same as OrbitalCommand \"\"\"\n        if self._proto.unit_alias == 0:\n            return None\n        if self._proto.unit_alias not in self._game_data.units:\n            return None\n        \"\"\" For flying OrbitalCommand, this returns UnitTypeId.OrbitalCommand \"\"\"\n        return UnitTypeId(self._proto.unit_alias)\n\n    @property\n    def race(self) -> Race:\n        return Race(self._proto.race)\n\n    @property\n    def cost(self) -> Cost:\n        return Cost(self._proto.mineral_cost, self._proto.vespene_cost, self._proto.build_time)\n\n    @property\n    def cost_zerg_corrected(self) -> Cost:\n        \"\"\" This returns 25 for extractor and 200 for spawning pool instead of 75 and 250 respectively \"\"\"\n        if self.race == Race.Zerg and Attribute.Structure.value in self.attributes:\n            # a = self._game_data.units(UnitTypeId.ZERGLING)\n            # print(a)\n            # print(vars(a))\n            return Cost(self._proto.mineral_cost - 50, self._proto.vespene_cost, self._proto.build_time)\n        else:\n            return self.cost\n\n    @property\n    def morph_cost(self) -> Optional[Cost]:\n        \"\"\" This returns 150 minerals for OrbitalCommand instead of 550 \"\"\"\n        # Morphing units\n        supply_cost = self._proto.food_required\n        if supply_cost > 0 and self.id in UNIT_TRAINED_FROM and len(UNIT_TRAINED_FROM[self.id]) == 1:\n            producer: UnitTypeId\n            for producer in UNIT_TRAINED_FROM[self.id]:\n                producer_unit_data = self._game_data.units[producer.value]\n                if 0 < producer_unit_data._proto.food_required <= supply_cost:\n                    if producer == UnitTypeId.ZERGLING:\n                        producer_cost = Cost(25, 0)\n                    else:\n                        producer_cost = self._game_data.calculate_ability_cost(producer_unit_data.creation_ability)\n                    return Cost(\n                        self._proto.mineral_cost - producer_cost.minerals,\n                        self._proto.vespene_cost - producer_cost.vespene,\n                        self._proto.build_time,\n                    )\n        # Fix for BARRACKSREACTOR which has tech alias [REACTOR] which has (0, 0) cost\n        if self.tech_alias is None or self.tech_alias[0] in {UnitTypeId.TECHLAB, UnitTypeId.REACTOR}:\n            return None\n        # Morphing a HIVE would have HATCHERY and LAIR in the tech alias - now subtract HIVE cost from LAIR cost instead of from HATCHERY cost\n        tech_alias_cost_minerals = max(\n            self._game_data.units[tech_alias.value].cost.minerals for tech_alias in self.tech_alias\n        )\n        tech_alias_cost_vespene = max(\n            self._game_data.units[tech_alias.value].cost.vespene for tech_alias in self.tech_alias\n        )\n        return Cost(\n            self._proto.mineral_cost - tech_alias_cost_minerals,\n            self._proto.vespene_cost - tech_alias_cost_vespene,\n            self._proto.build_time,\n        )",
  "class UpgradeData:\n\n    def __init__(self, game_data: GameData, proto):\n        \"\"\"\n        :param game_data:\n        :param proto:\n        \"\"\"\n        self._game_data = game_data\n        self._proto = proto\n\n    def __repr__(self):\n        return f\"UpgradeData({self.name} - research ability: {self.research_ability}, {self.cost})\"\n\n    @property\n    def name(self) -> str:\n        return self._proto.name\n\n    @property\n    def research_ability(self) -> Optional[AbilityData]:\n        if self._proto.ability_id == 0:\n            return None\n        if self._proto.ability_id not in self._game_data.abilities:\n            return None\n        return self._game_data.abilities[self._proto.ability_id]\n\n    @property\n    def cost(self) -> Cost:\n        return Cost(self._proto.mineral_cost, self._proto.vespene_cost, self._proto.research_time)",
  "class Cost:\n    \"\"\"\n    The cost of an action, a structure, a unit or a research upgrade.\n    The time is given in frames (22.4 frames per game second).\n    \"\"\"\n\n    def __init__(self, minerals: int, vespene: int, time: float = None):\n        \"\"\"\n        :param minerals:\n        :param vespene:\n        :param time:\n        \"\"\"\n        self.minerals = minerals\n        self.vespene = vespene\n        self.time = time\n\n    def __repr__(self) -> str:\n        return f\"Cost({self.minerals}, {self.vespene})\"\n\n    def __eq__(self, other: Cost) -> bool:\n        return self.minerals == other.minerals and self.vespene == other.vespene\n\n    def __ne__(self, other: Cost) -> bool:\n        return self.minerals != other.minerals or self.vespene != other.vespene\n\n    def __bool__(self) -> bool:\n        return self.minerals != 0 or self.vespene != 0\n\n    def __add__(self, other) -> Cost:\n        if not other:\n            return self\n        if not self:\n            return other\n        if self.time is None:\n            time = other.time\n        elif other.time is None:\n            time = self.time\n        else:\n            time = self.time + other.time\n        return self.__class__(self.minerals + other.minerals, self.vespene + other.vespene, time=time)\n\n    def __sub__(self, other) -> Cost:\n        assert isinstance(other, Cost)\n        if self.time is None:\n            time = other.time\n        elif other.time is None:\n            time = self.time\n        else:\n            time = self.time - other.time\n        return self.__class__(self.minerals - other.minerals, self.vespene - other.vespene, time=time)\n\n    def __mul__(self, other: int) -> Cost:\n        return self.__class__(self.minerals * other, self.vespene * other, time=self.time)\n\n    def __rmul__(self, other: int) -> Cost:\n        return self.__class__(self.minerals * other, self.vespene * other, time=self.time)",
  "def __init__(self, data):\n        \"\"\"\n        :param data:\n        \"\"\"\n        ids = set(a.value for a in AbilityId if a.value != 0)\n        self.abilities = {a.ability_id: AbilityData(self, a) for a in data.abilities if a.ability_id in ids}\n        self.units = {u.unit_id: UnitTypeData(self, u) for u in data.units if u.available}\n        self.upgrades = {u.upgrade_id: UpgradeData(self, u) for u in data.upgrades}\n        # Cached UnitTypeIds so that conversion does not take long. This needs to be moved elsewhere if a new GameData object is created multiple times per game\n        self.unit_types: Dict[int, UnitTypeId] = {}",
  "def calculate_ability_cost(self, ability) -> Cost:\n        if isinstance(ability, AbilityId):\n            ability = self.abilities[ability.value]\n        elif isinstance(ability, UnitCommand):\n            ability = self.abilities[ability.ability.value]\n\n        assert isinstance(ability, AbilityData), f\"C: {ability}\"\n\n        for unit in self.units.values():\n            if unit.creation_ability is None:\n                continue\n\n            if not AbilityData.id_exists(unit.creation_ability.id.value):\n                continue\n\n            if unit.creation_ability.is_free_morph:\n                continue\n\n            if unit.creation_ability == ability:\n                if unit.id == UnitTypeId.ZERGLING:\n                    # HARD CODED: zerglings are generated in pairs\n                    return Cost(unit.cost.minerals * 2, unit.cost.vespene * 2, unit.cost.time)\n                # Correction for morphing units, e.g. orbital would return 550/0 instead of actual 150/0\n                morph_cost = unit.morph_cost\n                if morph_cost:  # can be None\n                    return morph_cost\n                # Correction for zerg structures without morph: Extractor would return 75 instead of actual 25\n                return unit.cost_zerg_corrected\n\n        for upgrade in self.upgrades.values():\n            if upgrade.research_ability == ability:\n                return upgrade.cost\n\n        return Cost(0, 0)",
  "def id_exists(cls, ability_id):\n        assert isinstance(ability_id, int), f\"Wrong type: {ability_id} is not int\"\n        if ability_id == 0:\n            return False\n        i = bisect_left(cls.ability_ids, ability_id)  # quick binary search\n        return i != len(cls.ability_ids) and cls.ability_ids[i] == ability_id",
  "def __init__(self, game_data, proto):\n        self._game_data = game_data\n        self._proto = proto\n\n        # What happens if we comment this out? Should this not be commented out? What is its purpose?\n        assert self.id != 0",
  "def __repr__(self) -> str:\n        return f\"AbilityData(name={self._proto.button_name})\"",
  "def id(self) -> AbilityId:\n        \"\"\" Returns the generic remap ID. See sc2/dicts/generic_redirect_abilities.py \"\"\"\n        if self._proto.remaps_to_ability_id:\n            return AbilityId(self._proto.remaps_to_ability_id)\n        return AbilityId(self._proto.ability_id)",
  "def exact_id(self) -> AbilityId:\n        \"\"\" Returns the exact ID of the ability \"\"\"\n        return AbilityId(self._proto.ability_id)",
  "def link_name(self) -> str:\n        \"\"\" For Stimpack this returns 'BarracksTechLabResearch' \"\"\"\n        return self._proto.link_name",
  "def button_name(self) -> str:\n        \"\"\" For Stimpack this returns 'Stimpack' \"\"\"\n        return self._proto.button_name",
  "def friendly_name(self) -> str:\n        \"\"\" For Stimpack this returns 'Research Stimpack' \"\"\"\n        return self._proto.friendly_name",
  "def is_free_morph(self) -> bool:\n        if any(free in self._proto.link_name for free in FREE_ABILITIES):\n            return True\n        return False",
  "def cost(self) -> Cost:\n        return self._game_data.calculate_ability_cost(self.id)",
  "def __init__(self, game_data: GameData, proto):\n        \"\"\"\n        :param game_data:\n        :param proto:\n        \"\"\"\n        # The ability_id for lurkers is\n        # LURKERASPECTMPFROMHYDRALISKBURROWED_LURKERMPFROMHYDRALISKBURROWED\n        # instead of the correct MORPH_LURKER.\n        if proto.unit_id == UnitTypeId.LURKERMP.value:\n            proto.ability_id = AbilityId.MORPH_LURKER.value\n\n        self._game_data = game_data\n        self._proto = proto",
  "def __repr__(self) -> str:\n        return f\"UnitTypeData(name={self.name})\"",
  "def id(self) -> UnitTypeId:\n        return UnitTypeId(self._proto.unit_id)",
  "def name(self) -> str:\n        return self._proto.name",
  "def creation_ability(self) -> Optional[AbilityData]:\n        if self._proto.ability_id == 0:\n            return None\n        if self._proto.ability_id not in self._game_data.abilities:\n            return None\n        return self._game_data.abilities[self._proto.ability_id]",
  "def footprint_radius(self) -> Optional[float]:\n        \"\"\" See unit.py footprint_radius \"\"\"\n        if self.creation_ability is None:\n            return None\n        return self.creation_ability._proto.footprint_radius",
  "def attributes(self) -> List[Attribute]:\n        return self._proto.attributes",
  "def has_attribute(self, attr) -> bool:\n        assert isinstance(attr, Attribute)\n        return attr in self.attributes",
  "def has_minerals(self) -> bool:\n        return self._proto.has_minerals",
  "def has_vespene(self) -> bool:\n        return self._proto.has_vespene",
  "def cargo_size(self) -> int:\n        \"\"\" How much cargo this unit uses up in cargo_space \"\"\"\n        return self._proto.cargo_size",
  "def tech_requirement(self) -> Optional[UnitTypeId]:\n        \"\"\" Tech-building requirement of buildings - may work for units but unreliably \"\"\"\n        if self._proto.tech_requirement == 0:\n            return None\n        if self._proto.tech_requirement not in self._game_data.units:\n            return None\n        return UnitTypeId(self._proto.tech_requirement)",
  "def tech_alias(self) -> Optional[List[UnitTypeId]]:\n        \"\"\"Building tech equality, e.g. OrbitalCommand is the same as CommandCenter\n        Building tech equality, e.g. Hive is the same as Lair and Hatchery\n        For Hive, this returns [UnitTypeId.Hatchery, UnitTypeId.Lair]\n        For SCV, this returns None\"\"\"\n        return_list = [\n            UnitTypeId(tech_alias) for tech_alias in self._proto.tech_alias if tech_alias in self._game_data.units\n        ]\n        return return_list if return_list else None",
  "def unit_alias(self) -> Optional[UnitTypeId]:\n        \"\"\" Building type equality, e.g. FlyingOrbitalCommand is the same as OrbitalCommand \"\"\"\n        if self._proto.unit_alias == 0:\n            return None\n        if self._proto.unit_alias not in self._game_data.units:\n            return None\n        \"\"\" For flying OrbitalCommand, this returns UnitTypeId.OrbitalCommand \"\"\"\n        return UnitTypeId(self._proto.unit_alias)",
  "def race(self) -> Race:\n        return Race(self._proto.race)",
  "def cost(self) -> Cost:\n        return Cost(self._proto.mineral_cost, self._proto.vespene_cost, self._proto.build_time)",
  "def cost_zerg_corrected(self) -> Cost:\n        \"\"\" This returns 25 for extractor and 200 for spawning pool instead of 75 and 250 respectively \"\"\"\n        if self.race == Race.Zerg and Attribute.Structure.value in self.attributes:\n            # a = self._game_data.units(UnitTypeId.ZERGLING)\n            # print(a)\n            # print(vars(a))\n            return Cost(self._proto.mineral_cost - 50, self._proto.vespene_cost, self._proto.build_time)\n        else:\n            return self.cost",
  "def morph_cost(self) -> Optional[Cost]:\n        \"\"\" This returns 150 minerals for OrbitalCommand instead of 550 \"\"\"\n        # Morphing units\n        supply_cost = self._proto.food_required\n        if supply_cost > 0 and self.id in UNIT_TRAINED_FROM and len(UNIT_TRAINED_FROM[self.id]) == 1:\n            producer: UnitTypeId\n            for producer in UNIT_TRAINED_FROM[self.id]:\n                producer_unit_data = self._game_data.units[producer.value]\n                if 0 < producer_unit_data._proto.food_required <= supply_cost:\n                    if producer == UnitTypeId.ZERGLING:\n                        producer_cost = Cost(25, 0)\n                    else:\n                        producer_cost = self._game_data.calculate_ability_cost(producer_unit_data.creation_ability)\n                    return Cost(\n                        self._proto.mineral_cost - producer_cost.minerals,\n                        self._proto.vespene_cost - producer_cost.vespene,\n                        self._proto.build_time,\n                    )\n        # Fix for BARRACKSREACTOR which has tech alias [REACTOR] which has (0, 0) cost\n        if self.tech_alias is None or self.tech_alias[0] in {UnitTypeId.TECHLAB, UnitTypeId.REACTOR}:\n            return None\n        # Morphing a HIVE would have HATCHERY and LAIR in the tech alias - now subtract HIVE cost from LAIR cost instead of from HATCHERY cost\n        tech_alias_cost_minerals = max(\n            self._game_data.units[tech_alias.value].cost.minerals for tech_alias in self.tech_alias\n        )\n        tech_alias_cost_vespene = max(\n            self._game_data.units[tech_alias.value].cost.vespene for tech_alias in self.tech_alias\n        )\n        return Cost(\n            self._proto.mineral_cost - tech_alias_cost_minerals,\n            self._proto.vespene_cost - tech_alias_cost_vespene,\n            self._proto.build_time,\n        )",
  "def __init__(self, game_data: GameData, proto):\n        \"\"\"\n        :param game_data:\n        :param proto:\n        \"\"\"\n        self._game_data = game_data\n        self._proto = proto",
  "def __repr__(self):\n        return f\"UpgradeData({self.name} - research ability: {self.research_ability}, {self.cost})\"",
  "def name(self) -> str:\n        return self._proto.name",
  "def research_ability(self) -> Optional[AbilityData]:\n        if self._proto.ability_id == 0:\n            return None\n        if self._proto.ability_id not in self._game_data.abilities:\n            return None\n        return self._game_data.abilities[self._proto.ability_id]",
  "def cost(self) -> Cost:\n        return Cost(self._proto.mineral_cost, self._proto.vespene_cost, self._proto.research_time)",
  "def __init__(self, minerals: int, vespene: int, time: float = None):\n        \"\"\"\n        :param minerals:\n        :param vespene:\n        :param time:\n        \"\"\"\n        self.minerals = minerals\n        self.vespene = vespene\n        self.time = time",
  "def __repr__(self) -> str:\n        return f\"Cost({self.minerals}, {self.vespene})\"",
  "def __eq__(self, other: Cost) -> bool:\n        return self.minerals == other.minerals and self.vespene == other.vespene",
  "def __ne__(self, other: Cost) -> bool:\n        return self.minerals != other.minerals or self.vespene != other.vespene",
  "def __bool__(self) -> bool:\n        return self.minerals != 0 or self.vespene != 0",
  "def __add__(self, other) -> Cost:\n        if not other:\n            return self\n        if not self:\n            return other\n        if self.time is None:\n            time = other.time\n        elif other.time is None:\n            time = self.time\n        else:\n            time = self.time + other.time\n        return self.__class__(self.minerals + other.minerals, self.vespene + other.vespene, time=time)",
  "def __sub__(self, other) -> Cost:\n        assert isinstance(other, Cost)\n        if self.time is None:\n            time = other.time\n        elif other.time is None:\n            time = self.time\n        else:\n            time = self.time - other.time\n        return self.__class__(self.minerals - other.minerals, self.vespene - other.vespene, time=time)",
  "def __mul__(self, other: int) -> Cost:\n        return self.__class__(self.minerals * other, self.vespene * other, time=self.time)",
  "def __rmul__(self, other: int) -> Cost:\n        return self.__class__(self.minerals * other, self.vespene * other, time=self.time)",
  "def platform_detect():\n    pf = os.environ.get(\"SC2PF\", platform.system())\n    if pf == \"Linux\":\n        return wsl.detect() or pf\n    return pf",
  "def get_home():\n    \"\"\"Get home directory of user, using Windows home directory for WSL.\"\"\"\n    if PF == \"WSL1\" or PF == \"WSL2\":\n        return wsl.get_wsl_home() or Path.home().expanduser()\n    return Path.home().expanduser()",
  "def get_user_sc2_install():\n    \"\"\"Attempts to find a user's SC2 install if their OS has ExecuteInfo.txt\"\"\"\n    if USERPATH[PF]:\n        einfo = str(get_home() / Path(USERPATH[PF]))\n        if os.path.isfile(einfo):\n            with open(einfo) as f:\n                content = f.read()\n            if content:\n                base = re.search(r\" = (.*)Versions\", content).group(1)\n                if PF == \"WSL1\" or PF == \"WSL2\":\n                    base = str(wsl.win_path_to_wsl_path(base))\n\n                if os.path.exists(base):\n                    return base\n    return None",
  "def get_env():\n    # TODO: Linux env conf from: https://github.com/deepmind/pysc2/blob/master/pysc2/run_configs/platforms.py\n    return None",
  "def get_runner_args(cwd):\n    if \"WINE\" in os.environ:\n        runner_file = Path(os.environ.get(\"WINE\"))\n        runner_file = runner_file if runner_file.is_file() else runner_file / \"wine\"\n        \"\"\"\n        TODO Is converting linux path really necessary?\n        That would convert \n        '/home/burny/Games/battlenet/drive_c/Program Files (x86)/StarCraft II/Support64'\n        to \n        'Z:\\\\home\\\\burny\\\\Games\\\\battlenet\\\\drive_c\\\\Program Files (x86)\\\\StarCraft II\\\\Support64'\n        \"\"\"\n        return [runner_file, \"start\", \"/d\", cwd, \"/unix\"]\n    return []",
  "def latest_executeble(versions_dir, base_build=None):\n    latest = None\n\n    if base_build is not None:\n        try:\n            latest = (\n                int(base_build[4:]),\n                max(p for p in versions_dir.iterdir() if p.is_dir() and p.name.startswith(str(base_build))),\n            )\n        except ValueError:\n            pass\n\n    if base_build is None or latest is None:\n        latest = max((int(p.name[4:]), p) for p in versions_dir.iterdir() if p.is_dir() and p.name.startswith(\"Base\"))\n\n    version, path = latest\n\n    if version < 55958:\n        logger.critical(f\"Your SC2 binary is too old. Upgrade to 3.16.1 or newer.\")\n        exit(1)\n    return path / BINPATH[PF]",
  "class _MetaPaths(type):\n    \"\"\"\"Lazily loads paths to allow importing the library even if SC2 isn't installed.\"\"\"\n\n    def __setup(self):\n        if PF not in BASEDIR:\n            logger.critical(f\"Unsupported platform '{PF}'\")\n            exit(1)\n\n        try:\n            base = os.environ.get(\"SC2PATH\") or get_user_sc2_install() or BASEDIR[PF]\n            self.BASE = Path(base).expanduser()\n            self.EXECUTABLE = latest_executeble(self.BASE / \"Versions\")\n            self.CWD = self.BASE / CWD[PF] if CWD[PF] else None\n\n            self.REPLAYS = self.BASE / \"Replays\"\n\n            if (self.BASE / \"maps\").exists():\n                self.MAPS = self.BASE / \"maps\"\n            else:\n                self.MAPS = self.BASE / \"Maps\"\n        except FileNotFoundError as e:\n            logger.critical(f\"SC2 installation not found: File '{e.filename}' does not exist.\")\n            exit(1)\n\n    def __getattr__(self, attr):\n        self.__setup()\n        return getattr(self, attr)",
  "class Paths(metaclass=_MetaPaths):\n    \"\"\"Paths for SC2 folders, lazily loaded using the above metaclass.\"\"\"",
  "def __setup(self):\n        if PF not in BASEDIR:\n            logger.critical(f\"Unsupported platform '{PF}'\")\n            exit(1)\n\n        try:\n            base = os.environ.get(\"SC2PATH\") or get_user_sc2_install() or BASEDIR[PF]\n            self.BASE = Path(base).expanduser()\n            self.EXECUTABLE = latest_executeble(self.BASE / \"Versions\")\n            self.CWD = self.BASE / CWD[PF] if CWD[PF] else None\n\n            self.REPLAYS = self.BASE / \"Replays\"\n\n            if (self.BASE / \"maps\").exists():\n                self.MAPS = self.BASE / \"maps\"\n            else:\n                self.MAPS = self.BASE / \"Maps\"\n        except FileNotFoundError as e:\n            logger.critical(f\"SC2 installation not found: File '{e.filename}' does not exist.\")\n            exit(1)",
  "def __getattr__(self, attr):\n        self.__setup()\n        return getattr(self, attr)",
  "def _sign(num):\n    return math.copysign(1, num)",
  "class Pointlike(tuple):\n\n    @property\n    def position(self) -> Pointlike:\n        return self\n\n    def distance_to(self, target: Union[Unit, Point2]) -> float:\n        \"\"\"Calculate a single distance from a point or unit to another point or unit\n\n        :param target:\"\"\"\n        p = target.position\n        return math.hypot(self[0] - p[0], self[1] - p[1])\n\n    def distance_to_point2(self, p: Union[Point2, Tuple[float, float]]) -> float:\n        \"\"\"Same as the function above, but should be a bit faster because of the dropped asserts\n        and conversion.\n\n        :param p:\"\"\"\n        return math.hypot(self[0] - p[0], self[1] - p[1])\n\n    def _distance_squared(self, p2: Point2) -> float:\n        \"\"\"Function used to not take the square root as the distances will stay proportionally the same.\n        This is to speed up the sorting process.\n\n        :param p2:\"\"\"\n        return (self[0] - p2[0])**2 + (self[1] - p2[1])**2\n\n    def is_closer_than(self, distance: Union[int, float], p: Union[Unit, Point2]) -> bool:\n        \"\"\"Check if another point (or unit) is closer than the given distance.\n\n        :param distance:\n        :param p:\"\"\"\n        p = p.position\n        return self.distance_to_point2(p) < distance\n\n    def is_further_than(self, distance: Union[int, float], p: Union[Unit, Point2]) -> bool:\n        \"\"\"Check if another point (or unit) is further than the given distance.\n\n        :param distance:\n        :param p:\"\"\"\n        p = p.position\n        return self.distance_to_point2(p) > distance\n\n    def sort_by_distance(self, ps: Union[Units, Iterable[Point2]]) -> List[Point2]:\n        \"\"\"This returns the target points sorted as list.\n        You should not pass a set or dict since those are not sortable.\n        If you want to sort your units towards a point, use 'units.sorted_by_distance_to(point)' instead.\n\n        :param ps:\"\"\"\n        return sorted(ps, key=lambda p: self.distance_to_point2(p.position))\n\n    def closest(self, ps: Union[Units, Iterable[Point2]]) -> Union[Unit, Point2]:\n        \"\"\"This function assumes the 2d distance is meant\n\n        :param ps:\"\"\"\n        assert ps, f\"ps is empty\"\n        return min(ps, key=lambda p: self.distance_to(p))\n\n    def distance_to_closest(self, ps: Union[Units, Iterable[Point2]]) -> float:\n        \"\"\"This function assumes the 2d distance is meant\n        :param ps:\"\"\"\n        assert ps, f\"ps is empty\"\n        closest_distance = math.inf\n        for p2 in ps:\n            p2 = p2.position\n            distance = self.distance_to(p2)\n            if distance <= closest_distance:\n                closest_distance = distance\n        return closest_distance\n\n    def furthest(self, ps: Union[Units, Iterable[Point2]]) -> Union[Unit, Pointlike]:\n        \"\"\"This function assumes the 2d distance is meant\n\n        :param ps: Units object, or iterable of Unit or Point2\"\"\"\n        assert ps, f\"ps is empty\"\n        return max(ps, key=lambda p: self.distance_to(p))\n\n    def distance_to_furthest(self, ps: Union[Units, Iterable[Point2]]) -> float:\n        \"\"\"This function assumes the 2d distance is meant\n\n        :param ps:\"\"\"\n        assert ps, f\"ps is empty\"\n        furthest_distance = -math.inf\n        for p2 in ps:\n            p2 = p2.position\n            distance = self.distance_to(p2)\n            if distance >= furthest_distance:\n                furthest_distance = distance\n        return furthest_distance\n\n    def offset(self, p) -> Pointlike:\n        \"\"\"\n\n        :param p:\n        \"\"\"\n        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[:len(self)], fillvalue=0))\n\n    def unit_axes_towards(self, p):\n        \"\"\"\n\n        :param p:\n        \"\"\"\n        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[:len(self)], fillvalue=0))\n\n    def towards(self, p: Union[Unit, Pointlike], distance: Union[int, float] = 1, limit: bool = False) -> Pointlike:\n        \"\"\"\n\n        :param p:\n        :param distance:\n        :param limit:\n        \"\"\"\n        p = p.position\n        # assert self != p, f\"self is {self}, p is {p}\"\n        # TODO test and fix this if statement\n        if self == p:\n            return self\n        # end of test\n        d = self.distance_to(p)\n        if limit:\n            distance = min(d, distance)\n        return self.__class__(\n            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[:len(self)], fillvalue=0)\n        )\n\n    def __eq__(self, other):\n        try:\n            return all(abs(a - b) <= EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\n        except:\n            return False\n\n    def __hash__(self):\n        return hash(tuple(self))",
  "class Point2(Pointlike):\n\n    @classmethod\n    def from_proto(cls, data) -> Point2:\n        \"\"\"\n        :param data:\n        \"\"\"\n        return cls((data.x, data.y))\n\n    @property\n    def as_Point2D(self) -> common_pb.Point2D:\n        return common_pb.Point2D(x=self.x, y=self.y)\n\n    @property\n    def as_PointI(self) -> common_pb.PointI:\n        \"\"\"Represents points on the minimap. Values must be between 0 and 64.\"\"\"\n        return common_pb.PointI(x=self.x, y=self.y)\n\n    @property\n    def rounded(self) -> Point2:\n        return Point2((math.floor(self[0]), math.floor(self[1])))\n\n    @property\n    def length(self) -> float:\n        \"\"\" This property exists in case Point2 is used as a vector. \"\"\"\n        return math.hypot(self[0], self[1])\n\n    @property\n    def normalized(self) -> Point2:\n        \"\"\" This property exists in case Point2 is used as a vector. \"\"\"\n        length = self.length\n        # Cannot normalize if length is zero\n        assert length\n        return self.__class__((self[0] / length, self[1] / length))\n\n    @property\n    def x(self) -> float:\n        return self[0]\n\n    @property\n    def y(self) -> float:\n        return self[1]\n\n    @property\n    def to2(self) -> Point2:\n        return Point2(self[:2])\n\n    @property\n    def to3(self) -> Point3:\n        return Point3((*self, 0))\n\n    def offset(self, off):\n        return Point2((self[0] + off[0], self[1] + off[1]))\n\n    def random_on_distance(self, distance):\n        if isinstance(distance, (tuple, list)):  # interval\n            distance = distance[0] + random.random() * (distance[1] - distance[0])\n\n        assert distance > 0, f\"Distance is not greater than 0\"\n        angle = random.random() * 2 * math.pi\n\n        dx, dy = math.cos(angle), math.sin(angle)\n        return Point2((self.x + dx * distance, self.y + dy * distance))\n\n    def towards_with_random_angle(\n        self,\n        p: Union[Point2, Point3],\n        distance: Union[int, float] = 1,\n        max_difference: Union[int, float] = (math.pi / 4),\n    ) -> Point2:\n        tx, ty = self.to2.towards(p.to2, 1)\n        angle = math.atan2(ty - self.y, tx - self.x)\n        angle = (angle - max_difference) + max_difference * 2 * random.random()\n        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))\n\n    def circle_intersection(self, p: Point2, r: Union[int, float]) -> Set[Point2]:\n        \"\"\"self is point1, p is point2, r is the radius for circles originating in both points\n        Used in ramp finding\n\n        :param p:\n        :param r:\"\"\"\n        assert self != p, f\"self is equal to p\"\n        distanceBetweenPoints = self.distance_to(p)\n        assert r >= distanceBetweenPoints / 2\n        # remaining distance from center towards the intersection, using pythagoras\n        remainingDistanceFromCenter = (r**2 - (distanceBetweenPoints / 2)**2)**0.5\n        # center of both points\n        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\n        center = self.offset(offsetToCenter)\n\n        # stretch offset vector in the ratio of remaining distance from center to intersection\n        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\n        v = offsetToCenter\n        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\n\n        # rotate vector by 90\u00b0 and -90\u00b0\n        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\n        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\n        intersect1 = center.offset(vectorRotated1)\n        intersect2 = center.offset(vectorRotated2)\n        return {intersect1, intersect2}\n\n    @property\n    def neighbors4(self) -> set:\n        return {\n            Point2((self.x - 1, self.y)),\n            Point2((self.x + 1, self.y)),\n            Point2((self.x, self.y - 1)),\n            Point2((self.x, self.y + 1)),\n        }\n\n    @property\n    def neighbors8(self) -> set:\n        return self.neighbors4 | {\n            Point2((self.x - 1, self.y - 1)),\n            Point2((self.x - 1, self.y + 1)),\n            Point2((self.x + 1, self.y - 1)),\n            Point2((self.x + 1, self.y + 1)),\n        }\n\n    def negative_offset(self, other: Point2) -> Point2:\n        return self.__class__((self[0] - other[0], self[1] - other[1]))\n\n    def __add__(self, other: Point2) -> Point2:\n        return self.offset(other)\n\n    def __sub__(self, other: Point2) -> Point2:\n        return self.negative_offset(other)\n\n    def __neg__(self) -> Point2:\n        return self.__class__(-a for a in self)\n\n    def __abs__(self) -> float:\n        return math.hypot(self.x, self.y)\n\n    def __bool__(self) -> bool:\n        if self.x != 0 or self.y != 0:\n            return True\n        return False\n\n    def __mul__(self, other: Union[int, float, Point2]) -> Point2:\n        try:\n            return self.__class__((self.x * other.x, self.y * other.y))\n        except AttributeError:\n            return self.__class__((self.x * other, self.y * other))\n\n    def __rmul__(self, other: Union[int, float, Point2]) -> Point2:\n        return self.__mul__(other)\n\n    def __truediv__(self, other: Union[int, float, Point2]) -> Point2:\n        if isinstance(other, self.__class__):\n            return self.__class__((self.x / other.x, self.y / other.y))\n        return self.__class__((self.x / other, self.y / other))\n\n    def is_same_as(self, other: Point2, dist=0.001) -> bool:\n        return self.distance_to_point2(other) <= dist\n\n    def direction_vector(self, other: Point2) -> Point2:\n        \"\"\" Converts a vector to a direction that can face vertically, horizontally or diagonal or be zero, e.g. (0, 0), (1, -1), (1, 0) \"\"\"\n        return self.__class__((_sign(other.x - self.x), _sign(other.y - self.y)))\n\n    def manhattan_distance(self, other: Point2) -> float:\n        \"\"\"\n        :param other:\n        \"\"\"\n        return abs(other.x - self.x) + abs(other.y - self.y)\n\n    @staticmethod\n    def center(units_or_points: Iterable[Point2]) -> Point2:\n        \"\"\"Returns the central point for points in list\n\n        :param units_or_points:\"\"\"\n        s = Point2((0, 0))\n        for p in units_or_points:\n            s += p\n        return s / len(units_or_points)",
  "class Point3(Point2):\n\n    @classmethod\n    def from_proto(cls, data):\n        \"\"\"\n        :param data:\n        \"\"\"\n        return cls((data.x, data.y, data.z))\n\n    @property\n    def as_Point(self) -> common_pb.Point:\n        return common_pb.Point(x=self.x, y=self.y, z=self.z)\n\n    @property\n    def rounded(self) -> Point3:\n        return Point3((math.floor(self[0]), math.floor(self[1]), math.floor(self[2])))\n\n    @property\n    def z(self) -> float:\n        return self[2]\n\n    @property\n    def to3(self) -> Point3:\n        return Point3(self)\n\n    def __add__(self, other: Union[Point2, Point3]) -> Point3:\n        if not isinstance(other, Point3) and isinstance(other, Point2):\n            return Point3((self.x + other.x, self.y + other.y, self.z))\n        return Point3((self.x + other.x, self.y + other.y, self.z + other.z))",
  "class Size(Point2):\n\n    @property\n    def width(self) -> float:\n        return self[0]\n\n    @property\n    def height(self) -> float:\n        return self[1]",
  "class Rect(tuple):\n\n    @classmethod\n    def from_proto(cls, data):\n        \"\"\"\n        :param data:\n        \"\"\"\n        assert data.p0.x < data.p1.x and data.p0.y < data.p1.y\n        return cls((data.p0.x, data.p0.y, data.p1.x - data.p0.x, data.p1.y - data.p0.y))\n\n    @property\n    def x(self) -> float:\n        return self[0]\n\n    @property\n    def y(self) -> float:\n        return self[1]\n\n    @property\n    def width(self) -> float:\n        return self[2]\n\n    @property\n    def height(self) -> float:\n        return self[3]\n\n    @property\n    def right(self) -> float:\n        \"\"\" Returns the x-coordinate of the rectangle of its right side. \"\"\"\n        return self.x + self.width\n\n    @property\n    def top(self) -> float:\n        \"\"\" Returns the y-coordinate of the rectangle of its top side. \"\"\"\n        return self.y + self.height\n\n    @property\n    def size(self) -> Size:\n        return Size((self[2], self[3]))\n\n    @property\n    def center(self) -> Point2:\n        return Point2((self.x + self.width / 2, self.y + self.height / 2))\n\n    def offset(self, p):\n        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))",
  "def position(self) -> Pointlike:\n        return self",
  "def distance_to(self, target: Union[Unit, Point2]) -> float:\n        \"\"\"Calculate a single distance from a point or unit to another point or unit\n\n        :param target:\"\"\"\n        p = target.position\n        return math.hypot(self[0] - p[0], self[1] - p[1])",
  "def distance_to_point2(self, p: Union[Point2, Tuple[float, float]]) -> float:\n        \"\"\"Same as the function above, but should be a bit faster because of the dropped asserts\n        and conversion.\n\n        :param p:\"\"\"\n        return math.hypot(self[0] - p[0], self[1] - p[1])",
  "def _distance_squared(self, p2: Point2) -> float:\n        \"\"\"Function used to not take the square root as the distances will stay proportionally the same.\n        This is to speed up the sorting process.\n\n        :param p2:\"\"\"\n        return (self[0] - p2[0])**2 + (self[1] - p2[1])**2",
  "def is_closer_than(self, distance: Union[int, float], p: Union[Unit, Point2]) -> bool:\n        \"\"\"Check if another point (or unit) is closer than the given distance.\n\n        :param distance:\n        :param p:\"\"\"\n        p = p.position\n        return self.distance_to_point2(p) < distance",
  "def is_further_than(self, distance: Union[int, float], p: Union[Unit, Point2]) -> bool:\n        \"\"\"Check if another point (or unit) is further than the given distance.\n\n        :param distance:\n        :param p:\"\"\"\n        p = p.position\n        return self.distance_to_point2(p) > distance",
  "def sort_by_distance(self, ps: Union[Units, Iterable[Point2]]) -> List[Point2]:\n        \"\"\"This returns the target points sorted as list.\n        You should not pass a set or dict since those are not sortable.\n        If you want to sort your units towards a point, use 'units.sorted_by_distance_to(point)' instead.\n\n        :param ps:\"\"\"\n        return sorted(ps, key=lambda p: self.distance_to_point2(p.position))",
  "def closest(self, ps: Union[Units, Iterable[Point2]]) -> Union[Unit, Point2]:\n        \"\"\"This function assumes the 2d distance is meant\n\n        :param ps:\"\"\"\n        assert ps, f\"ps is empty\"\n        return min(ps, key=lambda p: self.distance_to(p))",
  "def distance_to_closest(self, ps: Union[Units, Iterable[Point2]]) -> float:\n        \"\"\"This function assumes the 2d distance is meant\n        :param ps:\"\"\"\n        assert ps, f\"ps is empty\"\n        closest_distance = math.inf\n        for p2 in ps:\n            p2 = p2.position\n            distance = self.distance_to(p2)\n            if distance <= closest_distance:\n                closest_distance = distance\n        return closest_distance",
  "def furthest(self, ps: Union[Units, Iterable[Point2]]) -> Union[Unit, Pointlike]:\n        \"\"\"This function assumes the 2d distance is meant\n\n        :param ps: Units object, or iterable of Unit or Point2\"\"\"\n        assert ps, f\"ps is empty\"\n        return max(ps, key=lambda p: self.distance_to(p))",
  "def distance_to_furthest(self, ps: Union[Units, Iterable[Point2]]) -> float:\n        \"\"\"This function assumes the 2d distance is meant\n\n        :param ps:\"\"\"\n        assert ps, f\"ps is empty\"\n        furthest_distance = -math.inf\n        for p2 in ps:\n            p2 = p2.position\n            distance = self.distance_to(p2)\n            if distance >= furthest_distance:\n                furthest_distance = distance\n        return furthest_distance",
  "def offset(self, p) -> Pointlike:\n        \"\"\"\n\n        :param p:\n        \"\"\"\n        return self.__class__(a + b for a, b in itertools.zip_longest(self, p[:len(self)], fillvalue=0))",
  "def unit_axes_towards(self, p):\n        \"\"\"\n\n        :param p:\n        \"\"\"\n        return self.__class__(_sign(b - a) for a, b in itertools.zip_longest(self, p[:len(self)], fillvalue=0))",
  "def towards(self, p: Union[Unit, Pointlike], distance: Union[int, float] = 1, limit: bool = False) -> Pointlike:\n        \"\"\"\n\n        :param p:\n        :param distance:\n        :param limit:\n        \"\"\"\n        p = p.position\n        # assert self != p, f\"self is {self}, p is {p}\"\n        # TODO test and fix this if statement\n        if self == p:\n            return self\n        # end of test\n        d = self.distance_to(p)\n        if limit:\n            distance = min(d, distance)\n        return self.__class__(\n            a + (b - a) / d * distance for a, b in itertools.zip_longest(self, p[:len(self)], fillvalue=0)\n        )",
  "def __eq__(self, other):\n        try:\n            return all(abs(a - b) <= EPSILON for a, b in itertools.zip_longest(self, other, fillvalue=0))\n        except:\n            return False",
  "def __hash__(self):\n        return hash(tuple(self))",
  "def from_proto(cls, data) -> Point2:\n        \"\"\"\n        :param data:\n        \"\"\"\n        return cls((data.x, data.y))",
  "def as_Point2D(self) -> common_pb.Point2D:\n        return common_pb.Point2D(x=self.x, y=self.y)",
  "def as_PointI(self) -> common_pb.PointI:\n        \"\"\"Represents points on the minimap. Values must be between 0 and 64.\"\"\"\n        return common_pb.PointI(x=self.x, y=self.y)",
  "def rounded(self) -> Point2:\n        return Point2((math.floor(self[0]), math.floor(self[1])))",
  "def length(self) -> float:\n        \"\"\" This property exists in case Point2 is used as a vector. \"\"\"\n        return math.hypot(self[0], self[1])",
  "def normalized(self) -> Point2:\n        \"\"\" This property exists in case Point2 is used as a vector. \"\"\"\n        length = self.length\n        # Cannot normalize if length is zero\n        assert length\n        return self.__class__((self[0] / length, self[1] / length))",
  "def x(self) -> float:\n        return self[0]",
  "def y(self) -> float:\n        return self[1]",
  "def to2(self) -> Point2:\n        return Point2(self[:2])",
  "def to3(self) -> Point3:\n        return Point3((*self, 0))",
  "def offset(self, off):\n        return Point2((self[0] + off[0], self[1] + off[1]))",
  "def random_on_distance(self, distance):\n        if isinstance(distance, (tuple, list)):  # interval\n            distance = distance[0] + random.random() * (distance[1] - distance[0])\n\n        assert distance > 0, f\"Distance is not greater than 0\"\n        angle = random.random() * 2 * math.pi\n\n        dx, dy = math.cos(angle), math.sin(angle)\n        return Point2((self.x + dx * distance, self.y + dy * distance))",
  "def towards_with_random_angle(\n        self,\n        p: Union[Point2, Point3],\n        distance: Union[int, float] = 1,\n        max_difference: Union[int, float] = (math.pi / 4),\n    ) -> Point2:\n        tx, ty = self.to2.towards(p.to2, 1)\n        angle = math.atan2(ty - self.y, tx - self.x)\n        angle = (angle - max_difference) + max_difference * 2 * random.random()\n        return Point2((self.x + math.cos(angle) * distance, self.y + math.sin(angle) * distance))",
  "def circle_intersection(self, p: Point2, r: Union[int, float]) -> Set[Point2]:\n        \"\"\"self is point1, p is point2, r is the radius for circles originating in both points\n        Used in ramp finding\n\n        :param p:\n        :param r:\"\"\"\n        assert self != p, f\"self is equal to p\"\n        distanceBetweenPoints = self.distance_to(p)\n        assert r >= distanceBetweenPoints / 2\n        # remaining distance from center towards the intersection, using pythagoras\n        remainingDistanceFromCenter = (r**2 - (distanceBetweenPoints / 2)**2)**0.5\n        # center of both points\n        offsetToCenter = Point2(((p.x - self.x) / 2, (p.y - self.y) / 2))\n        center = self.offset(offsetToCenter)\n\n        # stretch offset vector in the ratio of remaining distance from center to intersection\n        vectorStretchFactor = remainingDistanceFromCenter / (distanceBetweenPoints / 2)\n        v = offsetToCenter\n        offsetToCenterStretched = Point2((v.x * vectorStretchFactor, v.y * vectorStretchFactor))\n\n        # rotate vector by 90\u00b0 and -90\u00b0\n        vectorRotated1 = Point2((offsetToCenterStretched.y, -offsetToCenterStretched.x))\n        vectorRotated2 = Point2((-offsetToCenterStretched.y, offsetToCenterStretched.x))\n        intersect1 = center.offset(vectorRotated1)\n        intersect2 = center.offset(vectorRotated2)\n        return {intersect1, intersect2}",
  "def neighbors4(self) -> set:\n        return {\n            Point2((self.x - 1, self.y)),\n            Point2((self.x + 1, self.y)),\n            Point2((self.x, self.y - 1)),\n            Point2((self.x, self.y + 1)),\n        }",
  "def neighbors8(self) -> set:\n        return self.neighbors4 | {\n            Point2((self.x - 1, self.y - 1)),\n            Point2((self.x - 1, self.y + 1)),\n            Point2((self.x + 1, self.y - 1)),\n            Point2((self.x + 1, self.y + 1)),\n        }",
  "def negative_offset(self, other: Point2) -> Point2:\n        return self.__class__((self[0] - other[0], self[1] - other[1]))",
  "def __add__(self, other: Point2) -> Point2:\n        return self.offset(other)",
  "def __sub__(self, other: Point2) -> Point2:\n        return self.negative_offset(other)",
  "def __neg__(self) -> Point2:\n        return self.__class__(-a for a in self)",
  "def __abs__(self) -> float:\n        return math.hypot(self.x, self.y)",
  "def __bool__(self) -> bool:\n        if self.x != 0 or self.y != 0:\n            return True\n        return False",
  "def __mul__(self, other: Union[int, float, Point2]) -> Point2:\n        try:\n            return self.__class__((self.x * other.x, self.y * other.y))\n        except AttributeError:\n            return self.__class__((self.x * other, self.y * other))",
  "def __rmul__(self, other: Union[int, float, Point2]) -> Point2:\n        return self.__mul__(other)",
  "def __truediv__(self, other: Union[int, float, Point2]) -> Point2:\n        if isinstance(other, self.__class__):\n            return self.__class__((self.x / other.x, self.y / other.y))\n        return self.__class__((self.x / other, self.y / other))",
  "def is_same_as(self, other: Point2, dist=0.001) -> bool:\n        return self.distance_to_point2(other) <= dist",
  "def direction_vector(self, other: Point2) -> Point2:\n        \"\"\" Converts a vector to a direction that can face vertically, horizontally or diagonal or be zero, e.g. (0, 0), (1, -1), (1, 0) \"\"\"\n        return self.__class__((_sign(other.x - self.x), _sign(other.y - self.y)))",
  "def manhattan_distance(self, other: Point2) -> float:\n        \"\"\"\n        :param other:\n        \"\"\"\n        return abs(other.x - self.x) + abs(other.y - self.y)",
  "def center(units_or_points: Iterable[Point2]) -> Point2:\n        \"\"\"Returns the central point for points in list\n\n        :param units_or_points:\"\"\"\n        s = Point2((0, 0))\n        for p in units_or_points:\n            s += p\n        return s / len(units_or_points)",
  "def from_proto(cls, data):\n        \"\"\"\n        :param data:\n        \"\"\"\n        return cls((data.x, data.y, data.z))",
  "def as_Point(self) -> common_pb.Point:\n        return common_pb.Point(x=self.x, y=self.y, z=self.z)",
  "def rounded(self) -> Point3:\n        return Point3((math.floor(self[0]), math.floor(self[1]), math.floor(self[2])))",
  "def z(self) -> float:\n        return self[2]",
  "def to3(self) -> Point3:\n        return Point3(self)",
  "def __add__(self, other: Union[Point2, Point3]) -> Point3:\n        if not isinstance(other, Point3) and isinstance(other, Point2):\n            return Point3((self.x + other.x, self.y + other.y, self.z))\n        return Point3((self.x + other.x, self.y + other.y, self.z + other.z))",
  "def width(self) -> float:\n        return self[0]",
  "def height(self) -> float:\n        return self[1]",
  "def from_proto(cls, data):\n        \"\"\"\n        :param data:\n        \"\"\"\n        assert data.p0.x < data.p1.x and data.p0.y < data.p1.y\n        return cls((data.p0.x, data.p0.y, data.p1.x - data.p0.x, data.p1.y - data.p0.y))",
  "def x(self) -> float:\n        return self[0]",
  "def y(self) -> float:\n        return self[1]",
  "def width(self) -> float:\n        return self[2]",
  "def height(self) -> float:\n        return self[3]",
  "def right(self) -> float:\n        \"\"\" Returns the x-coordinate of the rectangle of its right side. \"\"\"\n        return self.x + self.width",
  "def top(self) -> float:\n        \"\"\" Returns the y-coordinate of the rectangle of its top side. \"\"\"\n        return self.y + self.height",
  "def size(self) -> Size:\n        return Size((self[2], self[3]))",
  "def center(self) -> Point2:\n        return Point2((self.x + self.width / 2, self.y + self.height / 2))",
  "def offset(self, p):\n        return self.__class__((self[0] + p[0], self[1] + p[1], self[2], self[3]))",
  "def win_path_to_wsl_path(path):\n    \"\"\"Convert a path like C:\\\\foo to /mnt/c/foo\"\"\"\n    return Path(\"/mnt\") / PureWindowsPath(re.sub(\"^([A-Z]):\", lambda m: m.group(1).lower(), path))",
  "def wsl_path_to_win_path(path):\n    \"\"\"Convert a path like /mnt/c/foo to C:\\\\foo\"\"\"\n    return PureWindowsPath(re.sub(\"^/mnt/([a-z])\", lambda m: m.group(1).upper() + \":\", path))",
  "def get_wsl_home():\n    \"\"\"Get home directory of from Windows, even if run in WSL\"\"\"\n    proc = subprocess.run([\"powershell.exe\", \"-Command\", \"Write-Host -NoNewLine $HOME\"], capture_output=True)\n\n    if proc.returncode != 0:\n        return None\n\n    return win_path_to_wsl_path(proc.stdout.decode(\"utf-8\"))",
  "def run(popen_args, sc2_cwd):\n    \"\"\"Run SC2 in Windows and get the pid so that it can be killed later.\"\"\"\n    path = wsl_path_to_win_path(popen_args[0])\n    args = \" \".join(popen_args[1:])\n\n    return subprocess.Popen(\n        [\"powershell.exe\", \"-Command\", RUN_SCRIPT % (path, args)],\n        cwd=sc2_cwd,\n        stdout=subprocess.PIPE,\n        universal_newlines=True,\n        bufsize=1,\n    )",
  "def kill(wsl_process):\n    \"\"\"Needed to kill a process started with WSL. Returns true if killed successfully.\"\"\"\n    # HACK: subprocess and WSL1 appear to have a nasty interaction where\n    # any streams are never closed and the process is never considered killed,\n    # despite having an exit code (this works on WSL2 as well, but isn't\n    # necessary). As a result,\n    # 1: We need to read using readline (to make sure we block long enough to\n    #    get the exit code in the rare case where the user immediately hits ^C)\n    out = wsl_process.stdout.readline().rstrip()\n    # 2: We need to use __exit__, since kill() calls send_signal(), which thinks\n    #    the process has already exited!\n    wsl_process.__exit__(None, None, None)\n    proc = subprocess.run([\"taskkill.exe\", \"-f\", \"-pid\", out], capture_output=True)\n    return proc.returncode == 0",
  "def detect():\n    \"\"\"Detect the current running version of WSL, and bail out if it doesn't exist\"\"\"\n    # Allow disabling WSL detection with an environment variable\n    if os.getenv(\"SC2_WSL_DETECT\", \"1\") == \"0\":\n        return None\n\n    wsl_name = os.environ.get(\"WSL_DISTRO_NAME\")\n    if not wsl_name:\n        return None\n\n    try:\n        wsl_proc = subprocess.run([\"wsl.exe\", \"--list\", \"--running\", \"--verbose\"], capture_output=True)\n    except Exception:\n        return None\n    if wsl_proc.returncode != 0:\n        return None\n\n    # WSL.exe returns a bunch of null characters for some reason, as well as\n    # windows-style linebreaks. It's inconsistent about how many \\rs it uses\n    # and this could change in the future, so strip out all junk and split by\n    # Unix-style newlines for safety's sake.\n    lines = re.sub(r\"\\000|\\r\", \"\", wsl_proc.stdout.decode(\"utf-8\")).split(\"\\n\")\n\n    def line_has_proc(ln):\n        return re.search(\"^\\\\s*[*]?\\\\s+\" + wsl_name, ln)\n\n    def line_version(ln):\n        return re.sub(\"^.*\\\\s+(\\\\d+)\\\\s*$\", \"\\\\1\", ln)\n\n    versions = [line_version(ln) for ln in lines if line_has_proc(ln)]\n\n    try:\n        version = versions[0]\n        if int(version) not in [1, 2]:\n            return None\n    except (ValueError, IndexError):\n        return None\n\n    logger.info(f\"WSL version {version} detected\")\n\n    if version == \"2\" and not (os.environ.get(\"SC2CLIENTHOST\") and os.environ.get(\"SC2SERVERHOST\")):\n        logger.warning(\"You appear to be running WSL2 without your hosts configured correctly.\")\n        logger.warning(\"This may result in SC2 staying on a black screen and not connecting to your bot.\")\n        logger.warning(\"Please see the python-sc2 README for WSL2 configuration instructions.\")\n\n    return \"WSL\" + version",
  "def line_has_proc(ln):\n        return re.search(\"^\\\\s*[*]?\\\\s+\" + wsl_name, ln)",
  "def line_version(ln):\n        return re.sub(\"^.*\\\\s+(\\\\d+)\\\\s*$\", \"\\\\1\", ln)",
  "class Client(Protocol):\n\n    def __init__(self, ws):\n        \"\"\"\n        :param ws:\n        \"\"\"\n        super().__init__(ws)\n        # How many frames will be waited between iterations before the next one is called\n        self.game_step: int = 8\n        self._player_id = None\n        self._game_result = None\n        # Store a hash value of all the debug requests to prevent sending the same ones again if they haven't changed last frame\n        self._debug_hash_tuple_last_iteration: Tuple[int, int, int, int] = (0, 0, 0, 0)\n        self._debug_draw_last_frame = False\n        self._debug_texts = []\n        self._debug_lines = []\n        self._debug_boxes = []\n        self._debug_spheres = []\n\n        self._renderer = None\n        self.raw_affects_selection = False\n\n    @property\n    def in_game(self):\n        return self._status in {Status.in_game, Status.in_replay}\n\n    async def join_game(self, name=None, race=None, observed_player_id=None, portconfig=None, rgb_render_config=None):\n        ifopts = sc_pb.InterfaceOptions(\n            raw=True,\n            score=True,\n            show_cloaked=True,\n            show_burrowed_shadows=True,\n            raw_affects_selection=self.raw_affects_selection,\n            raw_crop_to_playable_area=False,\n            show_placeholders=True,\n        )\n\n        if rgb_render_config:\n            assert isinstance(rgb_render_config, dict)\n            assert \"window_size\" in rgb_render_config and \"minimap_size\" in rgb_render_config\n            window_size = rgb_render_config[\"window_size\"]\n            minimap_size = rgb_render_config[\"minimap_size\"]\n            self._renderer = Renderer(self, window_size, minimap_size)\n            map_width, map_height = window_size\n            minimap_width, minimap_height = minimap_size\n\n            ifopts.render.resolution.x = map_width\n            ifopts.render.resolution.y = map_height\n            ifopts.render.minimap_resolution.x = minimap_width\n            ifopts.render.minimap_resolution.y = minimap_height\n\n        if race is None:\n            assert isinstance(observed_player_id, int), f\"observed_player_id is of type {type(observed_player_id)}\"\n            # join as observer\n            req = sc_pb.RequestJoinGame(observed_player_id=observed_player_id, options=ifopts)\n        else:\n            assert isinstance(race, Race)\n            req = sc_pb.RequestJoinGame(race=race.value, options=ifopts)\n\n        if portconfig:\n            req.server_ports.game_port = portconfig.server[0]\n            req.server_ports.base_port = portconfig.server[1]\n\n            for ppc in portconfig.players:\n                p = req.client_ports.add()\n                p.game_port = ppc[0]\n                p.base_port = ppc[1]\n\n        if name is not None:\n            assert isinstance(name, str), f\"name is of type {type(name)}\"\n            req.player_name = name\n\n        result = await self._execute(join_game=req)\n        self._game_result = None\n        self._player_id = result.join_game.player_id\n        return result.join_game.player_id\n\n    async def leave(self):\n        \"\"\" You can use 'await self._client.leave()' to surrender midst game. \"\"\"\n        is_resign = self._game_result is None\n\n        if is_resign:\n            # For all clients that can leave, result of leaving the game either\n            # loss, or the client will ignore the result\n            self._game_result = {self._player_id: Result.Defeat}\n\n        try:\n            await self._execute(leave_game=sc_pb.RequestLeaveGame())\n        except ProtocolError:\n            if is_resign:\n                raise\n\n    async def save_replay(self, path):\n        logger.debug(f\"Requesting replay from server\")\n        result = await self._execute(save_replay=sc_pb.RequestSaveReplay())\n        with open(path, \"wb\") as f:\n            f.write(result.save_replay.data)\n        logger.info(f\"Saved replay to {path}\")\n\n    async def observation(self, game_loop=None):\n        if game_loop is not None:\n            result = await self._execute(observation=sc_pb.RequestObservation(game_loop=game_loop))\n        else:\n            result = await self._execute(observation=sc_pb.RequestObservation())\n        assert result.HasField(\"observation\")\n\n        if not self.in_game or result.observation.player_result:\n            # Sometimes game ends one step before results are available\n            if not result.observation.player_result:\n                result = await self._execute(observation=sc_pb.RequestObservation())\n                assert result.observation.player_result\n\n            player_id_to_result = {}\n            for pr in result.observation.player_result:\n                player_id_to_result[pr.player_id] = Result(pr.result)\n            self._game_result = player_id_to_result\n\n        # if render_data is available, then RGB rendering was requested\n        if self._renderer and result.observation.observation.HasField(\"render_data\"):\n            await self._renderer.render(result.observation)\n\n        return result\n\n    async def step(self, step_size: int = None):\n        \"\"\" EXPERIMENTAL: Change self._client.game_step during the step function to increase or decrease steps per second \"\"\"\n        step_size = step_size or self.game_step\n        return await self._execute(step=sc_pb.RequestStep(count=step_size))\n\n    async def get_game_data(self) -> GameData:\n        result = await self._execute(\n            data=sc_pb.RequestData(ability_id=True, unit_type_id=True, upgrade_id=True, buff_id=True, effect_id=True)\n        )\n        return GameData(result.data)\n\n    async def dump_data(self, ability_id=True, unit_type_id=True, upgrade_id=True, buff_id=True, effect_id=True):\n        \"\"\"\n        Dump the game data files\n        choose what data to dump in the keywords\n        this function writes to a text file\n        call it one time in on_step with:\n        await self._client.dump_data()\n        \"\"\"\n        result = await self._execute(\n            data=sc_pb.RequestData(\n                ability_id=ability_id,\n                unit_type_id=unit_type_id,\n                upgrade_id=upgrade_id,\n                buff_id=buff_id,\n                effect_id=effect_id,\n            )\n        )\n        with open(\"data_dump.txt\", \"a\") as file:\n            file.write(str(result.data))\n\n    async def get_game_info(self) -> GameInfo:\n        result = await self._execute(game_info=sc_pb.RequestGameInfo())\n        return GameInfo(result.game_info)\n\n    async def actions(self, actions, return_successes=False):\n        if not actions:\n            return None\n        elif not isinstance(actions, list):\n            actions = [actions]\n\n        # On realtime=True, might get an error here: sc2.protocol.ProtocolError: ['Not in a game']\n        try:\n            res = await self._execute(\n                action=sc_pb.RequestAction(actions=(sc_pb.Action(action_raw=a) for a in combine_actions(actions)))\n            )\n        except ProtocolError as e:\n            return []\n        if return_successes:\n            return [ActionResult(r) for r in res.action.result]\n        else:\n            return [ActionResult(r) for r in res.action.result if ActionResult(r) != ActionResult.Success]\n\n    async def query_pathing(self, start: Union[Unit, Point2, Point3],\n                            end: Union[Point2, Point3]) -> Optional[Union[int, float]]:\n        \"\"\"Caution: returns \"None\" when path not found\n        Try to combine queries with the function below because the pathing query is generally slow.\n\n        :param start:\n        :param end:\"\"\"\n        assert isinstance(start, (Point2, Unit))\n        assert isinstance(end, Point2)\n        if isinstance(start, Point2):\n            path = [query_pb.RequestQueryPathing(start_pos=start.as_Point2D, end_pos=end.as_Point2D)]\n        else:\n            path = [query_pb.RequestQueryPathing(unit_tag=start.tag, end_pos=end.as_Point2D)]\n        result = await self._execute(query=query_pb.RequestQuery(pathing=path))\n        distance = float(result.query.pathing[0].distance)\n        if distance <= 0.0:\n            return None\n        return distance\n\n    async def query_pathings(self, zipped_list: List[List[Union[Unit, Point2, Point3]]]) -> List[Union[float, int]]:\n        \"\"\"Usage: await self.query_pathings([[unit1, target2], [unit2, target2]])\n        -> returns [distance1, distance2]\n        Caution: returns 0 when path not found\n\n        :param zipped_list:\n        \"\"\"\n        assert zipped_list, \"No zipped_list\"\n        assert isinstance(zipped_list, list), f\"{type(zipped_list)}\"\n        assert isinstance(zipped_list[0], list), f\"{type(zipped_list[0])}\"\n        assert len(zipped_list[0]) == 2, f\"{len(zipped_list[0])}\"\n        assert isinstance(zipped_list[0][0], (Point2, Unit)), f\"{type(zipped_list[0][0])}\"\n        assert isinstance(zipped_list[0][1], Point2), f\"{type(zipped_list[0][1])}\"\n        if isinstance(zipped_list[0][0], Point2):\n            path = (\n                query_pb.RequestQueryPathing(start_pos=p1.as_Point2D, end_pos=p2.as_Point2D) for p1, p2 in zipped_list\n            )\n        else:\n            path = (query_pb.RequestQueryPathing(unit_tag=p1.tag, end_pos=p2.as_Point2D) for p1, p2 in zipped_list)\n        results = await self._execute(query=query_pb.RequestQuery(pathing=path))\n        return [float(d.distance) for d in results.query.pathing]\n\n    async def _query_building_placement_fast(\n        self, ability: AbilityId, positions: List[Union[Point2, Point3]], ignore_resources: bool = True\n    ) -> List[bool]:\n        \"\"\"\n        Returns a list of booleans. Return True for positions that are valid, False otherwise.\n\n        :param ability:\n        :param positions:\n        :param ignore_resources:\n        \"\"\"\n        result = await self._execute(\n            query=query_pb.RequestQuery(\n                placements=(\n                    query_pb.RequestQueryBuildingPlacement(ability_id=ability.value, target_pos=position.as_Point2D)\n                    for position in positions\n                ),\n                ignore_resource_requirements=ignore_resources,\n            )\n        )\n        # Success enum value is 1, see https://github.com/Blizzard/s2client-proto/blob/9906df71d6909511907d8419b33acc1a3bd51ec0/s2clientprotocol/error.proto#L7\n        return [p.result == 1 for p in result.query.placements]\n\n    async def query_building_placement(\n        self,\n        ability: AbilityData,\n        positions: List[Union[Point2, Point3]],\n        ignore_resources: bool = True\n    ) -> List[ActionResult]:\n        \"\"\"This function might be deleted in favor of the function above (_query_building_placement_fast).\n\n        :param ability:\n        :param positions:\n        :param ignore_resources:\"\"\"\n        assert isinstance(ability, AbilityData)\n        result = await self._execute(\n            query=query_pb.RequestQuery(\n                placements=(\n                    query_pb.RequestQueryBuildingPlacement(ability_id=ability.id.value, target_pos=position.as_Point2D)\n                    for position in positions\n                ),\n                ignore_resource_requirements=ignore_resources,\n            )\n        )\n        # Unnecessary converting to ActionResult?\n        return [ActionResult(p.result) for p in result.query.placements]\n\n    async def query_available_abilities(\n        self, units: Union[List[Unit], Units], ignore_resource_requirements: bool = False\n    ) -> List[List[AbilityId]]:\n        \"\"\" Query abilities of multiple units \"\"\"\n        input_was_a_list = True\n        if not isinstance(units, list):\n            \"\"\" Deprecated, accepting a single unit may be removed in the future, query a list of units instead \"\"\"\n            assert isinstance(units, Unit)\n            units = [units]\n            input_was_a_list = False\n        assert units\n        result = await self._execute(\n            query=query_pb.RequestQuery(\n                abilities=(query_pb.RequestQueryAvailableAbilities(unit_tag=unit.tag) for unit in units),\n                ignore_resource_requirements=ignore_resource_requirements,\n            )\n        )\n        \"\"\" Fix for bots that only query a single unit, may be removed soon \"\"\"\n        if not input_was_a_list:\n            return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities][0]\n        return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities]\n\n    async def query_available_abilities_with_tag(\n        self, units: Union[List[Unit], Units], ignore_resource_requirements: bool = False\n    ) -> Dict[int, Set[AbilityId]]:\n        \"\"\" Query abilities of multiple units \"\"\"\n\n        result = await self._execute(\n            query=query_pb.RequestQuery(\n                abilities=(query_pb.RequestQueryAvailableAbilities(unit_tag=unit.tag) for unit in units),\n                ignore_resource_requirements=ignore_resource_requirements,\n            )\n        )\n        return {b.unit_tag: {AbilityId(a.ability_id) for a in b.abilities} for b in result.query.abilities}\n\n    async def chat_send(self, message: str, team_only: bool):\n        \"\"\" Writes a message to the chat \"\"\"\n        ch = ChatChannel.Team if team_only else ChatChannel.Broadcast\n        await self._execute(\n            action=sc_pb.RequestAction(\n                actions=[sc_pb.Action(action_chat=sc_pb.ActionChat(channel=ch.value, message=message))]\n            )\n        )\n\n    async def toggle_autocast(self, units: Union[List[Unit], Units], ability: AbilityId):\n        \"\"\"Toggle autocast of all specified units\n\n        :param units:\n        :param ability:\"\"\"\n        assert units\n        assert isinstance(units, list)\n        assert all(isinstance(u, Unit) for u in units)\n        assert isinstance(ability, AbilityId)\n\n        await self._execute(\n            action=sc_pb.RequestAction(\n                actions=[\n                    sc_pb.Action(\n                        action_raw=raw_pb.ActionRaw(\n                            toggle_autocast=raw_pb.\n                            ActionRawToggleAutocast(ability_id=ability.value, unit_tags=(u.tag for u in units))\n                        )\n                    )\n                ]\n            )\n        )\n\n    async def debug_create_unit(self, unit_spawn_commands: List[List[Union[UnitTypeId, int, Point2, Point3]]]):\n        \"\"\"Usage example (will spawn 5 marines in the center of the map for player ID 1):\n        await self._client.debug_create_unit([[UnitTypeId.MARINE, 5, self._game_info.map_center, 1]])\n\n        :param unit_spawn_commands:\"\"\"\n        assert isinstance(unit_spawn_commands, list)\n        assert unit_spawn_commands\n        assert isinstance(unit_spawn_commands[0], list)\n        assert len(unit_spawn_commands[0]) == 4\n        assert isinstance(unit_spawn_commands[0][0], UnitTypeId)\n        assert unit_spawn_commands[0][1] > 0  # careful, in realtime=True this function may create more units\n        assert isinstance(unit_spawn_commands[0][2], (Point2, Point3))\n        assert 1 <= unit_spawn_commands[0][3] <= 2\n\n        await self._execute(\n            debug=sc_pb.RequestDebug(\n                debug=(\n                    debug_pb.DebugCommand(\n                        create_unit=debug_pb.DebugCreateUnit(\n                            unit_type=unit_type.value,\n                            owner=owner_id,\n                            pos=position.as_Point2D,\n                            quantity=amount_of_units,\n                        )\n                    ) for unit_type, amount_of_units, position, owner_id in unit_spawn_commands\n                )\n            )\n        )\n\n    async def debug_kill_unit(self, unit_tags: Union[Unit, Units, List[int], Set[int]]):\n        \"\"\"\n        :param unit_tags:\n        \"\"\"\n        if isinstance(unit_tags, Units):\n            unit_tags = unit_tags.tags\n        if isinstance(unit_tags, Unit):\n            unit_tags = [unit_tags.tag]\n        assert unit_tags\n\n        await self._execute(\n            debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(kill_unit=debug_pb.DebugKillUnit(tag=unit_tags))])\n        )\n\n    async def move_camera(self, position: Union[Unit, Units, Point2, Point3]):\n        \"\"\"Moves camera to the target position\n\n        :param position:\"\"\"\n        assert isinstance(position, (Unit, Units, Point2, Point3))\n        if isinstance(position, Units):\n            position = position.center\n        if isinstance(position, Unit):\n            position = position.position\n        await self._execute(\n            action=sc_pb.RequestAction(\n                actions=[\n                    sc_pb.Action(\n                        action_raw=raw_pb.ActionRaw(\n                            camera_move=raw_pb.ActionRawCameraMove(center_world_space=position.to3.as_Point)\n                        )\n                    )\n                ]\n            )\n        )\n\n    async def obs_move_camera(self, position: Union[Unit, Units, Point2, Point3]):\n        \"\"\"Moves observer camera to the target position. Only works when observing (e.g. watching the replay).\n\n        :param position:\"\"\"\n        assert isinstance(position, (Unit, Units, Point2, Point3))\n        if isinstance(position, Units):\n            position = position.center\n        if isinstance(position, Unit):\n            position = position.position\n        await self._execute(\n            obs_action=sc_pb.RequestObserverAction(\n                actions=[\n                    sc_pb.ObserverAction(camera_move=sc_pb.ActionObserverCameraMove(world_pos=position.as_Point2D))\n                ]\n            )\n        )\n\n    async def move_camera_spatial(self, position: Union[Point2, Point3]):\n        \"\"\"Moves camera to the target position using the spatial aciton interface\n\n        :param position:\"\"\"\n        from s2clientprotocol import spatial_pb2 as spatial_pb\n\n        assert isinstance(position, (Point2, Point3))\n        action = sc_pb.Action(\n            action_render=spatial_pb.ActionSpatial(\n                camera_move=spatial_pb.ActionSpatialCameraMove(center_minimap=position.as_PointI)\n            )\n        )\n        await self._execute(action=sc_pb.RequestAction(actions=[action]))\n\n    def debug_text_simple(self, text: str):\n        \"\"\" Draws a text in the top left corner of the screen (up to a max of 6 messages fit there). \"\"\"\n        self._debug_texts.append(DrawItemScreenText(text=text, color=None, start_point=Point2((0, 0)), font_size=8))\n\n    def debug_text_screen(\n        self,\n        text: str,\n        pos: Union[Point2, Point3, tuple, list],\n        color: Union[tuple, list, Point3] = None,\n        size: int = 8,\n    ):\n        \"\"\"\n        Draws a text on the screen (monitor / game window) with coordinates 0 <= x, y <= 1.\n\n        :param text:\n        :param pos:\n        :param color:\n        :param size:\n        \"\"\"\n        assert len(pos) >= 2\n        assert 0 <= pos[0] <= 1\n        assert 0 <= pos[1] <= 1\n        pos = Point2((pos[0], pos[1]))\n        self._debug_texts.append(DrawItemScreenText(text=text, color=color, start_point=pos, font_size=size))\n\n    def debug_text_2d(\n        self,\n        text: str,\n        pos: Union[Point2, Point3, tuple, list],\n        color: Union[tuple, list, Point3] = None,\n        size: int = 8,\n    ):\n        return self.debug_text_screen(text, pos, color, size)\n\n    def debug_text_world(\n        self, text: str, pos: Union[Unit, Point3], color: Union[tuple, list, Point3] = None, size: int = 8\n    ):\n        \"\"\"\n        Draws a text at Point3 position in the game world.\n        To grab a unit's 3d position, use unit.position3d\n        Usually the Z value of a Point3 is between 8 and 14 (except for flying units). Use self.get_terrain_z_height() from bot_ai.py to get the Z value (height) of the terrain at a 2D position.\n\n        :param text:\n        :param color:\n        :param size:\n        \"\"\"\n        if isinstance(pos, Unit):\n            pos = pos.position3d\n        assert isinstance(pos, Point3)\n        self._debug_texts.append(DrawItemWorldText(text=text, color=color, start_point=pos, font_size=size))\n\n    def debug_text_3d(\n        self, text: str, pos: Union[Unit, Point3], color: Union[tuple, list, Point3] = None, size: int = 8\n    ):\n        return self.debug_text_world(text, pos, color, size)\n\n    def debug_line_out(\n        self, p0: Union[Unit, Point3], p1: Union[Unit, Point3], color: Union[tuple, list, Point3] = None\n    ):\n        \"\"\"\n        Draws a line from p0 to p1.\n\n        :param p0:\n        :param p1:\n        :param color:\n        \"\"\"\n        if isinstance(p0, Unit):\n            p0 = p0.position3d\n        assert isinstance(p0, Point3)\n        if isinstance(p1, Unit):\n            p1 = p1.position3d\n        assert isinstance(p1, Point3)\n        self._debug_lines.append(DrawItemLine(color=color, start_point=p0, end_point=p1))\n\n    def debug_box_out(\n        self,\n        p_min: Union[Unit, Point3],\n        p_max: Union[Unit, Point3],\n        color: Union[tuple, list, Point3] = None,\n    ):\n        \"\"\"\n        Draws a box with p_min and p_max as corners of the box.\n\n        :param p_min:\n        :param p_max:\n        :param color:\n        \"\"\"\n        if isinstance(p_min, Unit):\n            p_min = p_min.position3d\n        assert isinstance(p_min, Point3)\n        if isinstance(p_max, Unit):\n            p_max = p_max.position3d\n        assert isinstance(p_max, Point3)\n        self._debug_boxes.append(DrawItemBox(start_point=p_min, end_point=p_max, color=color))\n\n    def debug_box2_out(\n        self,\n        pos: Union[Unit, Point3],\n        half_vertex_length: float = 0.25,\n        color: Union[tuple, list, Point3] = None,\n    ):\n        \"\"\"\n        Draws a box center at a position 'pos', with box side lengths (vertices) of two times 'half_vertex_length'.\n\n        :param pos:\n        :param half_vertex_length:\n        :param color:\n        \"\"\"\n        if isinstance(pos, Unit):\n            pos = pos.position3d\n        assert isinstance(pos, Point3)\n        p0 = pos + Point3((-half_vertex_length, -half_vertex_length, -half_vertex_length))\n        p1 = pos + Point3((half_vertex_length, half_vertex_length, half_vertex_length))\n        self._debug_boxes.append(DrawItemBox(start_point=p0, end_point=p1, color=color))\n\n    def debug_sphere_out(self, p: Union[Unit, Point3], r: float, color: Union[tuple, list, Point3] = None):\n        \"\"\"\n        Draws a sphere at point p with radius r.\n\n        :param p:\n        :param r:\n        :param color:\n        \"\"\"\n        if isinstance(p, Unit):\n            p = p.position3d\n        assert isinstance(p, Point3)\n        self._debug_spheres.append(DrawItemSphere(start_point=p, radius=r, color=color))\n\n    async def _send_debug(self):\n        \"\"\"Sends the debug draw execution. This is run by main.py now automatically, if there is any items in the list. You do not need to run this manually any longer.\n        Check examples/terran/ramp_wall.py for example drawing. Each draw request needs to be sent again in every single on_step iteration.\n        \"\"\"\n        debug_hash = (\n            sum(hash(item) for item in self._debug_texts),\n            sum(hash(item) for item in self._debug_lines),\n            sum(hash(item) for item in self._debug_boxes),\n            sum(hash(item) for item in self._debug_spheres),\n        )\n        if debug_hash != (0, 0, 0, 0):\n            if debug_hash != self._debug_hash_tuple_last_iteration:\n                # Something has changed, either more or less is to be drawn, or a position of a drawing changed (e.g. when drawing on a moving unit)\n                self._debug_hash_tuple_last_iteration = debug_hash\n                await self._execute(\n                    debug=sc_pb.RequestDebug(\n                        debug=[\n                            debug_pb.DebugCommand(\n                                draw=debug_pb.DebugDraw(\n                                    text=[text.to_proto() for text in self._debug_texts] if self._debug_texts else None,\n                                    lines=[line.to_proto()\n                                           for line in self._debug_lines] if self._debug_lines else None,\n                                    boxes=[box.to_proto() for box in self._debug_boxes] if self._debug_boxes else None,\n                                    spheres=[sphere.to_proto()\n                                             for sphere in self._debug_spheres] if self._debug_spheres else None,\n                                )\n                            )\n                        ]\n                    )\n                )\n            self._debug_draw_last_frame = True\n            self._debug_texts.clear()\n            self._debug_lines.clear()\n            self._debug_boxes.clear()\n            self._debug_spheres.clear()\n        elif self._debug_draw_last_frame:\n            # Clear drawing if we drew last frame but nothing to draw this frame\n            self._debug_hash_tuple_last_iteration = (0, 0, 0, 0)\n            await self._execute(\n                debug=sc_pb.RequestDebug(\n                    debug=[\n                        debug_pb.DebugCommand(draw=debug_pb.DebugDraw(text=None, lines=None, boxes=None, spheres=None))\n                    ]\n                )\n            )\n            self._debug_draw_last_frame = False\n\n    async def debug_leave(self):\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(end_game=debug_pb.DebugEndGame())]))\n\n    async def debug_set_unit_value(self, unit_tags: Union[Iterable[int], Units, Unit], unit_value: int, value: float):\n        \"\"\"Sets a \"unit value\" (Energy, Life or Shields) of the given units to the given value.\n        Can't set the life of a unit to 0, use \"debug_kill_unit\" for that. Also can't set the life above the unit's maximum.\n        The following example sets the health of all your workers to 1:\n        await self.debug_set_unit_value(self.workers, 2, value=1)\"\"\"\n        if isinstance(unit_tags, Units):\n            unit_tags = unit_tags.tags\n        if isinstance(unit_tags, Unit):\n            unit_tags = [unit_tags.tag]\n        assert hasattr(\n            unit_tags, \"__iter__\"\n        ), f\"unit_tags argument needs to be an iterable (list, dict, set, Units), given argument is {type(unit_tags).__name__}\"\n        assert (\n            1 <= unit_value <= 3\n        ), f\"unit_value needs to be between 1 and 3 (1 for energy, 2 for life, 3 for shields), given argument is {unit_value}\"\n        assert all(tag > 0 for tag in unit_tags), f\"Unit tags have invalid value: {unit_tags}\"\n        assert isinstance(value, (int, float)), \"Value needs to be of type int or float\"\n        assert value >= 0, \"Value can't be negative\"\n        await self._execute(\n            debug=sc_pb.RequestDebug(\n                debug=(\n                    debug_pb.DebugCommand(\n                        unit_value=debug_pb.\n                        DebugSetUnitValue(unit_value=unit_value, value=float(value), unit_tag=unit_tag)\n                    ) for unit_tag in unit_tags\n                )\n            )\n        )\n\n    async def debug_hang(self, delay_in_seconds: float):\n        \"\"\" Freezes the SC2 client. Not recommended to be used. \"\"\"\n        delay_in_ms = int(round(delay_in_seconds * 1000))\n        await self._execute(\n            debug=sc_pb.RequestDebug(\n                debug=[debug_pb.DebugCommand(test_process=debug_pb.DebugTestProcess(test=1, delay_ms=delay_in_ms))]\n            )\n        )\n\n    async def debug_show_map(self):\n        \"\"\" Reveals the whole map for the bot. Using it a second time disables it again. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=1)]))\n\n    async def debug_control_enemy(self):\n        \"\"\" Allows control over enemy units and structures similar to team games control - does not allow the bot to spend the opponent's ressources. Using it a second time disables it again.  \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=2)]))\n\n    async def debug_food(self):\n        \"\"\" Should disable food usage (does not seem to work?). Using it a second time disables it again.  \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=3)]))\n\n    async def debug_free(self):\n        \"\"\" Units, structures and upgrades are free of mineral and gas cost. Using it a second time disables it again.  \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=4)]))\n\n    async def debug_all_resources(self):\n        \"\"\" Gives 5000 minerals and 5000 vespene to the bot. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=5)]))\n\n    async def debug_god(self):\n        \"\"\" Your units and structures no longer take any damage. Using it a second time disables it again. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=6)]))\n\n    async def debug_minerals(self):\n        \"\"\" Gives 5000 minerals to the bot. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=7)]))\n\n    async def debug_gas(self):\n        \"\"\" Gives 5000 vespene to the bot. This does not seem to be working. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=8)]))\n\n    async def debug_cooldown(self):\n        \"\"\" Disables cooldowns of unit abilities for the bot. Using it a second time disables it again. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=9)]))\n\n    async def debug_tech_tree(self):\n        \"\"\" Removes all tech requirements (e.g. can build a factory without having a barracks). Using it a second time disables it again. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=10)]))\n\n    async def debug_upgrade(self):\n        \"\"\" Researches all currently available upgrades. E.g. using it once unlocks combat shield, stimpack and 1-1. Using it a second time unlocks 2-2 and all other upgrades stay researched. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=11)]))\n\n    async def debug_fast_build(self):\n        \"\"\" Sets the build time of units and structures and upgrades to zero. Using it a second time disables it again. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=12)]))\n\n    async def quick_save(self):\n        \"\"\"Saves the current game state to an in-memory bookmark.\n        See: https://github.com/Blizzard/s2client-proto/blob/eeaf5efaea2259d7b70247211dff98da0a2685a2/s2clientprotocol/sc2api.proto#L93\"\"\"\n        await self._execute(quick_save=sc_pb.RequestQuickSave())\n\n    async def quick_load(self):\n        \"\"\"Loads the game state from the previously stored in-memory bookmark.\n        Caution:\n            - The SC2 Client will crash if the game wasn't quicksaved\n            - The bot step iteration counter will not reset\n            - self.state.game_loop will be set to zero after the quickload, and self.time is dependant on it\"\"\"\n        await self._execute(quick_load=sc_pb.RequestQuickLoad())",
  "class DrawItem:\n\n    @staticmethod\n    def to_debug_color(color: Union[tuple, Point3]):\n        \"\"\" Helper function for color conversion \"\"\"\n        if color is None:\n            return debug_pb.Color(r=255, g=255, b=255)\n        # Need to check if not of type Point3 because Point3 inherits from tuple\n        elif isinstance(color, (tuple, list)) and not isinstance(color, Point3) and len(color) == 3:\n            return debug_pb.Color(r=color[0], g=color[1], b=color[2])\n        # In case color is of type Point3\n        else:\n            r = getattr(color, \"r\", getattr(color, \"x\", 255))\n            g = getattr(color, \"g\", getattr(color, \"y\", 255))\n            b = getattr(color, \"b\", getattr(color, \"z\", 255))\n            if max(r, g, b) <= 1:\n                r *= 255\n                g *= 255\n                b *= 255\n\n            return debug_pb.Color(r=int(r), g=int(g), b=int(b))",
  "class DrawItemScreenText(DrawItem):\n\n    def __init__(self, start_point: Point2 = None, color: Point3 = None, text: str = \"\", font_size: int = 8):\n        self._start_point: Point2 = start_point\n        self._color: Point3 = color\n        self._text: str = text\n        self._font_size: int = font_size\n\n    def to_proto(self):\n        return debug_pb.DebugText(\n            color=self.to_debug_color(self._color),\n            text=self._text,\n            virtual_pos=self._start_point.to3.as_Point,\n            world_pos=None,\n            size=self._font_size,\n        )\n\n    def __hash__(self):\n        return hash((self._start_point, self._color, self._text, self._font_size))",
  "class DrawItemWorldText(DrawItem):\n\n    def __init__(self, start_point: Point3 = None, color: Point3 = None, text: str = \"\", font_size: int = 8):\n        self._start_point: Point3 = start_point\n        self._color: Point3 = color\n        self._text: str = text\n        self._font_size: int = font_size\n\n    def to_proto(self):\n        return debug_pb.DebugText(\n            color=self.to_debug_color(self._color),\n            text=self._text,\n            virtual_pos=None,\n            world_pos=self._start_point.as_Point,\n            size=self._font_size,\n        )\n\n    def __hash__(self):\n        return hash((self._start_point, self._text, self._font_size, self._color))",
  "class DrawItemLine(DrawItem):\n\n    def __init__(self, start_point: Point3 = None, end_point: Point3 = None, color: Point3 = None):\n        self._start_point: Point3 = start_point\n        self._end_point: Point3 = end_point\n        self._color: Point3 = color\n\n    def to_proto(self):\n        return debug_pb.DebugLine(\n            line=debug_pb.Line(p0=self._start_point.as_Point, p1=self._end_point.as_Point),\n            color=self.to_debug_color(self._color),\n        )\n\n    def __hash__(self):\n        return hash((self._start_point, self._end_point, self._color))",
  "class DrawItemBox(DrawItem):\n\n    def __init__(self, start_point: Point3 = None, end_point: Point3 = None, color: Point3 = None):\n        self._start_point: Point3 = start_point\n        self._end_point: Point3 = end_point\n        self._color: Point3 = color\n\n    def to_proto(self):\n        return debug_pb.DebugBox(\n            min=self._start_point.as_Point,\n            max=self._end_point.as_Point,\n            color=self.to_debug_color(self._color),\n        )\n\n    def __hash__(self):\n        return hash((self._start_point, self._end_point, self._color))",
  "class DrawItemSphere(DrawItem):\n\n    def __init__(self, start_point: Point3 = None, radius: float = None, color: Point3 = None):\n        self._start_point: Point3 = start_point\n        self._radius: float = radius\n        self._color: Point3 = color\n\n    def to_proto(self):\n        return debug_pb.DebugSphere(\n            p=self._start_point.as_Point, r=self._radius, color=self.to_debug_color(self._color)\n        )\n\n    def __hash__(self):\n        return hash((self._start_point, self._radius, self._color))",
  "def __init__(self, ws):\n        \"\"\"\n        :param ws:\n        \"\"\"\n        super().__init__(ws)\n        # How many frames will be waited between iterations before the next one is called\n        self.game_step: int = 8\n        self._player_id = None\n        self._game_result = None\n        # Store a hash value of all the debug requests to prevent sending the same ones again if they haven't changed last frame\n        self._debug_hash_tuple_last_iteration: Tuple[int, int, int, int] = (0, 0, 0, 0)\n        self._debug_draw_last_frame = False\n        self._debug_texts = []\n        self._debug_lines = []\n        self._debug_boxes = []\n        self._debug_spheres = []\n\n        self._renderer = None\n        self.raw_affects_selection = False",
  "def in_game(self):\n        return self._status in {Status.in_game, Status.in_replay}",
  "async def join_game(self, name=None, race=None, observed_player_id=None, portconfig=None, rgb_render_config=None):\n        ifopts = sc_pb.InterfaceOptions(\n            raw=True,\n            score=True,\n            show_cloaked=True,\n            show_burrowed_shadows=True,\n            raw_affects_selection=self.raw_affects_selection,\n            raw_crop_to_playable_area=False,\n            show_placeholders=True,\n        )\n\n        if rgb_render_config:\n            assert isinstance(rgb_render_config, dict)\n            assert \"window_size\" in rgb_render_config and \"minimap_size\" in rgb_render_config\n            window_size = rgb_render_config[\"window_size\"]\n            minimap_size = rgb_render_config[\"minimap_size\"]\n            self._renderer = Renderer(self, window_size, minimap_size)\n            map_width, map_height = window_size\n            minimap_width, minimap_height = minimap_size\n\n            ifopts.render.resolution.x = map_width\n            ifopts.render.resolution.y = map_height\n            ifopts.render.minimap_resolution.x = minimap_width\n            ifopts.render.minimap_resolution.y = minimap_height\n\n        if race is None:\n            assert isinstance(observed_player_id, int), f\"observed_player_id is of type {type(observed_player_id)}\"\n            # join as observer\n            req = sc_pb.RequestJoinGame(observed_player_id=observed_player_id, options=ifopts)\n        else:\n            assert isinstance(race, Race)\n            req = sc_pb.RequestJoinGame(race=race.value, options=ifopts)\n\n        if portconfig:\n            req.server_ports.game_port = portconfig.server[0]\n            req.server_ports.base_port = portconfig.server[1]\n\n            for ppc in portconfig.players:\n                p = req.client_ports.add()\n                p.game_port = ppc[0]\n                p.base_port = ppc[1]\n\n        if name is not None:\n            assert isinstance(name, str), f\"name is of type {type(name)}\"\n            req.player_name = name\n\n        result = await self._execute(join_game=req)\n        self._game_result = None\n        self._player_id = result.join_game.player_id\n        return result.join_game.player_id",
  "async def leave(self):\n        \"\"\" You can use 'await self._client.leave()' to surrender midst game. \"\"\"\n        is_resign = self._game_result is None\n\n        if is_resign:\n            # For all clients that can leave, result of leaving the game either\n            # loss, or the client will ignore the result\n            self._game_result = {self._player_id: Result.Defeat}\n\n        try:\n            await self._execute(leave_game=sc_pb.RequestLeaveGame())\n        except ProtocolError:\n            if is_resign:\n                raise",
  "async def save_replay(self, path):\n        logger.debug(f\"Requesting replay from server\")\n        result = await self._execute(save_replay=sc_pb.RequestSaveReplay())\n        with open(path, \"wb\") as f:\n            f.write(result.save_replay.data)\n        logger.info(f\"Saved replay to {path}\")",
  "async def observation(self, game_loop=None):\n        if game_loop is not None:\n            result = await self._execute(observation=sc_pb.RequestObservation(game_loop=game_loop))\n        else:\n            result = await self._execute(observation=sc_pb.RequestObservation())\n        assert result.HasField(\"observation\")\n\n        if not self.in_game or result.observation.player_result:\n            # Sometimes game ends one step before results are available\n            if not result.observation.player_result:\n                result = await self._execute(observation=sc_pb.RequestObservation())\n                assert result.observation.player_result\n\n            player_id_to_result = {}\n            for pr in result.observation.player_result:\n                player_id_to_result[pr.player_id] = Result(pr.result)\n            self._game_result = player_id_to_result\n\n        # if render_data is available, then RGB rendering was requested\n        if self._renderer and result.observation.observation.HasField(\"render_data\"):\n            await self._renderer.render(result.observation)\n\n        return result",
  "async def step(self, step_size: int = None):\n        \"\"\" EXPERIMENTAL: Change self._client.game_step during the step function to increase or decrease steps per second \"\"\"\n        step_size = step_size or self.game_step\n        return await self._execute(step=sc_pb.RequestStep(count=step_size))",
  "async def get_game_data(self) -> GameData:\n        result = await self._execute(\n            data=sc_pb.RequestData(ability_id=True, unit_type_id=True, upgrade_id=True, buff_id=True, effect_id=True)\n        )\n        return GameData(result.data)",
  "async def dump_data(self, ability_id=True, unit_type_id=True, upgrade_id=True, buff_id=True, effect_id=True):\n        \"\"\"\n        Dump the game data files\n        choose what data to dump in the keywords\n        this function writes to a text file\n        call it one time in on_step with:\n        await self._client.dump_data()\n        \"\"\"\n        result = await self._execute(\n            data=sc_pb.RequestData(\n                ability_id=ability_id,\n                unit_type_id=unit_type_id,\n                upgrade_id=upgrade_id,\n                buff_id=buff_id,\n                effect_id=effect_id,\n            )\n        )\n        with open(\"data_dump.txt\", \"a\") as file:\n            file.write(str(result.data))",
  "async def get_game_info(self) -> GameInfo:\n        result = await self._execute(game_info=sc_pb.RequestGameInfo())\n        return GameInfo(result.game_info)",
  "async def actions(self, actions, return_successes=False):\n        if not actions:\n            return None\n        elif not isinstance(actions, list):\n            actions = [actions]\n\n        # On realtime=True, might get an error here: sc2.protocol.ProtocolError: ['Not in a game']\n        try:\n            res = await self._execute(\n                action=sc_pb.RequestAction(actions=(sc_pb.Action(action_raw=a) for a in combine_actions(actions)))\n            )\n        except ProtocolError as e:\n            return []\n        if return_successes:\n            return [ActionResult(r) for r in res.action.result]\n        else:\n            return [ActionResult(r) for r in res.action.result if ActionResult(r) != ActionResult.Success]",
  "async def query_pathing(self, start: Union[Unit, Point2, Point3],\n                            end: Union[Point2, Point3]) -> Optional[Union[int, float]]:\n        \"\"\"Caution: returns \"None\" when path not found\n        Try to combine queries with the function below because the pathing query is generally slow.\n\n        :param start:\n        :param end:\"\"\"\n        assert isinstance(start, (Point2, Unit))\n        assert isinstance(end, Point2)\n        if isinstance(start, Point2):\n            path = [query_pb.RequestQueryPathing(start_pos=start.as_Point2D, end_pos=end.as_Point2D)]\n        else:\n            path = [query_pb.RequestQueryPathing(unit_tag=start.tag, end_pos=end.as_Point2D)]\n        result = await self._execute(query=query_pb.RequestQuery(pathing=path))\n        distance = float(result.query.pathing[0].distance)\n        if distance <= 0.0:\n            return None\n        return distance",
  "async def query_pathings(self, zipped_list: List[List[Union[Unit, Point2, Point3]]]) -> List[Union[float, int]]:\n        \"\"\"Usage: await self.query_pathings([[unit1, target2], [unit2, target2]])\n        -> returns [distance1, distance2]\n        Caution: returns 0 when path not found\n\n        :param zipped_list:\n        \"\"\"\n        assert zipped_list, \"No zipped_list\"\n        assert isinstance(zipped_list, list), f\"{type(zipped_list)}\"\n        assert isinstance(zipped_list[0], list), f\"{type(zipped_list[0])}\"\n        assert len(zipped_list[0]) == 2, f\"{len(zipped_list[0])}\"\n        assert isinstance(zipped_list[0][0], (Point2, Unit)), f\"{type(zipped_list[0][0])}\"\n        assert isinstance(zipped_list[0][1], Point2), f\"{type(zipped_list[0][1])}\"\n        if isinstance(zipped_list[0][0], Point2):\n            path = (\n                query_pb.RequestQueryPathing(start_pos=p1.as_Point2D, end_pos=p2.as_Point2D) for p1, p2 in zipped_list\n            )\n        else:\n            path = (query_pb.RequestQueryPathing(unit_tag=p1.tag, end_pos=p2.as_Point2D) for p1, p2 in zipped_list)\n        results = await self._execute(query=query_pb.RequestQuery(pathing=path))\n        return [float(d.distance) for d in results.query.pathing]",
  "async def _query_building_placement_fast(\n        self, ability: AbilityId, positions: List[Union[Point2, Point3]], ignore_resources: bool = True\n    ) -> List[bool]:\n        \"\"\"\n        Returns a list of booleans. Return True for positions that are valid, False otherwise.\n\n        :param ability:\n        :param positions:\n        :param ignore_resources:\n        \"\"\"\n        result = await self._execute(\n            query=query_pb.RequestQuery(\n                placements=(\n                    query_pb.RequestQueryBuildingPlacement(ability_id=ability.value, target_pos=position.as_Point2D)\n                    for position in positions\n                ),\n                ignore_resource_requirements=ignore_resources,\n            )\n        )\n        # Success enum value is 1, see https://github.com/Blizzard/s2client-proto/blob/9906df71d6909511907d8419b33acc1a3bd51ec0/s2clientprotocol/error.proto#L7\n        return [p.result == 1 for p in result.query.placements]",
  "async def query_building_placement(\n        self,\n        ability: AbilityData,\n        positions: List[Union[Point2, Point3]],\n        ignore_resources: bool = True\n    ) -> List[ActionResult]:\n        \"\"\"This function might be deleted in favor of the function above (_query_building_placement_fast).\n\n        :param ability:\n        :param positions:\n        :param ignore_resources:\"\"\"\n        assert isinstance(ability, AbilityData)\n        result = await self._execute(\n            query=query_pb.RequestQuery(\n                placements=(\n                    query_pb.RequestQueryBuildingPlacement(ability_id=ability.id.value, target_pos=position.as_Point2D)\n                    for position in positions\n                ),\n                ignore_resource_requirements=ignore_resources,\n            )\n        )\n        # Unnecessary converting to ActionResult?\n        return [ActionResult(p.result) for p in result.query.placements]",
  "async def query_available_abilities(\n        self, units: Union[List[Unit], Units], ignore_resource_requirements: bool = False\n    ) -> List[List[AbilityId]]:\n        \"\"\" Query abilities of multiple units \"\"\"\n        input_was_a_list = True\n        if not isinstance(units, list):\n            \"\"\" Deprecated, accepting a single unit may be removed in the future, query a list of units instead \"\"\"\n            assert isinstance(units, Unit)\n            units = [units]\n            input_was_a_list = False\n        assert units\n        result = await self._execute(\n            query=query_pb.RequestQuery(\n                abilities=(query_pb.RequestQueryAvailableAbilities(unit_tag=unit.tag) for unit in units),\n                ignore_resource_requirements=ignore_resource_requirements,\n            )\n        )\n        \"\"\" Fix for bots that only query a single unit, may be removed soon \"\"\"\n        if not input_was_a_list:\n            return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities][0]\n        return [[AbilityId(a.ability_id) for a in b.abilities] for b in result.query.abilities]",
  "async def query_available_abilities_with_tag(\n        self, units: Union[List[Unit], Units], ignore_resource_requirements: bool = False\n    ) -> Dict[int, Set[AbilityId]]:\n        \"\"\" Query abilities of multiple units \"\"\"\n\n        result = await self._execute(\n            query=query_pb.RequestQuery(\n                abilities=(query_pb.RequestQueryAvailableAbilities(unit_tag=unit.tag) for unit in units),\n                ignore_resource_requirements=ignore_resource_requirements,\n            )\n        )\n        return {b.unit_tag: {AbilityId(a.ability_id) for a in b.abilities} for b in result.query.abilities}",
  "async def chat_send(self, message: str, team_only: bool):\n        \"\"\" Writes a message to the chat \"\"\"\n        ch = ChatChannel.Team if team_only else ChatChannel.Broadcast\n        await self._execute(\n            action=sc_pb.RequestAction(\n                actions=[sc_pb.Action(action_chat=sc_pb.ActionChat(channel=ch.value, message=message))]\n            )\n        )",
  "async def toggle_autocast(self, units: Union[List[Unit], Units], ability: AbilityId):\n        \"\"\"Toggle autocast of all specified units\n\n        :param units:\n        :param ability:\"\"\"\n        assert units\n        assert isinstance(units, list)\n        assert all(isinstance(u, Unit) for u in units)\n        assert isinstance(ability, AbilityId)\n\n        await self._execute(\n            action=sc_pb.RequestAction(\n                actions=[\n                    sc_pb.Action(\n                        action_raw=raw_pb.ActionRaw(\n                            toggle_autocast=raw_pb.\n                            ActionRawToggleAutocast(ability_id=ability.value, unit_tags=(u.tag for u in units))\n                        )\n                    )\n                ]\n            )\n        )",
  "async def debug_create_unit(self, unit_spawn_commands: List[List[Union[UnitTypeId, int, Point2, Point3]]]):\n        \"\"\"Usage example (will spawn 5 marines in the center of the map for player ID 1):\n        await self._client.debug_create_unit([[UnitTypeId.MARINE, 5, self._game_info.map_center, 1]])\n\n        :param unit_spawn_commands:\"\"\"\n        assert isinstance(unit_spawn_commands, list)\n        assert unit_spawn_commands\n        assert isinstance(unit_spawn_commands[0], list)\n        assert len(unit_spawn_commands[0]) == 4\n        assert isinstance(unit_spawn_commands[0][0], UnitTypeId)\n        assert unit_spawn_commands[0][1] > 0  # careful, in realtime=True this function may create more units\n        assert isinstance(unit_spawn_commands[0][2], (Point2, Point3))\n        assert 1 <= unit_spawn_commands[0][3] <= 2\n\n        await self._execute(\n            debug=sc_pb.RequestDebug(\n                debug=(\n                    debug_pb.DebugCommand(\n                        create_unit=debug_pb.DebugCreateUnit(\n                            unit_type=unit_type.value,\n                            owner=owner_id,\n                            pos=position.as_Point2D,\n                            quantity=amount_of_units,\n                        )\n                    ) for unit_type, amount_of_units, position, owner_id in unit_spawn_commands\n                )\n            )\n        )",
  "async def debug_kill_unit(self, unit_tags: Union[Unit, Units, List[int], Set[int]]):\n        \"\"\"\n        :param unit_tags:\n        \"\"\"\n        if isinstance(unit_tags, Units):\n            unit_tags = unit_tags.tags\n        if isinstance(unit_tags, Unit):\n            unit_tags = [unit_tags.tag]\n        assert unit_tags\n\n        await self._execute(\n            debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(kill_unit=debug_pb.DebugKillUnit(tag=unit_tags))])\n        )",
  "async def move_camera(self, position: Union[Unit, Units, Point2, Point3]):\n        \"\"\"Moves camera to the target position\n\n        :param position:\"\"\"\n        assert isinstance(position, (Unit, Units, Point2, Point3))\n        if isinstance(position, Units):\n            position = position.center\n        if isinstance(position, Unit):\n            position = position.position\n        await self._execute(\n            action=sc_pb.RequestAction(\n                actions=[\n                    sc_pb.Action(\n                        action_raw=raw_pb.ActionRaw(\n                            camera_move=raw_pb.ActionRawCameraMove(center_world_space=position.to3.as_Point)\n                        )\n                    )\n                ]\n            )\n        )",
  "async def obs_move_camera(self, position: Union[Unit, Units, Point2, Point3]):\n        \"\"\"Moves observer camera to the target position. Only works when observing (e.g. watching the replay).\n\n        :param position:\"\"\"\n        assert isinstance(position, (Unit, Units, Point2, Point3))\n        if isinstance(position, Units):\n            position = position.center\n        if isinstance(position, Unit):\n            position = position.position\n        await self._execute(\n            obs_action=sc_pb.RequestObserverAction(\n                actions=[\n                    sc_pb.ObserverAction(camera_move=sc_pb.ActionObserverCameraMove(world_pos=position.as_Point2D))\n                ]\n            )\n        )",
  "async def move_camera_spatial(self, position: Union[Point2, Point3]):\n        \"\"\"Moves camera to the target position using the spatial aciton interface\n\n        :param position:\"\"\"\n        from s2clientprotocol import spatial_pb2 as spatial_pb\n\n        assert isinstance(position, (Point2, Point3))\n        action = sc_pb.Action(\n            action_render=spatial_pb.ActionSpatial(\n                camera_move=spatial_pb.ActionSpatialCameraMove(center_minimap=position.as_PointI)\n            )\n        )\n        await self._execute(action=sc_pb.RequestAction(actions=[action]))",
  "def debug_text_simple(self, text: str):\n        \"\"\" Draws a text in the top left corner of the screen (up to a max of 6 messages fit there). \"\"\"\n        self._debug_texts.append(DrawItemScreenText(text=text, color=None, start_point=Point2((0, 0)), font_size=8))",
  "def debug_text_screen(\n        self,\n        text: str,\n        pos: Union[Point2, Point3, tuple, list],\n        color: Union[tuple, list, Point3] = None,\n        size: int = 8,\n    ):\n        \"\"\"\n        Draws a text on the screen (monitor / game window) with coordinates 0 <= x, y <= 1.\n\n        :param text:\n        :param pos:\n        :param color:\n        :param size:\n        \"\"\"\n        assert len(pos) >= 2\n        assert 0 <= pos[0] <= 1\n        assert 0 <= pos[1] <= 1\n        pos = Point2((pos[0], pos[1]))\n        self._debug_texts.append(DrawItemScreenText(text=text, color=color, start_point=pos, font_size=size))",
  "def debug_text_2d(\n        self,\n        text: str,\n        pos: Union[Point2, Point3, tuple, list],\n        color: Union[tuple, list, Point3] = None,\n        size: int = 8,\n    ):\n        return self.debug_text_screen(text, pos, color, size)",
  "def debug_text_world(\n        self, text: str, pos: Union[Unit, Point3], color: Union[tuple, list, Point3] = None, size: int = 8\n    ):\n        \"\"\"\n        Draws a text at Point3 position in the game world.\n        To grab a unit's 3d position, use unit.position3d\n        Usually the Z value of a Point3 is between 8 and 14 (except for flying units). Use self.get_terrain_z_height() from bot_ai.py to get the Z value (height) of the terrain at a 2D position.\n\n        :param text:\n        :param color:\n        :param size:\n        \"\"\"\n        if isinstance(pos, Unit):\n            pos = pos.position3d\n        assert isinstance(pos, Point3)\n        self._debug_texts.append(DrawItemWorldText(text=text, color=color, start_point=pos, font_size=size))",
  "def debug_text_3d(\n        self, text: str, pos: Union[Unit, Point3], color: Union[tuple, list, Point3] = None, size: int = 8\n    ):\n        return self.debug_text_world(text, pos, color, size)",
  "def debug_line_out(\n        self, p0: Union[Unit, Point3], p1: Union[Unit, Point3], color: Union[tuple, list, Point3] = None\n    ):\n        \"\"\"\n        Draws a line from p0 to p1.\n\n        :param p0:\n        :param p1:\n        :param color:\n        \"\"\"\n        if isinstance(p0, Unit):\n            p0 = p0.position3d\n        assert isinstance(p0, Point3)\n        if isinstance(p1, Unit):\n            p1 = p1.position3d\n        assert isinstance(p1, Point3)\n        self._debug_lines.append(DrawItemLine(color=color, start_point=p0, end_point=p1))",
  "def debug_box_out(\n        self,\n        p_min: Union[Unit, Point3],\n        p_max: Union[Unit, Point3],\n        color: Union[tuple, list, Point3] = None,\n    ):\n        \"\"\"\n        Draws a box with p_min and p_max as corners of the box.\n\n        :param p_min:\n        :param p_max:\n        :param color:\n        \"\"\"\n        if isinstance(p_min, Unit):\n            p_min = p_min.position3d\n        assert isinstance(p_min, Point3)\n        if isinstance(p_max, Unit):\n            p_max = p_max.position3d\n        assert isinstance(p_max, Point3)\n        self._debug_boxes.append(DrawItemBox(start_point=p_min, end_point=p_max, color=color))",
  "def debug_box2_out(\n        self,\n        pos: Union[Unit, Point3],\n        half_vertex_length: float = 0.25,\n        color: Union[tuple, list, Point3] = None,\n    ):\n        \"\"\"\n        Draws a box center at a position 'pos', with box side lengths (vertices) of two times 'half_vertex_length'.\n\n        :param pos:\n        :param half_vertex_length:\n        :param color:\n        \"\"\"\n        if isinstance(pos, Unit):\n            pos = pos.position3d\n        assert isinstance(pos, Point3)\n        p0 = pos + Point3((-half_vertex_length, -half_vertex_length, -half_vertex_length))\n        p1 = pos + Point3((half_vertex_length, half_vertex_length, half_vertex_length))\n        self._debug_boxes.append(DrawItemBox(start_point=p0, end_point=p1, color=color))",
  "def debug_sphere_out(self, p: Union[Unit, Point3], r: float, color: Union[tuple, list, Point3] = None):\n        \"\"\"\n        Draws a sphere at point p with radius r.\n\n        :param p:\n        :param r:\n        :param color:\n        \"\"\"\n        if isinstance(p, Unit):\n            p = p.position3d\n        assert isinstance(p, Point3)\n        self._debug_spheres.append(DrawItemSphere(start_point=p, radius=r, color=color))",
  "async def _send_debug(self):\n        \"\"\"Sends the debug draw execution. This is run by main.py now automatically, if there is any items in the list. You do not need to run this manually any longer.\n        Check examples/terran/ramp_wall.py for example drawing. Each draw request needs to be sent again in every single on_step iteration.\n        \"\"\"\n        debug_hash = (\n            sum(hash(item) for item in self._debug_texts),\n            sum(hash(item) for item in self._debug_lines),\n            sum(hash(item) for item in self._debug_boxes),\n            sum(hash(item) for item in self._debug_spheres),\n        )\n        if debug_hash != (0, 0, 0, 0):\n            if debug_hash != self._debug_hash_tuple_last_iteration:\n                # Something has changed, either more or less is to be drawn, or a position of a drawing changed (e.g. when drawing on a moving unit)\n                self._debug_hash_tuple_last_iteration = debug_hash\n                await self._execute(\n                    debug=sc_pb.RequestDebug(\n                        debug=[\n                            debug_pb.DebugCommand(\n                                draw=debug_pb.DebugDraw(\n                                    text=[text.to_proto() for text in self._debug_texts] if self._debug_texts else None,\n                                    lines=[line.to_proto()\n                                           for line in self._debug_lines] if self._debug_lines else None,\n                                    boxes=[box.to_proto() for box in self._debug_boxes] if self._debug_boxes else None,\n                                    spheres=[sphere.to_proto()\n                                             for sphere in self._debug_spheres] if self._debug_spheres else None,\n                                )\n                            )\n                        ]\n                    )\n                )\n            self._debug_draw_last_frame = True\n            self._debug_texts.clear()\n            self._debug_lines.clear()\n            self._debug_boxes.clear()\n            self._debug_spheres.clear()\n        elif self._debug_draw_last_frame:\n            # Clear drawing if we drew last frame but nothing to draw this frame\n            self._debug_hash_tuple_last_iteration = (0, 0, 0, 0)\n            await self._execute(\n                debug=sc_pb.RequestDebug(\n                    debug=[\n                        debug_pb.DebugCommand(draw=debug_pb.DebugDraw(text=None, lines=None, boxes=None, spheres=None))\n                    ]\n                )\n            )\n            self._debug_draw_last_frame = False",
  "async def debug_leave(self):\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(end_game=debug_pb.DebugEndGame())]))",
  "async def debug_set_unit_value(self, unit_tags: Union[Iterable[int], Units, Unit], unit_value: int, value: float):\n        \"\"\"Sets a \"unit value\" (Energy, Life or Shields) of the given units to the given value.\n        Can't set the life of a unit to 0, use \"debug_kill_unit\" for that. Also can't set the life above the unit's maximum.\n        The following example sets the health of all your workers to 1:\n        await self.debug_set_unit_value(self.workers, 2, value=1)\"\"\"\n        if isinstance(unit_tags, Units):\n            unit_tags = unit_tags.tags\n        if isinstance(unit_tags, Unit):\n            unit_tags = [unit_tags.tag]\n        assert hasattr(\n            unit_tags, \"__iter__\"\n        ), f\"unit_tags argument needs to be an iterable (list, dict, set, Units), given argument is {type(unit_tags).__name__}\"\n        assert (\n            1 <= unit_value <= 3\n        ), f\"unit_value needs to be between 1 and 3 (1 for energy, 2 for life, 3 for shields), given argument is {unit_value}\"\n        assert all(tag > 0 for tag in unit_tags), f\"Unit tags have invalid value: {unit_tags}\"\n        assert isinstance(value, (int, float)), \"Value needs to be of type int or float\"\n        assert value >= 0, \"Value can't be negative\"\n        await self._execute(\n            debug=sc_pb.RequestDebug(\n                debug=(\n                    debug_pb.DebugCommand(\n                        unit_value=debug_pb.\n                        DebugSetUnitValue(unit_value=unit_value, value=float(value), unit_tag=unit_tag)\n                    ) for unit_tag in unit_tags\n                )\n            )\n        )",
  "async def debug_hang(self, delay_in_seconds: float):\n        \"\"\" Freezes the SC2 client. Not recommended to be used. \"\"\"\n        delay_in_ms = int(round(delay_in_seconds * 1000))\n        await self._execute(\n            debug=sc_pb.RequestDebug(\n                debug=[debug_pb.DebugCommand(test_process=debug_pb.DebugTestProcess(test=1, delay_ms=delay_in_ms))]\n            )\n        )",
  "async def debug_show_map(self):\n        \"\"\" Reveals the whole map for the bot. Using it a second time disables it again. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=1)]))",
  "async def debug_control_enemy(self):\n        \"\"\" Allows control over enemy units and structures similar to team games control - does not allow the bot to spend the opponent's ressources. Using it a second time disables it again.  \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=2)]))",
  "async def debug_food(self):\n        \"\"\" Should disable food usage (does not seem to work?). Using it a second time disables it again.  \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=3)]))",
  "async def debug_free(self):\n        \"\"\" Units, structures and upgrades are free of mineral and gas cost. Using it a second time disables it again.  \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=4)]))",
  "async def debug_all_resources(self):\n        \"\"\" Gives 5000 minerals and 5000 vespene to the bot. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=5)]))",
  "async def debug_god(self):\n        \"\"\" Your units and structures no longer take any damage. Using it a second time disables it again. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=6)]))",
  "async def debug_minerals(self):\n        \"\"\" Gives 5000 minerals to the bot. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=7)]))",
  "async def debug_gas(self):\n        \"\"\" Gives 5000 vespene to the bot. This does not seem to be working. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=8)]))",
  "async def debug_cooldown(self):\n        \"\"\" Disables cooldowns of unit abilities for the bot. Using it a second time disables it again. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=9)]))",
  "async def debug_tech_tree(self):\n        \"\"\" Removes all tech requirements (e.g. can build a factory without having a barracks). Using it a second time disables it again. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=10)]))",
  "async def debug_upgrade(self):\n        \"\"\" Researches all currently available upgrades. E.g. using it once unlocks combat shield, stimpack and 1-1. Using it a second time unlocks 2-2 and all other upgrades stay researched. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=11)]))",
  "async def debug_fast_build(self):\n        \"\"\" Sets the build time of units and structures and upgrades to zero. Using it a second time disables it again. \"\"\"\n        await self._execute(debug=sc_pb.RequestDebug(debug=[debug_pb.DebugCommand(game_state=12)]))",
  "async def quick_save(self):\n        \"\"\"Saves the current game state to an in-memory bookmark.\n        See: https://github.com/Blizzard/s2client-proto/blob/eeaf5efaea2259d7b70247211dff98da0a2685a2/s2clientprotocol/sc2api.proto#L93\"\"\"\n        await self._execute(quick_save=sc_pb.RequestQuickSave())",
  "async def quick_load(self):\n        \"\"\"Loads the game state from the previously stored in-memory bookmark.\n        Caution:\n            - The SC2 Client will crash if the game wasn't quicksaved\n            - The bot step iteration counter will not reset\n            - self.state.game_loop will be set to zero after the quickload, and self.time is dependant on it\"\"\"\n        await self._execute(quick_load=sc_pb.RequestQuickLoad())",
  "def to_debug_color(color: Union[tuple, Point3]):\n        \"\"\" Helper function for color conversion \"\"\"\n        if color is None:\n            return debug_pb.Color(r=255, g=255, b=255)\n        # Need to check if not of type Point3 because Point3 inherits from tuple\n        elif isinstance(color, (tuple, list)) and not isinstance(color, Point3) and len(color) == 3:\n            return debug_pb.Color(r=color[0], g=color[1], b=color[2])\n        # In case color is of type Point3\n        else:\n            r = getattr(color, \"r\", getattr(color, \"x\", 255))\n            g = getattr(color, \"g\", getattr(color, \"y\", 255))\n            b = getattr(color, \"b\", getattr(color, \"z\", 255))\n            if max(r, g, b) <= 1:\n                r *= 255\n                g *= 255\n                b *= 255\n\n            return debug_pb.Color(r=int(r), g=int(g), b=int(b))",
  "def __init__(self, start_point: Point2 = None, color: Point3 = None, text: str = \"\", font_size: int = 8):\n        self._start_point: Point2 = start_point\n        self._color: Point3 = color\n        self._text: str = text\n        self._font_size: int = font_size",
  "def to_proto(self):\n        return debug_pb.DebugText(\n            color=self.to_debug_color(self._color),\n            text=self._text,\n            virtual_pos=self._start_point.to3.as_Point,\n            world_pos=None,\n            size=self._font_size,\n        )",
  "def __hash__(self):\n        return hash((self._start_point, self._color, self._text, self._font_size))",
  "def __init__(self, start_point: Point3 = None, color: Point3 = None, text: str = \"\", font_size: int = 8):\n        self._start_point: Point3 = start_point\n        self._color: Point3 = color\n        self._text: str = text\n        self._font_size: int = font_size",
  "def to_proto(self):\n        return debug_pb.DebugText(\n            color=self.to_debug_color(self._color),\n            text=self._text,\n            virtual_pos=None,\n            world_pos=self._start_point.as_Point,\n            size=self._font_size,\n        )",
  "def __hash__(self):\n        return hash((self._start_point, self._text, self._font_size, self._color))",
  "def __init__(self, start_point: Point3 = None, end_point: Point3 = None, color: Point3 = None):\n        self._start_point: Point3 = start_point\n        self._end_point: Point3 = end_point\n        self._color: Point3 = color",
  "def to_proto(self):\n        return debug_pb.DebugLine(\n            line=debug_pb.Line(p0=self._start_point.as_Point, p1=self._end_point.as_Point),\n            color=self.to_debug_color(self._color),\n        )",
  "def __hash__(self):\n        return hash((self._start_point, self._end_point, self._color))",
  "def __init__(self, start_point: Point3 = None, end_point: Point3 = None, color: Point3 = None):\n        self._start_point: Point3 = start_point\n        self._end_point: Point3 = end_point\n        self._color: Point3 = color",
  "def to_proto(self):\n        return debug_pb.DebugBox(\n            min=self._start_point.as_Point,\n            max=self._end_point.as_Point,\n            color=self.to_debug_color(self._color),\n        )",
  "def __hash__(self):\n        return hash((self._start_point, self._end_point, self._color))",
  "def __init__(self, start_point: Point3 = None, radius: float = None, color: Point3 = None):\n        self._start_point: Point3 = start_point\n        self._radius: float = radius\n        self._color: Point3 = color",
  "def to_proto(self):\n        return debug_pb.DebugSphere(\n            p=self._start_point.as_Point, r=self._radius, color=self.to_debug_color(self._color)\n        )",
  "def __hash__(self):\n        return hash((self._start_point, self._radius, self._color))",
  "class PixelMap:\n\n    def __init__(self, proto, in_bits: bool = False, mirrored: bool = False):\n        \"\"\"\n        :param proto:\n        :param in_bits:\n        :param mirrored:\n        \"\"\"\n        self._proto = proto\n        # Used for copying pixelmaps\n        self._in_bits: bool = in_bits\n        self._mirrored: bool = mirrored\n\n        assert self.width * self.height == (8 if in_bits else 1) * len(\n            self._proto.data\n        ), f\"{self.width * self.height} {(8 if in_bits else 1)*len(self._proto.data)}\"\n        buffer_data = np.frombuffer(self._proto.data, dtype=np.uint8)\n        if in_bits:\n            buffer_data = np.unpackbits(buffer_data)\n        self.data_numpy = buffer_data.reshape(self._proto.size.y, self._proto.size.x)\n        if mirrored:\n            self.data_numpy = np.flipud(self.data_numpy)\n\n    @property\n    def width(self):\n        return self._proto.size.x\n\n    @property\n    def height(self):\n        return self._proto.size.y\n\n    @property\n    def bits_per_pixel(self):\n        return self._proto.bits_per_pixel\n\n    @property\n    def bytes_per_pixel(self):\n        return self._proto.bits_per_pixel // 8\n\n    def __getitem__(self, pos):\n        \"\"\" Example usage: is_pathable = self._game_info.pathing_grid[Point2((20, 20))] != 0 \"\"\"\n        assert 0 <= pos[0] < self.width, f\"x is {pos[0]}, self.width is {self.width}\"\n        assert 0 <= pos[1] < self.height, f\"y is {pos[1]}, self.height is {self.height}\"\n        return int(self.data_numpy[pos[1], pos[0]])\n\n    def __setitem__(self, pos, value):\n        \"\"\" Example usage: self._game_info.pathing_grid[Point2((20, 20))] = 255 \"\"\"\n        assert 0 <= pos[0] < self.width, f\"x is {pos[0]}, self.width is {self.width}\"\n        assert 0 <= pos[1] < self.height, f\"y is {pos[1]}, self.height is {self.height}\"\n        assert (\n            0 <= value <= 254 * self._in_bits + 1\n        ), f\"value is {value}, it should be between 0 and {254 * self._in_bits + 1}\"\n        assert isinstance(value, int), f\"value is of type {type(value)}, it should be an integer\"\n        self.data_numpy[pos[1], pos[0]] = value\n\n    def is_set(self, p):\n        return self[p] != 0\n\n    def is_empty(self, p):\n        return not self.is_set(p)\n\n    def copy(self):\n        return PixelMap(self._proto, in_bits=self._in_bits, mirrored=self._mirrored)\n\n    def flood_fill(self, start_point: Point2, pred: Callable[[int], bool]) -> Set[Point2]:\n        nodes: Set[Point2] = set()\n        queue: List[Point2] = [start_point]\n\n        while queue:\n            x, y = queue.pop()\n\n            if not (0 <= x < self.width and 0 <= y < self.height):\n                continue\n\n            if Point2((x, y)) in nodes:\n                continue\n\n            if pred(self[x, y]):\n                nodes.add(Point2((x, y)))\n                queue += [Point2((x + a, y + b)) for a in [-1, 0, 1] for b in [-1, 0, 1] if not (a == 0 and b == 0)]\n        return nodes\n\n    def flood_fill_all(self, pred: Callable[[int], bool]) -> Set[FrozenSet[Point2]]:\n        groups: Set[FrozenSet[Point2]] = set()\n\n        for x in range(self.width):\n            for y in range(self.height):\n                if any((x, y) in g for g in groups):\n                    continue\n\n                if pred(self[x, y]):\n                    groups.add(frozenset(self.flood_fill(Point2((x, y)), pred)))\n\n        return groups\n\n    def print(self, wide=False):\n        for y in range(self.height):\n            for x in range(self.width):\n                print(\"#\" if self.is_set((x, y)) else \" \", end=(\" \" if wide else \"\"))\n            print(\"\")\n\n    def save_image(self, filename):\n        data = [(0, 0, self[x, y]) for y in range(self.height) for x in range(self.width)]\n        from PIL import Image\n\n        im = Image.new(\"RGB\", (self.width, self.height))\n        im.putdata(data)\n        im.save(filename)\n\n    def plot(self):\n        import matplotlib.pyplot as plt\n\n        plt.imshow(self.data_numpy, origin=\"lower\")\n        plt.show()",
  "def __init__(self, proto, in_bits: bool = False, mirrored: bool = False):\n        \"\"\"\n        :param proto:\n        :param in_bits:\n        :param mirrored:\n        \"\"\"\n        self._proto = proto\n        # Used for copying pixelmaps\n        self._in_bits: bool = in_bits\n        self._mirrored: bool = mirrored\n\n        assert self.width * self.height == (8 if in_bits else 1) * len(\n            self._proto.data\n        ), f\"{self.width * self.height} {(8 if in_bits else 1)*len(self._proto.data)}\"\n        buffer_data = np.frombuffer(self._proto.data, dtype=np.uint8)\n        if in_bits:\n            buffer_data = np.unpackbits(buffer_data)\n        self.data_numpy = buffer_data.reshape(self._proto.size.y, self._proto.size.x)\n        if mirrored:\n            self.data_numpy = np.flipud(self.data_numpy)",
  "def width(self):\n        return self._proto.size.x",
  "def height(self):\n        return self._proto.size.y",
  "def bits_per_pixel(self):\n        return self._proto.bits_per_pixel",
  "def bytes_per_pixel(self):\n        return self._proto.bits_per_pixel // 8",
  "def __getitem__(self, pos):\n        \"\"\" Example usage: is_pathable = self._game_info.pathing_grid[Point2((20, 20))] != 0 \"\"\"\n        assert 0 <= pos[0] < self.width, f\"x is {pos[0]}, self.width is {self.width}\"\n        assert 0 <= pos[1] < self.height, f\"y is {pos[1]}, self.height is {self.height}\"\n        return int(self.data_numpy[pos[1], pos[0]])",
  "def __setitem__(self, pos, value):\n        \"\"\" Example usage: self._game_info.pathing_grid[Point2((20, 20))] = 255 \"\"\"\n        assert 0 <= pos[0] < self.width, f\"x is {pos[0]}, self.width is {self.width}\"\n        assert 0 <= pos[1] < self.height, f\"y is {pos[1]}, self.height is {self.height}\"\n        assert (\n            0 <= value <= 254 * self._in_bits + 1\n        ), f\"value is {value}, it should be between 0 and {254 * self._in_bits + 1}\"\n        assert isinstance(value, int), f\"value is of type {type(value)}, it should be an integer\"\n        self.data_numpy[pos[1], pos[0]] = value",
  "def is_set(self, p):\n        return self[p] != 0",
  "def is_empty(self, p):\n        return not self.is_set(p)",
  "def copy(self):\n        return PixelMap(self._proto, in_bits=self._in_bits, mirrored=self._mirrored)",
  "def flood_fill(self, start_point: Point2, pred: Callable[[int], bool]) -> Set[Point2]:\n        nodes: Set[Point2] = set()\n        queue: List[Point2] = [start_point]\n\n        while queue:\n            x, y = queue.pop()\n\n            if not (0 <= x < self.width and 0 <= y < self.height):\n                continue\n\n            if Point2((x, y)) in nodes:\n                continue\n\n            if pred(self[x, y]):\n                nodes.add(Point2((x, y)))\n                queue += [Point2((x + a, y + b)) for a in [-1, 0, 1] for b in [-1, 0, 1] if not (a == 0 and b == 0)]\n        return nodes",
  "def flood_fill_all(self, pred: Callable[[int], bool]) -> Set[FrozenSet[Point2]]:\n        groups: Set[FrozenSet[Point2]] = set()\n\n        for x in range(self.width):\n            for y in range(self.height):\n                if any((x, y) in g for g in groups):\n                    continue\n\n                if pred(self[x, y]):\n                    groups.add(frozenset(self.flood_fill(Point2((x, y)), pred)))\n\n        return groups",
  "def print(self, wide=False):\n        for y in range(self.height):\n            for x in range(self.width):\n                print(\"#\" if self.is_set((x, y)) else \" \", end=(\" \" if wide else \"\"))\n            print(\"\")",
  "def save_image(self, filename):\n        data = [(0, 0, self[x, y]) for y in range(self.height) for x in range(self.width)]\n        from PIL import Image\n\n        im = Image.new(\"RGB\", (self.width, self.height))\n        im.putdata(data)\n        im.save(filename)",
  "def plot(self):\n        import matplotlib.pyplot as plt\n\n        plt.imshow(self.data_numpy, origin=\"lower\")\n        plt.show()",
  "class Renderer:\n\n    def __init__(self, client, map_size, minimap_size):\n        self._client = client\n\n        self._window = None\n        self._map_size = map_size\n        self._map_image = None\n        self._minimap_size = minimap_size\n        self._minimap_image = None\n        self._mouse_x, self._mouse_y = None, None\n        self._text_supply = None\n        self._text_vespene = None\n        self._text_minerals = None\n        self._text_score = None\n        self._text_time = None\n\n    async def render(self, observation):\n        render_data = observation.observation.render_data\n\n        map_size = render_data.map.size\n        map_data = render_data.map.data\n        minimap_size = render_data.minimap.size\n        minimap_data = render_data.minimap.data\n\n        map_width, map_height = map_size.x, map_size.y\n        map_pitch = -map_width * 3\n\n        minimap_width, minimap_height = minimap_size.x, minimap_size.y\n        minimap_pitch = -minimap_width * 3\n\n        if not self._window:\n            from pyglet.image import ImageData\n            from pyglet.text import Label\n            from pyglet.window import Window\n\n            self._window = Window(width=map_width, height=map_height)\n            self._window.on_mouse_press = self._on_mouse_press\n            self._window.on_mouse_release = self._on_mouse_release\n            self._window.on_mouse_drag = self._on_mouse_drag\n            self._map_image = ImageData(map_width, map_height, \"RGB\", map_data, map_pitch)\n            self._minimap_image = ImageData(minimap_width, minimap_height, \"RGB\", minimap_data, minimap_pitch)\n            self._text_supply = Label(\n                \"\",\n                font_name=\"Arial\",\n                font_size=16,\n                anchor_x=\"right\",\n                anchor_y=\"top\",\n                x=self._map_size[0] - 10,\n                y=self._map_size[1] - 10,\n                color=(200, 200, 200, 255),\n            )\n            self._text_vespene = Label(\n                \"\",\n                font_name=\"Arial\",\n                font_size=16,\n                anchor_x=\"right\",\n                anchor_y=\"top\",\n                x=self._map_size[0] - 130,\n                y=self._map_size[1] - 10,\n                color=(28, 160, 16, 255),\n            )\n            self._text_minerals = Label(\n                \"\",\n                font_name=\"Arial\",\n                font_size=16,\n                anchor_x=\"right\",\n                anchor_y=\"top\",\n                x=self._map_size[0] - 200,\n                y=self._map_size[1] - 10,\n                color=(68, 140, 255, 255),\n            )\n            self._text_score = Label(\n                \"\",\n                font_name=\"Arial\",\n                font_size=16,\n                anchor_x=\"left\",\n                anchor_y=\"top\",\n                x=10,\n                y=self._map_size[1] - 10,\n                color=(219, 30, 30, 255),\n            )\n            self._text_time = Label(\n                \"\",\n                font_name=\"Arial\",\n                font_size=16,\n                anchor_x=\"right\",\n                anchor_y=\"bottom\",\n                x=self._minimap_size[0] - 10,\n                y=self._minimap_size[1] + 10,\n                color=(255, 255, 255, 255),\n            )\n        else:\n            self._map_image.set_data(\"RGB\", map_pitch, map_data)\n            self._minimap_image.set_data(\"RGB\", minimap_pitch, minimap_data)\n            self._text_time.text = str(datetime.timedelta(seconds=(observation.observation.game_loop * 0.725) // 16))\n            if observation.observation.HasField(\"player_common\"):\n                self._text_supply.text = \"{} / {}\".format(\n                    observation.observation.player_common.food_used, observation.observation.player_common.food_cap\n                )\n                self._text_vespene.text = str(observation.observation.player_common.vespene)\n                self._text_minerals.text = str(observation.observation.player_common.minerals)\n            if observation.observation.HasField(\"score\"):\n                self._text_score.text = \"{} score: {}\".format(\n                    score_pb._SCORE_SCORETYPE.values_by_number[observation.observation.score.score_type].name,\n                    observation.observation.score.score,\n                )\n\n        await self._update_window()\n\n        if self._client.in_game and (not observation.player_result) and self._mouse_x and self._mouse_y:\n            await self._client.move_camera_spatial(Point2((self._mouse_x, self._minimap_size[0] - self._mouse_y)))\n            self._mouse_x, self._mouse_y = None, None\n\n    async def _update_window(self):\n        self._window.switch_to()\n        self._window.dispatch_events()\n\n        self._window.clear()\n\n        self._map_image.blit(0, 0)\n        self._minimap_image.blit(0, 0)\n        self._text_time.draw()\n        self._text_score.draw()\n        self._text_minerals.draw()\n        self._text_vespene.draw()\n        self._text_supply.draw()\n\n        self._window.flip()\n\n    def _on_mouse_press(self, x, y, button, modifiers):\n        if button != 1:  # 1: mouse.LEFT\n            return\n        if x > self._minimap_size[0] or y > self._minimap_size[1]:\n            return\n        self._mouse_x, self._mouse_y = x, y\n\n    def _on_mouse_release(self, x, y, button, modifiers):\n        if button != 1:  # 1: mouse.LEFT\n            return\n        if x > self._minimap_size[0] or y > self._minimap_size[1]:\n            return\n        self._mouse_x, self._mouse_y = x, y\n\n    def _on_mouse_drag(self, x, y, dx, dy, buttons, modifiers):\n        if not buttons & 1:  # 1: mouse.LEFT\n            return\n        if x > self._minimap_size[0] or y > self._minimap_size[1]:\n            return\n        self._mouse_x, self._mouse_y = x, y",
  "def __init__(self, client, map_size, minimap_size):\n        self._client = client\n\n        self._window = None\n        self._map_size = map_size\n        self._map_image = None\n        self._minimap_size = minimap_size\n        self._minimap_image = None\n        self._mouse_x, self._mouse_y = None, None\n        self._text_supply = None\n        self._text_vespene = None\n        self._text_minerals = None\n        self._text_score = None\n        self._text_time = None",
  "async def render(self, observation):\n        render_data = observation.observation.render_data\n\n        map_size = render_data.map.size\n        map_data = render_data.map.data\n        minimap_size = render_data.minimap.size\n        minimap_data = render_data.minimap.data\n\n        map_width, map_height = map_size.x, map_size.y\n        map_pitch = -map_width * 3\n\n        minimap_width, minimap_height = minimap_size.x, minimap_size.y\n        minimap_pitch = -minimap_width * 3\n\n        if not self._window:\n            from pyglet.image import ImageData\n            from pyglet.text import Label\n            from pyglet.window import Window\n\n            self._window = Window(width=map_width, height=map_height)\n            self._window.on_mouse_press = self._on_mouse_press\n            self._window.on_mouse_release = self._on_mouse_release\n            self._window.on_mouse_drag = self._on_mouse_drag\n            self._map_image = ImageData(map_width, map_height, \"RGB\", map_data, map_pitch)\n            self._minimap_image = ImageData(minimap_width, minimap_height, \"RGB\", minimap_data, minimap_pitch)\n            self._text_supply = Label(\n                \"\",\n                font_name=\"Arial\",\n                font_size=16,\n                anchor_x=\"right\",\n                anchor_y=\"top\",\n                x=self._map_size[0] - 10,\n                y=self._map_size[1] - 10,\n                color=(200, 200, 200, 255),\n            )\n            self._text_vespene = Label(\n                \"\",\n                font_name=\"Arial\",\n                font_size=16,\n                anchor_x=\"right\",\n                anchor_y=\"top\",\n                x=self._map_size[0] - 130,\n                y=self._map_size[1] - 10,\n                color=(28, 160, 16, 255),\n            )\n            self._text_minerals = Label(\n                \"\",\n                font_name=\"Arial\",\n                font_size=16,\n                anchor_x=\"right\",\n                anchor_y=\"top\",\n                x=self._map_size[0] - 200,\n                y=self._map_size[1] - 10,\n                color=(68, 140, 255, 255),\n            )\n            self._text_score = Label(\n                \"\",\n                font_name=\"Arial\",\n                font_size=16,\n                anchor_x=\"left\",\n                anchor_y=\"top\",\n                x=10,\n                y=self._map_size[1] - 10,\n                color=(219, 30, 30, 255),\n            )\n            self._text_time = Label(\n                \"\",\n                font_name=\"Arial\",\n                font_size=16,\n                anchor_x=\"right\",\n                anchor_y=\"bottom\",\n                x=self._minimap_size[0] - 10,\n                y=self._minimap_size[1] + 10,\n                color=(255, 255, 255, 255),\n            )\n        else:\n            self._map_image.set_data(\"RGB\", map_pitch, map_data)\n            self._minimap_image.set_data(\"RGB\", minimap_pitch, minimap_data)\n            self._text_time.text = str(datetime.timedelta(seconds=(observation.observation.game_loop * 0.725) // 16))\n            if observation.observation.HasField(\"player_common\"):\n                self._text_supply.text = \"{} / {}\".format(\n                    observation.observation.player_common.food_used, observation.observation.player_common.food_cap\n                )\n                self._text_vespene.text = str(observation.observation.player_common.vespene)\n                self._text_minerals.text = str(observation.observation.player_common.minerals)\n            if observation.observation.HasField(\"score\"):\n                self._text_score.text = \"{} score: {}\".format(\n                    score_pb._SCORE_SCORETYPE.values_by_number[observation.observation.score.score_type].name,\n                    observation.observation.score.score,\n                )\n\n        await self._update_window()\n\n        if self._client.in_game and (not observation.player_result) and self._mouse_x and self._mouse_y:\n            await self._client.move_camera_spatial(Point2((self._mouse_x, self._minimap_size[0] - self._mouse_y)))\n            self._mouse_x, self._mouse_y = None, None",
  "async def _update_window(self):\n        self._window.switch_to()\n        self._window.dispatch_events()\n\n        self._window.clear()\n\n        self._map_image.blit(0, 0)\n        self._minimap_image.blit(0, 0)\n        self._text_time.draw()\n        self._text_score.draw()\n        self._text_minerals.draw()\n        self._text_vespene.draw()\n        self._text_supply.draw()\n\n        self._window.flip()",
  "def _on_mouse_press(self, x, y, button, modifiers):\n        if button != 1:  # 1: mouse.LEFT\n            return\n        if x > self._minimap_size[0] or y > self._minimap_size[1]:\n            return\n        self._mouse_x, self._mouse_y = x, y",
  "def _on_mouse_release(self, x, y, button, modifiers):\n        if button != 1:  # 1: mouse.LEFT\n            return\n        if x > self._minimap_size[0] or y > self._minimap_size[1]:\n            return\n        self._mouse_x, self._mouse_y = x, y",
  "def _on_mouse_drag(self, x, y, dx, dy, buttons, modifiers):\n        if not buttons & 1:  # 1: mouse.LEFT\n            return\n        if x > self._minimap_size[0] or y > self._minimap_size[1]:\n            return\n        self._mouse_x, self._mouse_y = x, y",
  "class ScoreDetails:\n    \"\"\"Accessable in self.state.score during step function\n    For more information, see https://github.com/Blizzard/s2client-proto/blob/master/s2clientprotocol/score.proto\n    \"\"\"\n\n    def __init__(self, proto):\n        self._data = proto\n        self._proto = proto.score_details\n\n    @property\n    def summary(self):\n        \"\"\"\n        TODO this is super ugly, how can we improve this summary?\n        Print summary to file with:\n        In on_step:\n\n        with open(\"stats.txt\", \"w+\") as file:\n            for stat in self.state.score.summary:\n                file.write(f\"{stat[0]:<35} {float(stat[1]):>35.3f}\\n\")\n        \"\"\"\n        values = [\n            \"score_type\",\n            \"score\",\n            \"idle_production_time\",\n            \"idle_worker_time\",\n            \"total_value_units\",\n            \"total_value_structures\",\n            \"killed_value_units\",\n            \"killed_value_structures\",\n            \"collected_minerals\",\n            \"collected_vespene\",\n            \"collection_rate_minerals\",\n            \"collection_rate_vespene\",\n            \"spent_minerals\",\n            \"spent_vespene\",\n            \"food_used_none\",\n            \"food_used_army\",\n            \"food_used_economy\",\n            \"food_used_technology\",\n            \"food_used_upgrade\",\n            \"killed_minerals_none\",\n            \"killed_minerals_army\",\n            \"killed_minerals_economy\",\n            \"killed_minerals_technology\",\n            \"killed_minerals_upgrade\",\n            \"killed_vespene_none\",\n            \"killed_vespene_army\",\n            \"killed_vespene_economy\",\n            \"killed_vespene_technology\",\n            \"killed_vespene_upgrade\",\n            \"lost_minerals_none\",\n            \"lost_minerals_army\",\n            \"lost_minerals_economy\",\n            \"lost_minerals_technology\",\n            \"lost_minerals_upgrade\",\n            \"lost_vespene_none\",\n            \"lost_vespene_army\",\n            \"lost_vespene_economy\",\n            \"lost_vespene_technology\",\n            \"lost_vespene_upgrade\",\n            \"friendly_fire_minerals_none\",\n            \"friendly_fire_minerals_army\",\n            \"friendly_fire_minerals_economy\",\n            \"friendly_fire_minerals_technology\",\n            \"friendly_fire_minerals_upgrade\",\n            \"friendly_fire_vespene_none\",\n            \"friendly_fire_vespene_army\",\n            \"friendly_fire_vespene_economy\",\n            \"friendly_fire_vespene_technology\",\n            \"friendly_fire_vespene_upgrade\",\n            \"used_minerals_none\",\n            \"used_minerals_army\",\n            \"used_minerals_economy\",\n            \"used_minerals_technology\",\n            \"used_minerals_upgrade\",\n            \"used_vespene_none\",\n            \"used_vespene_army\",\n            \"used_vespene_economy\",\n            \"used_vespene_technology\",\n            \"used_vespene_upgrade\",\n            \"total_used_minerals_none\",\n            \"total_used_minerals_army\",\n            \"total_used_minerals_economy\",\n            \"total_used_minerals_technology\",\n            \"total_used_minerals_upgrade\",\n            \"total_used_vespene_none\",\n            \"total_used_vespene_army\",\n            \"total_used_vespene_economy\",\n            \"total_used_vespene_technology\",\n            \"total_used_vespene_upgrade\",\n            \"total_damage_dealt_life\",\n            \"total_damage_dealt_shields\",\n            \"total_damage_dealt_energy\",\n            \"total_damage_taken_life\",\n            \"total_damage_taken_shields\",\n            \"total_damage_taken_energy\",\n            \"total_healed_life\",\n            \"total_healed_shields\",\n            \"total_healed_energy\",\n            \"current_apm\",\n            \"current_effective_apm\",\n        ]\n        return [[value, getattr(self, value)] for value in values]\n\n    @property\n    def score_type(self):\n        return self._data.score_type\n\n    @property\n    def score(self):\n        return self._data.score\n\n    @property\n    def idle_production_time(self):\n        return self._proto.idle_production_time\n\n    @property\n    def idle_worker_time(self):\n        return self._proto.idle_worker_time\n\n    @property\n    def total_value_units(self):\n        return self._proto.total_value_units\n\n    @property\n    def total_value_structures(self):\n        return self._proto.total_value_structures\n\n    @property\n    def killed_value_units(self):\n        return self._proto.killed_value_units\n\n    @property\n    def killed_value_structures(self):\n        return self._proto.killed_value_structures\n\n    @property\n    def collected_minerals(self):\n        return self._proto.collected_minerals\n\n    @property\n    def collected_vespene(self):\n        return self._proto.collected_vespene\n\n    @property\n    def collection_rate_minerals(self):\n        return self._proto.collection_rate_minerals\n\n    @property\n    def collection_rate_vespene(self):\n        return self._proto.collection_rate_vespene\n\n    @property\n    def spent_minerals(self):\n        return self._proto.spent_minerals\n\n    @property\n    def spent_vespene(self):\n        return self._proto.spent_vespene\n\n    @property\n    def food_used_none(self):\n        return self._proto.food_used.none\n\n    @property\n    def food_used_army(self):\n        return self._proto.food_used.army\n\n    @property\n    def food_used_economy(self):\n        return self._proto.food_used.economy\n\n    @property\n    def food_used_technology(self):\n        return self._proto.food_used.technology\n\n    @property\n    def food_used_upgrade(self):\n        return self._proto.food_used.upgrade\n\n    @property\n    def killed_minerals_none(self):\n        return self._proto.killed_minerals.none\n\n    @property\n    def killed_minerals_army(self):\n        return self._proto.killed_minerals.army\n\n    @property\n    def killed_minerals_economy(self):\n        return self._proto.killed_minerals.economy\n\n    @property\n    def killed_minerals_technology(self):\n        return self._proto.killed_minerals.technology\n\n    @property\n    def killed_minerals_upgrade(self):\n        return self._proto.killed_minerals.upgrade\n\n    @property\n    def killed_vespene_none(self):\n        return self._proto.killed_vespene.none\n\n    @property\n    def killed_vespene_army(self):\n        return self._proto.killed_vespene.army\n\n    @property\n    def killed_vespene_economy(self):\n        return self._proto.killed_vespene.economy\n\n    @property\n    def killed_vespene_technology(self):\n        return self._proto.killed_vespene.technology\n\n    @property\n    def killed_vespene_upgrade(self):\n        return self._proto.killed_vespene.upgrade\n\n    @property\n    def lost_minerals_none(self):\n        return self._proto.lost_minerals.none\n\n    @property\n    def lost_minerals_army(self):\n        return self._proto.lost_minerals.army\n\n    @property\n    def lost_minerals_economy(self):\n        return self._proto.lost_minerals.economy\n\n    @property\n    def lost_minerals_technology(self):\n        return self._proto.lost_minerals.technology\n\n    @property\n    def lost_minerals_upgrade(self):\n        return self._proto.lost_minerals.upgrade\n\n    @property\n    def lost_vespene_none(self):\n        return self._proto.lost_vespene.none\n\n    @property\n    def lost_vespene_army(self):\n        return self._proto.lost_vespene.army\n\n    @property\n    def lost_vespene_economy(self):\n        return self._proto.lost_vespene.economy\n\n    @property\n    def lost_vespene_technology(self):\n        return self._proto.lost_vespene.technology\n\n    @property\n    def lost_vespene_upgrade(self):\n        return self._proto.lost_vespene.upgrade\n\n    @property\n    def friendly_fire_minerals_none(self):\n        return self._proto.friendly_fire_minerals.none\n\n    @property\n    def friendly_fire_minerals_army(self):\n        return self._proto.friendly_fire_minerals.army\n\n    @property\n    def friendly_fire_minerals_economy(self):\n        return self._proto.friendly_fire_minerals.economy\n\n    @property\n    def friendly_fire_minerals_technology(self):\n        return self._proto.friendly_fire_minerals.technology\n\n    @property\n    def friendly_fire_minerals_upgrade(self):\n        return self._proto.friendly_fire_minerals.upgrade\n\n    @property\n    def friendly_fire_vespene_none(self):\n        return self._proto.friendly_fire_vespene.none\n\n    @property\n    def friendly_fire_vespene_army(self):\n        return self._proto.friendly_fire_vespene.army\n\n    @property\n    def friendly_fire_vespene_economy(self):\n        return self._proto.friendly_fire_vespene.economy\n\n    @property\n    def friendly_fire_vespene_technology(self):\n        return self._proto.friendly_fire_vespene.technology\n\n    @property\n    def friendly_fire_vespene_upgrade(self):\n        return self._proto.friendly_fire_vespene.upgrade\n\n    @property\n    def used_minerals_none(self):\n        return self._proto.used_minerals.none\n\n    @property\n    def used_minerals_army(self):\n        return self._proto.used_minerals.army\n\n    @property\n    def used_minerals_economy(self):\n        return self._proto.used_minerals.economy\n\n    @property\n    def used_minerals_technology(self):\n        return self._proto.used_minerals.technology\n\n    @property\n    def used_minerals_upgrade(self):\n        return self._proto.used_minerals.upgrade\n\n    @property\n    def used_vespene_none(self):\n        return self._proto.used_vespene.none\n\n    @property\n    def used_vespene_army(self):\n        return self._proto.used_vespene.army\n\n    @property\n    def used_vespene_economy(self):\n        return self._proto.used_vespene.economy\n\n    @property\n    def used_vespene_technology(self):\n        return self._proto.used_vespene.technology\n\n    @property\n    def used_vespene_upgrade(self):\n        return self._proto.used_vespene.upgrade\n\n    @property\n    def total_used_minerals_none(self):\n        return self._proto.total_used_minerals.none\n\n    @property\n    def total_used_minerals_army(self):\n        return self._proto.total_used_minerals.army\n\n    @property\n    def total_used_minerals_economy(self):\n        return self._proto.total_used_minerals.economy\n\n    @property\n    def total_used_minerals_technology(self):\n        return self._proto.total_used_minerals.technology\n\n    @property\n    def total_used_minerals_upgrade(self):\n        return self._proto.total_used_minerals.upgrade\n\n    @property\n    def total_used_vespene_none(self):\n        return self._proto.total_used_vespene.none\n\n    @property\n    def total_used_vespene_army(self):\n        return self._proto.total_used_vespene.army\n\n    @property\n    def total_used_vespene_economy(self):\n        return self._proto.total_used_vespene.economy\n\n    @property\n    def total_used_vespene_technology(self):\n        return self._proto.total_used_vespene.technology\n\n    @property\n    def total_used_vespene_upgrade(self):\n        return self._proto.total_used_vespene.upgrade\n\n    @property\n    def total_damage_dealt_life(self):\n        return self._proto.total_damage_dealt.life\n\n    @property\n    def total_damage_dealt_shields(self):\n        return self._proto.total_damage_dealt.shields\n\n    @property\n    def total_damage_dealt_energy(self):\n        return self._proto.total_damage_dealt.energy\n\n    @property\n    def total_damage_taken_life(self):\n        return self._proto.total_damage_taken.life\n\n    @property\n    def total_damage_taken_shields(self):\n        return self._proto.total_damage_taken.shields\n\n    @property\n    def total_damage_taken_energy(self):\n        return self._proto.total_damage_taken.energy\n\n    @property\n    def total_healed_life(self):\n        return self._proto.total_healed.life\n\n    @property\n    def total_healed_shields(self):\n        return self._proto.total_healed.shields\n\n    @property\n    def total_healed_energy(self):\n        return self._proto.total_healed.energy\n\n    @property\n    def current_apm(self):\n        return self._proto.current_apm\n\n    @property\n    def current_effective_apm(self):\n        return self._proto.current_effective_apm",
  "def __init__(self, proto):\n        self._data = proto\n        self._proto = proto.score_details",
  "def summary(self):\n        \"\"\"\n        TODO this is super ugly, how can we improve this summary?\n        Print summary to file with:\n        In on_step:\n\n        with open(\"stats.txt\", \"w+\") as file:\n            for stat in self.state.score.summary:\n                file.write(f\"{stat[0]:<35} {float(stat[1]):>35.3f}\\n\")\n        \"\"\"\n        values = [\n            \"score_type\",\n            \"score\",\n            \"idle_production_time\",\n            \"idle_worker_time\",\n            \"total_value_units\",\n            \"total_value_structures\",\n            \"killed_value_units\",\n            \"killed_value_structures\",\n            \"collected_minerals\",\n            \"collected_vespene\",\n            \"collection_rate_minerals\",\n            \"collection_rate_vespene\",\n            \"spent_minerals\",\n            \"spent_vespene\",\n            \"food_used_none\",\n            \"food_used_army\",\n            \"food_used_economy\",\n            \"food_used_technology\",\n            \"food_used_upgrade\",\n            \"killed_minerals_none\",\n            \"killed_minerals_army\",\n            \"killed_minerals_economy\",\n            \"killed_minerals_technology\",\n            \"killed_minerals_upgrade\",\n            \"killed_vespene_none\",\n            \"killed_vespene_army\",\n            \"killed_vespene_economy\",\n            \"killed_vespene_technology\",\n            \"killed_vespene_upgrade\",\n            \"lost_minerals_none\",\n            \"lost_minerals_army\",\n            \"lost_minerals_economy\",\n            \"lost_minerals_technology\",\n            \"lost_minerals_upgrade\",\n            \"lost_vespene_none\",\n            \"lost_vespene_army\",\n            \"lost_vespene_economy\",\n            \"lost_vespene_technology\",\n            \"lost_vespene_upgrade\",\n            \"friendly_fire_minerals_none\",\n            \"friendly_fire_minerals_army\",\n            \"friendly_fire_minerals_economy\",\n            \"friendly_fire_minerals_technology\",\n            \"friendly_fire_minerals_upgrade\",\n            \"friendly_fire_vespene_none\",\n            \"friendly_fire_vespene_army\",\n            \"friendly_fire_vespene_economy\",\n            \"friendly_fire_vespene_technology\",\n            \"friendly_fire_vespene_upgrade\",\n            \"used_minerals_none\",\n            \"used_minerals_army\",\n            \"used_minerals_economy\",\n            \"used_minerals_technology\",\n            \"used_minerals_upgrade\",\n            \"used_vespene_none\",\n            \"used_vespene_army\",\n            \"used_vespene_economy\",\n            \"used_vespene_technology\",\n            \"used_vespene_upgrade\",\n            \"total_used_minerals_none\",\n            \"total_used_minerals_army\",\n            \"total_used_minerals_economy\",\n            \"total_used_minerals_technology\",\n            \"total_used_minerals_upgrade\",\n            \"total_used_vespene_none\",\n            \"total_used_vespene_army\",\n            \"total_used_vespene_economy\",\n            \"total_used_vespene_technology\",\n            \"total_used_vespene_upgrade\",\n            \"total_damage_dealt_life\",\n            \"total_damage_dealt_shields\",\n            \"total_damage_dealt_energy\",\n            \"total_damage_taken_life\",\n            \"total_damage_taken_shields\",\n            \"total_damage_taken_energy\",\n            \"total_healed_life\",\n            \"total_healed_shields\",\n            \"total_healed_energy\",\n            \"current_apm\",\n            \"current_effective_apm\",\n        ]\n        return [[value, getattr(self, value)] for value in values]",
  "def score_type(self):\n        return self._data.score_type",
  "def score(self):\n        return self._data.score",
  "def idle_production_time(self):\n        return self._proto.idle_production_time",
  "def idle_worker_time(self):\n        return self._proto.idle_worker_time",
  "def total_value_units(self):\n        return self._proto.total_value_units",
  "def total_value_structures(self):\n        return self._proto.total_value_structures",
  "def killed_value_units(self):\n        return self._proto.killed_value_units",
  "def killed_value_structures(self):\n        return self._proto.killed_value_structures",
  "def collected_minerals(self):\n        return self._proto.collected_minerals",
  "def collected_vespene(self):\n        return self._proto.collected_vespene",
  "def collection_rate_minerals(self):\n        return self._proto.collection_rate_minerals",
  "def collection_rate_vespene(self):\n        return self._proto.collection_rate_vespene",
  "def spent_minerals(self):\n        return self._proto.spent_minerals",
  "def spent_vespene(self):\n        return self._proto.spent_vespene",
  "def food_used_none(self):\n        return self._proto.food_used.none",
  "def food_used_army(self):\n        return self._proto.food_used.army",
  "def food_used_economy(self):\n        return self._proto.food_used.economy",
  "def food_used_technology(self):\n        return self._proto.food_used.technology",
  "def food_used_upgrade(self):\n        return self._proto.food_used.upgrade",
  "def killed_minerals_none(self):\n        return self._proto.killed_minerals.none",
  "def killed_minerals_army(self):\n        return self._proto.killed_minerals.army",
  "def killed_minerals_economy(self):\n        return self._proto.killed_minerals.economy",
  "def killed_minerals_technology(self):\n        return self._proto.killed_minerals.technology",
  "def killed_minerals_upgrade(self):\n        return self._proto.killed_minerals.upgrade",
  "def killed_vespene_none(self):\n        return self._proto.killed_vespene.none",
  "def killed_vespene_army(self):\n        return self._proto.killed_vespene.army",
  "def killed_vespene_economy(self):\n        return self._proto.killed_vespene.economy",
  "def killed_vespene_technology(self):\n        return self._proto.killed_vespene.technology",
  "def killed_vespene_upgrade(self):\n        return self._proto.killed_vespene.upgrade",
  "def lost_minerals_none(self):\n        return self._proto.lost_minerals.none",
  "def lost_minerals_army(self):\n        return self._proto.lost_minerals.army",
  "def lost_minerals_economy(self):\n        return self._proto.lost_minerals.economy",
  "def lost_minerals_technology(self):\n        return self._proto.lost_minerals.technology",
  "def lost_minerals_upgrade(self):\n        return self._proto.lost_minerals.upgrade",
  "def lost_vespene_none(self):\n        return self._proto.lost_vespene.none",
  "def lost_vespene_army(self):\n        return self._proto.lost_vespene.army",
  "def lost_vespene_economy(self):\n        return self._proto.lost_vespene.economy",
  "def lost_vespene_technology(self):\n        return self._proto.lost_vespene.technology",
  "def lost_vespene_upgrade(self):\n        return self._proto.lost_vespene.upgrade",
  "def friendly_fire_minerals_none(self):\n        return self._proto.friendly_fire_minerals.none",
  "def friendly_fire_minerals_army(self):\n        return self._proto.friendly_fire_minerals.army",
  "def friendly_fire_minerals_economy(self):\n        return self._proto.friendly_fire_minerals.economy",
  "def friendly_fire_minerals_technology(self):\n        return self._proto.friendly_fire_minerals.technology",
  "def friendly_fire_minerals_upgrade(self):\n        return self._proto.friendly_fire_minerals.upgrade",
  "def friendly_fire_vespene_none(self):\n        return self._proto.friendly_fire_vespene.none",
  "def friendly_fire_vespene_army(self):\n        return self._proto.friendly_fire_vespene.army",
  "def friendly_fire_vespene_economy(self):\n        return self._proto.friendly_fire_vespene.economy",
  "def friendly_fire_vespene_technology(self):\n        return self._proto.friendly_fire_vespene.technology",
  "def friendly_fire_vespene_upgrade(self):\n        return self._proto.friendly_fire_vespene.upgrade",
  "def used_minerals_none(self):\n        return self._proto.used_minerals.none",
  "def used_minerals_army(self):\n        return self._proto.used_minerals.army",
  "def used_minerals_economy(self):\n        return self._proto.used_minerals.economy",
  "def used_minerals_technology(self):\n        return self._proto.used_minerals.technology",
  "def used_minerals_upgrade(self):\n        return self._proto.used_minerals.upgrade",
  "def used_vespene_none(self):\n        return self._proto.used_vespene.none",
  "def used_vespene_army(self):\n        return self._proto.used_vespene.army",
  "def used_vespene_economy(self):\n        return self._proto.used_vespene.economy",
  "def used_vespene_technology(self):\n        return self._proto.used_vespene.technology",
  "def used_vespene_upgrade(self):\n        return self._proto.used_vespene.upgrade",
  "def total_used_minerals_none(self):\n        return self._proto.total_used_minerals.none",
  "def total_used_minerals_army(self):\n        return self._proto.total_used_minerals.army",
  "def total_used_minerals_economy(self):\n        return self._proto.total_used_minerals.economy",
  "def total_used_minerals_technology(self):\n        return self._proto.total_used_minerals.technology",
  "def total_used_minerals_upgrade(self):\n        return self._proto.total_used_minerals.upgrade",
  "def total_used_vespene_none(self):\n        return self._proto.total_used_vespene.none",
  "def total_used_vespene_army(self):\n        return self._proto.total_used_vespene.army",
  "def total_used_vespene_economy(self):\n        return self._proto.total_used_vespene.economy",
  "def total_used_vespene_technology(self):\n        return self._proto.total_used_vespene.technology",
  "def total_used_vespene_upgrade(self):\n        return self._proto.total_used_vespene.upgrade",
  "def total_damage_dealt_life(self):\n        return self._proto.total_damage_dealt.life",
  "def total_damage_dealt_shields(self):\n        return self._proto.total_damage_dealt.shields",
  "def total_damage_dealt_energy(self):\n        return self._proto.total_damage_dealt.energy",
  "def total_damage_taken_life(self):\n        return self._proto.total_damage_taken.life",
  "def total_damage_taken_shields(self):\n        return self._proto.total_damage_taken.shields",
  "def total_damage_taken_energy(self):\n        return self._proto.total_damage_taken.energy",
  "def total_healed_life(self):\n        return self._proto.total_healed.life",
  "def total_healed_shields(self):\n        return self._proto.total_healed.shields",
  "def total_healed_energy(self):\n        return self._proto.total_healed.energy",
  "def current_apm(self):\n        return self._proto.current_apm",
  "def current_effective_apm(self):\n        return self._proto.current_effective_apm",
  "class IdGenerator:\n\n    def __init__(self, game_data: GameData = None, game_version: str = None, verbose: bool = False):\n        self.game_data: GameData = game_data\n        self.game_version = game_version\n        self.verbose = verbose\n\n        self.HEADER = f'# DO NOT EDIT!\\n# This file was automatically generated by \"{Path(__file__).name}\"\\n'\n\n        self.PF = platform.system()\n\n        self.HOME_DIR = str(Path.home())\n        self.DATA_JSON = {\n            \"Darwin\": self.HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\n            \"Windows\": self.HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\n            \"Linux\": self.HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\n        }\n\n        self.ENUM_TRANSLATE = {\n            \"Units\": \"UnitTypeId\",\n            \"Abilities\": \"AbilityId\",\n            \"Upgrades\": \"UpgradeId\",\n            \"Buffs\": \"BuffId\",\n            \"Effects\": \"EffectId\",\n        }\n\n        self.FILE_TRANSLATE = {\n            \"Units\": \"unit_typeid\",\n            \"Abilities\": \"ability_id\",\n            \"Upgrades\": \"upgrade_id\",\n            \"Buffs\": \"buff_id\",\n            \"Effects\": \"effect_id\",\n        }\n\n    def make_key(self, key):\n        if key[0].isdigit():\n            key = \"_\" + key\n        # In patch 5.0, the key has \"@\" character in it which is not possible with python enums\n        return key.upper().replace(\" \", \"_\").replace(\"@\", \"\")\n\n    def parse_data(self, data):\n        # for d in data:  # Units, Abilities, Upgrades, Buffs, Effects\n\n        units = self.parse_simple(\"Units\", data)\n        upgrades = self.parse_simple(\"Upgrades\", data)\n        effects = self.parse_simple(\"Effects\", data)\n        buffs = self.parse_simple(\"Buffs\", data)\n\n        abilities = {}\n        for v in data[\"Abilities\"]:\n            key = v[\"buttonname\"]\n            remapid = v.get(\"remapid\")\n\n            if (not key) and (remapid is None):\n                assert v[\"buttonname\"] == \"\"\n                continue\n\n            if not key:\n                if v[\"friendlyname\"] != \"\":\n                    key = v[\"friendlyname\"]\n                else:\n                    exit(f\"Not mapped: {v !r}\")\n\n            key = key.upper().replace(\" \", \"_\").replace(\"@\", \"\")\n\n            if \"name\" in v:\n                key = f'{v[\"name\"].upper().replace(\" \", \"_\")}_{key}'\n\n            if \"friendlyname\" in v:\n                key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\n\n            if key[0].isdigit():\n                key = \"_\" + key\n\n            if key in abilities and v[\"index\"] == 0:\n                print(f\"{key} has value 0 and id {v['id']}, overwriting {key}: {abilities[key]}\")\n                # Commented out to try to fix: 3670 is not a valid AbilityId\n                abilities[key] = v[\"id\"]\n            elif key in abilities:\n                print(f\"{key} has appeared a second time with id={v['id']}\")\n            else:\n                abilities[key] = v[\"id\"]\n\n        abilities[\"SMART\"] = 1\n\n        enums = {}\n        enums[\"Units\"] = units\n        enums[\"Abilities\"] = abilities\n        enums[\"Upgrades\"] = upgrades\n        enums[\"Buffs\"] = buffs\n        enums[\"Effects\"] = effects\n\n        return enums\n\n    def parse_simple(self, d, data):\n        units = {}\n        for v in data[d]:\n            key = v[\"name\"]\n\n            if not key:\n                continue\n            key_to_insert = self.make_key(key)\n            if key_to_insert in units:\n                index = 2\n                tmp = f\"{key_to_insert}_{index}\"\n                while tmp in units:\n                    index += 1\n                    tmp = f\"{key_to_insert}_{index}\"\n                key_to_insert = tmp\n            units[key_to_insert] = v[\"id\"]\n\n        return units\n\n    def generate_python_code(self, enums):\n        assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\n\n        sc2dir = Path(__file__).parent\n        idsdir = sc2dir / \"ids\"\n        idsdir.mkdir(exist_ok=True)\n\n        with (idsdir / \"__init__.py\").open(\"w\") as f:\n            initstring = f\"__all__ = {[n.lower() for n in self.FILE_TRANSLATE.values()] !r}\\n\".replace(\"'\", '\"')\n            f.write(\"\\n\".join([self.HEADER, initstring]))\n\n        for name, body in enums.items():\n            class_name = self.ENUM_TRANSLATE[name]\n\n            code = [self.HEADER, \"import enum\", \"\\n\", f\"class {class_name}(enum.Enum):\"]\n\n            for key, value in sorted(body.items(), key=lambda p: p[1]):\n                code.append(f\"    {key} = {value}\")\n\n            # Add repr function to more easily dump enums to dict\n            code += [\"\\n\", \"    def __repr__(self):\", '        return f\"' + class_name + '.{self.name}\"']\n\n            code += [\n                \"\\n\",\n                f\"for item in {class_name}:\",\n                # f\"    assert not item.name in globals()\",\n                f\"    globals()[item.name] = item\",\n                \"\",\n            ]\n\n            ids_file_path = (idsdir / self.FILE_TRANSLATE[name]).with_suffix(\".py\")\n            with ids_file_path.open(\"w\") as f:\n                f.write(\"\\n\".join(code))\n\n            # Apply formatting]\n            try:\n                subprocess.run([\"poetry\", \"run\", \"yapf\", ids_file_path, \"-i\"])\n            except FileNotFoundError:\n                print(\n                    f\"Yapf is not installed. Please use 'pip install yapf' to install yapf formatter.\\nCould not autoformat file {ids_file_path}\"\n                )\n\n        if self.game_version is not None:\n            version_path = Path(__file__).parent / \"ids\" / \"id_version.py\"\n            with open(version_path, \"w\") as f:\n                f.write(f'ID_VERSION_STRING = \"{self.game_version}\"\\n')\n\n    def update_ids_from_stableid_json(self):\n        if self.game_version is None or ID_VERSION_STRING is None or ID_VERSION_STRING != self.game_version:\n            if self.verbose and self.game_version is not None and ID_VERSION_STRING is not None:\n                logger.info(\n                    f\"Game version is different (Old: {self.game_version}, new: {ID_VERSION_STRING}. Updating ids to match game version\"\n                )\n            with open(self.DATA_JSON[self.PF], encoding=\"utf-8\") as data_file:\n                data = json.loads(data_file.read())\n                self.generate_python_code(self.parse_data(data))\n\n            # Update game_data if this is a live game\n            if self.game_data is not None:\n                self.reimport_ids()\n                self.update_game_data()\n\n    def reimport_ids(self):\n\n        # Reload the newly written \"id\" files\n        # TODO This only re-imports modules, but if they haven't been imported, it will yield an error\n        from sc2.ids.ability_id import AbilityId\n\n        importlib.reload(sys.modules[\"sc2.ids.ability_id\"])\n\n        importlib.reload(sys.modules[\"sc2.ids.unit_typeid\"])\n\n        importlib.reload(sys.modules[\"sc2.ids.upgrade_id\"])\n\n        importlib.reload(sys.modules[\"sc2.ids.effect_id\"])\n\n        importlib.reload(sys.modules[\"sc2.ids.buff_id\"])\n\n        # importlib.reload(sys.modules[\"sc2.ids.id_version\"])\n\n        importlib.reload(sys.modules[\"sc2.constants\"])\n\n    def update_game_data(self):\n        \"\"\"Re-generate the dicts from self.game_data.\n        This should be done after the ids have been reimported.\"\"\"\n        from sc2.ids.ability_id import AbilityId\n\n        ids = set(a.value for a in AbilityId if a.value != 0)\n        self.game_data.abilities = {\n            a.ability_id: AbilityData(self.game_data, a)\n            for a in self.game_data._proto.abilities if a.ability_id in ids\n        }\n        # self.game_data.abilities = {\n        #     a.ability_id: AbilityData(self.game_data, a) for a in self.game_data._proto.abilities\n        # }\n        self.game_data.units = {\n            u.unit_id: UnitTypeData(self.game_data, u)\n            for u in self.game_data._proto.units if u.available\n        }\n        self.game_data.upgrades = {u.upgrade_id: UpgradeData(self.game_data, u) for u in self.game_data._proto.upgrades}\n        self.game_data.unit_types = {}",
  "def __init__(self, game_data: GameData = None, game_version: str = None, verbose: bool = False):\n        self.game_data: GameData = game_data\n        self.game_version = game_version\n        self.verbose = verbose\n\n        self.HEADER = f'# DO NOT EDIT!\\n# This file was automatically generated by \"{Path(__file__).name}\"\\n'\n\n        self.PF = platform.system()\n\n        self.HOME_DIR = str(Path.home())\n        self.DATA_JSON = {\n            \"Darwin\": self.HOME_DIR + \"/Library/Application Support/Blizzard/StarCraft II/stableid.json\",\n            \"Windows\": self.HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\n            \"Linux\": self.HOME_DIR + \"/Documents/StarCraft II/stableid.json\",\n        }\n\n        self.ENUM_TRANSLATE = {\n            \"Units\": \"UnitTypeId\",\n            \"Abilities\": \"AbilityId\",\n            \"Upgrades\": \"UpgradeId\",\n            \"Buffs\": \"BuffId\",\n            \"Effects\": \"EffectId\",\n        }\n\n        self.FILE_TRANSLATE = {\n            \"Units\": \"unit_typeid\",\n            \"Abilities\": \"ability_id\",\n            \"Upgrades\": \"upgrade_id\",\n            \"Buffs\": \"buff_id\",\n            \"Effects\": \"effect_id\",\n        }",
  "def make_key(self, key):\n        if key[0].isdigit():\n            key = \"_\" + key\n        # In patch 5.0, the key has \"@\" character in it which is not possible with python enums\n        return key.upper().replace(\" \", \"_\").replace(\"@\", \"\")",
  "def parse_data(self, data):\n        # for d in data:  # Units, Abilities, Upgrades, Buffs, Effects\n\n        units = self.parse_simple(\"Units\", data)\n        upgrades = self.parse_simple(\"Upgrades\", data)\n        effects = self.parse_simple(\"Effects\", data)\n        buffs = self.parse_simple(\"Buffs\", data)\n\n        abilities = {}\n        for v in data[\"Abilities\"]:\n            key = v[\"buttonname\"]\n            remapid = v.get(\"remapid\")\n\n            if (not key) and (remapid is None):\n                assert v[\"buttonname\"] == \"\"\n                continue\n\n            if not key:\n                if v[\"friendlyname\"] != \"\":\n                    key = v[\"friendlyname\"]\n                else:\n                    exit(f\"Not mapped: {v !r}\")\n\n            key = key.upper().replace(\" \", \"_\").replace(\"@\", \"\")\n\n            if \"name\" in v:\n                key = f'{v[\"name\"].upper().replace(\" \", \"_\")}_{key}'\n\n            if \"friendlyname\" in v:\n                key = v[\"friendlyname\"].upper().replace(\" \", \"_\")\n\n            if key[0].isdigit():\n                key = \"_\" + key\n\n            if key in abilities and v[\"index\"] == 0:\n                print(f\"{key} has value 0 and id {v['id']}, overwriting {key}: {abilities[key]}\")\n                # Commented out to try to fix: 3670 is not a valid AbilityId\n                abilities[key] = v[\"id\"]\n            elif key in abilities:\n                print(f\"{key} has appeared a second time with id={v['id']}\")\n            else:\n                abilities[key] = v[\"id\"]\n\n        abilities[\"SMART\"] = 1\n\n        enums = {}\n        enums[\"Units\"] = units\n        enums[\"Abilities\"] = abilities\n        enums[\"Upgrades\"] = upgrades\n        enums[\"Buffs\"] = buffs\n        enums[\"Effects\"] = effects\n\n        return enums",
  "def parse_simple(self, d, data):\n        units = {}\n        for v in data[d]:\n            key = v[\"name\"]\n\n            if not key:\n                continue\n            key_to_insert = self.make_key(key)\n            if key_to_insert in units:\n                index = 2\n                tmp = f\"{key_to_insert}_{index}\"\n                while tmp in units:\n                    index += 1\n                    tmp = f\"{key_to_insert}_{index}\"\n                key_to_insert = tmp\n            units[key_to_insert] = v[\"id\"]\n\n        return units",
  "def generate_python_code(self, enums):\n        assert {\"Units\", \"Abilities\", \"Upgrades\", \"Buffs\", \"Effects\"} <= enums.keys()\n\n        sc2dir = Path(__file__).parent\n        idsdir = sc2dir / \"ids\"\n        idsdir.mkdir(exist_ok=True)\n\n        with (idsdir / \"__init__.py\").open(\"w\") as f:\n            initstring = f\"__all__ = {[n.lower() for n in self.FILE_TRANSLATE.values()] !r}\\n\".replace(\"'\", '\"')\n            f.write(\"\\n\".join([self.HEADER, initstring]))\n\n        for name, body in enums.items():\n            class_name = self.ENUM_TRANSLATE[name]\n\n            code = [self.HEADER, \"import enum\", \"\\n\", f\"class {class_name}(enum.Enum):\"]\n\n            for key, value in sorted(body.items(), key=lambda p: p[1]):\n                code.append(f\"    {key} = {value}\")\n\n            # Add repr function to more easily dump enums to dict\n            code += [\"\\n\", \"    def __repr__(self):\", '        return f\"' + class_name + '.{self.name}\"']\n\n            code += [\n                \"\\n\",\n                f\"for item in {class_name}:\",\n                # f\"    assert not item.name in globals()\",\n                f\"    globals()[item.name] = item\",\n                \"\",\n            ]\n\n            ids_file_path = (idsdir / self.FILE_TRANSLATE[name]).with_suffix(\".py\")\n            with ids_file_path.open(\"w\") as f:\n                f.write(\"\\n\".join(code))\n\n            # Apply formatting]\n            try:\n                subprocess.run([\"poetry\", \"run\", \"yapf\", ids_file_path, \"-i\"])\n            except FileNotFoundError:\n                print(\n                    f\"Yapf is not installed. Please use 'pip install yapf' to install yapf formatter.\\nCould not autoformat file {ids_file_path}\"\n                )\n\n        if self.game_version is not None:\n            version_path = Path(__file__).parent / \"ids\" / \"id_version.py\"\n            with open(version_path, \"w\") as f:\n                f.write(f'ID_VERSION_STRING = \"{self.game_version}\"\\n')",
  "def update_ids_from_stableid_json(self):\n        if self.game_version is None or ID_VERSION_STRING is None or ID_VERSION_STRING != self.game_version:\n            if self.verbose and self.game_version is not None and ID_VERSION_STRING is not None:\n                logger.info(\n                    f\"Game version is different (Old: {self.game_version}, new: {ID_VERSION_STRING}. Updating ids to match game version\"\n                )\n            with open(self.DATA_JSON[self.PF], encoding=\"utf-8\") as data_file:\n                data = json.loads(data_file.read())\n                self.generate_python_code(self.parse_data(data))\n\n            # Update game_data if this is a live game\n            if self.game_data is not None:\n                self.reimport_ids()\n                self.update_game_data()",
  "def reimport_ids(self):\n\n        # Reload the newly written \"id\" files\n        # TODO This only re-imports modules, but if they haven't been imported, it will yield an error\n        from sc2.ids.ability_id import AbilityId\n\n        importlib.reload(sys.modules[\"sc2.ids.ability_id\"])\n\n        importlib.reload(sys.modules[\"sc2.ids.unit_typeid\"])\n\n        importlib.reload(sys.modules[\"sc2.ids.upgrade_id\"])\n\n        importlib.reload(sys.modules[\"sc2.ids.effect_id\"])\n\n        importlib.reload(sys.modules[\"sc2.ids.buff_id\"])\n\n        # importlib.reload(sys.modules[\"sc2.ids.id_version\"])\n\n        importlib.reload(sys.modules[\"sc2.constants\"])",
  "def update_game_data(self):\n        \"\"\"Re-generate the dicts from self.game_data.\n        This should be done after the ids have been reimported.\"\"\"\n        from sc2.ids.ability_id import AbilityId\n\n        ids = set(a.value for a in AbilityId if a.value != 0)\n        self.game_data.abilities = {\n            a.ability_id: AbilityData(self.game_data, a)\n            for a in self.game_data._proto.abilities if a.ability_id in ids\n        }\n        # self.game_data.abilities = {\n        #     a.ability_id: AbilityData(self.game_data, a) for a in self.game_data._proto.abilities\n        # }\n        self.game_data.units = {\n            u.unit_id: UnitTypeData(self.game_data, u)\n            for u in self.game_data._proto.units if u.available\n        }\n        self.game_data.upgrades = {u.upgrade_id: UpgradeData(self.game_data, u) for u in self.game_data._proto.upgrades}\n        self.game_data.unit_types = {}",
  "class ExpiringDict(OrderedDict):\n    \"\"\"\n    An expiring dict that uses the bot.state.game_loop to only return items that are valid for a specific amount of time.\n\n    Example usages::\n\n        async def on_step(iteration: int):\n            # This dict will hold up to 10 items and only return values that have been added up to 20 frames ago\n            my_dict = ExpiringDict(self, max_age_frames=20)\n            if iteration == 0:\n                # Add item\n                my_dict[\"test\"] = \"something\"\n            if iteration == 2:\n                # On default, one iteration is called every 8 frames\n                if \"test\" in my_dict:\n                    print(\"test is in dict\")\n            if iteration == 20:\n                if \"test\" not in my_dict:\n                    print(\"test is not anymore in dict\")\n    \"\"\"\n\n    def __init__(self, bot: \"BotAI\", max_age_frames: int = 1):\n        assert max_age_frames >= -1\n        assert bot\n\n        OrderedDict.__init__(self)\n        self.bot: BotAI = bot\n        self.max_age: Union[int, float] = max_age_frames\n        self.lock: RLock = RLock()\n\n    @property\n    def frame(self) -> int:\n        return self.bot.state.game_loop\n\n    def __contains__(self, key) -> bool:\n        \"\"\" Return True if dict has key, else False, e.g. 'key in dict' \"\"\"\n        with self.lock:\n            if OrderedDict.__contains__(self, key):\n                # Each item is a list of [value, frame time]\n                item = OrderedDict.__getitem__(self, key)\n                if self.frame - item[1] < self.max_age:\n                    return True\n                else:\n                    del self[key]\n        return False\n\n    def __getitem__(self, key, with_age=False) -> any:\n        \"\"\" Return the item of the dict using d[key] \"\"\"\n        with self.lock:\n            try:\n                # Each item is a list of [value, frame time]\n                item = OrderedDict.__getitem__(self, key)\n                if self.frame - item[1] < self.max_age:\n                    if with_age:\n                        return item[0], item[1]\n                    return item[0]\n                else:\n                    del self[key]\n            except:\n                pass\n        raise KeyError(key)\n\n    def __setitem__(self, key, value):\n        \"\"\" Set d[key] = value \"\"\"\n        with self.lock:\n            OrderedDict.__setitem__(self, key, (value, self.frame))\n\n    def __repr__(self):\n        \"\"\" Printable version of the dict instead of getting memory adress \"\"\"\n        print_list = []\n        with self.lock:\n            for key, value in OrderedDict.items(self):\n                if self.frame - value[1] < self.max_age:\n                    try:\n                        print_list.append(f\"{repr(key)}: {repr(value)}\")\n                    except:\n                        print_list.append(f\"{key}: {value}\")\n        print_str = \", \".join(print_list)\n        return f\"ExpiringDict({print_str})\"\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __iter__(self):\n        \"\"\" Override 'for key in dict:' \"\"\"\n        with self.lock:\n            return self.keys()\n\n    # TODO find a way to improve len\n    def __len__(self):\n        \"\"\"Override len method as key value pairs aren't instantly being deleted, but only on __get__(item).\n        This function is slow because it has to check if each element is not expired yet.\"\"\"\n        with self.lock:\n            count = 0\n            for _ in self.values():\n                count += 1\n            return count\n\n    def pop(self, key, default=None, with_age=False):\n        \"\"\" Return the item and remove it \"\"\"\n        with self.lock:\n            if OrderedDict.__contains__(self, key):\n                item = OrderedDict.__getitem__(self, key)\n                if self.frame - item[1] < self.max_age:\n                    del self[key]\n                    if with_age:\n                        return item[0], item[1]\n                    return item[0]\n                del self[key]\n            if default is None:\n                raise KeyError(key)\n            elif with_age:\n                return default, self.frame\n            return default\n\n    def get(self, key, default=None, with_age=False):\n        \"\"\" Return the value for key if key is in dict, else default \"\"\"\n        with self.lock:\n            if OrderedDict.__contains__(self, key):\n                item = OrderedDict.__getitem__(self, key)\n                if self.frame - item[1] < self.max_age:\n                    if with_age:\n                        return item[0], item[1]\n                    return item[0]\n            if default is None:\n                raise KeyError(key)\n            elif with_age:\n                return default, self.frame\n            return\n\n    def update(self, other_dict: dict):\n        with self.lock:\n            for key, value in other_dict.items():\n                self[key] = value\n\n    def items(self) -> Iterable:\n        \"\"\" Return iterator of zipped list [keys, values] \"\"\"\n        with self.lock:\n            for key, value in OrderedDict.items(self):\n                if self.frame - value[1] < self.max_age:\n                    yield key, value[0]\n\n    def keys(self) -> Iterable:\n        \"\"\" Return iterator of keys \"\"\"\n        with self.lock:\n            for key, value in OrderedDict.items(self):\n                if self.frame - value[1] < self.max_age:\n                    yield key\n\n    def values(self) -> Iterable:\n        \"\"\" Return iterator of values \"\"\"\n        with self.lock:\n            for value in OrderedDict.values(self):\n                if self.frame - value[1] < self.max_age:\n                    yield value[0]",
  "def __init__(self, bot: \"BotAI\", max_age_frames: int = 1):\n        assert max_age_frames >= -1\n        assert bot\n\n        OrderedDict.__init__(self)\n        self.bot: BotAI = bot\n        self.max_age: Union[int, float] = max_age_frames\n        self.lock: RLock = RLock()",
  "def frame(self) -> int:\n        return self.bot.state.game_loop",
  "def __contains__(self, key) -> bool:\n        \"\"\" Return True if dict has key, else False, e.g. 'key in dict' \"\"\"\n        with self.lock:\n            if OrderedDict.__contains__(self, key):\n                # Each item is a list of [value, frame time]\n                item = OrderedDict.__getitem__(self, key)\n                if self.frame - item[1] < self.max_age:\n                    return True\n                else:\n                    del self[key]\n        return False",
  "def __getitem__(self, key, with_age=False) -> any:\n        \"\"\" Return the item of the dict using d[key] \"\"\"\n        with self.lock:\n            try:\n                # Each item is a list of [value, frame time]\n                item = OrderedDict.__getitem__(self, key)\n                if self.frame - item[1] < self.max_age:\n                    if with_age:\n                        return item[0], item[1]\n                    return item[0]\n                else:\n                    del self[key]\n            except:\n                pass\n        raise KeyError(key)",
  "def __setitem__(self, key, value):\n        \"\"\" Set d[key] = value \"\"\"\n        with self.lock:\n            OrderedDict.__setitem__(self, key, (value, self.frame))",
  "def __repr__(self):\n        \"\"\" Printable version of the dict instead of getting memory adress \"\"\"\n        print_list = []\n        with self.lock:\n            for key, value in OrderedDict.items(self):\n                if self.frame - value[1] < self.max_age:\n                    try:\n                        print_list.append(f\"{repr(key)}: {repr(value)}\")\n                    except:\n                        print_list.append(f\"{key}: {value}\")\n        print_str = \", \".join(print_list)\n        return f\"ExpiringDict({print_str})\"",
  "def __str__(self):\n        return self.__repr__()",
  "def __iter__(self):\n        \"\"\" Override 'for key in dict:' \"\"\"\n        with self.lock:\n            return self.keys()",
  "def __len__(self):\n        \"\"\"Override len method as key value pairs aren't instantly being deleted, but only on __get__(item).\n        This function is slow because it has to check if each element is not expired yet.\"\"\"\n        with self.lock:\n            count = 0\n            for _ in self.values():\n                count += 1\n            return count",
  "def pop(self, key, default=None, with_age=False):\n        \"\"\" Return the item and remove it \"\"\"\n        with self.lock:\n            if OrderedDict.__contains__(self, key):\n                item = OrderedDict.__getitem__(self, key)\n                if self.frame - item[1] < self.max_age:\n                    del self[key]\n                    if with_age:\n                        return item[0], item[1]\n                    return item[0]\n                del self[key]\n            if default is None:\n                raise KeyError(key)\n            elif with_age:\n                return default, self.frame\n            return default",
  "def get(self, key, default=None, with_age=False):\n        \"\"\" Return the value for key if key is in dict, else default \"\"\"\n        with self.lock:\n            if OrderedDict.__contains__(self, key):\n                item = OrderedDict.__getitem__(self, key)\n                if self.frame - item[1] < self.max_age:\n                    if with_age:\n                        return item[0], item[1]\n                    return item[0]\n            if default is None:\n                raise KeyError(key)\n            elif with_age:\n                return default, self.frame\n            return",
  "def update(self, other_dict: dict):\n        with self.lock:\n            for key, value in other_dict.items():\n                self[key] = value",
  "def items(self) -> Iterable:\n        \"\"\" Return iterator of zipped list [keys, values] \"\"\"\n        with self.lock:\n            for key, value in OrderedDict.items(self):\n                if self.frame - value[1] < self.max_age:\n                    yield key, value[0]",
  "def keys(self) -> Iterable:\n        \"\"\" Return iterator of keys \"\"\"\n        with self.lock:\n            for key, value in OrderedDict.items(self):\n                if self.frame - value[1] < self.max_age:\n                    yield key",
  "def values(self) -> Iterable:\n        \"\"\" Return iterator of values \"\"\"\n        with self.lock:\n            for value in OrderedDict.values(self):\n                if self.frame - value[1] < self.max_age:\n                    yield value[0]",
  "class GameMatch:\n    \"\"\"Dataclass for hosting a match of SC2.\n    This contains all of the needed information for RequestCreateGame.\n    :param sc2_config: dicts of arguments to unpack into sc2process's construction, one per player\n        second sc2_config will be ignored if only one sc2_instance is spawned\n        e.g. sc2_args=[{\"fullscreen\": True}, {}]: only player 1's sc2instance will be fullscreen\n    :param game_time_limit: The time (in seconds) until a match is artificially declared a Tie\n    \"\"\"\n\n    map_sc2: Map\n    players: List[AbstractPlayer]\n    realtime: bool = False\n    random_seed: int = None\n    disable_fog: bool = None\n    sc2_config: List[Dict] = None\n    game_time_limit: int = None\n\n    def __post_init__(self):\n        # avoid players sharing names\n        if len(self.players) > 1 and self.players[0].name is not None and self.players[0].name == self.players[1].name:\n            self.players[1].name += \"2\"\n\n        if self.sc2_config is not None:\n            if isinstance(self.sc2_config, dict):\n                self.sc2_config = [self.sc2_config]\n            if len(self.sc2_config) == 0:\n                self.sc2_config = [{}]\n            while len(self.sc2_config) < len(self.players):\n                self.sc2_config += self.sc2_config\n            self.sc2_config = self.sc2_config[:len(self.players)]\n\n    @property\n    def needed_sc2_count(self) -> int:\n        return sum(player.needs_sc2 for player in self.players)\n\n    @property\n    def host_game_kwargs(self) -> Dict:\n        return {\n            \"map_settings\": self.map_sc2,\n            \"players\": self.players,\n            \"realtime\": self.realtime,\n            \"random_seed\": self.random_seed,\n            \"disable_fog\": self.disable_fog,\n        }\n\n    def __repr__(self):\n        p1 = self.players[0]\n        p1 = p1.name if p1.name else p1\n        p2 = self.players[1]\n        p2 = p2.name if p2.name else p2\n        return f\"Map: {self.map_sc2.name}, {p1} vs {p2}, realtime:{self.realtime}, seed={self.random_seed}\"",
  "class SlidingTimeWindow:\n\n    def __init__(self, size: int):\n        assert size > 0\n\n        self.window_size = size\n        self.window = []\n\n    def push(self, value: float):\n        self.window = (self.window + [value])[-self.window_size:]\n\n    def clear(self):\n        self.window = []\n\n    @property\n    def sum(self) -> float:\n        return sum(self.window)\n\n    @property\n    def available(self) -> float:\n        return sum(self.window[1:])\n\n    @property\n    def available_fmt(self) -> float:\n        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])",
  "async def _play_game_human(client, player_id, realtime, game_time_limit):\n    while True:\n        state = await client.observation()\n        if client._game_result:\n            return client._game_result[player_id]\n\n        if game_time_limit and (state.observation.observation.game_loop * 0.725 * (1 / 16)) > game_time_limit:\n            print(state.observation.game_loop, state.observation.game_loop * 0.14)\n            return Result.Tie\n\n        if not realtime:\n            await client.step()",
  "async def _play_game_ai(client, player_id, ai, realtime, step_time_limit, game_time_limit):\n    if realtime:\n        assert step_time_limit is None\n\n    # step_time_limit works like this:\n    # * If None, then step time is not limited\n    # * If given integer or float, the bot will simpy resign if any step takes longer than that\n    # * Otherwise step_time_limit must be an object, with following settings:\n    #\n    # Key         | Value      | Description\n    # ------------|------------|-------------\n    # penalty     | None       | No penalty, the bot can continue on next step\n    # penalty     | N: int     | Cooldown penalty, BotAI.on_step will not be called for N steps\n    # penalty     | \"resign\"   | Bot resigns when going over time limit\n    # time_limit  | int/float  | Time limit for a single step\n    # window_size | N: int     | The time limit will be used for last N steps, instad of 1\n    #\n    # Cooldown is a harsh penalty. The both loses the ability to act, but even worse,\n    # the observation data from skipped steps is also lost. It's like falling asleep in\n    # a middle of the game.\n    time_penalty_cooldown = 0\n    if step_time_limit is None:\n        time_limit = None\n        time_window = None\n        time_penalty = None\n    elif isinstance(step_time_limit, (int, float)):\n        time_limit = float(step_time_limit)\n        time_window = SlidingTimeWindow(1)\n        time_penalty = \"resign\"\n    else:\n        assert isinstance(step_time_limit, dict)\n        time_penalty = step_time_limit.get(\"penalty\", None)\n        time_window = SlidingTimeWindow(int(step_time_limit.get(\"window_size\", 1)))\n        time_limit = float(step_time_limit.get(\"time_limit\", None))\n\n    ai._initialize_variables()\n\n    game_data = await client.get_game_data()\n    game_info = await client.get_game_info()\n    ping_response = await client.ping()\n\n    # This game_data will become self._game_data in botAI\n    ai._prepare_start(\n        client, player_id, game_info, game_data, realtime=realtime, base_build=ping_response.ping.base_build\n    )\n    state = await client.observation()\n    # check game result every time we get the observation\n    if client._game_result:\n        await ai.on_end(client._game_result[player_id])\n        return client._game_result[player_id]\n    gs = GameState(state.observation)\n    proto_game_info = await client._execute(game_info=sc_pb.RequestGameInfo())\n    try:\n        ai._prepare_step(gs, proto_game_info)\n        await ai.on_before_start()\n        ai._prepare_first_step()\n        await ai.on_start()\n    except Exception as e:\n        logger.exception(f\"AI on_start threw an error\")\n        logger.error(f\"resigning due to previous error\")\n        await ai.on_end(Result.Defeat)\n        return Result.Defeat\n\n    iteration = 0\n    # Only used in realtime=True\n    previous_state_observation = None\n    while True:\n        if iteration != 0:\n            if realtime:\n                # On realtime=True, might get an error here: sc2.protocol.ProtocolError: ['Not in a game']\n                try:\n                    requested_step = gs.game_loop + client.game_step\n                    state = await client.observation(requested_step)\n                    # If the bot took too long in the previous observation, request another observation one frame after\n                    if state.observation.observation.game_loop > requested_step:\n                        logger.debug(f\"Skipped a step in realtime=True\")\n                        previous_state_observation = state.observation\n                        state = await client.observation(state.observation.observation.game_loop + 1)\n                except ProtocolError:\n                    pass\n            else:\n                state = await client.observation()\n            # check game result every time we get the observation\n            if client._game_result:\n                try:\n                    await ai.on_end(client._game_result[player_id])\n                except TypeError as error:\n                    # print(f\"caught type error {error}\")\n                    # print(f\"return {client._game_result[player_id]}\")\n                    return client._game_result[player_id]\n                return client._game_result[player_id]\n            gs = GameState(state.observation, previous_state_observation)\n            previous_state_observation = None\n            logger.debug(f\"Score: {gs.score.score}\")\n\n            if game_time_limit and (gs.game_loop * 0.725 * (1 / 16)) > game_time_limit:\n                await ai.on_end(Result.Tie)\n                return Result.Tie\n            proto_game_info = await client._execute(game_info=sc_pb.RequestGameInfo())\n            ai._prepare_step(gs, proto_game_info)\n\n        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\n\n        try:\n            if realtime:\n                # Issue event like unit created or unit destroyed\n                await ai.issue_events()\n                await ai.on_step(iteration)\n                await ai._after_step()\n            else:\n                if time_penalty_cooldown > 0:\n                    time_penalty_cooldown -= 1\n                    logger.warning(f\"Running AI step: penalty cooldown: {time_penalty_cooldown}\")\n                    iteration -= 1  # Do not increment the iteration on this round\n                elif time_limit is None:\n                    # Issue event like unit created or unit destroyed\n                    await ai.issue_events()\n                    await ai.on_step(iteration)\n                    await ai._after_step()\n                else:\n                    out_of_budget = False\n                    budget = time_limit - time_window.available\n\n                    # Tell the bot how much time it has left attribute\n                    ai.time_budget_available = budget\n\n                    if budget < 0:\n                        logger.warning(f\"Running AI step: out of budget before step\")\n                        step_time = 0.0\n                        out_of_budget = True\n                    else:\n                        step_start = time.monotonic()\n                        try:\n                            async with async_timeout.timeout(budget):\n                                await ai.issue_events()\n                                await ai.on_step(iteration)\n                        except asyncio.TimeoutError:\n                            step_time = time.monotonic() - step_start\n                            logger.warning(\n                                f\"Running AI step: out of budget; \" +\n                                f\"budget={budget:.2f}, steptime={step_time:.2f}, \" +\n                                f\"window={time_window.available_fmt}\"\n                            )\n                            out_of_budget = True\n                        step_time = time.monotonic() - step_start\n\n                    time_window.push(step_time)\n\n                    if out_of_budget and time_penalty is not None:\n                        if time_penalty == \"resign\":\n                            raise RuntimeError(\"Out of time\")\n                        else:\n                            time_penalty_cooldown = int(time_penalty)\n                            time_window.clear()\n\n                    await ai._after_step()\n        except Exception as e:\n            if isinstance(e, ProtocolError) and e.is_game_over_error:\n                if realtime:\n                    return None\n                result = client._game_result[player_id]\n                if result is None:\n                    logger.error(\"Game over, but no results gathered\")\n                    raise\n                await ai.on_end(result)\n                return result\n            # NOTE: this message is caught by pytest suite\n            logger.exception(f\"AI step threw an error\")  # DO NOT EDIT!\n            logger.error(f\"Error: {e}\")\n            logger.error(f\"Resigning due to previous error\")\n            try:\n                await ai.on_end(Result.Defeat)\n            except TypeError as error:\n                # print(f\"caught type error {error}\")\n                # print(f\"return {Result.Defeat}\")\n                return Result.Defeat\n            return Result.Defeat\n\n        logger.debug(f\"Running AI step: done\")\n\n        if not realtime:\n            if not client.in_game:  # Client left (resigned) the game\n                await ai.on_end(client._game_result[player_id])\n                return client._game_result[player_id]\n\n            await client.step()\n\n        iteration += 1",
  "async def _play_game(\n    player,\n    client: Client,\n    realtime,\n    portconfig,\n    step_time_limit=None,\n    game_time_limit=None,\n    rgb_render_config=None\n) -> Result:\n    assert isinstance(realtime, bool), repr(realtime)\n\n    player_id = await client.join_game(\n        player.name, player.race, portconfig=portconfig, rgb_render_config=rgb_render_config\n    )\n    logger.info(f\"Player {player_id} - {player.name if player.name else str(player)}\")\n\n    if isinstance(player, Human):\n        result = await _play_game_human(client, player_id, realtime, game_time_limit)\n    else:\n        result = await _play_game_ai(client, player_id, player.ai, realtime, step_time_limit, game_time_limit)\n\n    logger.info(\n        f\"Result for player {player_id} - {player.name if player.name else str(player)}: \"\n        f\"{result._name_ if isinstance(result, Result) else result}\"\n    )\n\n    return result",
  "async def _play_replay(client, ai, realtime=False, player_id=0):\n    ai._initialize_variables()\n\n    game_data = await client.get_game_data()\n    game_info = await client.get_game_info()\n    ping_response = await client.ping()\n\n    client.game_step = 1\n    # This game_data will become self._game_data in botAI\n    ai._prepare_start(\n        client, player_id, game_info, game_data, realtime=realtime, base_build=ping_response.ping.base_build\n    )\n    state = await client.observation()\n    # Check game result every time we get the observation\n    if client._game_result:\n        await ai.on_end(client._game_result[player_id])\n        return client._game_result[player_id]\n    gs = GameState(state.observation)\n    proto_game_info = await client._execute(game_info=sc_pb.RequestGameInfo())\n    ai._prepare_step(gs, proto_game_info)\n    ai._prepare_first_step()\n    try:\n        await ai.on_start()\n    except Exception as e:\n        logger.exception(f\"AI on_start threw an error\")\n        logger.error(f\"resigning due to previous error\")\n        await ai.on_end(Result.Defeat)\n        return Result.Defeat\n\n    iteration = 0\n    while True:\n        if iteration != 0:\n            if realtime:\n                # TODO: check what happens if a bot takes too long to respond, so that the requested\n                #  game_loop might already be in the past\n                state = await client.observation(gs.game_loop + client.game_step)\n            else:\n                state = await client.observation()\n            # check game result every time we get the observation\n            if client._game_result:\n                try:\n                    await ai.on_end(client._game_result[player_id])\n                except TypeError as error:\n                    # print(f\"caught type error {error}\")\n                    # print(f\"return {client._game_result[player_id]}\")\n                    return client._game_result[player_id]\n                return client._game_result[player_id]\n            gs = GameState(state.observation)\n            logger.debug(f\"Score: {gs.score.score}\")\n\n            proto_game_info = await client._execute(game_info=sc_pb.RequestGameInfo())\n            ai._prepare_step(gs, proto_game_info)\n\n        logger.debug(f\"Running AI step, it={iteration} {gs.game_loop * 0.725 * (1 / 16):.2f}s\")\n\n        try:\n            # Issue event like unit created or unit destroyed\n            await ai.issue_events()\n            await ai.on_step(iteration)\n            await ai._after_step()\n\n        except Exception as e:\n            if isinstance(e, ProtocolError) and e.is_game_over_error:\n                if realtime:\n                    return None\n                # result = client._game_result[player_id]\n                # if result is None:\n                #     logger.error(\"Game over, but no results gathered\")\n                #     raise\n                await ai.on_end(Result.Victory)\n                return None\n            # NOTE: this message is caught by pytest suite\n            logger.exception(f\"AI step threw an error\")  # DO NOT EDIT!\n            logger.error(f\"Error: {e}\")\n            logger.error(f\"Resigning due to previous error\")\n            try:\n                await ai.on_end(Result.Defeat)\n            except TypeError as error:\n                # print(f\"caught type error {error}\")\n                # print(f\"return {Result.Defeat}\")\n                return Result.Defeat\n            return Result.Defeat\n\n        logger.debug(f\"Running AI step: done\")\n\n        if not realtime:\n            if not client.in_game:  # Client left (resigned) the game\n                await ai.on_end(Result.Victory)\n                return Result.Victory\n\n        await client.step()  # unindent one line to work in realtime\n\n        iteration += 1",
  "async def _setup_host_game(server: Controller, map_settings, players, realtime, random_seed=None, disable_fog=None):\n    r = await server.create_game(map_settings, players, realtime, random_seed, disable_fog)\n    if r.create_game.HasField(\"error\"):\n        err = f\"Could not create game: {CreateGameError(r.create_game.error)}\"\n        if r.create_game.HasField(\"error_details\"):\n            err += f\": {r.create_game.error_details}\"\n        logger.critical(err)\n        raise RuntimeError(err)\n\n    return Client(server._ws)",
  "async def _host_game(\n    map_settings,\n    players,\n    realtime=False,\n    portconfig=None,\n    save_replay_as=None,\n    step_time_limit=None,\n    game_time_limit=None,\n    rgb_render_config=None,\n    random_seed=None,\n    sc2_version=None,\n    disable_fog=None,\n):\n\n    assert players, \"Can't create a game without players\"\n\n    assert any(isinstance(p, (Human, Bot)) for p in players)\n\n    async with SC2Process(\n        fullscreen=players[0].fullscreen, render=rgb_render_config is not None, sc2_version=sc2_version\n    ) as server:\n        await server.ping()\n\n        client = await _setup_host_game(server, map_settings, players, realtime, random_seed, disable_fog)\n        # Bot can decide if it wants to launch with 'raw_affects_selection=True'\n        if not isinstance(players[0], Human) and getattr(players[0].ai, \"raw_affects_selection\", None) is not None:\n            client.raw_affects_selection = players[0].ai.raw_affects_selection\n\n        try:\n            result = await _play_game(\n                players[0], client, realtime, portconfig, step_time_limit, game_time_limit, rgb_render_config\n            )\n            if save_replay_as is not None:\n                await client.save_replay(save_replay_as)\n            await client.leave()\n            await client.quit()\n        except ConnectionAlreadyClosed:\n            logger.error(f\"Connection was closed before the game ended\")\n            return None\n\n        return result",
  "async def _host_game_aiter(\n    map_settings,\n    players,\n    realtime,\n    portconfig=None,\n    save_replay_as=None,\n    step_time_limit=None,\n    game_time_limit=None,\n):\n    assert players, \"Can't create a game without players\"\n\n    assert any(isinstance(p, (Human, Bot)) for p in players)\n\n    async with SC2Process() as server:\n        while True:\n            await server.ping()\n\n            client = await _setup_host_game(server, map_settings, players, realtime)\n            if not isinstance(players[0], Human) and getattr(players[0].ai, \"raw_affects_selection\", None) is not None:\n                client.raw_affects_selection = players[0].ai.raw_affects_selection\n\n            try:\n                result = await _play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)\n\n                if save_replay_as is not None:\n                    await client.save_replay(save_replay_as)\n                await client.leave()\n            except ConnectionAlreadyClosed:\n                logger.error(f\"Connection was closed before the game ended\")\n                return\n\n            new_players = yield result\n            if new_players is not None:\n                players = new_players",
  "def _host_game_iter(*args, **kwargs):\n    game = _host_game_aiter(*args, **kwargs)\n    new_playerconfig = None\n    while True:\n        new_playerconfig = yield asyncio.get_event_loop().run_until_complete(game.asend(new_playerconfig))",
  "async def _join_game(\n    players,\n    realtime,\n    portconfig,\n    save_replay_as=None,\n    step_time_limit=None,\n    game_time_limit=None,\n):\n    async with SC2Process(fullscreen=players[1].fullscreen) as server:\n        await server.ping()\n\n        client = Client(server._ws)\n        # Bot can decide if it wants to launch with 'raw_affects_selection=True'\n        if not isinstance(players[1], Human) and getattr(players[1].ai, \"raw_affects_selection\", None) is not None:\n            client.raw_affects_selection = players[1].ai.raw_affects_selection\n\n        try:\n            result = await _play_game(players[1], client, realtime, portconfig, step_time_limit, game_time_limit)\n            if save_replay_as is not None:\n                await client.save_replay(save_replay_as)\n            await client.leave()\n            await client.quit()\n        except ConnectionAlreadyClosed:\n            logger.error(f\"Connection was closed before the game ended\")\n            return None\n\n        return result",
  "async def _setup_replay(server, replay_path, realtime, observed_id):\n    await server.start_replay(replay_path, realtime, observed_id)\n    return Client(server._ws)",
  "async def _host_replay(replay_path, ai, realtime, portconfig, base_build, data_version, observed_id):\n    async with SC2Process(fullscreen=False, base_build=base_build, data_hash=data_version) as server:\n        response = await server.ping()\n\n        client = await _setup_replay(server, replay_path, realtime, observed_id)\n        result = await _play_replay(client, ai, realtime)\n        return result",
  "def get_replay_version(replay_path):\n    with open(replay_path, \"rb\") as f:\n        replay_data = f.read()\n        replay_io = six.BytesIO()\n        replay_io.write(replay_data)\n        replay_io.seek(0)\n        archive = mpyq.MPQArchive(replay_io).extract()\n        metadata = json.loads(archive[b\"replay.gamemetadata.json\"].decode(\"utf-8\"))\n        return metadata[\"BaseBuild\"], metadata[\"DataVersion\"]",
  "def run_game(map_settings, players, **kwargs):\n    if sum(isinstance(p, (Human, Bot)) for p in players) > 1:\n        host_only_args = [\"save_replay_as\", \"rgb_render_config\", \"random_seed\", \"sc2_version\", \"disable_fog\"]\n        join_kwargs = {k: v for k, v in kwargs.items() if k not in host_only_args}\n\n        portconfig = Portconfig()\n        result = asyncio.get_event_loop().run_until_complete(\n            asyncio.gather(\n                _host_game(map_settings, players, **kwargs, portconfig=portconfig),\n                _join_game(players, **join_kwargs, portconfig=portconfig),\n            )\n        )\n    else:\n        result = asyncio.get_event_loop().run_until_complete(_host_game(map_settings, players, **kwargs))\n    return result",
  "def run_replay(ai, replay_path, realtime=False, observed_id=0):\n    portconfig = Portconfig()\n    assert os.path.isfile(replay_path), f\"Replay does not exist at the given path: {replay_path}\"\n    assert os.path.isabs(\n        replay_path\n    ), f'Replay path has to be an absolute path, e.g. \"C:/replays/my_replay.SC2Replay\" but given path was \"{replay_path}\"'\n    base_build, data_version = get_replay_version(replay_path)\n    result = asyncio.get_event_loop().run_until_complete(\n        _host_replay(replay_path, ai, realtime, portconfig, base_build, data_version, observed_id)\n    )\n    return result",
  "async def play_from_websocket(\n    ws_connection: Union[str, ClientWebSocketResponse],\n    player: AbstractPlayer,\n    realtime: bool = False,\n    portconfig: Portconfig = None,\n    save_replay_as=None,\n    game_time_limit: int = None,\n    should_close=True,\n):\n    \"\"\"Use this to play when the match is handled externally e.g. for bot ladder games.\n    Portconfig MUST be specified if not playing vs Computer.\n    :param ws_connection: either a string(\"ws://{address}:{port}/sc2api\") or a ClientWebSocketResponse object\n    :param should_close: closes the connection if True. Use False if something else will reuse the connection\n\n    e.g. ladder usage: play_from_websocket(\"ws://127.0.0.1:5162/sc2api\", MyBot, False, portconfig=my_PC)\n    \"\"\"\n    session = None\n    try:\n        if isinstance(ws_connection, str):\n            session = ClientSession()\n            ws_connection = await session.ws_connect(ws_connection, timeout=120)\n            should_close = True\n        client = Client(ws_connection)\n        result = await _play_game(player, client, realtime, portconfig, game_time_limit=game_time_limit)\n        if save_replay_as is not None:\n            await client.save_replay(save_replay_as)\n    except ConnectionAlreadyClosed:\n        logger.error(f\"Connection was closed before the game ended\")\n        return None\n    finally:\n        if should_close:\n            await ws_connection.close()\n            if session:\n                await session.close()\n\n    return result",
  "async def run_match(controllers: List[Controller], match: GameMatch, close_ws=True):\n    await _setup_host_game(controllers[0], **match.host_game_kwargs)\n\n    # Setup portconfig beforehand, so all players use the same ports\n    startport = None\n    portconfig = None\n    if match.needed_sc2_count > 1:\n        if any(isinstance(player, BotProcess) for player in match.players):\n            portconfig = Portconfig.contiguous_ports()\n            # Most ladder bots generate their server and client ports as [s+2, s+3], [s+4, s+5]\n            startport = portconfig.server[0] - 2\n        else:\n            portconfig = Portconfig()\n\n    proxies = []\n    coros = []\n    i = 0\n    for player in match.players:\n        if player.needs_sc2:\n            if isinstance(player, BotProcess):\n                pport = portpicker.pick_unused_port()\n                p = Proxy(controllers[i], player, pport, match.game_time_limit, match.realtime)\n                proxies.append(p)\n                coros.append(p.play_with_proxy(startport))\n            else:\n                coros.append(\n                    play_from_websocket(\n                        controllers[i]._ws,\n                        player,\n                        match.realtime,\n                        portconfig,\n                        should_close=close_ws,\n                        game_time_limit=match.game_time_limit,\n                    )\n                )\n            i += 1\n\n    # async_results = await asyncio.wait_for(asyncio.gather(*coros, return_exceptions=True), timeout=None)\n    async_results = await asyncio.gather(*coros, return_exceptions=True)\n\n    if not isinstance(async_results, list):\n        async_results = [async_results]\n    for i, a in enumerate(async_results):\n        if isinstance(a, Exception):\n            logger.error(f\"Exception[{a}] thrown by {[p for p in match.players if p.needs_sc2][i]}\")\n\n    return process_results(match.players, async_results)",
  "def process_results(players, async_results):\n    opp_res = {Result.Victory: Result.Defeat, Result.Defeat: Result.Victory, Result.Tie: Result.Tie}\n    result: Dict[AbstractPlayer, Result] = {}\n    i = 0\n    for player in players:\n        if player.needs_sc2:\n            if sum(r == Result.Victory for r in async_results) <= 1:\n                result[player] = async_results[i]\n            else:\n                result[player] = Result.Undecided\n            i += 1\n        else:  # computer\n            other_result = async_results[0]\n            result[player] = opp_res[other_result] if other_result in opp_res else None\n\n    return result",
  "async def maintain_SCII_count(count: int, controllers: List[Controller], proc_args: List[Dict] = None):\n    \"\"\"Modifies the given list of controllers to reflect the desired amount of SCII processes\"\"\"\n    # kill unhealthy ones.\n    if controllers:\n        toRemove = []\n        alive = await asyncio.wait_for(\n            asyncio.gather(*(c.ping() for c in controllers if not c._ws.closed), return_exceptions=True), timeout=20\n        )\n        i = 0  # for alive\n        for controller in controllers:\n            if controller._ws.closed:\n                if not controller._process._session.closed:\n                    await controller._process._session.close()\n                toRemove.append(controller)\n            else:\n                if not isinstance(alive[i], sc_pb.Response):\n                    try:\n                        await controller._process._close_connection()\n                    finally:\n                        toRemove.append(controller)\n                i += 1\n        for c in toRemove:\n            c._process._clean()\n            if c._process in kill_switch._to_kill:\n                kill_switch._to_kill.remove(c._process)\n            controllers.remove(c)\n\n    # spawn more\n    if len(controllers) < count:\n        needed = count - len(controllers)\n        if proc_args:\n            index = len(controllers) % len(proc_args)\n        else:\n            proc_args = [{} for _ in range(needed)]\n            index = 0\n        extra = [SC2Process(**proc_args[(index + _) % len(proc_args)]) for _ in range(needed)]\n        logger.info(f\"Creating {needed} more SC2 Processes\")\n        for k in range(3):  # try thrice\n            if platform.system() == \"Linux\":\n                # Works on linux: start one client after the other\n                new_controllers = [await asyncio.wait_for(sc.__aenter__(), timeout=50) for sc in extra]\n            else:\n                # Doesnt seem to work on linux: starting 2 clients nearly at the same time\n                new_controllers = await asyncio.wait_for(\n                    asyncio.gather(*[sc.__aenter__() for sc in extra], return_exceptions=True), timeout=50\n                )\n\n            controllers.extend(c for c in new_controllers if isinstance(c, Controller))\n            if len(controllers) == count:\n                await asyncio.wait_for(asyncio.gather(*(c.ping() for c in controllers)), timeout=20)\n                break\n            extra = [\n                extra[i] for i, result in enumerate(new_controllers) if not isinstance(new_controllers, Controller)\n            ]\n        else:\n            logger.critical(\"Could not launch sufficient SC2\")\n            raise RuntimeError\n\n    # kill excess\n    while len(controllers) > count:\n        proc = controllers.pop()\n        proc = proc._process\n        logger.info(f\"Removing SCII listening to {proc._port}\")\n        await proc._close_connection()\n        proc._clean()\n        if proc in kill_switch._to_kill:\n            kill_switch._to_kill.remove(proc)",
  "def run_multiple_games(matches: List[GameMatch]):\n    return asyncio.get_event_loop().run_until_complete(a_run_multiple_games(matches))",
  "async def a_run_multiple_games(matches: List[GameMatch]):\n    \"\"\"Run multiple matches.\n    Non-python bots are supported.\n    When playing bot vs bot, this is less likely to fatally crash than repeating run_game()\n    \"\"\"\n    if not matches:\n        return\n\n    results = []\n    controllers = []\n    for m in matches:\n        result = None\n        dont_restart = m.needed_sc2_count == 2\n        try:\n            await maintain_SCII_count(m.needed_sc2_count, controllers, m.sc2_config)\n            result = await run_match(controllers, m, close_ws=dont_restart)\n        except SystemExit as e:\n            logger.info(f\"Game exit'ed as {e} during match {m}\")\n        except Exception as e:\n            logger.info(f\"Exception {e} thrown in match {m}\")\n        finally:\n            if dont_restart:  # Keeping them alive after a non-computer match can cause crashes\n                await maintain_SCII_count(0, controllers, m.sc2_config)\n            results.append(result)\n    kill_switch.kill_all()\n    return results",
  "async def a_run_multiple_games_nokill(matches: List[GameMatch]):\n    \"\"\"Run multiple matches while reusing SCII processes.\n    Prone to crashes and stalls\n    \"\"\"\n    # FIXME: check whether crashes between bot-vs-bot are avoidable or not\n    if not matches:\n        return\n\n    # Start the matches\n    results = []\n    controllers = []\n    for m in matches:\n        logger.info(f\"Starting match {1 + len(results)}: {m}\")\n        result = None\n        try:\n            await maintain_SCII_count(m.needed_sc2_count, controllers, m.sc2_config)\n            result = await run_match(controllers, m, close_ws=False)\n        except SystemExit as e:\n            logger.critical(f\"Game sys.exit'ed as {e} during match {m}\")\n        except Exception as e:\n            logger.trace(f\"Exception {e} thrown in match {m}\")\n        finally:\n            for c in controllers:\n                try:\n                    await c.ping()\n                    if c._status != Status.launched:\n                        await c._execute(leave_game=sc_pb.RequestLeaveGame())\n                except Exception as e:\n                    if not (isinstance(e, ProtocolError) and e.is_game_over_error):\n                        logger.info(f\"controller {c.__dict__} threw {e}\")\n\n            results.append(result)\n\n    # Fire the killswitch manually, instead of letting the winning player fire it.\n    await asyncio.wait_for(asyncio.gather(*(c._process._close_connection() for c in controllers)), timeout=50)\n    kill_switch.kill_all()\n    signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    return results",
  "def __post_init__(self):\n        # avoid players sharing names\n        if len(self.players) > 1 and self.players[0].name is not None and self.players[0].name == self.players[1].name:\n            self.players[1].name += \"2\"\n\n        if self.sc2_config is not None:\n            if isinstance(self.sc2_config, dict):\n                self.sc2_config = [self.sc2_config]\n            if len(self.sc2_config) == 0:\n                self.sc2_config = [{}]\n            while len(self.sc2_config) < len(self.players):\n                self.sc2_config += self.sc2_config\n            self.sc2_config = self.sc2_config[:len(self.players)]",
  "def needed_sc2_count(self) -> int:\n        return sum(player.needs_sc2 for player in self.players)",
  "def host_game_kwargs(self) -> Dict:\n        return {\n            \"map_settings\": self.map_sc2,\n            \"players\": self.players,\n            \"realtime\": self.realtime,\n            \"random_seed\": self.random_seed,\n            \"disable_fog\": self.disable_fog,\n        }",
  "def __repr__(self):\n        p1 = self.players[0]\n        p1 = p1.name if p1.name else p1\n        p2 = self.players[1]\n        p2 = p2.name if p2.name else p2\n        return f\"Map: {self.map_sc2.name}, {p1} vs {p2}, realtime:{self.realtime}, seed={self.random_seed}\"",
  "def __init__(self, size: int):\n        assert size > 0\n\n        self.window_size = size\n        self.window = []",
  "def push(self, value: float):\n        self.window = (self.window + [value])[-self.window_size:]",
  "def clear(self):\n        self.window = []",
  "def sum(self) -> float:\n        return sum(self.window)",
  "def available(self) -> float:\n        return sum(self.window[1:])",
  "def available_fmt(self) -> float:\n        return \",\".join(f\"{w:.2f}\" for w in self.window[1:])",
  "class Portconfig:\n    \"\"\"\n    A data class for ports used by participants to join a match.\n\n    EVERY participant joining the match must send the same sets of ports to join successfully.\n    SC2 needs 2 ports per connection (one for data, one as a 'header'), which is why the ports come in pairs.\n\n    :param guests: number of non-hosting participants in a match (i.e. 1 less than the number of participants)\n    :param server_ports: [int portA, int portB]\n    :param player_ports: [[int port1A, int port1B], [int port2A, int port2B], ... ]\n\n    .shared is deprecated, and should TODO be removed soon (once ladderbots' __init__.py doesnt specify them).\n\n    .server contains the pair of ports used by the participant 'hosting' the match\n\n    .players contains a pair of ports for every 'guest' (non-hosting participants) in the match\n    E.g. for 1v1, there will be only 1 guest. For 2v2 (coming soonTM), there would be 3 guests.\n    \"\"\"\n\n    def __init__(self, guests=1, server_ports=None, player_ports=None):\n        self.shared = None\n        self._picked_ports = []\n        if server_ports:\n            self.server = server_ports\n        else:\n            self.server = [portpicker.pick_unused_port() for _ in range(2)]\n            self._picked_ports.extend(self.server)\n        if player_ports:\n            self.players = player_ports\n        else:\n            self.players = [[portpicker.pick_unused_port() for _ in range(2)] for _ in range(guests)]\n            self._picked_ports.extend(port for player in self.players for port in player)\n\n    def clean(self):\n        while self._picked_ports:\n            portpicker.return_port(self._picked_ports.pop())\n\n    def __str__(self):\n        return f\"Portconfig(shared={self.shared}, server={self.server}, players={self.players})\"\n\n    @property\n    def as_json(self):\n        return json.dumps({\"shared\": self.shared, \"server\": self.server, \"players\": self.players})\n\n    @classmethod\n    def contiguous_ports(cls, guests=1, attempts=40):\n        \"\"\"Returns a Portconfig with adjacent ports\"\"\"\n        for _ in range(attempts):\n            start = portpicker.pick_unused_port()\n            others = [start + j for j in range(1, 2 + guests * 2)]\n            if all(portpicker.is_port_free(p) for p in others):\n                server_ports = [start, others.pop(0)]\n                player_ports = []\n                while others:\n                    player_ports.append([others.pop(0), others.pop(0)])\n                pc = cls(server_ports=server_ports, player_ports=player_ports)\n                pc._picked_ports.append(start)\n                return pc\n        raise portpicker.NoFreePortFoundError()\n\n    @classmethod\n    def from_json(cls, json_data):\n        data = json.loads(json_data)\n        return cls(server_ports=data[\"server\"], player_ports=data[\"players\"])",
  "def __init__(self, guests=1, server_ports=None, player_ports=None):\n        self.shared = None\n        self._picked_ports = []\n        if server_ports:\n            self.server = server_ports\n        else:\n            self.server = [portpicker.pick_unused_port() for _ in range(2)]\n            self._picked_ports.extend(self.server)\n        if player_ports:\n            self.players = player_ports\n        else:\n            self.players = [[portpicker.pick_unused_port() for _ in range(2)] for _ in range(guests)]\n            self._picked_ports.extend(port for player in self.players for port in player)",
  "def clean(self):\n        while self._picked_ports:\n            portpicker.return_port(self._picked_ports.pop())",
  "def __str__(self):\n        return f\"Portconfig(shared={self.shared}, server={self.server}, players={self.players})\"",
  "def as_json(self):\n        return json.dumps({\"shared\": self.shared, \"server\": self.server, \"players\": self.players})",
  "def contiguous_ports(cls, guests=1, attempts=40):\n        \"\"\"Returns a Portconfig with adjacent ports\"\"\"\n        for _ in range(attempts):\n            start = portpicker.pick_unused_port()\n            others = [start + j for j in range(1, 2 + guests * 2)]\n            if all(portpicker.is_port_free(p) for p in others):\n                server_ports = [start, others.pop(0)]\n                player_ports = []\n                while others:\n                    player_ports.append([others.pop(0), others.pop(0)])\n                pc = cls(server_ports=server_ports, player_ports=player_ports)\n                pc._picked_ports.append(start)\n                return pc\n        raise portpicker.NoFreePortFoundError()",
  "def from_json(cls, json_data):\n        data = json.loads(json_data)\n        return cls(server_ports=data[\"server\"], player_ports=data[\"players\"])",
  "class ObserverAI(DistanceCalculation):\n    \"\"\"Base class for bots.\"\"\"\n\n    EXPANSION_GAP_THRESHOLD = 15\n\n    def _initialize_variables(self):\n        DistanceCalculation.__init__(self)\n        # Specific opponent bot ID used in sc2ai ladder games http://sc2ai.net/\n        # The bot ID will stay the same each game so your bot can \"adapt\" to the opponent\n        self.opponent_id: int = None\n        # This value will be set to True by main.py in self._prepare_start if game is played in realtime (if true, the bot will have limited time per step)\n        self.realtime: bool = False\n        self.all_units: Units = Units([], self)\n        self.units: Units = Units([], self)\n        self.workers: Units = Units([], self)\n        self.townhalls: Units = Units([], self)\n        self.structures: Units = Units([], self)\n        self.gas_buildings: Units = Units([], self)\n        self.enemy_units: Units = Units([], self)\n        self.enemy_structures: Units = Units([], self)\n        self.resources: Units = Units([], self)\n        self.destructables: Units = Units([], self)\n        self.watchtowers: Units = Units([], self)\n        self.mineral_field: Units = Units([], self)\n        self.vespene_geyser: Units = Units([], self)\n        self.larva: Units = Units([], self)\n        self.techlab_tags: Set[int] = set()\n        self.reactor_tags: Set[int] = set()\n        self.minerals: int = None\n        self.vespene: int = None\n        self.supply_army: Union[float, int] = None\n        # Doesn't include workers in production\n        self.supply_workers: Union[float, int] = None\n        self.supply_cap: Union[float, int] = None\n        self.supply_used: Union[float, int] = None\n        self.supply_left: Union[float, int] = None\n        self.idle_worker_count: int = None\n        self.army_count: int = None\n        self.warp_gate_count: int = None\n        self.larva_count: int = None\n        self.actions: List[UnitCommand] = []\n        self.blips: Set[Blip] = set()\n        self.race: Race = None\n        self.enemy_race: Race = None\n        self._units_created: Counter = Counter()\n        self._unit_tags_seen_this_game: Set[int] = set()\n        self._units_previous_map: Dict[int, Unit] = {}\n        self._structures_previous_map: Dict[int, Unit] = {}\n        self._enemy_units_previous_map: Dict[int, Unit] = {}\n        self._enemy_structures_previous_map: Dict[int, Unit] = {}\n        self._all_units_previous_map: Dict[int, Unit] = {}\n        self._previous_upgrades: Set[UpgradeId] = set()\n        self._expansion_positions_list: List[Point2] = []\n        self._resource_location_to_expansion_position_dict: Dict[Point2, Point2] = {}\n        # Internally used to keep track which units received an action in this frame, so that self.train() function does not give the same larva two orders - cleared every frame\n        self.unit_tags_received_action: Set[int] = set()\n\n    @property\n    def time(self) -> float:\n        \"\"\" Returns time in seconds, assumes the game is played on 'faster' \"\"\"\n        return self.state.game_loop / 22.4  # / (1/1.4) * (1/16)\n\n    @property\n    def time_formatted(self) -> str:\n        \"\"\" Returns time as string in min:sec format \"\"\"\n        t = self.time\n        return f\"{int(t // 60):02}:{int(t % 60):02}\"\n\n    @property\n    def game_info(self) -> GameInfo:\n        \"\"\" See game_info.py \"\"\"\n        return self._game_info\n\n    @property\n    def game_data(self) -> GameData:\n        \"\"\" See game_data.py \"\"\"\n        return self._game_data\n\n    @property\n    def client(self) -> Client:\n        \"\"\" See client.py \"\"\"\n        return self._client\n\n    def alert(self, alert_code: Alert) -> bool:\n        \"\"\"\n        Check if alert is triggered in the current step.\n        Possible alerts are listed here https://github.com/Blizzard/s2client-proto/blob/e38efed74c03bec90f74b330ea1adda9215e655f/s2clientprotocol/sc2api.proto#L679-L702\n\n        Example use:\n\n            from sc2.data import Alert\n            if self.alert(Alert.AddOnComplete):\n                print(\"Addon Complete\")\n\n        Alert codes::\n\n            AlertError\n            AddOnComplete\n            BuildingComplete\n            BuildingUnderAttack\n            LarvaHatched\n            MergeComplete\n            MineralsExhausted\n            MorphComplete\n            MothershipComplete\n            MULEExpired\n            NuclearLaunchDetected\n            NukeComplete\n            NydusWormDetected\n            ResearchComplete\n            TrainError\n            TrainUnitComplete\n            TrainWorkerComplete\n            TransformationComplete\n            UnitUnderAttack\n            UpgradeComplete\n            VespeneExhausted\n            WarpInComplete\n\n        :param alert_code:\n        \"\"\"\n        assert isinstance(alert_code, Alert), f\"alert_code {alert_code} is no Alert\"\n        return alert_code.value in self.state.alerts\n\n    @property\n    def start_location(self) -> Point2:\n        \"\"\"\n        Returns the spawn location of the bot, using the position of the first created townhall.\n        This will be None if the bot is run on an arcade or custom map that does not feature townhalls at game start.\n        \"\"\"\n        return self._game_info.player_start_location\n\n    @property\n    def enemy_start_locations(self) -> List[Point2]:\n        \"\"\"Possible start locations for enemies.\"\"\"\n        return self._game_info.start_locations\n\n    async def get_available_abilities(\n        self, units: Union[List[Unit], Units], ignore_resource_requirements: bool = False\n    ) -> List[List[AbilityId]]:\n        \"\"\"Returns available abilities of one or more units. Right now only checks cooldown, energy cost, and whether the ability has been researched.\n\n        Examples::\n\n            units_abilities = await self.get_available_abilities(self.units)\n\n        or::\n\n            units_abilities = await self.get_available_abilities([self.units.random])\n\n        :param units:\n        :param ignore_resource_requirements:\"\"\"\n        return await self._client.query_available_abilities(units, ignore_resource_requirements)\n\n    @property_cache_once_per_frame\n    def _abilities_all_units(self) -> Counter:\n        \"\"\"Cache for the already_pending function, includes protoss units warping in,\n        all units in production and all structures, and all morphs\"\"\"\n        abilities_amount = Counter()\n        unit: Unit\n        for unit in self.units + self.structures:\n            for order in unit.orders:\n                abilities_amount[order.ability] += 1\n            if not unit.is_ready:\n                if self.race != Race.Terran or not unit.is_structure:\n                    # If an SCV is constructing a building, already_pending would count this structure twice\n                    # (once from the SCV order, and once from \"not structure.is_ready\")\n                    abilities_amount[self._game_data.units[unit.type_id.value].creation_ability] += 1\n\n        return abilities_amount\n\n    def _prepare_start(self, client, player_id, game_info, game_data, realtime: bool = False, base_build: int = -1):\n        \"\"\"\n        Ran until game start to set game and player data.\n\n        :param client:\n        :param player_id:\n        :param game_info:\n        :param game_data:\n        :param realtime:\n        \"\"\"\n        self._client: Client = client\n        self.player_id: int = player_id\n        self._game_info: GameInfo = game_info\n        self._game_data: GameData = game_data\n        self.realtime: bool = realtime\n        self.base_build: int = base_build\n\n    def _prepare_first_step(self):\n        \"\"\"First step extra preparations. Must not be called before _prepare_step.\"\"\"\n        if self.townhalls:\n            self._game_info.player_start_location = self.townhalls.first.position\n        self._game_info.map_ramps, self._game_info.vision_blockers = self._game_info._find_ramps_and_vision_blockers()\n\n    def _prepare_step(self, state, proto_game_info):\n        \"\"\"\n        :param state:\n        :param proto_game_info:\n        \"\"\"\n        # Set attributes from new state before on_step.\"\"\"\n        self.state: GameState = state  # See game_state.py\n        # Required for events, needs to be before self.units are initialized so the old units are stored\n        self._units_previous_map: Dict[int, Unit] = {unit.tag: unit for unit in self.units}\n        self._structures_previous_map: Dict[int, Unit] = {structure.tag: structure for structure in self.structures}\n        self._enemy_units_previous_map: Dict[int, Unit] = {unit.tag: unit for unit in self.enemy_units}\n        self._enemy_structures_previous_map: Dict[int, Unit] = {\n            structure.tag: structure\n            for structure in self.enemy_structures\n        }\n        self._all_units_previous_map: Dict[int, Unit] = {unit.tag: unit for unit in self.all_units}\n\n        self._prepare_units()\n\n    def _prepare_units(self):\n        # Set of enemy units detected by own sensor tower, as blips have less unit information than normal visible units\n        self.blips: Set[Blip] = set()\n        self.units: Units = Units([], self)\n        self.structures: Units = Units([], self)\n        self.enemy_units: Units = Units([], self)\n        self.enemy_structures: Units = Units([], self)\n        self.mineral_field: Units = Units([], self)\n        self.vespene_geyser: Units = Units([], self)\n        self.resources: Units = Units([], self)\n        self.destructables: Units = Units([], self)\n        self.watchtowers: Units = Units([], self)\n        self.all_units: Units = Units([], self)\n        self.workers: Units = Units([], self)\n        self.townhalls: Units = Units([], self)\n        self.gas_buildings: Units = Units([], self)\n        self.larva: Units = Units([], self)\n        self.techlab_tags: Set[int] = set()\n        self.reactor_tags: Set[int] = set()\n\n        for unit in self.state.observation_raw.units:\n            if unit.is_blip:\n                self.blips.add(Blip(unit))\n            else:\n                unit_type: int = unit.unit_type\n                # Convert these units to effects: reaper grenade, parasitic bomb dummy, forcefield\n                unit_obj = Unit(unit, self)\n                self.units.append(unit_obj)\n\n    async def _after_step(self) -> int:\n        \"\"\" Executed by main.py after each on_step function. \"\"\"\n        self.unit_tags_received_action.clear()\n        # Commit debug queries\n        await self._client._send_debug()\n        return self.state.game_loop\n\n    async def issue_events(self):\n        \"\"\"This function will be automatically run from main.py and triggers the following functions:\n        - on_unit_created\n        - on_unit_destroyed\n        - on_building_construction_started\n        - on_building_construction_complete\n        - on_upgrade_complete\n        \"\"\"\n        await self._issue_unit_dead_events()\n        await self._issue_unit_added_events()\n        await self._issue_building_events()\n        await self._issue_upgrade_events()\n\n    async def _issue_unit_added_events(self):\n        for unit in self.units:\n            if unit.tag not in self._units_previous_map and unit.tag not in self._unit_tags_seen_this_game:\n                self._unit_tags_seen_this_game.add(unit.tag)\n                await self.on_unit_created(unit)\n\n    async def _issue_upgrade_events(self):\n        difference = self.state.upgrades - self._previous_upgrades\n        for upgrade_completed in difference:\n            await self.on_upgrade_complete(upgrade_completed)\n        self._previous_upgrades = self.state.upgrades\n\n    async def _issue_building_events(self):\n        for structure in self.structures:\n            # Check build_progress < 1 to exclude starting townhall\n            if structure.tag not in self._structures_previous_map and structure.build_progress < 1:\n                await self.on_building_construction_started(structure)\n                continue\n            # From here on, only check completed structure, so we ignore structures with build_progress < 1\n            if structure.build_progress < 1:\n                continue\n            # Using get function in case somehow the previous structure map (from last frame) does not contain this structure\n            structure_prev = self._structures_previous_map.get(structure.tag, None)\n            if structure_prev and structure_prev.build_progress < 1:\n                await self.on_building_construction_complete(structure)\n\n    async def _issue_unit_dead_events(self):\n        for unit_tag in self.state.dead_units & set(self._all_units_previous_map.keys()):\n            await self.on_unit_destroyed(unit_tag)\n\n    async def on_unit_destroyed(self, unit_tag: int):\n        \"\"\"\n        Override this in your bot class.\n        This will event will be called when a unit (or structure, friendly or enemy) dies.\n        For enemy units, this only works if the enemy unit was in vision on death.\n\n        :param unit_tag:\n        \"\"\"\n\n    async def on_unit_created(self, unit: Unit):\n        \"\"\"Override this in your bot class. This function is called when a unit is created.\n\n        :param unit:\"\"\"\n\n    async def on_building_construction_started(self, unit: Unit):\n        \"\"\"\n        Override this in your bot class.\n        This function is called when a building construction has started.\n\n        :param unit:\n        \"\"\"\n\n    async def on_building_construction_complete(self, unit: Unit):\n        \"\"\"\n        Override this in your bot class. This function is called when a building\n        construction is completed.\n\n        :param unit:\n        \"\"\"\n\n    async def on_upgrade_complete(self, upgrade: UpgradeId):\n        \"\"\"\n        Override this in your bot class. This function is called with the upgrade id of an upgrade that was not finished last step and is now.\n\n        :param upgrade:\n        \"\"\"\n\n    async def on_start(self):\n        \"\"\"\n        Override this in your bot class. This function is called after \"on_start\".\n        At this point, game_data, game_info and the first iteration of game_state (self.state) are available.\n        \"\"\"\n\n    async def on_step(self, iteration: int):\n        \"\"\"\n        You need to implement this function!\n        Override this in your bot class.\n        This function is called on every game step (looped in realtime mode).\n\n        :param iteration:\n        \"\"\"\n        raise NotImplementedError\n\n    async def on_end(self, game_result: Result):\n        \"\"\"Override this in your bot class. This function is called at the end of a game.\n\n        :param game_result:\"\"\"",
  "def _initialize_variables(self):\n        DistanceCalculation.__init__(self)\n        # Specific opponent bot ID used in sc2ai ladder games http://sc2ai.net/\n        # The bot ID will stay the same each game so your bot can \"adapt\" to the opponent\n        self.opponent_id: int = None\n        # This value will be set to True by main.py in self._prepare_start if game is played in realtime (if true, the bot will have limited time per step)\n        self.realtime: bool = False\n        self.all_units: Units = Units([], self)\n        self.units: Units = Units([], self)\n        self.workers: Units = Units([], self)\n        self.townhalls: Units = Units([], self)\n        self.structures: Units = Units([], self)\n        self.gas_buildings: Units = Units([], self)\n        self.enemy_units: Units = Units([], self)\n        self.enemy_structures: Units = Units([], self)\n        self.resources: Units = Units([], self)\n        self.destructables: Units = Units([], self)\n        self.watchtowers: Units = Units([], self)\n        self.mineral_field: Units = Units([], self)\n        self.vespene_geyser: Units = Units([], self)\n        self.larva: Units = Units([], self)\n        self.techlab_tags: Set[int] = set()\n        self.reactor_tags: Set[int] = set()\n        self.minerals: int = None\n        self.vespene: int = None\n        self.supply_army: Union[float, int] = None\n        # Doesn't include workers in production\n        self.supply_workers: Union[float, int] = None\n        self.supply_cap: Union[float, int] = None\n        self.supply_used: Union[float, int] = None\n        self.supply_left: Union[float, int] = None\n        self.idle_worker_count: int = None\n        self.army_count: int = None\n        self.warp_gate_count: int = None\n        self.larva_count: int = None\n        self.actions: List[UnitCommand] = []\n        self.blips: Set[Blip] = set()\n        self.race: Race = None\n        self.enemy_race: Race = None\n        self._units_created: Counter = Counter()\n        self._unit_tags_seen_this_game: Set[int] = set()\n        self._units_previous_map: Dict[int, Unit] = {}\n        self._structures_previous_map: Dict[int, Unit] = {}\n        self._enemy_units_previous_map: Dict[int, Unit] = {}\n        self._enemy_structures_previous_map: Dict[int, Unit] = {}\n        self._all_units_previous_map: Dict[int, Unit] = {}\n        self._previous_upgrades: Set[UpgradeId] = set()\n        self._expansion_positions_list: List[Point2] = []\n        self._resource_location_to_expansion_position_dict: Dict[Point2, Point2] = {}\n        # Internally used to keep track which units received an action in this frame, so that self.train() function does not give the same larva two orders - cleared every frame\n        self.unit_tags_received_action: Set[int] = set()",
  "def time(self) -> float:\n        \"\"\" Returns time in seconds, assumes the game is played on 'faster' \"\"\"\n        return self.state.game_loop / 22.4",
  "def time_formatted(self) -> str:\n        \"\"\" Returns time as string in min:sec format \"\"\"\n        t = self.time\n        return f\"{int(t // 60):02}:{int(t % 60):02}\"",
  "def game_info(self) -> GameInfo:\n        \"\"\" See game_info.py \"\"\"\n        return self._game_info",
  "def game_data(self) -> GameData:\n        \"\"\" See game_data.py \"\"\"\n        return self._game_data",
  "def client(self) -> Client:\n        \"\"\" See client.py \"\"\"\n        return self._client",
  "def alert(self, alert_code: Alert) -> bool:\n        \"\"\"\n        Check if alert is triggered in the current step.\n        Possible alerts are listed here https://github.com/Blizzard/s2client-proto/blob/e38efed74c03bec90f74b330ea1adda9215e655f/s2clientprotocol/sc2api.proto#L679-L702\n\n        Example use:\n\n            from sc2.data import Alert\n            if self.alert(Alert.AddOnComplete):\n                print(\"Addon Complete\")\n\n        Alert codes::\n\n            AlertError\n            AddOnComplete\n            BuildingComplete\n            BuildingUnderAttack\n            LarvaHatched\n            MergeComplete\n            MineralsExhausted\n            MorphComplete\n            MothershipComplete\n            MULEExpired\n            NuclearLaunchDetected\n            NukeComplete\n            NydusWormDetected\n            ResearchComplete\n            TrainError\n            TrainUnitComplete\n            TrainWorkerComplete\n            TransformationComplete\n            UnitUnderAttack\n            UpgradeComplete\n            VespeneExhausted\n            WarpInComplete\n\n        :param alert_code:\n        \"\"\"\n        assert isinstance(alert_code, Alert), f\"alert_code {alert_code} is no Alert\"\n        return alert_code.value in self.state.alerts",
  "def start_location(self) -> Point2:\n        \"\"\"\n        Returns the spawn location of the bot, using the position of the first created townhall.\n        This will be None if the bot is run on an arcade or custom map that does not feature townhalls at game start.\n        \"\"\"\n        return self._game_info.player_start_location",
  "def enemy_start_locations(self) -> List[Point2]:\n        \"\"\"Possible start locations for enemies.\"\"\"\n        return self._game_info.start_locations",
  "async def get_available_abilities(\n        self, units: Union[List[Unit], Units], ignore_resource_requirements: bool = False\n    ) -> List[List[AbilityId]]:\n        \"\"\"Returns available abilities of one or more units. Right now only checks cooldown, energy cost, and whether the ability has been researched.\n\n        Examples::\n\n            units_abilities = await self.get_available_abilities(self.units)\n\n        or::\n\n            units_abilities = await self.get_available_abilities([self.units.random])\n\n        :param units:\n        :param ignore_resource_requirements:\"\"\"\n        return await self._client.query_available_abilities(units, ignore_resource_requirements)",
  "def _abilities_all_units(self) -> Counter:\n        \"\"\"Cache for the already_pending function, includes protoss units warping in,\n        all units in production and all structures, and all morphs\"\"\"\n        abilities_amount = Counter()\n        unit: Unit\n        for unit in self.units + self.structures:\n            for order in unit.orders:\n                abilities_amount[order.ability] += 1\n            if not unit.is_ready:\n                if self.race != Race.Terran or not unit.is_structure:\n                    # If an SCV is constructing a building, already_pending would count this structure twice\n                    # (once from the SCV order, and once from \"not structure.is_ready\")\n                    abilities_amount[self._game_data.units[unit.type_id.value].creation_ability] += 1\n\n        return abilities_amount",
  "def _prepare_start(self, client, player_id, game_info, game_data, realtime: bool = False, base_build: int = -1):\n        \"\"\"\n        Ran until game start to set game and player data.\n\n        :param client:\n        :param player_id:\n        :param game_info:\n        :param game_data:\n        :param realtime:\n        \"\"\"\n        self._client: Client = client\n        self.player_id: int = player_id\n        self._game_info: GameInfo = game_info\n        self._game_data: GameData = game_data\n        self.realtime: bool = realtime\n        self.base_build: int = base_build",
  "def _prepare_first_step(self):\n        \"\"\"First step extra preparations. Must not be called before _prepare_step.\"\"\"\n        if self.townhalls:\n            self._game_info.player_start_location = self.townhalls.first.position\n        self._game_info.map_ramps, self._game_info.vision_blockers = self._game_info._find_ramps_and_vision_blockers()",
  "def _prepare_step(self, state, proto_game_info):\n        \"\"\"\n        :param state:\n        :param proto_game_info:\n        \"\"\"\n        # Set attributes from new state before on_step.\"\"\"\n        self.state: GameState = state  # See game_state.py\n        # Required for events, needs to be before self.units are initialized so the old units are stored\n        self._units_previous_map: Dict[int, Unit] = {unit.tag: unit for unit in self.units}\n        self._structures_previous_map: Dict[int, Unit] = {structure.tag: structure for structure in self.structures}\n        self._enemy_units_previous_map: Dict[int, Unit] = {unit.tag: unit for unit in self.enemy_units}\n        self._enemy_structures_previous_map: Dict[int, Unit] = {\n            structure.tag: structure\n            for structure in self.enemy_structures\n        }\n        self._all_units_previous_map: Dict[int, Unit] = {unit.tag: unit for unit in self.all_units}\n\n        self._prepare_units()",
  "def _prepare_units(self):\n        # Set of enemy units detected by own sensor tower, as blips have less unit information than normal visible units\n        self.blips: Set[Blip] = set()\n        self.units: Units = Units([], self)\n        self.structures: Units = Units([], self)\n        self.enemy_units: Units = Units([], self)\n        self.enemy_structures: Units = Units([], self)\n        self.mineral_field: Units = Units([], self)\n        self.vespene_geyser: Units = Units([], self)\n        self.resources: Units = Units([], self)\n        self.destructables: Units = Units([], self)\n        self.watchtowers: Units = Units([], self)\n        self.all_units: Units = Units([], self)\n        self.workers: Units = Units([], self)\n        self.townhalls: Units = Units([], self)\n        self.gas_buildings: Units = Units([], self)\n        self.larva: Units = Units([], self)\n        self.techlab_tags: Set[int] = set()\n        self.reactor_tags: Set[int] = set()\n\n        for unit in self.state.observation_raw.units:\n            if unit.is_blip:\n                self.blips.add(Blip(unit))\n            else:\n                unit_type: int = unit.unit_type\n                # Convert these units to effects: reaper grenade, parasitic bomb dummy, forcefield\n                unit_obj = Unit(unit, self)\n                self.units.append(unit_obj)",
  "async def _after_step(self) -> int:\n        \"\"\" Executed by main.py after each on_step function. \"\"\"\n        self.unit_tags_received_action.clear()\n        # Commit debug queries\n        await self._client._send_debug()\n        return self.state.game_loop",
  "async def issue_events(self):\n        \"\"\"This function will be automatically run from main.py and triggers the following functions:\n        - on_unit_created\n        - on_unit_destroyed\n        - on_building_construction_started\n        - on_building_construction_complete\n        - on_upgrade_complete\n        \"\"\"\n        await self._issue_unit_dead_events()\n        await self._issue_unit_added_events()\n        await self._issue_building_events()\n        await self._issue_upgrade_events()",
  "async def _issue_unit_added_events(self):\n        for unit in self.units:\n            if unit.tag not in self._units_previous_map and unit.tag not in self._unit_tags_seen_this_game:\n                self._unit_tags_seen_this_game.add(unit.tag)\n                await self.on_unit_created(unit)",
  "async def _issue_upgrade_events(self):\n        difference = self.state.upgrades - self._previous_upgrades\n        for upgrade_completed in difference:\n            await self.on_upgrade_complete(upgrade_completed)\n        self._previous_upgrades = self.state.upgrades",
  "async def _issue_building_events(self):\n        for structure in self.structures:\n            # Check build_progress < 1 to exclude starting townhall\n            if structure.tag not in self._structures_previous_map and structure.build_progress < 1:\n                await self.on_building_construction_started(structure)\n                continue\n            # From here on, only check completed structure, so we ignore structures with build_progress < 1\n            if structure.build_progress < 1:\n                continue\n            # Using get function in case somehow the previous structure map (from last frame) does not contain this structure\n            structure_prev = self._structures_previous_map.get(structure.tag, None)\n            if structure_prev and structure_prev.build_progress < 1:\n                await self.on_building_construction_complete(structure)",
  "async def _issue_unit_dead_events(self):\n        for unit_tag in self.state.dead_units & set(self._all_units_previous_map.keys()):\n            await self.on_unit_destroyed(unit_tag)",
  "async def on_unit_destroyed(self, unit_tag: int):\n        \"\"\"\n        Override this in your bot class.\n        This will event will be called when a unit (or structure, friendly or enemy) dies.\n        For enemy units, this only works if the enemy unit was in vision on death.\n\n        :param unit_tag:\n        \"\"\"",
  "async def on_unit_created(self, unit: Unit):\n        \"\"\"Override this in your bot class. This function is called when a unit is created.\n\n        :param unit:\"\"\"",
  "async def on_building_construction_started(self, unit: Unit):\n        \"\"\"\n        Override this in your bot class.\n        This function is called when a building construction has started.\n\n        :param unit:\n        \"\"\"",
  "async def on_building_construction_complete(self, unit: Unit):\n        \"\"\"\n        Override this in your bot class. This function is called when a building\n        construction is completed.\n\n        :param unit:\n        \"\"\"",
  "async def on_upgrade_complete(self, upgrade: UpgradeId):\n        \"\"\"\n        Override this in your bot class. This function is called with the upgrade id of an upgrade that was not finished last step and is now.\n\n        :param upgrade:\n        \"\"\"",
  "async def on_start(self):\n        \"\"\"\n        Override this in your bot class. This function is called after \"on_start\".\n        At this point, game_data, game_info and the first iteration of game_state (self.state) are available.\n        \"\"\"",
  "async def on_step(self, iteration: int):\n        \"\"\"\n        You need to implement this function!\n        Override this in your bot class.\n        This function is called on every game step (looped in realtime mode).\n\n        :param iteration:\n        \"\"\"\n        raise NotImplementedError",
  "async def on_end(self, game_result: Result):\n        \"\"\"Override this in your bot class. This function is called at the end of a game.\n\n        :param game_result:\"\"\"",
  "def property_cache_forever(f):\n\n    @wraps(f)\n    def inner(self):\n        property_cache = \"_cache_\" + f.__name__\n        cache_updated = hasattr(self, property_cache)\n        if not cache_updated:\n            setattr(self, property_cache, f(self))\n        cache = getattr(self, property_cache)\n        return cache\n\n    return property(inner)",
  "def property_cache_once_per_frame(f):\n    \"\"\"This decorator caches the return value for one game loop,\n    then clears it if it is accessed in a different game loop.\n    Only works on properties of the bot object, because it requires\n    access to self.state.game_loop\"\"\"\n\n    @wraps(f)\n    def inner(self):\n        property_cache = \"_cache_\" + f.__name__\n        state_cache = \"_frame_\" + f.__name__\n        cache_updated = getattr(self, state_cache, -1) == self.state.game_loop\n        if not cache_updated:\n            setattr(self, property_cache, f(self))\n            setattr(self, state_cache, self.state.game_loop)\n\n        cache = getattr(self, property_cache)\n        should_copy = callable(getattr(cache, \"copy\", None))\n        if should_copy:\n            return cache.copy()\n        return cache\n\n    return property(inner)",
  "def property_cache_once_per_frame_no_copy(f):\n    \"\"\"This decorator caches the return value for one game loop,\n    then clears it if it is accessed in a different game loop.\n    Only works on properties of the bot object, because it requires\n    access to self.state.game_loop\n\n    This decorator compared to the above runs a little faster, however you should only use this decorator if you are sure that you do not modify the mutable once it is calculated and cached.\"\"\"\n\n    @wraps(f)\n    def inner(self):\n        property_cache = \"_cache_\" + f.__name__\n        state_cache = \"_frame_\" + f.__name__\n        cache_updated = getattr(self, state_cache, -1) == self.state.game_loop\n        if not cache_updated:\n            setattr(self, property_cache, f(self))\n            setattr(self, state_cache, self.state.game_loop)\n\n        cache = getattr(self, property_cache)\n        return cache\n\n    return property(inner)",
  "def property_immutable_cache(f):\n    \"\"\" This cache should only be used on properties that return an immutable object (bool, str, int, float, tuple, Unit, Point2, Point3) \"\"\"\n\n    @wraps(f)\n    def inner(self):\n        if f.__name__ not in self.cache:\n            self.cache[f.__name__] = f(self)\n        return self.cache[f.__name__]\n\n    return property(inner)",
  "def property_mutable_cache(f):\n    \"\"\" This cache should only be used on properties that return a mutable object (Units, list, set, dict, Counter) \"\"\"\n\n    @wraps(f)\n    def inner(self):\n        if f.__name__ not in self.cache:\n            self.cache[f.__name__] = f(self)\n        return self.cache[f.__name__].copy()\n\n    return property(inner)",
  "def inner(self):\n        property_cache = \"_cache_\" + f.__name__\n        cache_updated = hasattr(self, property_cache)\n        if not cache_updated:\n            setattr(self, property_cache, f(self))\n        cache = getattr(self, property_cache)\n        return cache",
  "def inner(self):\n        property_cache = \"_cache_\" + f.__name__\n        state_cache = \"_frame_\" + f.__name__\n        cache_updated = getattr(self, state_cache, -1) == self.state.game_loop\n        if not cache_updated:\n            setattr(self, property_cache, f(self))\n            setattr(self, state_cache, self.state.game_loop)\n\n        cache = getattr(self, property_cache)\n        should_copy = callable(getattr(cache, \"copy\", None))\n        if should_copy:\n            return cache.copy()\n        return cache",
  "def inner(self):\n        property_cache = \"_cache_\" + f.__name__\n        state_cache = \"_frame_\" + f.__name__\n        cache_updated = getattr(self, state_cache, -1) == self.state.game_loop\n        if not cache_updated:\n            setattr(self, property_cache, f(self))\n            setattr(self, state_cache, self.state.game_loop)\n\n        cache = getattr(self, property_cache)\n        return cache",
  "def inner(self):\n        if f.__name__ not in self.cache:\n            self.cache[f.__name__] = f(self)\n        return self.cache[f.__name__]",
  "def inner(self):\n        if f.__name__ not in self.cache:\n            self.cache[f.__name__] = f(self)\n        return self.cache[f.__name__].copy()",
  "def is_submodule(path):\n    if path.is_file():\n        return path.suffix == \".py\" and path.stem != \"__init__\"\n    elif path.is_dir():\n        return (path / \"__init__.py\").exists()\n    return False",
  "class AbstractPlayer:\n\n    def __init__(self, p_type, race=None, name=None, difficulty=None, ai_build=None, fullscreen=False):\n        assert isinstance(p_type, PlayerType), f\"p_type is of type {type(p_type)}\"\n        assert name is None or isinstance(name, str), f\"name is of type {type(name)}\"\n\n        self.name = name\n        self.type = p_type\n        self.fullscreen = fullscreen\n        if race is not None:\n            self.race = race\n        if p_type == PlayerType.Computer:\n            assert isinstance(difficulty, Difficulty), f\"difficulty is of type {type(difficulty)}\"\n            # Workaround, proto information does not carry ai_build info\n            # We cant set that in the Player classmethod\n            assert ai_build is None or isinstance(ai_build, AIBuild), f\"ai_build is of type {type(ai_build)}\"\n            self.difficulty = difficulty\n            self.ai_build = ai_build\n\n        elif p_type == PlayerType.Observer:\n            assert race is None\n            assert difficulty is None\n            assert ai_build is None\n\n        else:\n            assert isinstance(race, Race), f\"race is of type {type(race)}\"\n            assert difficulty is None\n            assert ai_build is None\n\n    @property\n    def needs_sc2(self):\n        return not isinstance(self, Computer)",
  "class Human(AbstractPlayer):\n\n    def __init__(self, race, name=None, fullscreen=False):\n        super().__init__(PlayerType.Participant, race, name=name, fullscreen=fullscreen)\n\n    def __str__(self):\n        if self.name is not None:\n            return f\"Human({self.race._name_}, name={self.name !r})\"\n        else:\n            return f\"Human({self.race._name_})\"",
  "class Bot(AbstractPlayer):\n\n    def __init__(self, race, ai, name=None, fullscreen=False):\n        \"\"\"\n        AI can be None if this player object is just used to inform the\n        server about player types.\n        \"\"\"\n        assert isinstance(ai, BotAI) or ai is None, f\"ai is of type {type(ai)}, inherit BotAI from bot_ai.py\"\n        super().__init__(PlayerType.Participant, race, name=name, fullscreen=fullscreen)\n        self.ai = ai\n\n    def __str__(self):\n        if self.name is not None:\n            return f\"Bot {self.ai.__class__.__name__}({self.race._name_}), name={self.name !r})\"\n        else:\n            return f\"Bot {self.ai.__class__.__name__}({self.race._name_})\"",
  "class Computer(AbstractPlayer):\n\n    def __init__(self, race, difficulty=Difficulty.Easy, ai_build=AIBuild.RandomBuild):\n        super().__init__(PlayerType.Computer, race, difficulty=difficulty, ai_build=ai_build)\n\n    def __str__(self):\n        return f\"Computer {self.difficulty._name_}({self.race._name_}, {self.ai_build.name})\"",
  "class Observer(AbstractPlayer):\n\n    def __init__(self):\n        super().__init__(PlayerType.Observer)\n\n    def __str__(self):\n        return \"Observer\"",
  "class Player(AbstractPlayer):\n\n    @classmethod\n    def from_proto(cls, proto):\n        if PlayerType(proto.type) == PlayerType.Observer:\n            return cls(proto.player_id, PlayerType(proto.type), None, None, None)\n        return cls(\n            proto.player_id,\n            PlayerType(proto.type),\n            Race(proto.race_requested),\n            Difficulty(proto.difficulty) if proto.HasField(\"difficulty\") else None,\n            Race(proto.race_actual) if proto.HasField(\"race_actual\") else None,\n            proto.player_name if proto.HasField(\"player_name\") else None,\n        )\n\n    def __init__(self, player_id, p_type, requested_race, difficulty=None, actual_race=None, name=None, ai_build=None):\n        super().__init__(p_type, requested_race, difficulty=difficulty, name=name, ai_build=ai_build)\n        self.id: int = player_id\n        self.actual_race: Race = actual_race",
  "class BotProcess(AbstractPlayer):\n    \"\"\"\n    Class for handling bots launched externally, including non-python bots.\n    Default parameters comply with sc2ai and aiarena ladders.\n\n    :param path: the executable file's path\n    :param launch_list: list of strings that launches the bot e.g. [\"python\", \"run.py\"] or [\"run.exe\"]\n    :param race: bot's race\n    :param name: bot's name\n    :param sc2port_arg: the accepted argument name for the port of the sc2 instance to listen to\n    :param hostaddress_arg: the accepted argument name for the address of the sc2 instance to listen to\n    :param match_arg: the accepted argument name for the starting port to generate a portconfig from\n    :param realtime_arg: the accepted argument name for specifying realtime\n    :param other_args: anything else that is needed\n\n    e.g. to call a bot capable of running on the bot ladders:\n        BotProcess(os.getcwd(), \"python run.py\", Race.Terran, \"INnoVation\")\n    \"\"\"\n\n    def __init__(\n        self,\n        path: Union[str, Path],\n        launch_list: List[str],\n        race: Race,\n        name=None,\n        sc2port_arg=\"--GamePort\",\n        hostaddress_arg=\"--LadderServer\",\n        match_arg=\"--StartPort\",\n        realtime_arg=\"--RealTime\",\n        other_args: str = None,\n        stdout: str = None,\n    ):\n        self.race = race\n        self.type = PlayerType.Participant\n        self.name = name\n\n        assert Path(path).exists()\n        self.path = path\n        self.launch_list = launch_list\n        self.sc2port_arg = sc2port_arg\n        self.match_arg = match_arg\n        self.hostaddress_arg = hostaddress_arg\n        self.realtime_arg = realtime_arg\n        self.other_args = other_args\n        self.stdout = stdout\n\n    def __repr__(self):\n        if self.name is not None:\n            return f\"Bot {self.name}({self.race.name} from {self.launch_list})\"\n        return f\"Bot({self.race.name} from {self.launch_list})\"\n\n    def cmd_line(self,\n                 sc2port: Union[int, str],\n                 matchport: Union[int, str],\n                 hostaddress: str,\n                 realtime: bool = False) -> List[str]:\n        \"\"\"\n\n        :param sc2port: the port that the launched sc2 instance listens to\n        :param matchport: some starting port that both bots use to generate identical portconfigs.\n                Note: This will not be sent if playing vs computer\n        :param hostaddress: the address the sc2 instances used\n        :param realtime: 1 or 0, indicating whether the match is played in realtime or not\n        :return: string that will be used to start the bot's process\n        \"\"\"\n        cmd_line = [\n            *self.launch_list,\n            self.sc2port_arg,\n            str(sc2port),\n            self.hostaddress_arg,\n            hostaddress,\n        ]\n        if matchport is not None:\n            cmd_line.extend([self.match_arg, str(matchport)])\n        if self.other_args is not None:\n            cmd_line.append(self.other_args)\n        if realtime:\n            cmd_line.extend([self.realtime_arg])\n        return cmd_line",
  "def __init__(self, p_type, race=None, name=None, difficulty=None, ai_build=None, fullscreen=False):\n        assert isinstance(p_type, PlayerType), f\"p_type is of type {type(p_type)}\"\n        assert name is None or isinstance(name, str), f\"name is of type {type(name)}\"\n\n        self.name = name\n        self.type = p_type\n        self.fullscreen = fullscreen\n        if race is not None:\n            self.race = race\n        if p_type == PlayerType.Computer:\n            assert isinstance(difficulty, Difficulty), f\"difficulty is of type {type(difficulty)}\"\n            # Workaround, proto information does not carry ai_build info\n            # We cant set that in the Player classmethod\n            assert ai_build is None or isinstance(ai_build, AIBuild), f\"ai_build is of type {type(ai_build)}\"\n            self.difficulty = difficulty\n            self.ai_build = ai_build\n\n        elif p_type == PlayerType.Observer:\n            assert race is None\n            assert difficulty is None\n            assert ai_build is None\n\n        else:\n            assert isinstance(race, Race), f\"race is of type {type(race)}\"\n            assert difficulty is None\n            assert ai_build is None",
  "def needs_sc2(self):\n        return not isinstance(self, Computer)",
  "def __init__(self, race, name=None, fullscreen=False):\n        super().__init__(PlayerType.Participant, race, name=name, fullscreen=fullscreen)",
  "def __str__(self):\n        if self.name is not None:\n            return f\"Human({self.race._name_}, name={self.name !r})\"\n        else:\n            return f\"Human({self.race._name_})\"",
  "def __init__(self, race, ai, name=None, fullscreen=False):\n        \"\"\"\n        AI can be None if this player object is just used to inform the\n        server about player types.\n        \"\"\"\n        assert isinstance(ai, BotAI) or ai is None, f\"ai is of type {type(ai)}, inherit BotAI from bot_ai.py\"\n        super().__init__(PlayerType.Participant, race, name=name, fullscreen=fullscreen)\n        self.ai = ai",
  "def __str__(self):\n        if self.name is not None:\n            return f\"Bot {self.ai.__class__.__name__}({self.race._name_}), name={self.name !r})\"\n        else:\n            return f\"Bot {self.ai.__class__.__name__}({self.race._name_})\"",
  "def __init__(self, race, difficulty=Difficulty.Easy, ai_build=AIBuild.RandomBuild):\n        super().__init__(PlayerType.Computer, race, difficulty=difficulty, ai_build=ai_build)",
  "def __str__(self):\n        return f\"Computer {self.difficulty._name_}({self.race._name_}, {self.ai_build.name})\"",
  "def __init__(self):\n        super().__init__(PlayerType.Observer)",
  "def __str__(self):\n        return \"Observer\"",
  "def from_proto(cls, proto):\n        if PlayerType(proto.type) == PlayerType.Observer:\n            return cls(proto.player_id, PlayerType(proto.type), None, None, None)\n        return cls(\n            proto.player_id,\n            PlayerType(proto.type),\n            Race(proto.race_requested),\n            Difficulty(proto.difficulty) if proto.HasField(\"difficulty\") else None,\n            Race(proto.race_actual) if proto.HasField(\"race_actual\") else None,\n            proto.player_name if proto.HasField(\"player_name\") else None,\n        )",
  "def __init__(self, player_id, p_type, requested_race, difficulty=None, actual_race=None, name=None, ai_build=None):\n        super().__init__(p_type, requested_race, difficulty=difficulty, name=name, ai_build=ai_build)\n        self.id: int = player_id\n        self.actual_race: Race = actual_race",
  "def __init__(\n        self,\n        path: Union[str, Path],\n        launch_list: List[str],\n        race: Race,\n        name=None,\n        sc2port_arg=\"--GamePort\",\n        hostaddress_arg=\"--LadderServer\",\n        match_arg=\"--StartPort\",\n        realtime_arg=\"--RealTime\",\n        other_args: str = None,\n        stdout: str = None,\n    ):\n        self.race = race\n        self.type = PlayerType.Participant\n        self.name = name\n\n        assert Path(path).exists()\n        self.path = path\n        self.launch_list = launch_list\n        self.sc2port_arg = sc2port_arg\n        self.match_arg = match_arg\n        self.hostaddress_arg = hostaddress_arg\n        self.realtime_arg = realtime_arg\n        self.other_args = other_args\n        self.stdout = stdout",
  "def __repr__(self):\n        if self.name is not None:\n            return f\"Bot {self.name}({self.race.name} from {self.launch_list})\"\n        return f\"Bot({self.race.name} from {self.launch_list})\"",
  "def cmd_line(self,\n                 sc2port: Union[int, str],\n                 matchport: Union[int, str],\n                 hostaddress: str,\n                 realtime: bool = False) -> List[str]:\n        \"\"\"\n\n        :param sc2port: the port that the launched sc2 instance listens to\n        :param matchport: some starting port that both bots use to generate identical portconfigs.\n                Note: This will not be sent if playing vs computer\n        :param hostaddress: the address the sc2 instances used\n        :param realtime: 1 or 0, indicating whether the match is played in realtime or not\n        :return: string that will be used to start the bot's process\n        \"\"\"\n        cmd_line = [\n            *self.launch_list,\n            self.sc2port_arg,\n            str(sc2port),\n            self.hostaddress_arg,\n            hostaddress,\n        ]\n        if matchport is not None:\n            cmd_line.extend([self.match_arg, str(matchport)])\n        if self.other_args is not None:\n            cmd_line.append(self.other_args)\n        if realtime:\n            cmd_line.extend([self.realtime_arg])\n        return cmd_line",
  "class kill_switch:\n    _to_kill: List[Any] = []\n\n    @classmethod\n    def add(cls, value):\n        logger.debug(\"kill_switch: Add switch\")\n        cls._to_kill.append(value)\n\n    @classmethod\n    def kill_all(cls):\n        logger.info(f\"kill_switch: Process cleanup for {len(cls._to_kill)} processes\")\n        for p in cls._to_kill:\n            p._clean()",
  "class SC2Process:\n    \"\"\"\n    A class for handling SCII applications.\n\n    :param host: hostname for the url the SCII application will listen to\n    :param port: the websocket port the SCII application will listen to\n    :param fullscreen: whether to launch the SCII application in fullscreen or not, defaults to False\n    :param resolution: (window width, window height) in pixels, defaults to (1024, 768)\n    :param placement: (x, y) the distances of the SCII app's top left corner from the top left corner of the screen\n                       e.g. (20, 30) is 20 to the right of the screen's left border, and 30 below the top border\n    :param render:\n    :param sc2_version:\n    :param base_build:\n    :param data_hash:\n    \"\"\"\n\n    def __init__(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        fullscreen: bool = False,\n        resolution: Optional[Union[List[int], Tuple[int, int]]] = None,\n        placement: Optional[Union[List[int], Tuple[int, int]]] = None,\n        render: bool = False,\n        sc2_version: str = None,\n        base_build: str = None,\n        data_hash: str = None,\n    ) -> None:\n        assert isinstance(host, str) or host is None\n        assert isinstance(port, int) or port is None\n\n        self._render = render\n        self._arguments: Dict[str, str] = {\"-displayMode\": str(int(fullscreen))}\n        if not fullscreen:\n            if resolution and len(resolution) == 2:\n                self._arguments[\"-windowwidth\"] = str(resolution[0])\n                self._arguments[\"-windowheight\"] = str(resolution[1])\n            if placement and len(placement) == 2:\n                self._arguments[\"-windowx\"] = str(placement[0])\n                self._arguments[\"-windowy\"] = str(placement[1])\n\n        self._host = host or os.environ.get(\"SC2CLIENTHOST\", \"127.0.0.1\")\n        self._serverhost = os.environ.get(\"SC2SERVERHOST\", self._host)\n\n        if port is None:\n            self._port = portpicker.pick_unused_port()\n        else:\n            self._port = port\n        self._used_portpicker = bool(port is None)\n        self._tmp_dir = tempfile.mkdtemp(prefix=\"SC2_\")\n        self._process: subprocess = None\n        self._session = None\n        self._ws = None\n        self._sc2_version = sc2_version\n        self._base_build = base_build\n        self._data_hash = data_hash\n\n    async def __aenter__(self) -> Controller:\n        kill_switch.add(self)\n\n        def signal_handler(*args):\n            # unused arguments: signal handling library expects all signal\n            # callback handlers to accept two positional arguments\n            kill_switch.kill_all()\n\n        signal.signal(signal.SIGINT, signal_handler)\n\n        try:\n            self._process = self._launch()\n            self._ws = await self._connect()\n        except:\n            await self._close_connection()\n            self._clean()\n            raise\n\n        return Controller(self._ws, self)\n\n    async def __aexit__(self, *args):\n        await self._close_connection()\n        kill_switch.kill_all()\n        signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    @property\n    def ws_url(self):\n        return f\"ws://{self._host}:{self._port}/sc2api\"\n\n    @property\n    def versions(self):\n        \"\"\"Opens the versions.json file which origins from\n        https://github.com/Blizzard/s2client-proto/blob/master/buildinfo/versions.json\"\"\"\n        return VERSIONS\n\n    def find_data_hash(self, target_sc2_version: str) -> Optional[str]:\n        \"\"\" Returns the data hash from the matching version string. \"\"\"\n        version: dict\n        for version in self.versions:\n            if version[\"label\"] == target_sc2_version:\n                return version[\"data-hash\"]\n\n    def _launch(self):\n        if self._base_build:\n            executable = str(paths.latest_executeble(Paths.BASE / \"Versions\", self._base_build))\n        else:\n            executable = str(Paths.EXECUTABLE)\n        if self._port is None:\n            self._port = portpicker.pick_unused_port()\n            self._used_portpicker = True\n        args = paths.get_runner_args(Paths.CWD) + [\n            executable,\n            \"-listen\",\n            self._serverhost,\n            \"-port\",\n            str(self._port),\n            \"-dataDir\",\n            str(Paths.BASE),\n            \"-tempDir\",\n            self._tmp_dir,\n        ]\n        for arg, value in self._arguments.items():\n            args.append(arg)\n            args.append(value)\n        if self._sc2_version:\n\n            def special_match(strg: str):\n                \"\"\" Tests if the specified version is in the versions.py dict. \"\"\"\n                for version in self.versions:\n                    if version[\"label\"] == strg:\n                        return True\n                return False\n\n            valid_version_string = special_match(self._sc2_version)\n            if valid_version_string:\n                self._data_hash = self.find_data_hash(self._sc2_version)\n                assert (\n                    self._data_hash is not None\n                ), f\"StarCraft 2 Client version ({self._sc2_version}) was not found inside sc2/versions.py file. Please check your spelling or check the versions.py file.\"\n\n            else:\n                logger.warning(\n                    f'The submitted version string in sc2.rungame() function call (sc2_version=\"{self._sc2_version}\") was not found in versions.py. Running latest version instead.'\n                )\n\n        if self._data_hash:\n            args.extend([\"-dataVersion\", self._data_hash])\n\n        if self._render:\n            args.extend([\"-eglpath\", \"libEGL.so\"])\n\n        # if logger.getEffectiveLevel() <= logging.DEBUG:\n        args.append(\"-verbose\")\n\n        sc2_cwd = str(Paths.CWD) if Paths.CWD else None\n\n        if paths.PF == \"WSL1\" or paths.PF == \"WSL2\":\n            return wsl.run(args, sc2_cwd)\n\n        return subprocess.Popen(\n            args,\n            cwd=sc2_cwd,\n            # Suppress Wine error messages\n            stderr=subprocess.DEVNULL\n            # , env=run_config.env\n        )\n\n    async def _connect(self):\n        # How long it waits for SC2 to start (in seconds)\n        for i in range(180):\n            if self._process is None:\n                # The ._clean() was called, clearing the process\n                logger.debug(\"Process cleanup complete, exit\")\n                sys.exit()\n\n            await asyncio.sleep(1)\n            try:\n                self._session = aiohttp.ClientSession()\n                ws = await self._session.ws_connect(self.ws_url, timeout=120)\n                # FIXME fix deprecation warning in for future aiohttp version\n                # ws = await self._session.ws_connect(\n                #     self.ws_url, timeout=aiohttp.client_ws.ClientWSTimeout(ws_close=120)\n                # )\n                logger.debug(\"Websocket connection ready\")\n                return ws\n            except aiohttp.client_exceptions.ClientConnectorError:\n                await self._session.close()\n                if i > 15:\n                    logger.debug(\"Connection refused (startup not complete (yet))\")\n\n        logger.debug(\"Websocket connection to SC2 process timed out\")\n        raise TimeoutError(\"Websocket\")\n\n    async def _close_connection(self):\n        logger.info(f\"Closing connection at {self._port}...\")\n\n        if self._ws is not None:\n            await self._ws.close()\n\n        if self._session is not None:\n            await self._session.close()\n\n    def _clean(self):\n        logger.info(\"Cleaning up...\")\n\n        if self._process is not None:\n            if paths.PF == \"WSL1\" or paths.PF == \"WSL2\":\n                if wsl.kill(self._process):\n                    logger.error(\"KILLED\")\n            elif self._process.poll() is None:\n                for _ in range(3):\n                    self._process.terminate()\n                    time.sleep(0.5)\n                    if not self._process or self._process.poll() is not None:\n                        break\n            else:\n                self._process.kill()\n                self._process.wait()\n                logger.error(\"KILLED\")\n            # Try to kill wineserver on linux\n            if paths.PF == \"Linux\" or paths.PF == \"WineLinux\":\n                try:\n                    p = subprocess.Popen([\"wineserver\", \"-k\"])\n                    p.wait()\n                # Command wineserver not detected\n                except FileNotFoundError:\n                    pass\n\n        if os.path.exists(self._tmp_dir):\n            shutil.rmtree(self._tmp_dir)\n\n        self._process = None\n        self._ws = None\n        if self._used_portpicker and self._port is not None:\n            portpicker.return_port(self._port)\n            self._port = None\n        logger.info(\"Cleanup complete\")",
  "def add(cls, value):\n        logger.debug(\"kill_switch: Add switch\")\n        cls._to_kill.append(value)",
  "def kill_all(cls):\n        logger.info(f\"kill_switch: Process cleanup for {len(cls._to_kill)} processes\")\n        for p in cls._to_kill:\n            p._clean()",
  "def __init__(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        fullscreen: bool = False,\n        resolution: Optional[Union[List[int], Tuple[int, int]]] = None,\n        placement: Optional[Union[List[int], Tuple[int, int]]] = None,\n        render: bool = False,\n        sc2_version: str = None,\n        base_build: str = None,\n        data_hash: str = None,\n    ) -> None:\n        assert isinstance(host, str) or host is None\n        assert isinstance(port, int) or port is None\n\n        self._render = render\n        self._arguments: Dict[str, str] = {\"-displayMode\": str(int(fullscreen))}\n        if not fullscreen:\n            if resolution and len(resolution) == 2:\n                self._arguments[\"-windowwidth\"] = str(resolution[0])\n                self._arguments[\"-windowheight\"] = str(resolution[1])\n            if placement and len(placement) == 2:\n                self._arguments[\"-windowx\"] = str(placement[0])\n                self._arguments[\"-windowy\"] = str(placement[1])\n\n        self._host = host or os.environ.get(\"SC2CLIENTHOST\", \"127.0.0.1\")\n        self._serverhost = os.environ.get(\"SC2SERVERHOST\", self._host)\n\n        if port is None:\n            self._port = portpicker.pick_unused_port()\n        else:\n            self._port = port\n        self._used_portpicker = bool(port is None)\n        self._tmp_dir = tempfile.mkdtemp(prefix=\"SC2_\")\n        self._process: subprocess = None\n        self._session = None\n        self._ws = None\n        self._sc2_version = sc2_version\n        self._base_build = base_build\n        self._data_hash = data_hash",
  "async def __aenter__(self) -> Controller:\n        kill_switch.add(self)\n\n        def signal_handler(*args):\n            # unused arguments: signal handling library expects all signal\n            # callback handlers to accept two positional arguments\n            kill_switch.kill_all()\n\n        signal.signal(signal.SIGINT, signal_handler)\n\n        try:\n            self._process = self._launch()\n            self._ws = await self._connect()\n        except:\n            await self._close_connection()\n            self._clean()\n            raise\n\n        return Controller(self._ws, self)",
  "async def __aexit__(self, *args):\n        await self._close_connection()\n        kill_switch.kill_all()\n        signal.signal(signal.SIGINT, signal.SIG_DFL)",
  "def ws_url(self):\n        return f\"ws://{self._host}:{self._port}/sc2api\"",
  "def versions(self):\n        \"\"\"Opens the versions.json file which origins from\n        https://github.com/Blizzard/s2client-proto/blob/master/buildinfo/versions.json\"\"\"\n        return VERSIONS",
  "def find_data_hash(self, target_sc2_version: str) -> Optional[str]:\n        \"\"\" Returns the data hash from the matching version string. \"\"\"\n        version: dict\n        for version in self.versions:\n            if version[\"label\"] == target_sc2_version:\n                return version[\"data-hash\"]",
  "def _launch(self):\n        if self._base_build:\n            executable = str(paths.latest_executeble(Paths.BASE / \"Versions\", self._base_build))\n        else:\n            executable = str(Paths.EXECUTABLE)\n        if self._port is None:\n            self._port = portpicker.pick_unused_port()\n            self._used_portpicker = True\n        args = paths.get_runner_args(Paths.CWD) + [\n            executable,\n            \"-listen\",\n            self._serverhost,\n            \"-port\",\n            str(self._port),\n            \"-dataDir\",\n            str(Paths.BASE),\n            \"-tempDir\",\n            self._tmp_dir,\n        ]\n        for arg, value in self._arguments.items():\n            args.append(arg)\n            args.append(value)\n        if self._sc2_version:\n\n            def special_match(strg: str):\n                \"\"\" Tests if the specified version is in the versions.py dict. \"\"\"\n                for version in self.versions:\n                    if version[\"label\"] == strg:\n                        return True\n                return False\n\n            valid_version_string = special_match(self._sc2_version)\n            if valid_version_string:\n                self._data_hash = self.find_data_hash(self._sc2_version)\n                assert (\n                    self._data_hash is not None\n                ), f\"StarCraft 2 Client version ({self._sc2_version}) was not found inside sc2/versions.py file. Please check your spelling or check the versions.py file.\"\n\n            else:\n                logger.warning(\n                    f'The submitted version string in sc2.rungame() function call (sc2_version=\"{self._sc2_version}\") was not found in versions.py. Running latest version instead.'\n                )\n\n        if self._data_hash:\n            args.extend([\"-dataVersion\", self._data_hash])\n\n        if self._render:\n            args.extend([\"-eglpath\", \"libEGL.so\"])\n\n        # if logger.getEffectiveLevel() <= logging.DEBUG:\n        args.append(\"-verbose\")\n\n        sc2_cwd = str(Paths.CWD) if Paths.CWD else None\n\n        if paths.PF == \"WSL1\" or paths.PF == \"WSL2\":\n            return wsl.run(args, sc2_cwd)\n\n        return subprocess.Popen(\n            args,\n            cwd=sc2_cwd,\n            # Suppress Wine error messages\n            stderr=subprocess.DEVNULL\n            # , env=run_config.env\n        )",
  "async def _connect(self):\n        # How long it waits for SC2 to start (in seconds)\n        for i in range(180):\n            if self._process is None:\n                # The ._clean() was called, clearing the process\n                logger.debug(\"Process cleanup complete, exit\")\n                sys.exit()\n\n            await asyncio.sleep(1)\n            try:\n                self._session = aiohttp.ClientSession()\n                ws = await self._session.ws_connect(self.ws_url, timeout=120)\n                # FIXME fix deprecation warning in for future aiohttp version\n                # ws = await self._session.ws_connect(\n                #     self.ws_url, timeout=aiohttp.client_ws.ClientWSTimeout(ws_close=120)\n                # )\n                logger.debug(\"Websocket connection ready\")\n                return ws\n            except aiohttp.client_exceptions.ClientConnectorError:\n                await self._session.close()\n                if i > 15:\n                    logger.debug(\"Connection refused (startup not complete (yet))\")\n\n        logger.debug(\"Websocket connection to SC2 process timed out\")\n        raise TimeoutError(\"Websocket\")",
  "async def _close_connection(self):\n        logger.info(f\"Closing connection at {self._port}...\")\n\n        if self._ws is not None:\n            await self._ws.close()\n\n        if self._session is not None:\n            await self._session.close()",
  "def _clean(self):\n        logger.info(\"Cleaning up...\")\n\n        if self._process is not None:\n            if paths.PF == \"WSL1\" or paths.PF == \"WSL2\":\n                if wsl.kill(self._process):\n                    logger.error(\"KILLED\")\n            elif self._process.poll() is None:\n                for _ in range(3):\n                    self._process.terminate()\n                    time.sleep(0.5)\n                    if not self._process or self._process.poll() is not None:\n                        break\n            else:\n                self._process.kill()\n                self._process.wait()\n                logger.error(\"KILLED\")\n            # Try to kill wineserver on linux\n            if paths.PF == \"Linux\" or paths.PF == \"WineLinux\":\n                try:\n                    p = subprocess.Popen([\"wineserver\", \"-k\"])\n                    p.wait()\n                # Command wineserver not detected\n                except FileNotFoundError:\n                    pass\n\n        if os.path.exists(self._tmp_dir):\n            shutil.rmtree(self._tmp_dir)\n\n        self._process = None\n        self._ws = None\n        if self._used_portpicker and self._port is not None:\n            portpicker.return_port(self._port)\n            self._port = None\n        logger.info(\"Cleanup complete\")",
  "def signal_handler(*args):\n            # unused arguments: signal handling library expects all signal\n            # callback handlers to accept two positional arguments\n            kill_switch.kill_all()",
  "def special_match(strg: str):\n                \"\"\" Tests if the specified version is in the versions.py dict. \"\"\"\n                for version in self.versions:\n                    if version[\"label\"] == strg:\n                        return True\n                return False",
  "class Controller(Protocol):\n\n    def __init__(self, ws, process):\n        super().__init__(ws)\n        self._process = process\n\n    @property\n    def running(self):\n        return self._process._process is not None\n\n    async def create_game(self, game_map, players, realtime: bool, random_seed=None, disable_fog=None):\n        req = sc_pb.RequestCreateGame(\n            local_map=sc_pb.LocalMap(map_path=str(game_map.relative_path)), realtime=realtime, disable_fog=disable_fog\n        )\n        if random_seed is not None:\n            req.random_seed = random_seed\n\n        for player in players:\n            p = req.player_setup.add()\n            p.type = player.type.value\n            if isinstance(player, Computer):\n                p.race = player.race.value\n                p.difficulty = player.difficulty.value\n                p.ai_build = player.ai_build.value\n\n        logger.info(\"Creating new game\")\n        logger.info(f\"Map:     {game_map.name}\")\n        logger.info(f\"Players: {', '.join(str(p) for p in players)}\")\n        result = await self._execute(create_game=req)\n        return result\n\n    async def request_available_maps(self):\n        req = sc_pb.RequestAvailableMaps()\n        result = await self._execute(available_maps=req)\n        return result\n\n    async def request_save_map(self, download_path: str):\n        \"\"\" Not working on linux. \"\"\"\n        req = sc_pb.RequestSaveMap(map_path=download_path)\n        result = await self._execute(save_map=req)\n        return result\n\n    async def request_replay_info(self, replay_path: str):\n        \"\"\" Not working on linux. \"\"\"\n        req = sc_pb.RequestReplayInfo(replay_path=replay_path, download_data=False)\n        result = await self._execute(replay_info=req)\n        return result\n\n    async def start_replay(self, replay_path: str, realtime: bool, observed_id: int = 0):\n        ifopts = sc_pb.InterfaceOptions(\n            raw=True, score=True, show_cloaked=True, raw_affects_selection=True, raw_crop_to_playable_area=False\n        )\n        if platform.system() == \"Linux\":\n            replay_name = Path(replay_path).name\n            home_replay_folder = Path.home() / \"Documents\" / \"StarCraft II\" / \"Replays\"\n            if str(home_replay_folder / replay_name) != replay_path:\n                logger.warning(\n                    f\"Linux detected, please put your replay in your home directory at {home_replay_folder}. It was detected at {replay_path}\"\n                )\n                raise FileNotFoundError\n            replay_path = replay_name\n\n        req = sc_pb.RequestStartReplay(\n            replay_path=replay_path, observed_player_id=observed_id, realtime=realtime, options=ifopts\n        )\n\n        result = await self._execute(start_replay=req)\n        assert result.status == 4, f\"{result.start_replay.error} - {result.start_replay.error_details}\"\n        return result",
  "def __init__(self, ws, process):\n        super().__init__(ws)\n        self._process = process",
  "def running(self):\n        return self._process._process is not None",
  "async def create_game(self, game_map, players, realtime: bool, random_seed=None, disable_fog=None):\n        req = sc_pb.RequestCreateGame(\n            local_map=sc_pb.LocalMap(map_path=str(game_map.relative_path)), realtime=realtime, disable_fog=disable_fog\n        )\n        if random_seed is not None:\n            req.random_seed = random_seed\n\n        for player in players:\n            p = req.player_setup.add()\n            p.type = player.type.value\n            if isinstance(player, Computer):\n                p.race = player.race.value\n                p.difficulty = player.difficulty.value\n                p.ai_build = player.ai_build.value\n\n        logger.info(\"Creating new game\")\n        logger.info(f\"Map:     {game_map.name}\")\n        logger.info(f\"Players: {', '.join(str(p) for p in players)}\")\n        result = await self._execute(create_game=req)\n        return result",
  "async def request_available_maps(self):\n        req = sc_pb.RequestAvailableMaps()\n        result = await self._execute(available_maps=req)\n        return result",
  "async def request_save_map(self, download_path: str):\n        \"\"\" Not working on linux. \"\"\"\n        req = sc_pb.RequestSaveMap(map_path=download_path)\n        result = await self._execute(save_map=req)\n        return result",
  "async def request_replay_info(self, replay_path: str):\n        \"\"\" Not working on linux. \"\"\"\n        req = sc_pb.RequestReplayInfo(replay_path=replay_path, download_data=False)\n        result = await self._execute(replay_info=req)\n        return result",
  "async def start_replay(self, replay_path: str, realtime: bool, observed_id: int = 0):\n        ifopts = sc_pb.InterfaceOptions(\n            raw=True, score=True, show_cloaked=True, raw_affects_selection=True, raw_crop_to_playable_area=False\n        )\n        if platform.system() == \"Linux\":\n            replay_name = Path(replay_path).name\n            home_replay_folder = Path.home() / \"Documents\" / \"StarCraft II\" / \"Replays\"\n            if str(home_replay_folder / replay_name) != replay_path:\n                logger.warning(\n                    f\"Linux detected, please put your replay in your home directory at {home_replay_folder}. It was detected at {replay_path}\"\n                )\n                raise FileNotFoundError\n            replay_path = replay_name\n\n        req = sc_pb.RequestStartReplay(\n            replay_path=replay_path, observed_player_id=observed_id, realtime=realtime, options=ifopts\n        )\n\n        result = await self._execute(start_replay=req)\n        assert result.status == 4, f\"{result.start_replay.error} - {result.start_replay.error_details}\"\n        return result",
  "class ProtocolError(Exception):\n\n    @property\n    def is_game_over_error(self) -> bool:\n        return self.args[0] in [\"['Game has already ended']\", \"['Not supported if game has already ended']\"]",
  "class ConnectionAlreadyClosed(ProtocolError):\n    pass",
  "class Protocol:\n\n    def __init__(self, ws):\n        \"\"\"\n        A class for communicating with an SCII application.\n        :param ws: the websocket (type: aiohttp.ClientWebSocketResponse) used to communicate with a specific SCII app\n        \"\"\"\n        assert ws\n        self._ws: ClientWebSocketResponse = ws\n        self._status: Status = None\n\n    async def __request(self, request):\n        logger.debug(f\"Sending request: {request !r}\")\n        try:\n            await self._ws.send_bytes(request.SerializeToString())\n        except TypeError:\n            logger.exception(\"Cannot send: Connection already closed.\")\n            raise ConnectionAlreadyClosed(\"Connection already closed.\")\n        logger.debug(\"Request sent\")\n\n        response = sc_pb.Response()\n        try:\n            response_bytes = await self._ws.receive_bytes()\n        except TypeError:\n            if self._status == Status.ended:\n                logger.info(\"Cannot receive: Game has already ended.\")\n                raise ConnectionAlreadyClosed(\"Game has already ended\")\n            else:\n                logger.error(\"Cannot receive: Connection already closed.\")\n                raise ConnectionAlreadyClosed(\"Connection already closed.\")\n        except asyncio.CancelledError:\n            # If request is sent, the response must be received before reraising cancel\n            try:\n                await self._ws.receive_bytes()\n            except asyncio.CancelledError:\n                logger.critical(\"Requests must not be cancelled multiple times\")\n                sys.exit(2)\n            raise\n\n        response.ParseFromString(response_bytes)\n        logger.debug(\"Response received\")\n        return response\n\n    async def _execute(self, **kwargs):\n        assert len(kwargs) == 1, \"Only one request allowed\"\n\n        response = await self.__request(sc_pb.Request(**kwargs))\n\n        new_status = Status(response.status)\n        if new_status != self._status:\n            logger.info(f\"Client status changed to {new_status} (was {self._status})\")\n        self._status = new_status\n\n        if response.error:\n            logger.debug(f\"Response contained an error: {response.error}\")\n            raise ProtocolError(f\"{response.error}\")\n\n        return response\n\n    async def ping(self):\n        result = await self._execute(ping=sc_pb.RequestPing())\n        return result\n\n    async def quit(self):\n        try:\n            await self._execute(quit=sc_pb.RequestQuit())\n        except ConnectionAlreadyClosed:\n            pass",
  "def is_game_over_error(self) -> bool:\n        return self.args[0] in [\"['Game has already ended']\", \"['Not supported if game has already ended']\"]",
  "def __init__(self, ws):\n        \"\"\"\n        A class for communicating with an SCII application.\n        :param ws: the websocket (type: aiohttp.ClientWebSocketResponse) used to communicate with a specific SCII app\n        \"\"\"\n        assert ws\n        self._ws: ClientWebSocketResponse = ws\n        self._status: Status = None",
  "async def __request(self, request):\n        logger.debug(f\"Sending request: {request !r}\")\n        try:\n            await self._ws.send_bytes(request.SerializeToString())\n        except TypeError:\n            logger.exception(\"Cannot send: Connection already closed.\")\n            raise ConnectionAlreadyClosed(\"Connection already closed.\")\n        logger.debug(\"Request sent\")\n\n        response = sc_pb.Response()\n        try:\n            response_bytes = await self._ws.receive_bytes()\n        except TypeError:\n            if self._status == Status.ended:\n                logger.info(\"Cannot receive: Game has already ended.\")\n                raise ConnectionAlreadyClosed(\"Game has already ended\")\n            else:\n                logger.error(\"Cannot receive: Connection already closed.\")\n                raise ConnectionAlreadyClosed(\"Connection already closed.\")\n        except asyncio.CancelledError:\n            # If request is sent, the response must be received before reraising cancel\n            try:\n                await self._ws.receive_bytes()\n            except asyncio.CancelledError:\n                logger.critical(\"Requests must not be cancelled multiple times\")\n                sys.exit(2)\n            raise\n\n        response.ParseFromString(response_bytes)\n        logger.debug(\"Response received\")\n        return response",
  "async def _execute(self, **kwargs):\n        assert len(kwargs) == 1, \"Only one request allowed\"\n\n        response = await self.__request(sc_pb.Request(**kwargs))\n\n        new_status = Status(response.status)\n        if new_status != self._status:\n            logger.info(f\"Client status changed to {new_status} (was {self._status})\")\n        self._status = new_status\n\n        if response.error:\n            logger.debug(f\"Response contained an error: {response.error}\")\n            raise ProtocolError(f\"{response.error}\")\n\n        return response",
  "async def ping(self):\n        result = await self._execute(ping=sc_pb.RequestPing())\n        return result",
  "async def quit(self):\n        try:\n            await self._execute(quit=sc_pb.RequestQuit())\n        except ConnectionAlreadyClosed:\n            pass",
  "def combine_actions(action_iter):\n    \"\"\"\n    Example input:\n    [\n        # Each entry in the list is a unit command, with an ability, unit, target, and queue=boolean\n        UnitCommand(AbilityId.TRAINQUEEN_QUEEN, Unit(name='Hive', tag=4353687554), None, False),\n        UnitCommand(AbilityId.TRAINQUEEN_QUEEN, Unit(name='Lair', tag=4359979012), None, False),\n        UnitCommand(AbilityId.TRAINQUEEN_QUEEN, Unit(name='Hatchery', tag=4359454723), None, False),\n    ]\n    \"\"\"\n    for key, items in groupby(action_iter, key=lambda a: a.combining_tuple):\n        ability: AbilityId\n        target: Union[None, Point2, Unit]\n        queue: bool\n        # See constants.py for combineable abilities\n        combineable: bool\n        ability, target, queue, combineable = key\n\n        if combineable:\n            # Combine actions with no target, e.g. lift, burrowup, burrowdown, siege, unsiege, uproot spines\n            cmd = raw_pb.ActionRawUnitCommand(\n                ability_id=ability.value, unit_tags={u.unit.tag\n                                                     for u in items}, queue_command=queue\n            )\n            # Combine actions with target point, e.g. attack_move or move commands on a position\n            if isinstance(target, Point2):\n                cmd.target_world_space_pos.x = target.x\n                cmd.target_world_space_pos.y = target.y\n            # Combine actions with target unit, e.g. attack commands directly on a unit\n            elif isinstance(target, Unit):\n                cmd.target_unit_tag = target.tag\n            elif target is not None:\n                raise RuntimeError(f\"Must target a unit, point or None, found '{target !r}'\")\n\n            yield raw_pb.ActionRaw(unit_command=cmd)\n\n        else:\n            \"\"\"\n            Return one action for each unit; this is required for certain commands that would otherwise be grouped, and only executed once\n            Examples:\n            Select 3 hatcheries, build a queen with each hatch - the grouping function would group these unit tags and only issue one train command once to all 3 unit tags - resulting in one total train command\n            I imagine the same thing would happen to certain other abilities: Battlecruiser yamato on same target, queen transfuse on same target, ghost snipe on same target, all build commands with the same unit type and also all morphs (zergling to banelings)\n            However, other abilities can and should be grouped, see constants.py 'COMBINEABLE_ABILITIES'\n            \"\"\"\n            u: UnitCommand\n            if target is None:\n                for u in items:\n                    cmd = raw_pb.ActionRawUnitCommand(\n                        ability_id=ability.value, unit_tags={u.unit.tag}, queue_command=queue\n                    )\n                    yield raw_pb.ActionRaw(unit_command=cmd)\n            elif isinstance(target, Point2):\n                for u in items:\n                    cmd = raw_pb.ActionRawUnitCommand(\n                        ability_id=ability.value,\n                        unit_tags={u.unit.tag},\n                        queue_command=queue,\n                        target_world_space_pos=target.as_Point2D,\n                    )\n                    yield raw_pb.ActionRaw(unit_command=cmd)\n\n            elif isinstance(target, Unit):\n                for u in items:\n                    cmd = raw_pb.ActionRawUnitCommand(\n                        ability_id=ability.value,\n                        unit_tags={u.unit.tag},\n                        queue_command=queue,\n                        target_unit_tag=target.tag,\n                    )\n                    yield raw_pb.ActionRaw(unit_command=cmd)\n            else:\n                raise RuntimeError(f\"Must target a unit, point or None, found '{target !r}'\")",
  "class Proxy:\n    \"\"\"\n    Class for handling communication between sc2 and an external bot.\n    This \"middleman\" is needed for enforcing time limits, collecting results, and closing things properly.\n    \"\"\"\n\n    def __init__(\n        self,\n        controller: Controller,\n        player: BotProcess,\n        proxyport: int,\n        game_time_limit: int = None,\n        realtime: bool = False,\n    ):\n        self.controller = controller\n        self.player = player\n        self.port = proxyport\n        self.timeout_loop = game_time_limit * 22.4 if game_time_limit else None\n        self.realtime = realtime\n        logger.debug(\n            f\"Proxy Inited with ctrl {controller}({controller._process._port}), player {player}, proxyport {proxyport}, lim {game_time_limit}\"\n        )\n\n        self.result = None\n        self.player_id: int = None\n        self.done = False\n\n    async def parse_request(self, msg):\n        request = sc_pb.Request()\n        request.ParseFromString(msg.data)\n        if request.HasField(\"quit\"):\n            request = sc_pb.Request(leave_game=sc_pb.RequestLeaveGame())\n        if request.HasField(\"leave_game\"):\n            if self.controller._status == Status.in_game:\n                logger.info(f\"Proxy: player {self.player.name}({self.player_id}) surrenders\")\n                self.result = {self.player_id: Result.Defeat}\n            elif self.controller._status == Status.ended:\n                await self.get_response()\n        elif request.HasField(\"join_game\") and not request.join_game.HasField(\"player_name\"):\n            request.join_game.player_name = self.player.name\n        await self.controller._ws.send_bytes(request.SerializeToString())\n\n    async def get_response(self):\n        response_bytes = None\n        try:\n            response_bytes = await self.controller._ws.receive_bytes()\n        except TypeError as e:\n            logger.exception(\"Cannot receive: SC2 Connection already closed.\")\n            tb = traceback.format_exc()\n            logger.error(f\"Exception {e}: {tb}\")\n        except asyncio.CancelledError:\n            logger.info(f\"Proxy({self.player.name}), caught receive from sc2\")\n            try:\n                x = await self.controller._ws.receive_bytes()\n                if response_bytes is None:\n                    response_bytes = x\n            except (asyncio.CancelledError, asyncio.TimeoutError, Exception) as e:\n                tb = traceback.format_exc()\n                logger.error(f\"Exception {e}: {tb}\")\n        except Exception as e:\n            tb = traceback.format_exc()\n            logger.error(f\"Exception {e}: {tb}\")\n        return response_bytes\n\n    async def parse_response(self, response_bytes):\n        response = sc_pb.Response()\n        response.ParseFromString(response_bytes)\n\n        if not response.HasField(\"status\"):\n            logger.critical(\"Proxy: RESPONSE HAS NO STATUS {response}\")\n        else:\n            new_status = Status(response.status)\n            if new_status != self.controller._status:\n                logger.info(f\"Controller({self.player.name}): {self.controller._status}->{new_status}\")\n                self.controller._status = new_status\n\n        if self.player_id is None:\n            if response.HasField(\"join_game\"):\n                self.player_id = response.join_game.player_id\n                logger.info(f\"Proxy({self.player.name}): got join_game for {self.player_id}\")\n\n        if self.result is None:\n            if response.HasField(\"observation\"):\n                obs: sc_pb.ResponseObservation = response.observation\n                if obs.player_result:\n                    self.result = {pr.player_id: Result(pr.result) for pr in obs.player_result}\n                elif (\n                    self.timeout_loop and obs.HasField(\"observation\") and obs.observation.game_loop > self.timeout_loop\n                ):\n                    self.result = {i: Result.Tie for i in range(1, 3)}\n                    logger.info(f\"Proxy({self.player.name}) timing out\")\n                    act = [sc_pb.Action(action_chat=sc_pb.ActionChat(message=f\"Proxy: Timing out\"))]\n                    await self.controller._execute(action=sc_pb.RequestAction(actions=act))\n        return response\n\n    async def get_result(self):\n        try:\n            res = await self.controller.ping()\n            if res.status in {Status.in_game, Status.in_replay, Status.ended}:\n                res = await self.controller._execute(observation=sc_pb.RequestObservation())\n                if res.HasField(\"observation\") and res.observation.player_result:\n                    self.result = {pr.player_id: Result(pr.result) for pr in res.observation.player_result}\n        except Exception as e:\n            tb = traceback.format_exc()\n            logger.error(f\"Obs-check: {e}, traceback: {tb}\")\n\n    async def proxy_handler(self, request):\n        bot_ws = web.WebSocketResponse(receive_timeout=30)\n        await bot_ws.prepare(request)\n        try:\n            async for msg in bot_ws:\n                if msg.data is None:\n                    raise TypeError(f\"data is None, {msg}\")\n                if msg.data and msg.type == WSMsgType.BINARY:\n\n                    await self.parse_request(msg)\n\n                    response_bytes = await self.get_response()\n                    if response_bytes is None:\n                        raise ConnectionError(\"Could not get response_bytes\")\n\n                    new_response = await self.parse_response(response_bytes)\n                    await bot_ws.send_bytes(new_response.SerializeToString())\n\n                elif msg.type == WSMsgType.CLOSED:\n                    logger.error(\"Client shutdown\")\n                else:\n                    logger.error(\"Incorrect message type\")\n        except Exception as e:\n            IGNORED_ERRORS = {ConnectionError, asyncio.CancelledError}\n            if not any([isinstance(e, E) for E in IGNORED_ERRORS]):\n                tb = traceback.format_exc()\n                logger.info(f\"Proxy({self.player.name}): Caught {e} traceback: {tb}\")\n        finally:\n            try:\n                if self.controller._status in {Status.in_game, Status.in_replay}:\n                    await self.controller._execute(leave_game=sc_pb.RequestLeaveGame())\n                await bot_ws.close()\n            except Exception as ee:\n                tbb = traceback.format_exc()\n                logger.info(f\"Proxy({self.player.name}): Caught during Surrender\", ee, \"traceback:\", tbb)\n            self.done = True\n        return bot_ws\n\n    async def play_with_proxy(self, startport):\n        logger.info(f\"Proxy({self.port}): Starting app\")\n        app = web.Application()\n        app.router.add_route(\"GET\", \"/sc2api\", self.proxy_handler)\n        apprunner = web.AppRunner(app, access_log=None)\n        await apprunner.setup()\n        appsite = web.TCPSite(apprunner, self.controller._process._host, self.port)\n        await appsite.start()\n\n        subproc_args = {\"cwd\": str(self.player.path), \"stderr\": subprocess.STDOUT}\n        if platform.system() == \"Linux\":\n            subproc_args[\"preexec_fn\"] = os.setpgrp\n        elif platform.system() == \"Windows\":\n            subproc_args[\"creationflags\"] = subprocess.CREATE_NEW_PROCESS_GROUP\n\n        player_command_line = self.player.cmd_line(self.port, startport, self.controller._process._host, self.realtime)\n        logger.info(f\"Starting bot with command: {' '.join(player_command_line)}\")\n        if self.player.stdout is None:\n            bot_process = subprocess.Popen(player_command_line, stdout=subprocess.DEVNULL, **subproc_args)\n        else:\n            with open(self.player.stdout, \"w+\") as out:\n                bot_process = subprocess.Popen(player_command_line, stdout=out, **subproc_args)\n\n        while self.result is None:\n            bot_alive = bot_process and bot_process.poll() is None\n            sc2_alive = self.controller.running\n            if self.done or not (bot_alive and sc2_alive):\n                logger.info(\n                    f\"Proxy({self.port}): {self.player.name} died, \"\n                    f\"bot{(not bot_alive) * ' not'} alive, sc2{(not sc2_alive) * ' not'} alive\"\n                )\n                # Maybe its still possible to retrieve a result\n                if sc2_alive and not self.done:\n                    await self.get_response()\n                logger.info(f\"Proxy({self.port}): breaking, result {self.result}\")\n                break\n            await asyncio.sleep(5)\n\n        # cleanup\n        logger.info(f\"({self.port}): cleaning up {self.player !r}\")\n        for i in range(3):\n            if isinstance(bot_process, subprocess.Popen):\n                if bot_process.stdout and not bot_process.stdout.closed:  # should not run anymore\n                    logger.info(f\"==================output for player {self.player.name}\")\n                    for l in bot_process.stdout.readlines():\n                        logger.opt(raw=True).info(l.decode(\"utf-8\"))\n                    bot_process.stdout.close()\n                    logger.info(\"==================\")\n                bot_process.terminate()\n                bot_process.wait()\n            time.sleep(0.5)\n            if not bot_process or bot_process.poll() is not None:\n                break\n        else:\n            bot_process.terminate()\n            bot_process.wait()\n        try:\n            await apprunner.cleanup()\n        except Exception as e:\n            logger.error(f\"cleaning error {e}\")\n        if isinstance(self.result, dict):\n            self.result[None] = None\n            return self.result[self.player_id]\n        else:\n            return self.result",
  "def __init__(\n        self,\n        controller: Controller,\n        player: BotProcess,\n        proxyport: int,\n        game_time_limit: int = None,\n        realtime: bool = False,\n    ):\n        self.controller = controller\n        self.player = player\n        self.port = proxyport\n        self.timeout_loop = game_time_limit * 22.4 if game_time_limit else None\n        self.realtime = realtime\n        logger.debug(\n            f\"Proxy Inited with ctrl {controller}({controller._process._port}), player {player}, proxyport {proxyport}, lim {game_time_limit}\"\n        )\n\n        self.result = None\n        self.player_id: int = None\n        self.done = False",
  "async def parse_request(self, msg):\n        request = sc_pb.Request()\n        request.ParseFromString(msg.data)\n        if request.HasField(\"quit\"):\n            request = sc_pb.Request(leave_game=sc_pb.RequestLeaveGame())\n        if request.HasField(\"leave_game\"):\n            if self.controller._status == Status.in_game:\n                logger.info(f\"Proxy: player {self.player.name}({self.player_id}) surrenders\")\n                self.result = {self.player_id: Result.Defeat}\n            elif self.controller._status == Status.ended:\n                await self.get_response()\n        elif request.HasField(\"join_game\") and not request.join_game.HasField(\"player_name\"):\n            request.join_game.player_name = self.player.name\n        await self.controller._ws.send_bytes(request.SerializeToString())",
  "async def get_response(self):\n        response_bytes = None\n        try:\n            response_bytes = await self.controller._ws.receive_bytes()\n        except TypeError as e:\n            logger.exception(\"Cannot receive: SC2 Connection already closed.\")\n            tb = traceback.format_exc()\n            logger.error(f\"Exception {e}: {tb}\")\n        except asyncio.CancelledError:\n            logger.info(f\"Proxy({self.player.name}), caught receive from sc2\")\n            try:\n                x = await self.controller._ws.receive_bytes()\n                if response_bytes is None:\n                    response_bytes = x\n            except (asyncio.CancelledError, asyncio.TimeoutError, Exception) as e:\n                tb = traceback.format_exc()\n                logger.error(f\"Exception {e}: {tb}\")\n        except Exception as e:\n            tb = traceback.format_exc()\n            logger.error(f\"Exception {e}: {tb}\")\n        return response_bytes",
  "async def parse_response(self, response_bytes):\n        response = sc_pb.Response()\n        response.ParseFromString(response_bytes)\n\n        if not response.HasField(\"status\"):\n            logger.critical(\"Proxy: RESPONSE HAS NO STATUS {response}\")\n        else:\n            new_status = Status(response.status)\n            if new_status != self.controller._status:\n                logger.info(f\"Controller({self.player.name}): {self.controller._status}->{new_status}\")\n                self.controller._status = new_status\n\n        if self.player_id is None:\n            if response.HasField(\"join_game\"):\n                self.player_id = response.join_game.player_id\n                logger.info(f\"Proxy({self.player.name}): got join_game for {self.player_id}\")\n\n        if self.result is None:\n            if response.HasField(\"observation\"):\n                obs: sc_pb.ResponseObservation = response.observation\n                if obs.player_result:\n                    self.result = {pr.player_id: Result(pr.result) for pr in obs.player_result}\n                elif (\n                    self.timeout_loop and obs.HasField(\"observation\") and obs.observation.game_loop > self.timeout_loop\n                ):\n                    self.result = {i: Result.Tie for i in range(1, 3)}\n                    logger.info(f\"Proxy({self.player.name}) timing out\")\n                    act = [sc_pb.Action(action_chat=sc_pb.ActionChat(message=f\"Proxy: Timing out\"))]\n                    await self.controller._execute(action=sc_pb.RequestAction(actions=act))\n        return response",
  "async def get_result(self):\n        try:\n            res = await self.controller.ping()\n            if res.status in {Status.in_game, Status.in_replay, Status.ended}:\n                res = await self.controller._execute(observation=sc_pb.RequestObservation())\n                if res.HasField(\"observation\") and res.observation.player_result:\n                    self.result = {pr.player_id: Result(pr.result) for pr in res.observation.player_result}\n        except Exception as e:\n            tb = traceback.format_exc()\n            logger.error(f\"Obs-check: {e}, traceback: {tb}\")",
  "async def proxy_handler(self, request):\n        bot_ws = web.WebSocketResponse(receive_timeout=30)\n        await bot_ws.prepare(request)\n        try:\n            async for msg in bot_ws:\n                if msg.data is None:\n                    raise TypeError(f\"data is None, {msg}\")\n                if msg.data and msg.type == WSMsgType.BINARY:\n\n                    await self.parse_request(msg)\n\n                    response_bytes = await self.get_response()\n                    if response_bytes is None:\n                        raise ConnectionError(\"Could not get response_bytes\")\n\n                    new_response = await self.parse_response(response_bytes)\n                    await bot_ws.send_bytes(new_response.SerializeToString())\n\n                elif msg.type == WSMsgType.CLOSED:\n                    logger.error(\"Client shutdown\")\n                else:\n                    logger.error(\"Incorrect message type\")\n        except Exception as e:\n            IGNORED_ERRORS = {ConnectionError, asyncio.CancelledError}\n            if not any([isinstance(e, E) for E in IGNORED_ERRORS]):\n                tb = traceback.format_exc()\n                logger.info(f\"Proxy({self.player.name}): Caught {e} traceback: {tb}\")\n        finally:\n            try:\n                if self.controller._status in {Status.in_game, Status.in_replay}:\n                    await self.controller._execute(leave_game=sc_pb.RequestLeaveGame())\n                await bot_ws.close()\n            except Exception as ee:\n                tbb = traceback.format_exc()\n                logger.info(f\"Proxy({self.player.name}): Caught during Surrender\", ee, \"traceback:\", tbb)\n            self.done = True\n        return bot_ws",
  "async def play_with_proxy(self, startport):\n        logger.info(f\"Proxy({self.port}): Starting app\")\n        app = web.Application()\n        app.router.add_route(\"GET\", \"/sc2api\", self.proxy_handler)\n        apprunner = web.AppRunner(app, access_log=None)\n        await apprunner.setup()\n        appsite = web.TCPSite(apprunner, self.controller._process._host, self.port)\n        await appsite.start()\n\n        subproc_args = {\"cwd\": str(self.player.path), \"stderr\": subprocess.STDOUT}\n        if platform.system() == \"Linux\":\n            subproc_args[\"preexec_fn\"] = os.setpgrp\n        elif platform.system() == \"Windows\":\n            subproc_args[\"creationflags\"] = subprocess.CREATE_NEW_PROCESS_GROUP\n\n        player_command_line = self.player.cmd_line(self.port, startport, self.controller._process._host, self.realtime)\n        logger.info(f\"Starting bot with command: {' '.join(player_command_line)}\")\n        if self.player.stdout is None:\n            bot_process = subprocess.Popen(player_command_line, stdout=subprocess.DEVNULL, **subproc_args)\n        else:\n            with open(self.player.stdout, \"w+\") as out:\n                bot_process = subprocess.Popen(player_command_line, stdout=out, **subproc_args)\n\n        while self.result is None:\n            bot_alive = bot_process and bot_process.poll() is None\n            sc2_alive = self.controller.running\n            if self.done or not (bot_alive and sc2_alive):\n                logger.info(\n                    f\"Proxy({self.port}): {self.player.name} died, \"\n                    f\"bot{(not bot_alive) * ' not'} alive, sc2{(not sc2_alive) * ' not'} alive\"\n                )\n                # Maybe its still possible to retrieve a result\n                if sc2_alive and not self.done:\n                    await self.get_response()\n                logger.info(f\"Proxy({self.port}): breaking, result {self.result}\")\n                break\n            await asyncio.sleep(5)\n\n        # cleanup\n        logger.info(f\"({self.port}): cleaning up {self.player !r}\")\n        for i in range(3):\n            if isinstance(bot_process, subprocess.Popen):\n                if bot_process.stdout and not bot_process.stdout.closed:  # should not run anymore\n                    logger.info(f\"==================output for player {self.player.name}\")\n                    for l in bot_process.stdout.readlines():\n                        logger.opt(raw=True).info(l.decode(\"utf-8\"))\n                    bot_process.stdout.close()\n                    logger.info(\"==================\")\n                bot_process.terminate()\n                bot_process.wait()\n            time.sleep(0.5)\n            if not bot_process or bot_process.poll() is not None:\n                break\n        else:\n            bot_process.terminate()\n            bot_process.wait()\n        try:\n            await apprunner.cleanup()\n        except Exception as e:\n            logger.error(f\"cleaning error {e}\")\n        if isinstance(self.result, dict):\n            self.result[None] = None\n            return self.result[self.player_id]\n        else:\n            return self.result",
  "class PowerSource:\n\n    @classmethod\n    def from_proto(cls, proto):\n        return cls(Point2.from_proto(proto.pos), proto.radius, proto.tag)\n\n    def __init__(self, position, radius, unit_tag):\n        assert isinstance(position, Point2)\n        assert radius > 0\n        self.position = position\n        self.radius = radius\n        self.unit_tag = unit_tag\n\n    def covers(self, position):\n        return self.position.distance_to(position) <= self.radius\n\n    def __repr__(self):\n        return f\"PowerSource({self.position}, {self.radius})\"",
  "class PsionicMatrix:\n\n    @classmethod\n    def from_proto(cls, proto):\n        return cls([PowerSource.from_proto(p) for p in proto])\n\n    def __init__(self, sources):\n        self.sources = sources\n\n    def covers(self, position):\n        return any(source.covers(position) for source in self.sources)",
  "def from_proto(cls, proto):\n        return cls(Point2.from_proto(proto.pos), proto.radius, proto.tag)",
  "def __init__(self, position, radius, unit_tag):\n        assert isinstance(position, Point2)\n        assert radius > 0\n        self.position = position\n        self.radius = radius\n        self.unit_tag = unit_tag",
  "def covers(self, position):\n        return self.position.distance_to(position) <= self.radius",
  "def __repr__(self):\n        return f\"PowerSource({self.position}, {self.radius})\"",
  "def from_proto(cls, proto):\n        return cls([PowerSource.from_proto(p) for p in proto])",
  "def __init__(self, sources):\n        self.sources = sources",
  "def covers(self, position):\n        return any(source.covers(position) for source in self.sources)",
  "class ControlGroup(set):\n\n    def __init__(self, units):\n        super().__init__({unit.tag for unit in units})\n\n    def __hash__(self):\n        return hash(tuple(sorted(list(self))))\n\n    def select_units(self, units):\n        return units.filter(lambda unit: unit.tag in self)\n\n    def missing_unit_tags(self, units):\n        return {t for t in self if units.find_by_tag(t) is None}\n\n    @property\n    def amount(self) -> int:\n        return len(self)\n\n    @property\n    def empty(self) -> bool:\n        return not self\n\n    def add_unit(self, unit):\n        self.add(unit.tag)\n\n    def add_units(self, units):\n        for unit in units:\n            self.add_unit(unit)\n\n    def remove_unit(self, unit):\n        self.discard(unit.tag)\n\n    def remove_units(self, units):\n        for unit in units:\n            self.discard(unit.tag)",
  "def __init__(self, units):\n        super().__init__({unit.tag for unit in units})",
  "def __hash__(self):\n        return hash(tuple(sorted(list(self))))",
  "def select_units(self, units):\n        return units.filter(lambda unit: unit.tag in self)",
  "def missing_unit_tags(self, units):\n        return {t for t in self if units.find_by_tag(t) is None}",
  "def amount(self) -> int:\n        return len(self)",
  "def empty(self) -> bool:\n        return not self",
  "def add_unit(self, unit):\n        self.add(unit.tag)",
  "def add_units(self, units):\n        for unit in units:\n            self.add_unit(unit)",
  "def remove_unit(self, unit):\n        self.discard(unit.tag)",
  "def remove_units(self, units):\n        for unit in units:\n            self.discard(unit.tag)",
  "def time_this(label):\n    start = time.perf_counter_ns()\n    try:\n        yield\n    finally:\n        end = time.perf_counter_ns()\n        print(f\"TIME {label}: {(end-start)/1000000000} sec\")",
  "def is_submodule(path):\n    if path.is_file():\n        return path.suffix == \".py\" and path.stem != \"__init__\"\n    elif path.is_dir():\n        return (path / \"__init__.py\").exists()\n    return False",
  "class UnitTypeId(enum.Enum):\n    NOTAUNIT = 0\n    SYSTEM_SNAPSHOT_DUMMY = 1\n    BALL = 2\n    STEREOSCOPICOPTIONSUNIT = 3\n    COLOSSUS = 4\n    TECHLAB = 5\n    REACTOR = 6\n    INFESTORTERRAN = 7\n    BANELINGCOCOON = 8\n    BANELING = 9\n    MOTHERSHIP = 10\n    POINTDEFENSEDRONE = 11\n    CHANGELING = 12\n    CHANGELINGZEALOT = 13\n    CHANGELINGMARINESHIELD = 14\n    CHANGELINGMARINE = 15\n    CHANGELINGZERGLINGWINGS = 16\n    CHANGELINGZERGLING = 17\n    COMMANDCENTER = 18\n    SUPPLYDEPOT = 19\n    REFINERY = 20\n    BARRACKS = 21\n    ENGINEERINGBAY = 22\n    MISSILETURRET = 23\n    BUNKER = 24\n    SENSORTOWER = 25\n    GHOSTACADEMY = 26\n    FACTORY = 27\n    STARPORT = 28\n    ARMORY = 29\n    FUSIONCORE = 30\n    AUTOTURRET = 31\n    SIEGETANKSIEGED = 32\n    SIEGETANK = 33\n    VIKINGASSAULT = 34\n    VIKINGFIGHTER = 35\n    COMMANDCENTERFLYING = 36\n    BARRACKSTECHLAB = 37\n    BARRACKSREACTOR = 38\n    FACTORYTECHLAB = 39\n    FACTORYREACTOR = 40\n    STARPORTTECHLAB = 41\n    STARPORTREACTOR = 42\n    FACTORYFLYING = 43\n    STARPORTFLYING = 44\n    SCV = 45\n    BARRACKSFLYING = 46\n    SUPPLYDEPOTLOWERED = 47\n    MARINE = 48\n    REAPER = 49\n    GHOST = 50\n    MARAUDER = 51\n    THOR = 52\n    HELLION = 53\n    MEDIVAC = 54\n    BANSHEE = 55\n    RAVEN = 56\n    BATTLECRUISER = 57\n    NUKE = 58\n    NEXUS = 59\n    PYLON = 60\n    ASSIMILATOR = 61\n    GATEWAY = 62\n    FORGE = 63\n    FLEETBEACON = 64\n    TWILIGHTCOUNCIL = 65\n    PHOTONCANNON = 66\n    STARGATE = 67\n    TEMPLARARCHIVE = 68\n    DARKSHRINE = 69\n    ROBOTICSBAY = 70\n    ROBOTICSFACILITY = 71\n    CYBERNETICSCORE = 72\n    ZEALOT = 73\n    STALKER = 74\n    HIGHTEMPLAR = 75\n    DARKTEMPLAR = 76\n    SENTRY = 77\n    PHOENIX = 78\n    CARRIER = 79\n    VOIDRAY = 80\n    WARPPRISM = 81\n    OBSERVER = 82\n    IMMORTAL = 83\n    PROBE = 84\n    INTERCEPTOR = 85\n    HATCHERY = 86\n    CREEPTUMOR = 87\n    EXTRACTOR = 88\n    SPAWNINGPOOL = 89\n    EVOLUTIONCHAMBER = 90\n    HYDRALISKDEN = 91\n    SPIRE = 92\n    ULTRALISKCAVERN = 93\n    INFESTATIONPIT = 94\n    NYDUSNETWORK = 95\n    BANELINGNEST = 96\n    ROACHWARREN = 97\n    SPINECRAWLER = 98\n    SPORECRAWLER = 99\n    LAIR = 100\n    HIVE = 101\n    GREATERSPIRE = 102\n    EGG = 103\n    DRONE = 104\n    ZERGLING = 105\n    OVERLORD = 106\n    HYDRALISK = 107\n    MUTALISK = 108\n    ULTRALISK = 109\n    ROACH = 110\n    INFESTOR = 111\n    CORRUPTOR = 112\n    BROODLORDCOCOON = 113\n    BROODLORD = 114\n    BANELINGBURROWED = 115\n    DRONEBURROWED = 116\n    HYDRALISKBURROWED = 117\n    ROACHBURROWED = 118\n    ZERGLINGBURROWED = 119\n    INFESTORTERRANBURROWED = 120\n    REDSTONELAVACRITTERBURROWED = 121\n    REDSTONELAVACRITTERINJUREDBURROWED = 122\n    REDSTONELAVACRITTER = 123\n    REDSTONELAVACRITTERINJURED = 124\n    QUEENBURROWED = 125\n    QUEEN = 126\n    INFESTORBURROWED = 127\n    OVERLORDCOCOON = 128\n    OVERSEER = 129\n    PLANETARYFORTRESS = 130\n    ULTRALISKBURROWED = 131\n    ORBITALCOMMAND = 132\n    WARPGATE = 133\n    ORBITALCOMMANDFLYING = 134\n    FORCEFIELD = 135\n    WARPPRISMPHASING = 136\n    CREEPTUMORBURROWED = 137\n    CREEPTUMORQUEEN = 138\n    SPINECRAWLERUPROOTED = 139\n    SPORECRAWLERUPROOTED = 140\n    ARCHON = 141\n    NYDUSCANAL = 142\n    BROODLINGESCORT = 143\n    GHOSTALTERNATE = 144\n    GHOSTNOVA = 145\n    RICHMINERALFIELD = 146\n    RICHMINERALFIELD750 = 147\n    URSADON = 148\n    XELNAGATOWER = 149\n    INFESTEDTERRANSEGG = 150\n    LARVA = 151\n    REAPERPLACEHOLDER = 152\n    MARINEACGLUESCREENDUMMY = 153\n    FIREBATACGLUESCREENDUMMY = 154\n    MEDICACGLUESCREENDUMMY = 155\n    MARAUDERACGLUESCREENDUMMY = 156\n    VULTUREACGLUESCREENDUMMY = 157\n    SIEGETANKACGLUESCREENDUMMY = 158\n    VIKINGACGLUESCREENDUMMY = 159\n    BANSHEEACGLUESCREENDUMMY = 160\n    BATTLECRUISERACGLUESCREENDUMMY = 161\n    ORBITALCOMMANDACGLUESCREENDUMMY = 162\n    BUNKERACGLUESCREENDUMMY = 163\n    BUNKERUPGRADEDACGLUESCREENDUMMY = 164\n    MISSILETURRETACGLUESCREENDUMMY = 165\n    HELLBATACGLUESCREENDUMMY = 166\n    GOLIATHACGLUESCREENDUMMY = 167\n    CYCLONEACGLUESCREENDUMMY = 168\n    WRAITHACGLUESCREENDUMMY = 169\n    SCIENCEVESSELACGLUESCREENDUMMY = 170\n    HERCULESACGLUESCREENDUMMY = 171\n    THORACGLUESCREENDUMMY = 172\n    PERDITIONTURRETACGLUESCREENDUMMY = 173\n    FLAMINGBETTYACGLUESCREENDUMMY = 174\n    DEVASTATIONTURRETACGLUESCREENDUMMY = 175\n    BLASTERBILLYACGLUESCREENDUMMY = 176\n    SPINNINGDIZZYACGLUESCREENDUMMY = 177\n    ZERGLINGKERRIGANACGLUESCREENDUMMY = 178\n    RAPTORACGLUESCREENDUMMY = 179\n    QUEENCOOPACGLUESCREENDUMMY = 180\n    HYDRALISKACGLUESCREENDUMMY = 181\n    HYDRALISKLURKERACGLUESCREENDUMMY = 182\n    MUTALISKBROODLORDACGLUESCREENDUMMY = 183\n    BROODLORDACGLUESCREENDUMMY = 184\n    ULTRALISKACGLUESCREENDUMMY = 185\n    TORRASQUEACGLUESCREENDUMMY = 186\n    OVERSEERACGLUESCREENDUMMY = 187\n    LURKERACGLUESCREENDUMMY = 188\n    SPINECRAWLERACGLUESCREENDUMMY = 189\n    SPORECRAWLERACGLUESCREENDUMMY = 190\n    NYDUSNETWORKACGLUESCREENDUMMY = 191\n    OMEGANETWORKACGLUESCREENDUMMY = 192\n    ZERGLINGZAGARAACGLUESCREENDUMMY = 193\n    SWARMLINGACGLUESCREENDUMMY = 194\n    BANELINGACGLUESCREENDUMMY = 195\n    SPLITTERLINGACGLUESCREENDUMMY = 196\n    ABERRATIONACGLUESCREENDUMMY = 197\n    SCOURGEACGLUESCREENDUMMY = 198\n    CORRUPTORACGLUESCREENDUMMY = 199\n    BILELAUNCHERACGLUESCREENDUMMY = 200\n    SWARMQUEENACGLUESCREENDUMMY = 201\n    ROACHACGLUESCREENDUMMY = 202\n    ROACHVILEACGLUESCREENDUMMY = 203\n    RAVAGERACGLUESCREENDUMMY = 204\n    SWARMHOSTACGLUESCREENDUMMY = 205\n    MUTALISKACGLUESCREENDUMMY = 206\n    GUARDIANACGLUESCREENDUMMY = 207\n    DEVOURERACGLUESCREENDUMMY = 208\n    VIPERACGLUESCREENDUMMY = 209\n    BRUTALISKACGLUESCREENDUMMY = 210\n    LEVIATHANACGLUESCREENDUMMY = 211\n    ZEALOTACGLUESCREENDUMMY = 212\n    ZEALOTAIURACGLUESCREENDUMMY = 213\n    DRAGOONACGLUESCREENDUMMY = 214\n    HIGHTEMPLARACGLUESCREENDUMMY = 215\n    ARCHONACGLUESCREENDUMMY = 216\n    IMMORTALACGLUESCREENDUMMY = 217\n    OBSERVERACGLUESCREENDUMMY = 218\n    PHOENIXAIURACGLUESCREENDUMMY = 219\n    REAVERACGLUESCREENDUMMY = 220\n    TEMPESTACGLUESCREENDUMMY = 221\n    PHOTONCANNONACGLUESCREENDUMMY = 222\n    ZEALOTVORAZUNACGLUESCREENDUMMY = 223\n    ZEALOTSHAKURASACGLUESCREENDUMMY = 224\n    STALKERSHAKURASACGLUESCREENDUMMY = 225\n    DARKTEMPLARSHAKURASACGLUESCREENDUMMY = 226\n    CORSAIRACGLUESCREENDUMMY = 227\n    VOIDRAYACGLUESCREENDUMMY = 228\n    VOIDRAYSHAKURASACGLUESCREENDUMMY = 229\n    ORACLEACGLUESCREENDUMMY = 230\n    DARKARCHONACGLUESCREENDUMMY = 231\n    DARKPYLONACGLUESCREENDUMMY = 232\n    ZEALOTPURIFIERACGLUESCREENDUMMY = 233\n    SENTRYPURIFIERACGLUESCREENDUMMY = 234\n    IMMORTALKARAXACGLUESCREENDUMMY = 235\n    COLOSSUSACGLUESCREENDUMMY = 236\n    COLOSSUSPURIFIERACGLUESCREENDUMMY = 237\n    PHOENIXPURIFIERACGLUESCREENDUMMY = 238\n    CARRIERACGLUESCREENDUMMY = 239\n    CARRIERAIURACGLUESCREENDUMMY = 240\n    KHAYDARINMONOLITHACGLUESCREENDUMMY = 241\n    SHIELDBATTERYACGLUESCREENDUMMY = 242\n    ELITEMARINEACGLUESCREENDUMMY = 243\n    MARAUDERCOMMANDOACGLUESCREENDUMMY = 244\n    SPECOPSGHOSTACGLUESCREENDUMMY = 245\n    HELLBATRANGERACGLUESCREENDUMMY = 246\n    STRIKEGOLIATHACGLUESCREENDUMMY = 247\n    HEAVYSIEGETANKACGLUESCREENDUMMY = 248\n    RAIDLIBERATORACGLUESCREENDUMMY = 249\n    RAVENTYPEIIACGLUESCREENDUMMY = 250\n    COVERTBANSHEEACGLUESCREENDUMMY = 251\n    RAILGUNTURRETACGLUESCREENDUMMY = 252\n    BLACKOPSMISSILETURRETACGLUESCREENDUMMY = 253\n    SUPPLICANTACGLUESCREENDUMMY = 254\n    STALKERTALDARIMACGLUESCREENDUMMY = 255\n    SENTRYTALDARIMACGLUESCREENDUMMY = 256\n    HIGHTEMPLARTALDARIMACGLUESCREENDUMMY = 257\n    IMMORTALTALDARIMACGLUESCREENDUMMY = 258\n    COLOSSUSTALDARIMACGLUESCREENDUMMY = 259\n    WARPPRISMTALDARIMACGLUESCREENDUMMY = 260\n    PHOTONCANNONTALDARIMACGLUESCREENDUMMY = 261\n    NEEDLESPINESWEAPON = 262\n    CORRUPTIONWEAPON = 263\n    INFESTEDTERRANSWEAPON = 264\n    NEURALPARASITEWEAPON = 265\n    POINTDEFENSEDRONERELEASEWEAPON = 266\n    HUNTERSEEKERWEAPON = 267\n    MULE = 268\n    THORAAWEAPON = 269\n    PUNISHERGRENADESLMWEAPON = 270\n    VIKINGFIGHTERWEAPON = 271\n    ATALASERBATTERYLMWEAPON = 272\n    ATSLASERBATTERYLMWEAPON = 273\n    LONGBOLTMISSILEWEAPON = 274\n    D8CHARGEWEAPON = 275\n    YAMATOWEAPON = 276\n    IONCANNONSWEAPON = 277\n    ACIDSALIVAWEAPON = 278\n    SPINECRAWLERWEAPON = 279\n    SPORECRAWLERWEAPON = 280\n    GLAIVEWURMWEAPON = 281\n    GLAIVEWURMM2WEAPON = 282\n    GLAIVEWURMM3WEAPON = 283\n    STALKERWEAPON = 284\n    EMP2WEAPON = 285\n    BACKLASHROCKETSLMWEAPON = 286\n    PHOTONCANNONWEAPON = 287\n    PARASITESPOREWEAPON = 288\n    BROODLING = 289\n    BROODLORDBWEAPON = 290\n    AUTOTURRETRELEASEWEAPON = 291\n    LARVARELEASEMISSILE = 292\n    ACIDSPINESWEAPON = 293\n    FRENZYWEAPON = 294\n    CONTAMINATEWEAPON = 295\n    BEACONRALLY = 296\n    BEACONARMY = 297\n    BEACONATTACK = 298\n    BEACONDEFEND = 299\n    BEACONHARASS = 300\n    BEACONIDLE = 301\n    BEACONAUTO = 302\n    BEACONDETECT = 303\n    BEACONSCOUT = 304\n    BEACONCLAIM = 305\n    BEACONEXPAND = 306\n    BEACONCUSTOM1 = 307\n    BEACONCUSTOM2 = 308\n    BEACONCUSTOM3 = 309\n    BEACONCUSTOM4 = 310\n    ADEPT = 311\n    ROCKS2X2NONCONJOINED = 312\n    FUNGALGROWTHMISSILE = 313\n    NEURALPARASITETENTACLEMISSILE = 314\n    BEACON_PROTOSS = 315\n    BEACON_PROTOSSSMALL = 316\n    BEACON_TERRAN = 317\n    BEACON_TERRANSMALL = 318\n    BEACON_ZERG = 319\n    BEACON_ZERGSMALL = 320\n    LYOTE = 321\n    CARRIONBIRD = 322\n    KARAKMALE = 323\n    KARAKFEMALE = 324\n    URSADAKFEMALEEXOTIC = 325\n    URSADAKMALE = 326\n    URSADAKFEMALE = 327\n    URSADAKCALF = 328\n    URSADAKMALEEXOTIC = 329\n    UTILITYBOT = 330\n    COMMENTATORBOT1 = 331\n    COMMENTATORBOT2 = 332\n    COMMENTATORBOT3 = 333\n    COMMENTATORBOT4 = 334\n    SCANTIPEDE = 335\n    DOG = 336\n    SHEEP = 337\n    COW = 338\n    INFESTEDTERRANSEGGPLACEMENT = 339\n    INFESTORTERRANSWEAPON = 340\n    MINERALFIELD = 341\n    VESPENEGEYSER = 342\n    SPACEPLATFORMGEYSER = 343\n    RICHVESPENEGEYSER = 344\n    DESTRUCTIBLESEARCHLIGHT = 345\n    DESTRUCTIBLEBULLHORNLIGHTS = 346\n    DESTRUCTIBLESTREETLIGHT = 347\n    DESTRUCTIBLESPACEPLATFORMSIGN = 348\n    DESTRUCTIBLESTOREFRONTCITYPROPS = 349\n    DESTRUCTIBLEBILLBOARDTALL = 350\n    DESTRUCTIBLEBILLBOARDSCROLLINGTEXT = 351\n    DESTRUCTIBLESPACEPLATFORMBARRIER = 352\n    DESTRUCTIBLESIGNSDIRECTIONAL = 353\n    DESTRUCTIBLESIGNSCONSTRUCTION = 354\n    DESTRUCTIBLESIGNSFUNNY = 355\n    DESTRUCTIBLESIGNSICONS = 356\n    DESTRUCTIBLESIGNSWARNING = 357\n    DESTRUCTIBLEGARAGE = 358\n    DESTRUCTIBLEGARAGELARGE = 359\n    DESTRUCTIBLETRAFFICSIGNAL = 360\n    TRAFFICSIGNAL = 361\n    BRAXISALPHADESTRUCTIBLE1X1 = 362\n    BRAXISALPHADESTRUCTIBLE2X2 = 363\n    DESTRUCTIBLEDEBRIS4X4 = 364\n    DESTRUCTIBLEDEBRIS6X6 = 365\n    DESTRUCTIBLEROCK2X4VERTICAL = 366\n    DESTRUCTIBLEROCK2X4HORIZONTAL = 367\n    DESTRUCTIBLEROCK2X6VERTICAL = 368\n    DESTRUCTIBLEROCK2X6HORIZONTAL = 369\n    DESTRUCTIBLEROCK4X4 = 370\n    DESTRUCTIBLEROCK6X6 = 371\n    DESTRUCTIBLERAMPDIAGONALHUGEULBR = 372\n    DESTRUCTIBLERAMPDIAGONALHUGEBLUR = 373\n    DESTRUCTIBLERAMPVERTICALHUGE = 374\n    DESTRUCTIBLERAMPHORIZONTALHUGE = 375\n    DESTRUCTIBLEDEBRISRAMPDIAGONALHUGEULBR = 376\n    DESTRUCTIBLEDEBRISRAMPDIAGONALHUGEBLUR = 377\n    OVERLORDGENERATECREEPKEYBIND = 378\n    MENGSKSTATUEALONE = 379\n    MENGSKSTATUE = 380\n    WOLFSTATUE = 381\n    GLOBESTATUE = 382\n    WEAPON = 383\n    GLAIVEWURMBOUNCEWEAPON = 384\n    BROODLORDWEAPON = 385\n    BROODLORDAWEAPON = 386\n    CREEPBLOCKER1X1 = 387\n    PERMANENTCREEPBLOCKER1X1 = 388\n    PATHINGBLOCKER1X1 = 389\n    PATHINGBLOCKER2X2 = 390\n    AUTOTESTATTACKTARGETGROUND = 391\n    AUTOTESTATTACKTARGETAIR = 392\n    AUTOTESTATTACKER = 393\n    HELPEREMITTERSELECTIONARROW = 394\n    MULTIKILLOBJECT = 395\n    SHAPEGOLFBALL = 396\n    SHAPECONE = 397\n    SHAPECUBE = 398\n    SHAPECYLINDER = 399\n    SHAPEDODECAHEDRON = 400\n    SHAPEICOSAHEDRON = 401\n    SHAPEOCTAHEDRON = 402\n    SHAPEPYRAMID = 403\n    SHAPEROUNDEDCUBE = 404\n    SHAPESPHERE = 405\n    SHAPETETRAHEDRON = 406\n    SHAPETHICKTORUS = 407\n    SHAPETHINTORUS = 408\n    SHAPETORUS = 409\n    SHAPE4POINTSTAR = 410\n    SHAPE5POINTSTAR = 411\n    SHAPE6POINTSTAR = 412\n    SHAPE8POINTSTAR = 413\n    SHAPEARROWPOINTER = 414\n    SHAPEBOWL = 415\n    SHAPEBOX = 416\n    SHAPECAPSULE = 417\n    SHAPECRESCENTMOON = 418\n    SHAPEDECAHEDRON = 419\n    SHAPEDIAMOND = 420\n    SHAPEFOOTBALL = 421\n    SHAPEGEMSTONE = 422\n    SHAPEHEART = 423\n    SHAPEJACK = 424\n    SHAPEPLUSSIGN = 425\n    SHAPESHAMROCK = 426\n    SHAPESPADE = 427\n    SHAPETUBE = 428\n    SHAPEEGG = 429\n    SHAPEYENSIGN = 430\n    SHAPEX = 431\n    SHAPEWATERMELON = 432\n    SHAPEWONSIGN = 433\n    SHAPETENNISBALL = 434\n    SHAPESTRAWBERRY = 435\n    SHAPESMILEYFACE = 436\n    SHAPESOCCERBALL = 437\n    SHAPERAINBOW = 438\n    SHAPESADFACE = 439\n    SHAPEPOUNDSIGN = 440\n    SHAPEPEAR = 441\n    SHAPEPINEAPPLE = 442\n    SHAPEORANGE = 443\n    SHAPEPEANUT = 444\n    SHAPEO = 445\n    SHAPELEMON = 446\n    SHAPEMONEYBAG = 447\n    SHAPEHORSESHOE = 448\n    SHAPEHOCKEYSTICK = 449\n    SHAPEHOCKEYPUCK = 450\n    SHAPEHAND = 451\n    SHAPEGOLFCLUB = 452\n    SHAPEGRAPE = 453\n    SHAPEEUROSIGN = 454\n    SHAPEDOLLARSIGN = 455\n    SHAPEBASKETBALL = 456\n    SHAPECARROT = 457\n    SHAPECHERRY = 458\n    SHAPEBASEBALL = 459\n    SHAPEBASEBALLBAT = 460\n    SHAPEBANANA = 461\n    SHAPEAPPLE = 462\n    SHAPECASHLARGE = 463\n    SHAPECASHMEDIUM = 464\n    SHAPECASHSMALL = 465\n    SHAPEFOOTBALLCOLORED = 466\n    SHAPELEMONSMALL = 467\n    SHAPEORANGESMALL = 468\n    SHAPETREASURECHESTOPEN = 469\n    SHAPETREASURECHESTCLOSED = 470\n    SHAPEWATERMELONSMALL = 471\n    UNBUILDABLEROCKSDESTRUCTIBLE = 472\n    UNBUILDABLEBRICKSDESTRUCTIBLE = 473\n    UNBUILDABLEPLATESDESTRUCTIBLE = 474\n    DEBRIS2X2NONCONJOINED = 475\n    ENEMYPATHINGBLOCKER1X1 = 476\n    ENEMYPATHINGBLOCKER2X2 = 477\n    ENEMYPATHINGBLOCKER4X4 = 478\n    ENEMYPATHINGBLOCKER8X8 = 479\n    ENEMYPATHINGBLOCKER16X16 = 480\n    SCOPETEST = 481\n    SENTRYACGLUESCREENDUMMY = 482\n    MINERALFIELD750 = 483\n    HELLIONTANK = 484\n    COLLAPSIBLETERRANTOWERDEBRIS = 485\n    DEBRISRAMPLEFT = 486\n    DEBRISRAMPRIGHT = 487\n    MOTHERSHIPCORE = 488\n    LOCUSTMP = 489\n    COLLAPSIBLEROCKTOWERDEBRIS = 490\n    NYDUSCANALATTACKER = 491\n    NYDUSCANALCREEPER = 492\n    SWARMHOSTBURROWEDMP = 493\n    SWARMHOSTMP = 494\n    ORACLE = 495\n    TEMPEST = 496\n    WARHOUND = 497\n    WIDOWMINE = 498\n    VIPER = 499\n    WIDOWMINEBURROWED = 500\n    LURKERMPEGG = 501\n    LURKERMP = 502\n    LURKERMPBURROWED = 503\n    LURKERDENMP = 504\n    EXTENDINGBRIDGENEWIDE8OUT = 505\n    EXTENDINGBRIDGENEWIDE8 = 506\n    EXTENDINGBRIDGENWWIDE8OUT = 507\n    EXTENDINGBRIDGENWWIDE8 = 508\n    EXTENDINGBRIDGENEWIDE10OUT = 509\n    EXTENDINGBRIDGENEWIDE10 = 510\n    EXTENDINGBRIDGENWWIDE10OUT = 511\n    EXTENDINGBRIDGENWWIDE10 = 512\n    EXTENDINGBRIDGENEWIDE12OUT = 513\n    EXTENDINGBRIDGENEWIDE12 = 514\n    EXTENDINGBRIDGENWWIDE12OUT = 515\n    EXTENDINGBRIDGENWWIDE12 = 516\n    COLLAPSIBLEROCKTOWERDEBRISRAMPRIGHT = 517\n    COLLAPSIBLEROCKTOWERDEBRISRAMPLEFT = 518\n    XELNAGA_CAVERNS_DOORE = 519\n    XELNAGA_CAVERNS_DOOREOPENED = 520\n    XELNAGA_CAVERNS_DOORN = 521\n    XELNAGA_CAVERNS_DOORNE = 522\n    XELNAGA_CAVERNS_DOORNEOPENED = 523\n    XELNAGA_CAVERNS_DOORNOPENED = 524\n    XELNAGA_CAVERNS_DOORNW = 525\n    XELNAGA_CAVERNS_DOORNWOPENED = 526\n    XELNAGA_CAVERNS_DOORS = 527\n    XELNAGA_CAVERNS_DOORSE = 528\n    XELNAGA_CAVERNS_DOORSEOPENED = 529\n    XELNAGA_CAVERNS_DOORSOPENED = 530\n    XELNAGA_CAVERNS_DOORSW = 531\n    XELNAGA_CAVERNS_DOORSWOPENED = 532\n    XELNAGA_CAVERNS_DOORW = 533\n    XELNAGA_CAVERNS_DOORWOPENED = 534\n    XELNAGA_CAVERNS_FLOATING_BRIDGENE8OUT = 535\n    XELNAGA_CAVERNS_FLOATING_BRIDGENE8 = 536\n    XELNAGA_CAVERNS_FLOATING_BRIDGENW8OUT = 537\n    XELNAGA_CAVERNS_FLOATING_BRIDGENW8 = 538\n    XELNAGA_CAVERNS_FLOATING_BRIDGENE10OUT = 539\n    XELNAGA_CAVERNS_FLOATING_BRIDGENE10 = 540\n    XELNAGA_CAVERNS_FLOATING_BRIDGENW10OUT = 541\n    XELNAGA_CAVERNS_FLOATING_BRIDGENW10 = 542\n    XELNAGA_CAVERNS_FLOATING_BRIDGENE12OUT = 543\n    XELNAGA_CAVERNS_FLOATING_BRIDGENE12 = 544\n    XELNAGA_CAVERNS_FLOATING_BRIDGENW12OUT = 545\n    XELNAGA_CAVERNS_FLOATING_BRIDGENW12 = 546\n    XELNAGA_CAVERNS_FLOATING_BRIDGEH8OUT = 547\n    XELNAGA_CAVERNS_FLOATING_BRIDGEH8 = 548\n    XELNAGA_CAVERNS_FLOATING_BRIDGEV8OUT = 549\n    XELNAGA_CAVERNS_FLOATING_BRIDGEV8 = 550\n    XELNAGA_CAVERNS_FLOATING_BRIDGEH10OUT = 551\n    XELNAGA_CAVERNS_FLOATING_BRIDGEH10 = 552\n    XELNAGA_CAVERNS_FLOATING_BRIDGEV10OUT = 553\n    XELNAGA_CAVERNS_FLOATING_BRIDGEV10 = 554\n    XELNAGA_CAVERNS_FLOATING_BRIDGEH12OUT = 555\n    XELNAGA_CAVERNS_FLOATING_BRIDGEH12 = 556\n    XELNAGA_CAVERNS_FLOATING_BRIDGEV12OUT = 557\n    XELNAGA_CAVERNS_FLOATING_BRIDGEV12 = 558\n    COLLAPSIBLETERRANTOWERPUSHUNITRAMPLEFT = 559\n    COLLAPSIBLETERRANTOWERPUSHUNITRAMPRIGHT = 560\n    COLLAPSIBLEROCKTOWERPUSHUNIT = 561\n    COLLAPSIBLETERRANTOWERPUSHUNIT = 562\n    COLLAPSIBLEROCKTOWERPUSHUNITRAMPRIGHT = 563\n    COLLAPSIBLEROCKTOWERPUSHUNITRAMPLEFT = 564\n    DIGESTERCREEPSPRAYTARGETUNIT = 565\n    DIGESTERCREEPSPRAYUNIT = 566\n    NYDUSCANALATTACKERWEAPON = 567\n    VIPERCONSUMESTRUCTUREWEAPON = 568\n    RESOURCEBLOCKER = 569\n    TEMPESTWEAPON = 570\n    YOINKMISSILE = 571\n    YOINKVIKINGAIRMISSILE = 572\n    YOINKVIKINGGROUNDMISSILE = 573\n    YOINKSIEGETANKMISSILE = 574\n    WARHOUNDWEAPON = 575\n    EYESTALKWEAPON = 576\n    WIDOWMINEWEAPON = 577\n    WIDOWMINEAIRWEAPON = 578\n    MOTHERSHIPCOREWEAPONWEAPON = 579\n    TORNADOMISSILEWEAPON = 580\n    TORNADOMISSILEDUMMYWEAPON = 581\n    TALONSMISSILEWEAPON = 582\n    CREEPTUMORMISSILE = 583\n    LOCUSTMPEGGAMISSILEWEAPON = 584\n    LOCUSTMPEGGBMISSILEWEAPON = 585\n    LOCUSTMPWEAPON = 586\n    REPULSORCANNONWEAPON = 587\n    COLLAPSIBLEROCKTOWERDIAGONAL = 588\n    COLLAPSIBLETERRANTOWERDIAGONAL = 589\n    COLLAPSIBLETERRANTOWERRAMPLEFT = 590\n    COLLAPSIBLETERRANTOWERRAMPRIGHT = 591\n    ICE2X2NONCONJOINED = 592\n    ICEPROTOSSCRATES = 593\n    PROTOSSCRATES = 594\n    TOWERMINE = 595\n    PICKUPPALLETGAS = 596\n    PICKUPPALLETMINERALS = 597\n    PICKUPSCRAPSALVAGE1X1 = 598\n    PICKUPSCRAPSALVAGE2X2 = 599\n    PICKUPSCRAPSALVAGE3X3 = 600\n    ROUGHTERRAIN = 601\n    UNBUILDABLEBRICKSSMALLUNIT = 602\n    UNBUILDABLEPLATESSMALLUNIT = 603\n    UNBUILDABLEPLATESUNIT = 604\n    UNBUILDABLEROCKSSMALLUNIT = 605\n    XELNAGAHEALINGSHRINE = 606\n    INVISIBLETARGETDUMMY = 607\n    PROTOSSVESPENEGEYSER = 608\n    COLLAPSIBLEROCKTOWER = 609\n    COLLAPSIBLETERRANTOWER = 610\n    THORNLIZARD = 611\n    CLEANINGBOT = 612\n    DESTRUCTIBLEROCK6X6WEAK = 613\n    PROTOSSSNAKESEGMENTDEMO = 614\n    PHYSICSCAPSULE = 615\n    PHYSICSCUBE = 616\n    PHYSICSCYLINDER = 617\n    PHYSICSKNOT = 618\n    PHYSICSL = 619\n    PHYSICSPRIMITIVES = 620\n    PHYSICSSPHERE = 621\n    PHYSICSSTAR = 622\n    CREEPBLOCKER4X4 = 623\n    DESTRUCTIBLECITYDEBRIS2X4VERTICAL = 624\n    DESTRUCTIBLECITYDEBRIS2X4HORIZONTAL = 625\n    DESTRUCTIBLECITYDEBRIS2X6VERTICAL = 626\n    DESTRUCTIBLECITYDEBRIS2X6HORIZONTAL = 627\n    DESTRUCTIBLECITYDEBRIS4X4 = 628\n    DESTRUCTIBLECITYDEBRIS6X6 = 629\n    DESTRUCTIBLECITYDEBRISHUGEDIAGONALBLUR = 630\n    DESTRUCTIBLECITYDEBRISHUGEDIAGONALULBR = 631\n    TESTZERG = 632\n    PATHINGBLOCKERRADIUS1 = 633\n    DESTRUCTIBLEROCKEX12X4VERTICAL = 634\n    DESTRUCTIBLEROCKEX12X4HORIZONTAL = 635\n    DESTRUCTIBLEROCKEX12X6VERTICAL = 636\n    DESTRUCTIBLEROCKEX12X6HORIZONTAL = 637\n    DESTRUCTIBLEROCKEX14X4 = 638\n    DESTRUCTIBLEROCKEX16X6 = 639\n    DESTRUCTIBLEROCKEX1DIAGONALHUGEULBR = 640\n    DESTRUCTIBLEROCKEX1DIAGONALHUGEBLUR = 641\n    DESTRUCTIBLEROCKEX1VERTICALHUGE = 642\n    DESTRUCTIBLEROCKEX1HORIZONTALHUGE = 643\n    DESTRUCTIBLEICE2X4VERTICAL = 644\n    DESTRUCTIBLEICE2X4HORIZONTAL = 645\n    DESTRUCTIBLEICE2X6VERTICAL = 646\n    DESTRUCTIBLEICE2X6HORIZONTAL = 647\n    DESTRUCTIBLEICE4X4 = 648\n    DESTRUCTIBLEICE6X6 = 649\n    DESTRUCTIBLEICEDIAGONALHUGEULBR = 650\n    DESTRUCTIBLEICEDIAGONALHUGEBLUR = 651\n    DESTRUCTIBLEICEVERTICALHUGE = 652\n    DESTRUCTIBLEICEHORIZONTALHUGE = 653\n    DESERTPLANETSEARCHLIGHT = 654\n    DESERTPLANETSTREETLIGHT = 655\n    UNBUILDABLEBRICKSUNIT = 656\n    UNBUILDABLEROCKSUNIT = 657\n    ZERUSDESTRUCTIBLEARCH = 658\n    ARTOSILOPE = 659\n    ANTEPLOTT = 660\n    LABBOT = 661\n    CRABEETLE = 662\n    COLLAPSIBLEROCKTOWERRAMPRIGHT = 663\n    COLLAPSIBLEROCKTOWERRAMPLEFT = 664\n    LABMINERALFIELD = 665\n    LABMINERALFIELD750 = 666\n    SNOWREFINERY_TERRAN_EXTENDINGBRIDGENESHORT8OUT = 667\n    SNOWREFINERY_TERRAN_EXTENDINGBRIDGENESHORT8 = 668\n    SNOWREFINERY_TERRAN_EXTENDINGBRIDGENWSHORT8OUT = 669\n    SNOWREFINERY_TERRAN_EXTENDINGBRIDGENWSHORT8 = 670\n    TARSONIS_DOORN = 671\n    TARSONIS_DOORNLOWERED = 672\n    TARSONIS_DOORNE = 673\n    TARSONIS_DOORNELOWERED = 674\n    TARSONIS_DOORE = 675\n    TARSONIS_DOORELOWERED = 676\n    TARSONIS_DOORNW = 677\n    TARSONIS_DOORNWLOWERED = 678\n    COMPOUNDMANSION_DOORN = 679\n    COMPOUNDMANSION_DOORNLOWERED = 680\n    COMPOUNDMANSION_DOORNE = 681\n    COMPOUNDMANSION_DOORNELOWERED = 682\n    COMPOUNDMANSION_DOORE = 683\n    COMPOUNDMANSION_DOORELOWERED = 684\n    COMPOUNDMANSION_DOORNW = 685\n    COMPOUNDMANSION_DOORNWLOWERED = 686\n    RAVAGERCOCOON = 687\n    RAVAGER = 688\n    LIBERATOR = 689\n    RAVAGERBURROWED = 690\n    THORAP = 691\n    CYCLONE = 692\n    LOCUSTMPFLYING = 693\n    DISRUPTOR = 694\n    AIURLIGHTBRIDGENE8OUT = 695\n    AIURLIGHTBRIDGENE8 = 696\n    AIURLIGHTBRIDGENE10OUT = 697\n    AIURLIGHTBRIDGENE10 = 698\n    AIURLIGHTBRIDGENE12OUT = 699\n    AIURLIGHTBRIDGENE12 = 700\n    AIURLIGHTBRIDGENW8OUT = 701\n    AIURLIGHTBRIDGENW8 = 702\n    AIURLIGHTBRIDGENW10OUT = 703\n    AIURLIGHTBRIDGENW10 = 704\n    AIURLIGHTBRIDGENW12OUT = 705\n    AIURLIGHTBRIDGENW12 = 706\n    AIURTEMPLEBRIDGENE8OUT = 707\n    AIURTEMPLEBRIDGENE10OUT = 708\n    AIURTEMPLEBRIDGENE12OUT = 709\n    AIURTEMPLEBRIDGENW8OUT = 710\n    AIURTEMPLEBRIDGENW10OUT = 711\n    AIURTEMPLEBRIDGENW12OUT = 712\n    SHAKURASLIGHTBRIDGENE8OUT = 713\n    SHAKURASLIGHTBRIDGENE8 = 714\n    SHAKURASLIGHTBRIDGENE10OUT = 715\n    SHAKURASLIGHTBRIDGENE10 = 716\n    SHAKURASLIGHTBRIDGENE12OUT = 717\n    SHAKURASLIGHTBRIDGENE12 = 718\n    SHAKURASLIGHTBRIDGENW8OUT = 719\n    SHAKURASLIGHTBRIDGENW8 = 720\n    SHAKURASLIGHTBRIDGENW10OUT = 721\n    SHAKURASLIGHTBRIDGENW10 = 722\n    SHAKURASLIGHTBRIDGENW12OUT = 723\n    SHAKURASLIGHTBRIDGENW12 = 724\n    VOIDMPIMMORTALREVIVECORPSE = 725\n    GUARDIANCOCOONMP = 726\n    GUARDIANMP = 727\n    DEVOURERCOCOONMP = 728\n    DEVOURERMP = 729\n    DEFILERMPBURROWED = 730\n    DEFILERMP = 731\n    ORACLESTASISTRAP = 732\n    DISRUPTORPHASED = 733\n    LIBERATORAG = 734\n    AIURLIGHTBRIDGEABANDONEDNE8OUT = 735\n    AIURLIGHTBRIDGEABANDONEDNE8 = 736\n    AIURLIGHTBRIDGEABANDONEDNE10OUT = 737\n    AIURLIGHTBRIDGEABANDONEDNE10 = 738\n    AIURLIGHTBRIDGEABANDONEDNE12OUT = 739\n    AIURLIGHTBRIDGEABANDONEDNE12 = 740\n    AIURLIGHTBRIDGEABANDONEDNW8OUT = 741\n    AIURLIGHTBRIDGEABANDONEDNW8 = 742\n    AIURLIGHTBRIDGEABANDONEDNW10OUT = 743\n    AIURLIGHTBRIDGEABANDONEDNW10 = 744\n    AIURLIGHTBRIDGEABANDONEDNW12OUT = 745\n    AIURLIGHTBRIDGEABANDONEDNW12 = 746\n    COLLAPSIBLEPURIFIERTOWERDEBRIS = 747\n    PORTCITY_BRIDGE_UNITNE8OUT = 748\n    PORTCITY_BRIDGE_UNITNE8 = 749\n    PORTCITY_BRIDGE_UNITSE8OUT = 750\n    PORTCITY_BRIDGE_UNITSE8 = 751\n    PORTCITY_BRIDGE_UNITNW8OUT = 752\n    PORTCITY_BRIDGE_UNITNW8 = 753\n    PORTCITY_BRIDGE_UNITSW8OUT = 754\n    PORTCITY_BRIDGE_UNITSW8 = 755\n    PORTCITY_BRIDGE_UNITNE10OUT = 756\n    PORTCITY_BRIDGE_UNITNE10 = 757\n    PORTCITY_BRIDGE_UNITSE10OUT = 758\n    PORTCITY_BRIDGE_UNITSE10 = 759\n    PORTCITY_BRIDGE_UNITNW10OUT = 760\n    PORTCITY_BRIDGE_UNITNW10 = 761\n    PORTCITY_BRIDGE_UNITSW10OUT = 762\n    PORTCITY_BRIDGE_UNITSW10 = 763\n    PORTCITY_BRIDGE_UNITNE12OUT = 764\n    PORTCITY_BRIDGE_UNITNE12 = 765\n    PORTCITY_BRIDGE_UNITSE12OUT = 766\n    PORTCITY_BRIDGE_UNITSE12 = 767\n    PORTCITY_BRIDGE_UNITNW12OUT = 768\n    PORTCITY_BRIDGE_UNITNW12 = 769\n    PORTCITY_BRIDGE_UNITSW12OUT = 770\n    PORTCITY_BRIDGE_UNITSW12 = 771\n    PORTCITY_BRIDGE_UNITN8OUT = 772\n    PORTCITY_BRIDGE_UNITN8 = 773\n    PORTCITY_BRIDGE_UNITS8OUT = 774\n    PORTCITY_BRIDGE_UNITS8 = 775\n    PORTCITY_BRIDGE_UNITE8OUT = 776\n    PORTCITY_BRIDGE_UNITE8 = 777\n    PORTCITY_BRIDGE_UNITW8OUT = 778\n    PORTCITY_BRIDGE_UNITW8 = 779\n    PORTCITY_BRIDGE_UNITN10OUT = 780\n    PORTCITY_BRIDGE_UNITN10 = 781\n    PORTCITY_BRIDGE_UNITS10OUT = 782\n    PORTCITY_BRIDGE_UNITS10 = 783\n    PORTCITY_BRIDGE_UNITE10OUT = 784\n    PORTCITY_BRIDGE_UNITE10 = 785\n    PORTCITY_BRIDGE_UNITW10OUT = 786\n    PORTCITY_BRIDGE_UNITW10 = 787\n    PORTCITY_BRIDGE_UNITN12OUT = 788\n    PORTCITY_BRIDGE_UNITN12 = 789\n    PORTCITY_BRIDGE_UNITS12OUT = 790\n    PORTCITY_BRIDGE_UNITS12 = 791\n    PORTCITY_BRIDGE_UNITE12OUT = 792\n    PORTCITY_BRIDGE_UNITE12 = 793\n    PORTCITY_BRIDGE_UNITW12OUT = 794\n    PORTCITY_BRIDGE_UNITW12 = 795\n    PURIFIERRICHMINERALFIELD = 796\n    PURIFIERRICHMINERALFIELD750 = 797\n    COLLAPSIBLEPURIFIERTOWERPUSHUNIT = 798\n    LOCUSTMPPRECURSOR = 799\n    RELEASEINTERCEPTORSBEACON = 800\n    ADEPTPHASESHIFT = 801\n    RAVAGERCORROSIVEBILEMISSILE = 802\n    HYDRALISKIMPALEMISSILE = 803\n    CYCLONEMISSILELARGEAIR = 804\n    CYCLONEMISSILE = 805\n    CYCLONEMISSILELARGE = 806\n    THORAALANCE = 807\n    ORACLEWEAPON = 808\n    TEMPESTWEAPONGROUND = 809\n    RAVAGERWEAPONMISSILE = 810\n    SCOUTMPAIRWEAPONLEFT = 811\n    SCOUTMPAIRWEAPONRIGHT = 812\n    ARBITERMPWEAPONMISSILE = 813\n    GUARDIANMPWEAPON = 814\n    DEVOURERMPWEAPONMISSILE = 815\n    DEFILERMPDARKSWARMWEAPON = 816\n    QUEENMPENSNAREMISSILE = 817\n    QUEENMPSPAWNBROODLINGSMISSILE = 818\n    LIGHTNINGBOMBWEAPON = 819\n    HERCPLACEMENT = 820\n    GRAPPLEWEAPON = 821\n    CAUSTICSPRAYMISSILE = 822\n    PARASITICBOMBMISSILE = 823\n    PARASITICBOMBDUMMY = 824\n    ADEPTWEAPON = 825\n    ADEPTUPGRADEWEAPON = 826\n    LIBERATORMISSILE = 827\n    LIBERATORDAMAGEMISSILE = 828\n    LIBERATORAGMISSILE = 829\n    KD8CHARGE = 830\n    KD8CHARGEWEAPON = 831\n    SLAYNELEMENTALGRABWEAPON = 832\n    SLAYNELEMENTALGRABAIRUNIT = 833\n    SLAYNELEMENTALGRABGROUNDUNIT = 834\n    SLAYNELEMENTALWEAPON = 835\n    DESTRUCTIBLEEXPEDITIONGATE6X6 = 836\n    DESTRUCTIBLEZERGINFESTATION3X3 = 837\n    HERC = 838\n    MOOPY = 839\n    REPLICANT = 840\n    SEEKERMISSILE = 841\n    AIURTEMPLEBRIDGEDESTRUCTIBLENE8OUT = 842\n    AIURTEMPLEBRIDGEDESTRUCTIBLENE10OUT = 843\n    AIURTEMPLEBRIDGEDESTRUCTIBLENE12OUT = 844\n    AIURTEMPLEBRIDGEDESTRUCTIBLENW8OUT = 845\n    AIURTEMPLEBRIDGEDESTRUCTIBLENW10OUT = 846\n    AIURTEMPLEBRIDGEDESTRUCTIBLENW12OUT = 847\n    AIURTEMPLEBRIDGEDESTRUCTIBLESW8OUT = 848\n    AIURTEMPLEBRIDGEDESTRUCTIBLESW10OUT = 849\n    AIURTEMPLEBRIDGEDESTRUCTIBLESW12OUT = 850\n    AIURTEMPLEBRIDGEDESTRUCTIBLESE8OUT = 851\n    AIURTEMPLEBRIDGEDESTRUCTIBLESE10OUT = 852\n    AIURTEMPLEBRIDGEDESTRUCTIBLESE12OUT = 853\n    FLYOVERUNIT = 854\n    CORSAIRMP = 855\n    SCOUTMP = 856\n    ARBITERMP = 857\n    SCOURGEMP = 858\n    DEFILERMPPLAGUEWEAPON = 859\n    QUEENMP = 860\n    XELNAGADESTRUCTIBLERAMPBLOCKER6S = 861\n    XELNAGADESTRUCTIBLERAMPBLOCKER6SE = 862\n    XELNAGADESTRUCTIBLERAMPBLOCKER6E = 863\n    XELNAGADESTRUCTIBLERAMPBLOCKER6NE = 864\n    XELNAGADESTRUCTIBLERAMPBLOCKER6N = 865\n    XELNAGADESTRUCTIBLERAMPBLOCKER6NW = 866\n    XELNAGADESTRUCTIBLERAMPBLOCKER6W = 867\n    XELNAGADESTRUCTIBLERAMPBLOCKER6SW = 868\n    XELNAGADESTRUCTIBLERAMPBLOCKER8S = 869\n    XELNAGADESTRUCTIBLERAMPBLOCKER8SE = 870\n    XELNAGADESTRUCTIBLERAMPBLOCKER8E = 871\n    XELNAGADESTRUCTIBLERAMPBLOCKER8NE = 872\n    XELNAGADESTRUCTIBLERAMPBLOCKER8N = 873\n    XELNAGADESTRUCTIBLERAMPBLOCKER8NW = 874\n    XELNAGADESTRUCTIBLERAMPBLOCKER8W = 875\n    XELNAGADESTRUCTIBLERAMPBLOCKER8SW = 876\n    REPTILECRATE = 877\n    SLAYNSWARMHOSTSPAWNFLYER = 878\n    SLAYNELEMENTAL = 879\n    PURIFIERVESPENEGEYSER = 880\n    SHAKURASVESPENEGEYSER = 881\n    COLLAPSIBLEPURIFIERTOWERDIAGONAL = 882\n    CREEPONLYBLOCKER4X4 = 883\n    PURIFIERMINERALFIELD = 884\n    PURIFIERMINERALFIELD750 = 885\n    BATTLESTATIONMINERALFIELD = 886\n    BATTLESTATIONMINERALFIELD750 = 887\n    BEACON_NOVA = 888\n    BEACON_NOVASMALL = 889\n    URSULA = 890\n    ELSECARO_COLONIST_HUT = 891\n    TRANSPORTOVERLORDCOCOON = 892\n    OVERLORDTRANSPORT = 893\n    PYLONOVERCHARGED = 894\n    BYPASSARMORDRONE = 895\n    ADEPTPIERCINGWEAPON = 896\n    CORROSIVEPARASITEWEAPON = 897\n    INFESTEDTERRAN = 898\n    MERCCOMPOUND = 899\n    SUPPLYDEPOTDROP = 900\n    LURKERDEN = 901\n    D8CHARGE = 902\n    THORWRECKAGE = 903\n    GOLIATH = 904\n    TECHREACTOR = 905\n    SS_POWERUPBOMB = 906\n    SS_POWERUPHEALTH = 907\n    SS_POWERUPSIDEMISSILES = 908\n    SS_POWERUPSTRONGERMISSILES = 909\n    LURKEREGG = 910\n    LURKER = 911\n    LURKERBURROWED = 912\n    ARCHIVESEALED = 913\n    INFESTEDCIVILIAN = 914\n    FLAMINGBETTY = 915\n    INFESTEDCIVILIANBURROWED = 916\n    SELENDISINTERCEPTOR = 917\n    SIEGEBREAKERSIEGED = 918\n    SIEGEBREAKER = 919\n    PERDITIONTURRETUNDERGROUND = 920\n    PERDITIONTURRET = 921\n    SENTRYGUNUNDERGROUND = 922\n    SENTRYGUN = 923\n    WARPIG = 924\n    DEVILDOG = 925\n    SPARTANCOMPANY = 926\n    HAMMERSECURITY = 927\n    HELSANGELFIGHTER = 928\n    DUSKWING = 929\n    DUKESREVENGE = 930\n    ODINWRECKAGE = 931\n    HERONUKE = 932\n    KERRIGANCHARBURROWED = 933\n    KERRIGANCHAR = 934\n    SPIDERMINEBURROWED = 935\n    SPIDERMINE = 936\n    ZERATUL = 937\n    URUN = 938\n    MOHANDAR = 939\n    SELENDIS = 940\n    SCOUT = 941\n    OMEGALISKBURROWED = 942\n    OMEGALISK = 943\n    INFESTEDABOMINATIONBURROWED = 944\n    INFESTEDABOMINATION = 945\n    HUNTERKILLERBURROWED = 946\n    HUNTERKILLER = 947\n    INFESTEDTERRANCAMPAIGNBURROWED = 948\n    INFESTEDTERRANCAMPAIGN = 949\n    CHECKSTATION = 950\n    CHECKSTATIONDIAGONALBLUR = 951\n    CHECKSTATIONDIAGONALULBR = 952\n    CHECKSTATIONVERTICAL = 953\n    CHECKSTATIONOPENED = 954\n    CHECKSTATIONDIAGONALBLUROPENED = 955\n    CHECKSTATIONDIAGONALULBROPENED = 956\n    CHECKSTATIONVERTICALOPENED = 957\n    BARRACKSTECHREACTOR = 958\n    FACTORYTECHREACTOR = 959\n    STARPORTTECHREACTOR = 960\n    SPECTRENUKE = 961\n    COLONISTSHIPFLYING = 962\n    COLONISTSHIP = 963\n    BIODOMECOMMANDFLYING = 964\n    BIODOMECOMMAND = 965\n    HERCULESLANDERFLYING = 966\n    HERCULESLANDER = 967\n    ZHAKULDASLIGHTBRIDGEOFF = 968\n    ZHAKULDASLIGHTBRIDGE = 969\n    ZHAKULDASLIBRARYUNITBURROWED = 970\n    ZHAKULDASLIBRARYUNIT = 971\n    XELNAGATEMPLEDOORBURROWED = 972\n    XELNAGATEMPLEDOOR = 973\n    XELNAGATEMPLEDOORURDLBURROWED = 974\n    XELNAGATEMPLEDOORURDL = 975\n    HELSANGELASSAULT = 976\n    AUTOMATEDREFINERY = 977\n    BATTLECRUISERHELIOSMORPH = 978\n    HEALINGPOTIONTESTINSTANT = 979\n    SPACEPLATFORMCLIFFDOOROPEN0 = 980\n    SPACEPLATFORMCLIFFDOOR0 = 981\n    SPACEPLATFORMCLIFFDOOROPEN1 = 982\n    SPACEPLATFORMCLIFFDOOR1 = 983\n    DESTRUCTIBLEGATEDIAGONALBLURLOWERED = 984\n    DESTRUCTIBLEGATEDIAGONALULBRLOWERED = 985\n    DESTRUCTIBLEGATESTRAIGHTHORIZONTALBFLOWERED = 986\n    DESTRUCTIBLEGATESTRAIGHTHORIZONTALLOWERED = 987\n    DESTRUCTIBLEGATESTRAIGHTVERTICALLFLOWERED = 988\n    DESTRUCTIBLEGATESTRAIGHTVERTICALLOWERED = 989\n    DESTRUCTIBLEGATEDIAGONALBLUR = 990\n    DESTRUCTIBLEGATEDIAGONALULBR = 991\n    DESTRUCTIBLEGATESTRAIGHTHORIZONTALBF = 992\n    DESTRUCTIBLEGATESTRAIGHTHORIZONTAL = 993\n    DESTRUCTIBLEGATESTRAIGHTVERTICALLF = 994\n    DESTRUCTIBLEGATESTRAIGHTVERTICAL = 995\n    METALGATEDIAGONALBLURLOWERED = 996\n    METALGATEDIAGONALULBRLOWERED = 997\n    METALGATESTRAIGHTHORIZONTALBFLOWERED = 998\n    METALGATESTRAIGHTHORIZONTALLOWERED = 999\n    METALGATESTRAIGHTVERTICALLFLOWERED = 1000\n    METALGATESTRAIGHTVERTICALLOWERED = 1001\n    METALGATEDIAGONALBLUR = 1002\n    METALGATEDIAGONALULBR = 1003\n    METALGATESTRAIGHTHORIZONTALBF = 1004\n    METALGATESTRAIGHTHORIZONTAL = 1005\n    METALGATESTRAIGHTVERTICALLF = 1006\n    METALGATESTRAIGHTVERTICAL = 1007\n    SECURITYGATEDIAGONALBLURLOWERED = 1008\n    SECURITYGATEDIAGONALULBRLOWERED = 1009\n    SECURITYGATESTRAIGHTHORIZONTALBFLOWERED = 1010\n    SECURITYGATESTRAIGHTHORIZONTALLOWERED = 1011\n    SECURITYGATESTRAIGHTVERTICALLFLOWERED = 1012\n    SECURITYGATESTRAIGHTVERTICALLOWERED = 1013\n    SECURITYGATEDIAGONALBLUR = 1014\n    SECURITYGATEDIAGONALULBR = 1015\n    SECURITYGATESTRAIGHTHORIZONTALBF = 1016\n    SECURITYGATESTRAIGHTHORIZONTAL = 1017\n    SECURITYGATESTRAIGHTVERTICALLF = 1018\n    SECURITYGATESTRAIGHTVERTICAL = 1019\n    TERRAZINENODEDEADTERRAN = 1020\n    TERRAZINENODEHAPPYPROTOSS = 1021\n    ZHAKULDASLIGHTBRIDGEOFFTOPRIGHT = 1022\n    ZHAKULDASLIGHTBRIDGETOPRIGHT = 1023\n    BATTLECRUISERHELIOS = 1024\n    NUKESILONOVA = 1025\n    ODIN = 1026\n    PYGALISKCOCOON = 1027\n    DEVOURERTISSUEDOODAD = 1028\n    SS_BATTLECRUISERMISSILELAUNCHER = 1029\n    SS_TERRATRONMISSILESPINNERMISSILE = 1030\n    SS_TERRATRONSAW = 1031\n    SS_BATTLECRUISERHUNTERSEEKERMISSILE = 1032\n    SS_LEVIATHANBOMB = 1033\n    DEVOURERTISSUEMISSILE = 1034\n    SS_INTERCEPTOR = 1035\n    SS_LEVIATHANBOMBMISSILE = 1036\n    SS_LEVIATHANSPAWNBOMBMISSILE = 1037\n    SS_FIGHTERMISSILELEFT = 1038\n    SS_FIGHTERMISSILERIGHT = 1039\n    SS_INTERCEPTORSPAWNMISSILE = 1040\n    SS_CARRIERBOSSMISSILE = 1041\n    SS_LEVIATHANTENTACLETARGET = 1042\n    SS_LEVIATHANTENTACLEL2MISSILE = 1043\n    SS_LEVIATHANTENTACLER1MISSILE = 1044\n    SS_LEVIATHANTENTACLER2MISSILE = 1045\n    SS_LEVIATHANTENTACLEL1MISSILE = 1046\n    SS_TERRATRONMISSILE = 1047\n    SS_WRAITHMISSILE = 1048\n    SS_SCOURGEMISSILE = 1049\n    SS_CORRUPTORMISSILE = 1050\n    SS_SWARMGUARDIANMISSILE = 1051\n    SS_STRONGMISSILE1 = 1052\n    SS_STRONGMISSILE2 = 1053\n    SS_FIGHTERDRONEMISSILE = 1054\n    SS_PHOENIXMISSILE = 1055\n    SS_SCOUTMISSILE = 1056\n    SS_INTERCEPTORMISSILE = 1057\n    SS_SCIENCEVESSELMISSILE = 1058\n    SS_BATTLECRUISERMISSILE = 1059\n    D8CLUSTERBOMBWEAPON = 1060\n    D8CLUSTERBOMB = 1061\n    BROODLORDEGG = 1062\n    BROODLORDEGGMISSILE = 1063\n    CIVILIANWEAPON = 1064\n    BATTLECRUISERHELIOSALMWEAPON = 1065\n    BATTLECRUISERLOKILMWEAPON = 1066\n    BATTLECRUISERHELIOSGLMWEAPON = 1067\n    BIOSTASISMISSILE = 1068\n    INFESTEDVENTBROODLORDEGG = 1069\n    INFESTEDVENTCORRUPTOREGG = 1070\n    TENTACLEAMISSILE = 1071\n    TENTACLEBMISSILE = 1072\n    TENTACLECMISSILE = 1073\n    TENTACLEDMISSILE = 1074\n    MUTALISKEGG = 1075\n    INFESTEDVENTMUTALISKEGG = 1076\n    MUTALISKEGGMISSILE = 1077\n    INFESTEDVENTEGGMISSILE = 1078\n    SPORECANNONFIREMISSILE = 1079\n    EXPERIMENTALPLASMAGUNWEAPON = 1080\n    BRUTALISKWEAPON = 1081\n    LOKIHURRICANEMISSILELEFT = 1082\n    LOKIHURRICANEMISSILERIGHT = 1083\n    ODINAAWEAPON = 1084\n    DUSKWINGWEAPON = 1085\n    KERRIGANWEAPON = 1086\n    ULTRASONICPULSEWEAPON = 1087\n    KERRIGANCHARWEAPON = 1088\n    DEVASTATORMISSILEWEAPON = 1089\n    SWANNWEAPON = 1090\n    HAMMERSECURITYLMWEAPON = 1091\n    CONSUMEDNAFEEDBACKWEAPON = 1092\n    URUNWEAPONLEFT = 1093\n    URUNWEAPONRIGHT = 1094\n    HAILSTORMMISSILESWEAPON = 1095\n    COLONYINFESTATIONWEAPON = 1096\n    VOIDSEEKERPHASEMINEBLASTWEAPON = 1097\n    VOIDSEEKERPHASEMINEBLASTSECONDARYWEAPON = 1098\n    TOSSGRENADEWEAPON = 1099\n    TYCHUSGRENADEWEAPON = 1100\n    VILESTREAMWEAPON = 1101\n    WRAITHAIRWEAPONRIGHT = 1102\n    WRAITHAIRWEAPONLEFT = 1103\n    WRAITHGROUNDWEAPON = 1104\n    WEAPONHYBRIDD = 1105\n    KARASSWEAPON = 1106\n    HYBRIDCPLASMAWEAPON = 1107\n    WARBOTBMISSILE = 1108\n    LOKIYAMATOWEAPON = 1109\n    HYPERIONYAMATOSPECIALWEAPON = 1110\n    HYPERIONLMWEAPON = 1111\n    HYPERIONALMWEAPON = 1112\n    VULTUREWEAPON = 1113\n    SCOUTAIRWEAPONLEFT = 1114\n    SCOUTAIRWEAPONRIGHT = 1115\n    HUNTERKILLERWEAPON = 1116\n    GOLIATHAWEAPON = 1117\n    SPARTANCOMPANYAWEAPON = 1118\n    LEVIATHANSCOURGEMISSILE = 1119\n    BIOPLASMIDDISCHARGEWEAPON = 1120\n    VOIDSEEKERWEAPON = 1121\n    HELSANGELFIGHTERWEAPON = 1122\n    DRBATTLECRUISERALMWEAPON = 1123\n    DRBATTLECRUISERGLMWEAPON = 1124\n    HURRICANEMISSILERIGHT = 1125\n    HURRICANEMISSILELEFT = 1126\n    HYBRIDSINGULARITYFEEDBACKWEAPON = 1127\n    DOMINIONKILLTEAMLMWEAPON = 1128\n    ITEMGRENADESWEAPON = 1129\n    ITEMGRAVITYBOMBSWEAPON = 1130\n    TESTHEROTHROWMISSILE = 1131\n    TESTHERODEBUGMISSILEABILITY1WEAPON = 1132\n    TESTHERODEBUGMISSILEABILITY2WEAPON = 1133\n    SPECTRE = 1134\n    VULTURE = 1135\n    LOKI = 1136\n    WRAITH = 1137\n    DOMINIONKILLTEAM = 1138\n    FIREBAT = 1139\n    DIAMONDBACK = 1140\n    G4CHARGEWEAPON = 1141\n    SS_BLACKEDGEBORDER = 1142\n    DEVOURERTISSUESAMPLETUBE = 1143\n    MONOLITH = 1144\n    OBELISK = 1145\n    ARCHIVE = 1146\n    ARTIFACTVAULT = 1147\n    AVERNUSGATECONTROL = 1148\n    GATECONTROLUNIT = 1149\n    BLIMPADS = 1150\n    BLOCKER6X6 = 1151\n    BLOCKER8X8 = 1152\n    BLOCKER16X16 = 1153\n    CARGOTRUCKUNITFLATBED = 1154\n    CARGOTRUCKUNITTRAILER = 1155\n    BLIMP = 1156\n    CASTANARWINDOWLARGEDIAGONALULBRUNIT = 1157\n    BLOCKER4X4 = 1158\n    HOMELARGE = 1159\n    HOMESMALL = 1160\n    ELEVATORBLOCKER = 1161\n    QUESTIONMARK = 1162\n    NYDUSWORMLAVADEATH = 1163\n    SS_BACKGROUNDSPACELARGE = 1164\n    SS_BACKGROUNDSPACETERRAN00 = 1165\n    SS_BACKGROUNDSPACETERRAN02 = 1166\n    SS_BACKGROUNDSPACEZERG00 = 1167\n    SS_BACKGROUNDSPACEZERG02 = 1168\n    SS_CARRIERBOSS = 1169\n    SS_BATTLECRUISER = 1170\n    SS_TERRATRONMISSILESPINNERLAUNCHER = 1171\n    SS_TERRATRONMISSILESPINNER = 1172\n    SS_TERRATRONBEAMTARGET = 1173\n    SS_LIGHTNINGPROJECTORFACERIGHT = 1174\n    SS_SCOURGE = 1175\n    SS_CORRUPTOR = 1176\n    SS_TERRATRONMISSILELAUNCHER = 1177\n    SS_LIGHTNINGPROJECTORFACELEFT = 1178\n    SS_WRAITH = 1179\n    SS_SWARMGUARDIAN = 1180\n    SS_SCOUT = 1181\n    SS_LEVIATHAN = 1182\n    SS_SCIENCEVESSEL = 1183\n    SS_TERRATRON = 1184\n    SECRETDOCUMENTS = 1185\n    PREDATOR = 1186\n    DEFILERBONESAMPLE = 1187\n    DEVOURERTISSUESAMPLE = 1188\n    PROTOSSPSIELEMENTS = 1189\n    TASSADAR = 1190\n    SCIENCEFACILITY = 1191\n    INFESTEDCOCOON = 1192\n    FUSIONREACTOR = 1193\n    BUBBACOMMERCIAL = 1194\n    XELNAGAPRISONHEIGHT2 = 1195\n    XELNAGAPRISON = 1196\n    XELNAGAPRISONNORTH = 1197\n    XELNAGAPRISONNORTHHEIGHT2 = 1198\n    ZERGDROPPODCREEP = 1199\n    IPISTOLAD = 1200\n    L800ETC_AD = 1201\n    NUKENOODLESCOMMERCIAL = 1202\n    PSIOPSCOMMERCIAL = 1203\n    SHIPALARM = 1204\n    SPACEPLATFORMDESTRUCTIBLEJUMBOBLOCKER = 1205\n    SPACEPLATFORMDESTRUCTIBLELARGEBLOCKER = 1206\n    SPACEPLATFORMDESTRUCTIBLEMEDIUMBLOCKER = 1207\n    SPACEPLATFORMDESTRUCTIBLESMALLBLOCKER = 1208\n    TALDARIMMOTHERSHIP = 1209\n    PLASMATORPEDOESWEAPON = 1210\n    PSIDISRUPTOR = 1211\n    HIVEMINDEMULATOR = 1212\n    RAYNOR01 = 1213\n    SCIENCEVESSEL = 1214\n    SCOURGE = 1215\n    SPACEPLATFORMREACTORPATHINGBLOCKER = 1216\n    TAURENOUTHOUSE = 1217\n    TYCHUSEJECTMISSILE = 1218\n    FEEDERLING = 1219\n    ULAANSMOKEBRIDGE = 1220\n    TALDARIMPRISONCRYSTAL = 1221\n    SPACEDIABLO = 1222\n    MURLOCMARINE = 1223\n    XELNAGAPRISONCONSOLE = 1224\n    TALDARIMPRISON = 1225\n    ADJUTANTCAPSULE = 1226\n    XELNAGAVAULT = 1227\n    HOLDINGPEN = 1228\n    SCRAPHUGE = 1229\n    PRISONERCIVILIAN = 1230\n    BIODOMEHALFBUILT = 1231\n    BIODOME = 1232\n    DESTRUCTIBLEKORHALFLAG = 1233\n    DESTRUCTIBLEKORHALPODIUM = 1234\n    DESTRUCTIBLEKORHALTREE = 1235\n    DESTRUCTIBLEKORHALFOLIAGE = 1236\n    DESTRUCTIBLESANDBAGS = 1237\n    CASTANARWINDOWLARGEDIAGONALBLURUNIT = 1238\n    CARGOTRUCKUNITBARRELS = 1239\n    SPORECANNON = 1240\n    STETMANN = 1241\n    BRIDGEBLOCKER4X12 = 1242\n    CIVILIANSHIPWRECKED = 1243\n    SWANN = 1244\n    DRAKKENLASERDRILL = 1245\n    MINDSIPHONRETURNWEAPON = 1246\n    KERRIGANEGG = 1247\n    CHRYSALISEGG = 1248\n    PRISONERSPECTRE = 1249\n    PRISONZEALOT = 1250\n    SCRAPSALVAGE1X1 = 1251\n    SCRAPSALVAGE2X2 = 1252\n    SCRAPSALVAGE3X3 = 1253\n    RAYNORCOMMANDO = 1254\n    OVERMIND = 1255\n    OVERMINDREMAINS = 1256\n    INFESTEDMERCHAVEN = 1257\n    MONLYTHARTIFACTFORCEFIELD = 1258\n    MONLYTHFORCEFIELDSTATUE = 1259\n    VIROPHAGE = 1260\n    PSISHOCKWEAPON = 1261\n    TYCHUSCOMMANDO = 1262\n    BRUTALISK = 1263\n    PYGALISK = 1264\n    VALHALLABASEDESTRUCTIBLEDOORDEAD = 1265\n    VALHALLABASEDESTRUCTIBLEDOOR = 1266\n    VOIDSEEKER = 1267\n    MINDSIPHONWEAPON = 1268\n    WARBOT = 1269\n    PLATFORMCONNECTOR = 1270\n    ARTANIS = 1271\n    TERRAZINECANISTER = 1272\n    HERCULES = 1273\n    MERCENARYFORTRESS = 1274\n    RAYNOR = 1275\n    ARTIFACTPIECE1 = 1276\n    ARTIFACTPIECE2 = 1277\n    ARTIFACTPIECE4 = 1278\n    ARTIFACTPIECE3 = 1279\n    ARTIFACTPIECE5 = 1280\n    RIPFIELDGENERATOR = 1281\n    RIPFIELDGENERATORSMALL = 1282\n    XELNAGAWORLDSHIPVAULT = 1283\n    TYCHUSCHAINGUN = 1284\n    ARTIFACT = 1285\n    CELLBLOCKB = 1286\n    GHOSTLASERLINES = 1287\n    MAINCELLBLOCK = 1288\n    KERRIGAN = 1289\n    DATACORE = 1290\n    SPECIALOPSDROPSHIP = 1291\n    TOSH = 1292\n    CASTANARULTRALISKSHACKLEDUNIT = 1293\n    KARASS = 1294\n    INVISIBLEPYLON = 1295\n    MAAR = 1296\n    HYBRIDDESTROYER = 1297\n    HYBRIDREAVER = 1298\n    HYBRID = 1299\n    TERRAZINENODE = 1300\n    TRANSPORTTRUCK = 1301\n    WALLOFFIRE = 1302\n    WEAPONHYBRIDC = 1303\n    XELNAGATEMPLE = 1304\n    EXPLODINGBARRELLARGE = 1305\n    SUPERWARPGATE = 1306\n    TERRAZINETANK = 1307\n    XELNAGASHRINE = 1308\n    SMCAMERABRIDGE = 1309\n    SMMARSARABARTYCHUSCAMERAS = 1310\n    SMHYPERIONBRIDGESTAGE1HANSONCAMERAS = 1311\n    SMHYPERIONBRIDGESTAGE1HORNERCAMERAS = 1312\n    SMHYPERIONBRIDGESTAGE1TYCHUSCAMERAS = 1313\n    SMHYPERIONBRIDGESTAGE1TOSHCAMERAS = 1314\n    SMHYPERIONARMORYSTAGE1SWANNCAMERAS = 1315\n    SMHYPERIONCANTINATOSHCAMERAS = 1316\n    SMHYPERIONCANTINATYCHUSCAMERAS = 1317\n    SMHYPERIONCANTINAYBARRACAMERAS = 1318\n    SMHYPERIONLABADJUTANTCAMERAS = 1319\n    SMHYPERIONLABCOWINCAMERAS = 1320\n    SMHYPERIONLABHANSONCAMERAS = 1321\n    SMHYPERIONBRIDGETRAYNOR03BRIEFINGCAMERA = 1322\n    SMTESTCAMERA = 1323\n    SMCAMERATERRAN01 = 1324\n    SMCAMERATERRAN02A = 1325\n    SMCAMERATERRAN02B = 1326\n    SMCAMERATERRAN03 = 1327\n    SMCAMERATERRAN04 = 1328\n    SMCAMERATERRAN04A = 1329\n    SMCAMERATERRAN04B = 1330\n    SMCAMERATERRAN05 = 1331\n    SMCAMERATERRAN06A = 1332\n    SMCAMERATERRAN06B = 1333\n    SMCAMERATERRAN06C = 1334\n    SMCAMERATERRAN07 = 1335\n    SMCAMERATERRAN08 = 1336\n    SMCAMERATERRAN09 = 1337\n    SMCAMERATERRAN10 = 1338\n    SMCAMERATERRAN11 = 1339\n    SMCAMERATERRAN12 = 1340\n    SMCAMERATERRAN13 = 1341\n    SMCAMERATERRAN14 = 1342\n    SMCAMERATERRAN15 = 1343\n    SMCAMERATERRAN16 = 1344\n    SMCAMERATERRAN17 = 1345\n    SMCAMERATERRAN20 = 1346\n    SMFIRSTOFFICER = 1347\n    SMHYPERIONBRIDGEBRIEFINGLEFT = 1348\n    SMHYPERIONBRIDGEBRIEFINGRIGHT = 1349\n    SMHYPERIONMEDLABBRIEFING = 1350\n    SMHYPERIONMEDLABBRIEFINGCENTER = 1351\n    SMHYPERIONMEDLABBRIEFINGLEFT = 1352\n    SMHYPERIONMEDLABBRIEFINGRIGHT = 1353\n    SMTOSHSHUTTLESET = 1354\n    SMKERRIGANPHOTO = 1355\n    SMTOSHSHUTTLESET2 = 1356\n    SMMARSARABARJUKEBOXHS = 1357\n    SMMARSARABARKERRIGANPHOTOHS = 1358\n    SMVALERIANFLAGSHIPCORRIDORSSET = 1359\n    SMVALERIANFLAGSHIPCORRIDORSSET2 = 1360\n    SMVALERIANFLAGSHIPCORRIDORSSET3 = 1361\n    SMVALERIANFLAGSHIPCORRIDORSSET4 = 1362\n    SMVALERIANOBSERVATORYSET = 1363\n    SMVALERIANOBSERVATORYSET2 = 1364\n    SMVALERIANOBSERVATORYSET3 = 1365\n    SMVALERIANOBSERVATORYPAINTINGHS = 1366\n    SMCHARBATTLEZONEFLAG = 1367\n    SMUNNSET = 1368\n    SMTERRANREADYROOMSET = 1369\n    SMCHARBATTLEZONESET = 1370\n    SMCHARBATTLEZONESET2 = 1371\n    SMCHARBATTLEZONESET3 = 1372\n    SMCHARBATTLEZONESET4 = 1373\n    SMCHARBATTLEZONESET5 = 1374\n    SMCHARBATTLEZONEARTIFACTHS = 1375\n    SMCHARBATTLEZONERADIOHS = 1376\n    SMCHARBATTLEZONEDROPSHIPHS = 1377\n    SMCHARBATTLEZONEBRIEFCASEHS = 1378\n    SMCHARBATTLEZONEBRIEFINGSET = 1379\n    SMCHARBATTLEZONEBRIEFINGSET2 = 1380\n    SMCHARBATTLEZONEBRIEFINGSETLEFT = 1381\n    SMCHARBATTLEZONEBRIEFINGSETRIGHT = 1382\n    SMMARSARABARBADGEHS = 1383\n    SMHYPERIONCANTINABADGEHS = 1384\n    SMHYPERIONCANTINAPOSTER1HS = 1385\n    SMHYPERIONCANTINAPOSTER2HS = 1386\n    SMHYPERIONCANTINAPOSTER3HS = 1387\n    SMHYPERIONCANTINAPOSTER4HS = 1388\n    SMHYPERIONCANTINAPOSTER5HS = 1389\n    SMFLY = 1390\n    SMBRIDGEWINDOWSPACE = 1391\n    SMBRIDGEPLANETSPACE = 1392\n    SMBRIDGEPLANETSPACEASTEROIDS = 1393\n    SMBRIDGEPLANETAGRIA = 1394\n    SMBRIDGEPLANETAIUR = 1395\n    SMBRIDGEPLANETAVERNUS = 1396\n    SMBRIDGEPLANETBELSHIR = 1397\n    SMBRIDGEPLANETCASTANAR = 1398\n    SMBRIDGEPLANETCHAR = 1399\n    SMBRIDGEPLANETHAVEN = 1400\n    SMBRIDGEPLANETKORHAL = 1401\n    SMBRIDGEPLANETMEINHOFF = 1402\n    SMBRIDGEPLANETMONLYTH = 1403\n    SMBRIDGEPLANETNEWFOLSOM = 1404\n    SMBRIDGEPLANETPORTZION = 1405\n    SMBRIDGEPLANETREDSTONE = 1406\n    SMBRIDGEPLANETSHAKURAS = 1407\n    SMBRIDGEPLANETTARSONIS = 1408\n    SMBRIDGEPLANETTYPHON = 1409\n    SMBRIDGEPLANETTYRADOR = 1410\n    SMBRIDGEPLANETULAAN = 1411\n    SMBRIDGEPLANETULNAR = 1412\n    SMBRIDGEPLANETVALHALLA = 1413\n    SMBRIDGEPLANETXIL = 1414\n    SMBRIDGEPLANETZHAKULDAS = 1415\n    SMMARSARAPLANET = 1416\n    SMNOVA = 1417\n    SMHAVENPLANET = 1418\n    SMHYPERIONBRIDGEBRIEFING = 1419\n    SMHYPERIONBRIDGEBRIEFINGCENTER = 1420\n    SMCHARBATTLEFIELDENDPROPS = 1421\n    SMCHARBATTLEZONETURRET = 1422\n    SMTERRAN01FX = 1423\n    SMTERRAN03FX = 1424\n    SMTERRAN05FX = 1425\n    SMTERRAN05FXMUTALISKS = 1426\n    SMTERRAN05PROPS = 1427\n    SMTERRAN06AFX = 1428\n    SMTERRAN06BFX = 1429\n    SMTERRAN06CFX = 1430\n    SMTERRAN12FX = 1431\n    SMTERRAN14FX = 1432\n    SMTERRAN15FX = 1433\n    SMTERRAN06APROPS = 1434\n    SMTERRAN06BPROPS = 1435\n    SMTERRAN07PROPS = 1436\n    SMTERRAN07FX = 1437\n    SMTERRAN08PROPS = 1438\n    SMTERRAN09FX = 1439\n    SMTERRAN09PROPS = 1440\n    SMTERRAN11FX = 1441\n    SMTERRAN11FXMISSILES = 1442\n    SMTERRAN11FXEXPLOSIONS = 1443\n    SMTERRAN11FXBLOOD = 1444\n    SMTERRAN11FXDEBRIS = 1445\n    SMTERRAN11FXDEBRIS1 = 1446\n    SMTERRAN11FXDEBRIS2 = 1447\n    SMTERRAN11PROPS = 1448\n    SMTERRAN11PROPSBURROWROCKS = 1449\n    SMTERRAN11PROPSRIFLESHELLS = 1450\n    SMTERRAN12PROPS = 1451\n    SMTERRAN13PROPS = 1452\n    SMTERRAN14PROPS = 1453\n    SMTERRAN15PROPS = 1454\n    SMTERRAN16FX = 1455\n    SMTERRAN16FXFLAK = 1456\n    SMTERRAN17PROPS = 1457\n    SMTERRAN17FX = 1458\n    SMMARSARABARPROPS = 1459\n    SMHYPERIONCORRIDORPROPS = 1460\n    ZERATULCRYSTALCHARGE = 1461\n    SMRAYNORHANDS = 1462\n    SMPRESSROOMPROPS = 1463\n    SMRAYNORGUN = 1464\n    SMMARINERIFLE = 1465\n    SMTOSHKNIFE = 1466\n    SMTOSHSHUTTLEPROPS = 1467\n    SMHYPERIONEXTERIOR = 1468\n    SMHYPERIONEXTERIORLOW = 1469\n    SMHYPERIONEXTERIORHOLOGRAM = 1470\n    SMCHARCUTSCENES00 = 1471\n    SMCHARCUTSCENES01 = 1472\n    SMCHARCUTSCENES02 = 1473\n    SMCHARCUTSCENES03 = 1474\n    SMMARSARABARBRIEFINGSET = 1475\n    SMMARSARABARBRIEFINGSET2 = 1476\n    SMMARSARABARBRIEFINGSETLEFT = 1477\n    SMMARSARABARBRIEFINGSETRIGHT = 1478\n    SMMARSARABARBRIEFINGTVMAIN = 1479\n    SMMARSARABARBRIEFINGTVMAIN2 = 1480\n    SMMARSARABARBRIEFINGTVMAIN3 = 1481\n    SMMARSARABARBRIEFINGTVPORTRAIT1 = 1482\n    SMMARSARABARBRIEFINGTVPORTRAIT2 = 1483\n    SMMARSARABARBRIEFINGTVPORTRAIT3 = 1484\n    SMMARSARABARBRIEFINGTVPORTRAIT4 = 1485\n    SMMARSARABARBRIEFINGTVPORTRAIT5 = 1486\n    SMMARSARABARSET = 1487\n    SMMARSARABARSET2 = 1488\n    SMMARSARABARSTARMAPHS = 1489\n    SMMARSARABARTVHS = 1490\n    SMMARSARABARHYDRALISKSKULLHS = 1491\n    SMMARSARABARCORKBOARDHS = 1492\n    SMMARSARABARCORKBOARDBACKGROUND = 1493\n    SMMARSARABARCORKBOARDITEM1HS = 1494\n    SMMARSARABARCORKBOARDITEM2HS = 1495\n    SMMARSARABARCORKBOARDITEM3HS = 1496\n    SMMARSARABARCORKBOARDITEM4HS = 1497\n    SMMARSARABARCORKBOARDITEM5HS = 1498\n    SMMARSARABARCORKBOARDITEM6HS = 1499\n    SMMARSARABARCORKBOARDITEM7HS = 1500\n    SMMARSARABARCORKBOARDITEM8HS = 1501\n    SMMARSARABARCORKBOARDITEM9HS = 1502\n    SMMARSARABARBOTTLESHS = 1503\n    SMVALERIANOBSERVATORYPROPS = 1504\n    SMVALERIANOBSERVATORYSTARMAP = 1505\n    SMBANSHEE = 1506\n    SMVIKING = 1507\n    SMARMORYBANSHEE = 1508\n    SMARMORYDROPSHIP = 1509\n    SMARMORYTANK = 1510\n    SMARMORYVIKING = 1511\n    SMARMORYSPIDERMINE = 1512\n    SMARMORYGHOSTCRATE = 1513\n    SMARMORYSPECTRECRATE = 1514\n    SMARMORYBANSHEEPHCRATE = 1515\n    SMARMORYDROPSHIPPHCRATE = 1516\n    SMARMORYTANKPHCRATE = 1517\n    SMARMORYVIKINGPHCRATE = 1518\n    SMARMORYSPIDERMINEPHCRATE = 1519\n    SMARMORYGHOSTCRATEPHCRATE = 1520\n    SMARMORYSPECTRECRATEPHCRATE = 1521\n    SMARMORYRIFLE = 1522\n    SMDROPSHIP = 1523\n    SMDROPSHIPBLUE = 1524\n    SMHYPERIONARMORYVIKING = 1525\n    SMCHARGATLINGGUN = 1526\n    SMBOUNTYHUNTER = 1527\n    SMCIVILIAN = 1528\n    SMZERGEDHANSON = 1529\n    SMLABASSISTANT = 1530\n    SMHYPERIONARMORER = 1531\n    SMUNNSCREEN = 1532\n    NEWSARCTURUSINTERVIEWSET = 1533\n    NEWSARCTURUSPRESSROOM = 1534\n    SMDONNYVERMILLIONSET = 1535\n    NEWSMEINHOFFREFUGEECENTER = 1536\n    NEWSRAYNORLOGO = 1537\n    NEWSTVEFFECT = 1538\n    SMUNNCAMERA = 1539\n    SMLEEKENOSET = 1540\n    SMTVSTATIC = 1541\n    SMDONNYVERMILLION = 1542\n    SMDONNYVERMILLIONDEATH = 1543\n    SMLEEKENO = 1544\n    SMKATELOCKWELL = 1545\n    SMMIKELIBERTY = 1546\n    SMTERRANREADYROOMLEFTTV = 1547\n    SMTERRANREADYROOMMAINTV = 1548\n    SMTERRANREADYROOMRIGHTTV = 1549\n    SMHYPERIONARMORYSTAGE1SET = 1550\n    SMHYPERIONARMORYSTAGE1SET01 = 1551\n    SMHYPERIONARMORYSTAGE1SET02 = 1552\n    SMHYPERIONARMORYSTAGE1SET03 = 1553\n    SMHYPERIONARMORYSPACELIGHTING = 1554\n    SMHYPERIONARMORYSTAGE1TECHNOLOGYCONSOLEHS = 1555\n    SMHYPERIONBRIDGESTAGE1BOW = 1556\n    SMHYPERIONBRIDGESTAGE1SET = 1557\n    SMHYPERIONBRIDGESTAGE1SET2 = 1558\n    SMHYPERIONBRIDGESTAGE1SET3 = 1559\n    SMHYPERIONBRIDGEHOLOMAP = 1560\n    SMHYPERIONCANTINASTAGE1SET = 1561\n    SMHYPERIONCANTINASTAGE1SET2 = 1562\n    SMHYPERIONCANTINASTAGE1WALLPIECE = 1563\n    SMHYPERIONBRIDGEPROPS = 1564\n    SMHYPERIONCANTINAPROPS = 1565\n    SMHYPERIONMEDLABPROPS = 1566\n    SMHYPERIONMEDLABPROTOSSCRYOTUBE0HS = 1567\n    SMHYPERIONMEDLABPROTOSSCRYOTUBE1HS = 1568\n    SMHYPERIONMEDLABPROTOSSCRYOTUBE2HS = 1569\n    SMHYPERIONMEDLABPROTOSSCRYOTUBE3HS = 1570\n    SMHYPERIONMEDLABPROTOSSCRYOTUBE4HS = 1571\n    SMHYPERIONMEDLABPROTOSSCRYOTUBE5HS = 1572\n    SMHYPERIONMEDLABZERGCRYOTUBE0HS = 1573\n    SMHYPERIONMEDLABZERGCRYOTUBE1HS = 1574\n    SMHYPERIONMEDLABZERGCRYOTUBE2HS = 1575\n    SMHYPERIONMEDLABZERGCRYOTUBE3HS = 1576\n    SMHYPERIONMEDLABZERGCRYOTUBE4HS = 1577\n    SMHYPERIONMEDLABZERGCRYOTUBE5HS = 1578\n    SMHYPERIONMEDLABCRYOTUBEA = 1579\n    SMHYPERIONMEDLABCRYOTUBEB = 1580\n    SMHYPERIONCANTINASTAGE1EXITHS = 1581\n    SMHYPERIONCANTINASTAGE1STAIRCASEHS = 1582\n    SMHYPERIONCANTINASTAGE1TVHS = 1583\n    SMHYPERIONCANTINASTAGE1ARCADEGAMEHS = 1584\n    SMHYPERIONCANTINASTAGE1JUKEBOXHS = 1585\n    SMHYPERIONCANTINASTAGE1CORKBOARDHS = 1586\n    SMHYPERIONCANTINAPROGRESSFRAME = 1587\n    SMHYPERIONCANTINAHYDRACLAWSHS = 1588\n    SMHYPERIONCANTINAMERCCOMPUTERHS = 1589\n    SMHYPERIONCANTINASTAGE1PROGRESS1HS = 1590\n    SMHYPERIONCANTINASTAGE1PROGRESS2HS = 1591\n    SMHYPERIONCANTINASTAGE1PROGRESS3HS = 1592\n    SMHYPERIONCANTINASTAGE1PROGRESS4HS = 1593\n    SMHYPERIONCANTINASTAGE1PROGRESS5HS = 1594\n    SMHYPERIONCANTINASTAGE1PROGRESS6HS = 1595\n    SMHYPERIONCORRIDORSET = 1596\n    SMHYPERIONBRIDGESTAGE1BATTLEREPORTSHS = 1597\n    SMHYPERIONBRIDGESTAGE1CENTERCONSOLEHS = 1598\n    SMHYPERIONBRIDGESTAGE1BATTLECOMMANDHS = 1599\n    SMHYPERIONBRIDGESTAGE1CANTINAHS = 1600\n    SMHYPERIONBRIDGESTAGE1WINDOWHS = 1601\n    SMHYPERIONMEDLABSTAGE1SET = 1602\n    SMHYPERIONMEDLABSTAGE1SET2 = 1603\n    SMHYPERIONMEDLABSTAGE1SETLIGHTS = 1604\n    SMHYPERIONMEDLABSTAGE1CONSOLEHS = 1605\n    SMHYPERIONMEDLABSTAGE1DOORHS = 1606\n    SMHYPERIONMEDLABSTAGE1CRYSTALHS = 1607\n    SMHYPERIONMEDLABSTAGE1ARTIFACTHS = 1608\n    SMHYPERIONLABARTIFACTPART1HS = 1609\n    SMHYPERIONLABARTIFACTPART2HS = 1610\n    SMHYPERIONLABARTIFACTPART3HS = 1611\n    SMHYPERIONLABARTIFACTPART4HS = 1612\n    SMHYPERIONLABARTIFACTBASEHS = 1613\n    SMSHADOWBOX = 1614\n    SMCHARBATTLEZONESHADOWBOX = 1615\n    SMCHARINTERACTIVESKYPARALLAX = 1616\n    SMCHARINTERACTIVE02SKYPARALLAX = 1617\n    SMRAYNORCOMMANDER = 1618\n    SMADJUTANT = 1619\n    SMADJUTANTHOLOGRAM = 1620\n    SMMARAUDER = 1621\n    SMFIREBAT = 1622\n    SMMARAUDERPHCRATE = 1623\n    SMFIREBATPHCRATE = 1624\n    SMRAYNORMARINE = 1625\n    SMMARINE01 = 1626\n    SMMARINE02 = 1627\n    SMMARINE02AOD = 1628\n    SMMARINE03 = 1629\n    SMMARINE04 = 1630\n    SMCADE = 1631\n    SMHALL = 1632\n    SMBRALIK = 1633\n    SMANNABELLE = 1634\n    SMEARL = 1635\n    SMKACHINSKY = 1636\n    SMGENERICMALEGREASEMONKEY01 = 1637\n    SMGENERICMALEGREASEMONKEY02 = 1638\n    SMGENERICMALEOFFICER01 = 1639\n    SMGENERICMALEOFFICER02 = 1640\n    SMSTETMANN = 1641\n    SMCOOPER = 1642\n    SMHILL = 1643\n    SMYBARRA = 1644\n    SMVALERIANMENGSK = 1645\n    SMARCTURUSMENGSK = 1646\n    SMARCTURUSHOLOGRAM = 1647\n    SMZERATUL = 1648\n    SMHYDRALISK = 1649\n    SMHYDRALISKDEAD = 1650\n    SMMUTALISK = 1651\n    SMZERGLING = 1652\n    SCIENTIST = 1653\n    MINERMALE = 1654\n    CIVILIAN = 1655\n    COLONIST = 1656\n    CIVILIANFEMALE = 1657\n    COLONISTFEMALE = 1658\n    HUT = 1659\n    COLONISTHUT = 1660\n    INFESTABLEHUT = 1661\n    INFESTABLECOLONISTHUT = 1662\n    XELNAGASHRINEXIL = 1663\n    PROTOSSRELIC = 1664\n    PICKUPGRENADES = 1665\n    PICKUPPLASMAGUN = 1666\n    PICKUPPLASMAROUNDS = 1667\n    PICKUPMEDICRECHARGE = 1668\n    PICKUPMANARECHARGE = 1669\n    PICKUPRESTORATIONCHARGE = 1670\n    PICKUPCHRONORIFTDEVICE = 1671\n    PICKUPCHRONORIFTCHARGE = 1672\n    GASCANISTER = 1673\n    GASCANISTERPROTOSS = 1674\n    GASCANISTERZERG = 1675\n    MINERALCRYSTAL = 1676\n    PALLETGAS = 1677\n    PALLETMINERALS = 1678\n    NATURALGAS = 1679\n    NATURALMINERALS = 1680\n    NATURALMINERALSRED = 1681\n    PICKUPHEALTH25 = 1682\n    PICKUPHEALTH50 = 1683\n    PICKUPHEALTH100 = 1684\n    PICKUPHEALTHFULL = 1685\n    PICKUPENERGY25 = 1686\n    PICKUPENERGY50 = 1687\n    PICKUPENERGY100 = 1688\n    PICKUPENERGYFULL = 1689\n    PICKUPMINES = 1690\n    PICKUPPSISTORM = 1691\n    CIVILIANCARSUNIT = 1692\n    CRUISERBIKE = 1693\n    TERRANBUGGY = 1694\n    COLONISTVEHICLEUNIT = 1695\n    COLONISTVEHICLEUNIT01 = 1696\n    DUMPTRUCK = 1697\n    TANKERTRUCK = 1698\n    FLATBEDTRUCK = 1699\n    COLONISTSHIPTHANSON02A = 1700\n    PURIFIER = 1701\n    INFESTEDARMORY = 1702\n    INFESTEDBARRACKS = 1703\n    INFESTEDBUNKER = 1704\n    INFESTEDCC = 1705\n    INFESTEDENGBAY = 1706\n    INFESTEDFACTORY = 1707\n    INFESTEDREFINERY = 1708\n    INFESTEDSTARPORT = 1709\n    INFESTEDMISSILETURRET = 1710\n    LOGISTICSHEADQUARTERS = 1711\n    INFESTEDSUPPLY = 1712\n    TARSONISENGINE = 1713\n    TARSONISENGINEFAST = 1714\n    FREIGHTCAR = 1715\n    CABOOSE = 1716\n    HYPERION = 1717\n    MENGSKHOLOGRAMBILLBOARD = 1718\n    TRAYNOR01SIGNSDESTRUCTIBLE1 = 1719\n    ABANDONEDBUILDING = 1720\n    NOVA = 1721\n    FOOD1000 = 1722\n    PSIINDOCTRINATOR = 1723\n    JORIUMSTOCKPILE = 1724\n    ZERGDROPPOD = 1725\n    TERRANDROPPOD = 1726\n    COLONISTBIODOME = 1727\n    COLONISTBIODOMEHALFBUILT = 1728\n    INFESTABLEBIODOME = 1729\n    INFESTABLECOLONISTBIODOME = 1730\n    MEDIC = 1731\n    VIKINGSKY_UNIT = 1732\n    SS_FIGHTER = 1733\n    SS_PHOENIX = 1734\n    SS_CARRIER = 1735\n    SS_BACKGROUNDZERG01 = 1736\n    SS_BACKGROUNDSPACE00 = 1737\n    SS_BACKGROUNDSPACE01 = 1738\n    SS_BACKGROUNDSPACE02 = 1739\n    SS_BACKGROUNDSPACEPROT00 = 1740\n    SS_BACKGROUNDSPACEPROT01 = 1741\n    SS_BACKGROUNDSPACEPROT02 = 1742\n    SS_BACKGROUNDSPACEPROT03 = 1743\n    SS_BACKGROUNDSPACEPROT04 = 1744\n    SS_BACKGROUNDSPACEPROTOSSLARGE = 1745\n    SS_BACKGROUNDSPACEZERGLARGE = 1746\n    SS_BACKGROUNDSPACETERRANLARGE = 1747\n    SS_BACKGROUNDSPACEZERG01 = 1748\n    SS_BACKGROUNDSPACETERRAN01 = 1749\n    BREACHINGCHARGE = 1750\n    INFESTATIONSPIRE = 1751\n    SPACEPLATFORMVENTSUNIT = 1752\n    STONEZEALOT = 1753\n    PRESERVERPRISON = 1754\n    PORTJUNKER = 1755\n    LEVIATHAN = 1756\n    SWARMLING = 1757\n    VALHALLADESTRUCTIBLEWALL = 1758\n    NEWFOLSOMPRISONENTRANCE = 1759\n    ODINBUILD = 1760\n    NUKEPACK = 1761\n    CHARDESTRUCTIBLEROCKCOVER = 1762\n    CHARDESTRUCTIBLEROCKCOVERV = 1763\n    CHARDESTRUCTIBLEROCKCOVERULDR = 1764\n    CHARDESTRUCTIBLEROCKCOVERURDL = 1765\n    MAARWARPINUNIT = 1766\n    EGGPURPLE = 1767\n    TRUCKFLATBEDUNIT = 1768\n    TRUCKSEMIUNIT = 1769\n    TRUCKUTILITYUNIT = 1770\n    INFESTEDCOLONISTSHIP = 1771\n    CASTANARDESTRUCTIBLEDEBRIS = 1772\n    COLONISTTRANSPORT = 1773\n    PRESERVERBASE = 1774\n    PRESERVERA = 1775\n    PRESERVERB = 1776\n    PRESERVERC = 1777\n    TAURENSPACEMARINE = 1778\n    MARSARABRIDGEBLUR = 1779\n    MARSARABRIDGEBRUL = 1780\n    SHORTBRIDGEVERTICAL = 1781\n    SHORTBRIDGEHORIZONTAL = 1782\n    TESTHERO = 1783\n    TESTSHOP = 1784\n    HEALINGPOTIONTESTTARGET = 1785\n    _4SLOTBAG = 1786\n    _6SLOTBAG = 1787\n    _8SLOTBAG = 1788\n    _10SLOTBAG = 1789\n    _12SLOTBAG = 1790\n    _14SLOTBAG = 1791\n    _16SLOTBAG = 1792\n    _18SLOTBAG = 1793\n    _20SLOTBAG = 1794\n    _22SLOTBAG = 1795\n    _24SLOTBAG = 1796\n    REPULSERFIELD6 = 1797\n    REPULSERFIELD8 = 1798\n    REPULSERFIELD10 = 1799\n    REPULSERFIELD12 = 1800\n    DESTRUCTIBLEWALLCORNER45ULBL = 1801\n    DESTRUCTIBLEWALLCORNER45ULUR = 1802\n    DESTRUCTIBLEWALLCORNER45URBR = 1803\n    DESTRUCTIBLEWALLCORNER45 = 1804\n    DESTRUCTIBLEWALLCORNER45UR90L = 1805\n    DESTRUCTIBLEWALLCORNER45UL90B = 1806\n    DESTRUCTIBLEWALLCORNER45BL90R = 1807\n    DESTRUCTIBLEWALLCORNER45BR90T = 1808\n    DESTRUCTIBLEWALLCORNER90L45BR = 1809\n    DESTRUCTIBLEWALLCORNER90T45BL = 1810\n    DESTRUCTIBLEWALLCORNER90R45UL = 1811\n    DESTRUCTIBLEWALLCORNER90B45UR = 1812\n    DESTRUCTIBLEWALLCORNER90TR = 1813\n    DESTRUCTIBLEWALLCORNER90BR = 1814\n    DESTRUCTIBLEWALLCORNER90LB = 1815\n    DESTRUCTIBLEWALLCORNER90LT = 1816\n    DESTRUCTIBLEWALLDIAGONALBLUR = 1817\n    DESTRUCTIBLEWALLDIAGONALBLURLF = 1818\n    DESTRUCTIBLEWALLDIAGONALULBRLF = 1819\n    DESTRUCTIBLEWALLDIAGONALULBR = 1820\n    DESTRUCTIBLEWALLSTRAIGHTVERTICAL = 1821\n    DESTRUCTIBLEWALLVERTICALLF = 1822\n    DESTRUCTIBLEWALLSTRAIGHTHORIZONTAL = 1823\n    DESTRUCTIBLEWALLSTRAIGHTHORIZONTALBF = 1824\n    DEFENSEWALLE = 1825\n    DEFENSEWALLS = 1826\n    DEFENSEWALLW = 1827\n    DEFENSEWALLN = 1828\n    DEFENSEWALLNE = 1829\n    DEFENSEWALLSW = 1830\n    DEFENSEWALLNW = 1831\n    DEFENSEWALLSE = 1832\n    WRECKEDBATTLECRUISERHELIOSFINAL = 1833\n    FIREWORKSBLUE = 1834\n    FIREWORKSRED = 1835\n    FIREWORKSYELLOW = 1836\n    PURIFIERBLASTMARKUNIT = 1837\n    ITEMGRAVITYBOMBS = 1838\n    ITEMGRENADES = 1839\n    ITEMMEDKIT = 1840\n    ITEMMINES = 1841\n    REAPERPLACEMENT = 1842\n    QUEENZAGARAACGLUESCREENDUMMY = 1843\n    OVERSEERZAGARAACGLUESCREENDUMMY = 1844\n    STUKOVINFESTEDCIVILIANACGLUESCREENDUMMY = 1845\n    STUKOVINFESTEDMARINEACGLUESCREENDUMMY = 1846\n    STUKOVINFESTEDSIEGETANKACGLUESCREENDUMMY = 1847\n    STUKOVINFESTEDDIAMONDBACKACGLUESCREENDUMMY = 1848\n    STUKOVINFESTEDBANSHEEACGLUESCREENDUMMY = 1849\n    SILIBERATORACGLUESCREENDUMMY = 1850\n    STUKOVINFESTEDBUNKERACGLUESCREENDUMMY = 1851\n    STUKOVINFESTEDMISSILETURRETACGLUESCREENDUMMY = 1852\n    STUKOVBROODQUEENACGLUESCREENDUMMY = 1853\n    ZEALOTFENIXACGLUESCREENDUMMY = 1854\n    SENTRYFENIXACGLUESCREENDUMMY = 1855\n    ADEPTFENIXACGLUESCREENDUMMY = 1856\n    IMMORTALFENIXACGLUESCREENDUMMY = 1857\n    COLOSSUSFENIXACGLUESCREENDUMMY = 1858\n    DISRUPTORACGLUESCREENDUMMY = 1859\n    OBSERVERFENIXACGLUESCREENDUMMY = 1860\n    SCOUTACGLUESCREENDUMMY = 1861\n    CARRIERFENIXACGLUESCREENDUMMY = 1862\n    PHOTONCANNONFENIXACGLUESCREENDUMMY = 1863\n    PRIMALZERGLINGACGLUESCREENDUMMY = 1864\n    RAVASAURACGLUESCREENDUMMY = 1865\n    PRIMALROACHACGLUESCREENDUMMY = 1866\n    FIREROACHACGLUESCREENDUMMY = 1867\n    PRIMALGUARDIANACGLUESCREENDUMMY = 1868\n    PRIMALHYDRALISKACGLUESCREENDUMMY = 1869\n    PRIMALMUTALISKACGLUESCREENDUMMY = 1870\n    PRIMALIMPALERACGLUESCREENDUMMY = 1871\n    PRIMALSWARMHOSTACGLUESCREENDUMMY = 1872\n    CREEPERHOSTACGLUESCREENDUMMY = 1873\n    PRIMALULTRALISKACGLUESCREENDUMMY = 1874\n    TYRANNOZORACGLUESCREENDUMMY = 1875\n    PRIMALWURMACGLUESCREENDUMMY = 1876\n    HHREAPERACGLUESCREENDUMMY = 1877\n    HHWIDOWMINEACGLUESCREENDUMMY = 1878\n    HHHELLIONTANKACGLUESCREENDUMMY = 1879\n    HHWRAITHACGLUESCREENDUMMY = 1880\n    HHVIKINGACGLUESCREENDUMMY = 1881\n    HHBATTLECRUISERACGLUESCREENDUMMY = 1882\n    HHRAVENACGLUESCREENDUMMY = 1883\n    HHBOMBERPLATFORMACGLUESCREENDUMMY = 1884\n    HHMERCSTARPORTACGLUESCREENDUMMY = 1885\n    HHMISSILETURRETACGLUESCREENDUMMY = 1886\n    HIGHTEMPLARSKINPREVIEW = 1887\n    WARPPRISMSKINPREVIEW = 1888\n    SIEGETANKSKINPREVIEW = 1889\n    LIBERATORSKINPREVIEW = 1890\n    VIKINGSKINPREVIEW = 1891\n    STUKOVINFESTEDTROOPERACGLUESCREENDUMMY = 1892\n    XELNAGADESTRUCTIBLEBLOCKER6S = 1893\n    XELNAGADESTRUCTIBLEBLOCKER6SE = 1894\n    XELNAGADESTRUCTIBLEBLOCKER6E = 1895\n    XELNAGADESTRUCTIBLEBLOCKER6NE = 1896\n    XELNAGADESTRUCTIBLEBLOCKER6N = 1897\n    XELNAGADESTRUCTIBLEBLOCKER6NW = 1898\n    XELNAGADESTRUCTIBLEBLOCKER6W = 1899\n    XELNAGADESTRUCTIBLEBLOCKER6SW = 1900\n    XELNAGADESTRUCTIBLEBLOCKER8S = 1901\n    XELNAGADESTRUCTIBLEBLOCKER8SE = 1902\n    XELNAGADESTRUCTIBLEBLOCKER8E = 1903\n    XELNAGADESTRUCTIBLEBLOCKER8NE = 1904\n    XELNAGADESTRUCTIBLEBLOCKER8N = 1905\n    XELNAGADESTRUCTIBLEBLOCKER8NW = 1906\n    XELNAGADESTRUCTIBLEBLOCKER8W = 1907\n    XELNAGADESTRUCTIBLEBLOCKER8SW = 1908\n    SNOWGLAZESTARTERMP = 1909\n    SHIELDBATTERY = 1910\n    OBSERVERSIEGEMODE = 1911\n    OVERSEERSIEGEMODE = 1912\n    RAVENREPAIRDRONE = 1913\n    HIGHTEMPLARWEAPONMISSILE = 1914\n    CYCLONEMISSILELARGEAIRALTERNATIVE = 1915\n    RAVENSCRAMBLERMISSILE = 1916\n    RAVENREPAIRDRONERELEASEWEAPON = 1917\n    RAVENSHREDDERMISSILEWEAPON = 1918\n    INFESTEDACIDSPINESWEAPON = 1919\n    INFESTORENSNAREATTACKMISSILE = 1920\n    SNARE_PLACEHOLDER = 1921\n    TYCHUSREAPERACGLUESCREENDUMMY = 1922\n    TYCHUSFIREBATACGLUESCREENDUMMY = 1923\n    TYCHUSSPECTREACGLUESCREENDUMMY = 1924\n    TYCHUSMEDICACGLUESCREENDUMMY = 1925\n    TYCHUSMARAUDERACGLUESCREENDUMMY = 1926\n    TYCHUSWARHOUNDACGLUESCREENDUMMY = 1927\n    TYCHUSHERCACGLUESCREENDUMMY = 1928\n    TYCHUSGHOSTACGLUESCREENDUMMY = 1929\n    TYCHUSSCVAUTOTURRETACGLUESCREENDUMMY = 1930\n    ZERATULSTALKERACGLUESCREENDUMMY = 1931\n    ZERATULSENTRYACGLUESCREENDUMMY = 1932\n    ZERATULDARKTEMPLARACGLUESCREENDUMMY = 1933\n    ZERATULIMMORTALACGLUESCREENDUMMY = 1934\n    ZERATULOBSERVERACGLUESCREENDUMMY = 1935\n    ZERATULDISRUPTORACGLUESCREENDUMMY = 1936\n    ZERATULWARPPRISMACGLUESCREENDUMMY = 1937\n    ZERATULPHOTONCANNONACGLUESCREENDUMMY = 1938\n    RENEGADELONGBOLTMISSILEWEAPON = 1939\n    VIKING = 1940\n    RENEGADEMISSILETURRET = 1941\n    PARASITICBOMBRELAYDUMMY = 1942\n    REFINERYRICH = 1943\n    MECHAZERGLINGACGLUESCREENDUMMY = 1944\n    MECHABANELINGACGLUESCREENDUMMY = 1945\n    MECHAHYDRALISKACGLUESCREENDUMMY = 1946\n    MECHAINFESTORACGLUESCREENDUMMY = 1947\n    MECHACORRUPTORACGLUESCREENDUMMY = 1948\n    MECHAULTRALISKACGLUESCREENDUMMY = 1949\n    MECHAOVERSEERACGLUESCREENDUMMY = 1950\n    MECHALURKERACGLUESCREENDUMMY = 1951\n    MECHABATTLECARRIERLORDACGLUESCREENDUMMY = 1952\n    MECHASPINECRAWLERACGLUESCREENDUMMY = 1953\n    MECHASPORECRAWLERACGLUESCREENDUMMY = 1954\n    TROOPERMENGSKACGLUESCREENDUMMY = 1955\n    MEDIVACMENGSKACGLUESCREENDUMMY = 1956\n    BLIMPMENGSKACGLUESCREENDUMMY = 1957\n    MARAUDERMENGSKACGLUESCREENDUMMY = 1958\n    GHOSTMENGSKACGLUESCREENDUMMY = 1959\n    SIEGETANKMENGSKACGLUESCREENDUMMY = 1960\n    THORMENGSKACGLUESCREENDUMMY = 1961\n    VIKINGMENGSKACGLUESCREENDUMMY = 1962\n    BATTLECRUISERMENGSKACGLUESCREENDUMMY = 1963\n    BUNKERDEPOTMENGSKACGLUESCREENDUMMY = 1964\n    MISSILETURRETMENGSKACGLUESCREENDUMMY = 1965\n    ARTILLERYMENGSKACGLUESCREENDUMMY = 1966\n    LOADOUTSPRAY1 = 1967\n    LOADOUTSPRAY2 = 1968\n    LOADOUTSPRAY3 = 1969\n    LOADOUTSPRAY4 = 1970\n    LOADOUTSPRAY5 = 1971\n    LOADOUTSPRAY6 = 1972\n    LOADOUTSPRAY7 = 1973\n    LOADOUTSPRAY8 = 1974\n    LOADOUTSPRAY9 = 1975\n    LOADOUTSPRAY10 = 1976\n    LOADOUTSPRAY11 = 1977\n    LOADOUTSPRAY12 = 1978\n    LOADOUTSPRAY13 = 1979\n    LOADOUTSPRAY14 = 1980\n    PREVIEWBUNKERUPGRADED = 1981\n    INHIBITORZONESMALL = 1982\n    INHIBITORZONEMEDIUM = 1983\n    INHIBITORZONELARGE = 1984\n    ACCELERATIONZONESMALL = 1985\n    ACCELERATIONZONEMEDIUM = 1986\n    ACCELERATIONZONELARGE = 1987\n    ACCELERATIONZONEFLYINGSMALL = 1988\n    ACCELERATIONZONEFLYINGMEDIUM = 1989\n    ACCELERATIONZONEFLYINGLARGE = 1990\n    INHIBITORZONEFLYINGSMALL = 1991\n    INHIBITORZONEFLYINGMEDIUM = 1992\n    INHIBITORZONEFLYINGLARGE = 1993\n    ASSIMILATORRICH = 1994\n    EXTRACTORRICH = 1995\n    MINERALFIELD450 = 1996\n    MINERALFIELDOPAQUE = 1997\n    MINERALFIELDOPAQUE900 = 1998\n    COLLAPSIBLEROCKTOWERDEBRISRAMPLEFTGREEN = 1999\n    COLLAPSIBLEROCKTOWERDEBRISRAMPRIGHTGREEN = 2000\n    COLLAPSIBLEROCKTOWERPUSHUNITRAMPLEFTGREEN = 2001\n    COLLAPSIBLEROCKTOWERPUSHUNITRAMPRIGHTGREEN = 2002\n    COLLAPSIBLEROCKTOWERRAMPLEFTGREEN = 2003\n    COLLAPSIBLEROCKTOWERRAMPRIGHTGREEN = 2004\n\n    def __repr__(self):\n        return f\"UnitTypeId.{self.name}\"",
  "def __repr__(self):\n        return f\"UnitTypeId.{self.name}\"",
  "class AbilityId(enum.Enum):\n    NULL_NULL = 0\n    SMART = 1\n    TAUNT_TAUNT = 2\n    STOP_STOP = 4\n    STOP_HOLDFIRESPECIAL = 5\n    STOP_CHEER = 6\n    STOP_DANCE = 7\n    HOLDFIRE_STOPSPECIAL = 10\n    HOLDFIRE_HOLDFIRE = 11\n    MOVE_MOVE = 16\n    PATROL_PATROL = 17\n    HOLDPOSITION_HOLD = 18\n    SCAN_MOVE = 19\n    MOVE_TURN = 20\n    BEACON_CANCEL = 21\n    BEACON_BEACONMOVE = 22\n    ATTACK_ATTACK = 23\n    ATTACK_ATTACKTOWARDS = 24\n    ATTACK_ATTACKBARRAGE = 25\n    EFFECT_SPRAY_TERRAN = 26\n    EFFECT_SPRAY_ZERG = 28\n    EFFECT_SPRAY_PROTOSS = 30\n    EFFECT_SALVAGE = 32\n    CORRUPTION_CORRUPTIONABILITY = 34\n    CORRUPTION_CANCEL = 35\n    BEHAVIOR_HOLDFIREON_GHOST = 36\n    BEHAVIOR_HOLDFIREOFF_GHOST = 38\n    MORPHTOINFESTEDTERRAN_INFESTEDTERRANS = 40\n    EXPLODE_EXPLODE = 42\n    RESEARCH_INTERCEPTORGRAVITONCATAPULT = 44\n    FLEETBEACONRESEARCH_RESEARCHINTERCEPTORLAUNCHSPEEDUPGRADE = 45\n    RESEARCH_PHOENIXANIONPULSECRYSTALS = 46\n    FLEETBEACONRESEARCH_TEMPESTRANGEUPGRADE = 47\n    FLEETBEACONRESEARCH_RESEARCHVOIDRAYSPEEDUPGRADE = 48\n    FLEETBEACONRESEARCH_TEMPESTRESEARCHGROUNDATTACKUPGRADE = 49\n    FUNGALGROWTH_FUNGALGROWTH = 74\n    GUARDIANSHIELD_GUARDIANSHIELD = 76\n    EFFECT_REPAIR_MULE = 78\n    MORPHZERGLINGTOBANELING_BANELING = 80\n    NEXUSTRAINMOTHERSHIP_MOTHERSHIP = 110\n    FEEDBACK_FEEDBACK = 140\n    EFFECT_MASSRECALL_STRATEGICRECALL = 142\n    PLACEPOINTDEFENSEDRONE_POINTDEFENSEDRONE = 144\n    HALLUCINATION_ARCHON = 146\n    HALLUCINATION_COLOSSUS = 148\n    HALLUCINATION_HIGHTEMPLAR = 150\n    HALLUCINATION_IMMORTAL = 152\n    HALLUCINATION_PHOENIX = 154\n    HALLUCINATION_PROBE = 156\n    HALLUCINATION_STALKER = 158\n    HALLUCINATION_VOIDRAY = 160\n    HALLUCINATION_WARPPRISM = 162\n    HALLUCINATION_ZEALOT = 164\n    HARVEST_GATHER_MULE = 166\n    HARVEST_RETURN_MULE = 167\n    SEEKERMISSILE_HUNTERSEEKERMISSILE = 169\n    CALLDOWNMULE_CALLDOWNMULE = 171\n    GRAVITONBEAM_GRAVITONBEAM = 173\n    CANCEL_GRAVITONBEAM = 174\n    BUILDINPROGRESSNYDUSCANAL_CANCEL = 175\n    SIPHON_SIPHON = 177\n    SIPHON_CANCEL = 178\n    LEECH_LEECH = 179\n    SPAWNCHANGELING_SPAWNCHANGELING = 181\n    DISGUISEASZEALOT_ZEALOT = 183\n    DISGUISEASMARINEWITHSHIELD_MARINE = 185\n    DISGUISEASMARINEWITHOUTSHIELD_MARINE = 187\n    DISGUISEASZERGLINGWITHWINGS_ZERGLING = 189\n    DISGUISEASZERGLINGWITHOUTWINGS_ZERGLING = 191\n    PHASESHIFT_PHASESHIFT = 193\n    RALLY_BUILDING = 195\n    RALLY_MORPHING_UNIT = 199\n    RALLY_COMMANDCENTER = 203\n    RALLY_NEXUS = 207\n    RALLY_HATCHERY_UNITS = 211\n    RALLY_HATCHERY_WORKERS = 212\n    RESEARCH_GLIALREGENERATION = 216\n    RESEARCH_TUNNELINGCLAWS = 217\n    ROACHWARRENRESEARCH_ROACHSUPPLY = 218\n    SAPSTRUCTURE_SAPSTRUCTURE = 245\n    INFESTEDTERRANS_INFESTEDTERRANS = 247\n    NEURALPARASITE_NEURALPARASITE = 249\n    CANCEL_NEURALPARASITE = 250\n    EFFECT_INJECTLARVA = 251\n    EFFECT_STIM_MARAUDER = 253\n    SUPPLYDROP_SUPPLYDROP = 255\n    _250MMSTRIKECANNONS_250MMSTRIKECANNONS = 257\n    _250MMSTRIKECANNONS_CANCEL = 258\n    TEMPORALRIFT_TEMPORALRIFT = 259\n    EFFECT_CHRONOBOOST = 261\n    RESEARCH_ANABOLICSYNTHESIS = 263\n    RESEARCH_CHITINOUSPLATING = 265\n    WORMHOLETRANSIT_WORMHOLETRANSIT = 293\n    HARVEST_GATHER_SCV = 295\n    HARVEST_RETURN_SCV = 296\n    HARVEST_GATHER_PROBE = 298\n    HARVEST_RETURN_PROBE = 299\n    ATTACKWARPPRISM_ATTACKWARPPRISM = 301\n    ATTACKWARPPRISM_ATTACKTOWARDS = 302\n    ATTACKWARPPRISM_ATTACKBARRAGE = 303\n    CANCEL_QUEUE1 = 304\n    CANCELSLOT_QUEUE1 = 305\n    CANCEL_QUEUE5 = 306\n    CANCELSLOT_QUEUE5 = 307\n    CANCEL_QUEUECANCELTOSELECTION = 308\n    CANCELSLOT_QUEUECANCELTOSELECTION = 309\n    QUE5LONGBLEND_CANCEL = 310\n    QUE5LONGBLEND_CANCELSLOT = 311\n    CANCEL_QUEUEADDON = 312\n    CANCELSLOT_ADDON = 313\n    CANCEL_BUILDINPROGRESS = 314\n    HALT_BUILDING = 315\n    EFFECT_REPAIR_SCV = 316\n    TERRANBUILD_COMMANDCENTER = 318\n    TERRANBUILD_SUPPLYDEPOT = 319\n    TERRANBUILD_REFINERY = 320\n    TERRANBUILD_BARRACKS = 321\n    TERRANBUILD_ENGINEERINGBAY = 322\n    TERRANBUILD_MISSILETURRET = 323\n    TERRANBUILD_BUNKER = 324\n    TERRANBUILD_SENSORTOWER = 326\n    TERRANBUILD_GHOSTACADEMY = 327\n    TERRANBUILD_FACTORY = 328\n    TERRANBUILD_STARPORT = 329\n    TERRANBUILD_ARMORY = 331\n    TERRANBUILD_FUSIONCORE = 333\n    HALT_TERRANBUILD = 348\n    RAVENBUILD_AUTOTURRET = 349\n    RAVENBUILD_CANCEL = 379\n    EFFECT_STIM_MARINE = 380\n    BEHAVIOR_CLOAKON_GHOST = 382\n    BEHAVIOR_CLOAKOFF_GHOST = 383\n    SNIPE_SNIPE = 384\n    MEDIVACHEAL_HEAL = 386\n    SIEGEMODE_SIEGEMODE = 388\n    UNSIEGE_UNSIEGE = 390\n    BEHAVIOR_CLOAKON_BANSHEE = 392\n    BEHAVIOR_CLOAKOFF_BANSHEE = 393\n    LOAD_MEDIVAC = 394\n    UNLOADALLAT_MEDIVAC = 396\n    UNLOADUNIT_MEDIVAC = 397\n    SCANNERSWEEP_SCAN = 399\n    YAMATO_YAMATOGUN = 401\n    MORPH_VIKINGASSAULTMODE = 403\n    MORPH_VIKINGFIGHTERMODE = 405\n    LOAD_BUNKER = 407\n    UNLOADALL_BUNKER = 408\n    UNLOADUNIT_BUNKER = 410\n    UNLOADALL_COMMANDCENTER = 413\n    UNLOADUNIT_COMMANDCENTER = 415\n    LOADALL_COMMANDCENTER = 416\n    LIFT_COMMANDCENTER = 417\n    LAND_COMMANDCENTER = 419\n    BUILD_TECHLAB_BARRACKS = 421\n    BUILD_REACTOR_BARRACKS = 422\n    CANCEL_BARRACKSADDON = 451\n    LIFT_BARRACKS = 452\n    BUILD_TECHLAB_FACTORY = 454\n    BUILD_REACTOR_FACTORY = 455\n    CANCEL_FACTORYADDON = 484\n    LIFT_FACTORY = 485\n    BUILD_TECHLAB_STARPORT = 487\n    BUILD_REACTOR_STARPORT = 488\n    CANCEL_STARPORTADDON = 517\n    LIFT_STARPORT = 518\n    LAND_FACTORY = 520\n    LAND_STARPORT = 522\n    COMMANDCENTERTRAIN_SCV = 524\n    LAND_BARRACKS = 554\n    MORPH_SUPPLYDEPOT_LOWER = 556\n    MORPH_SUPPLYDEPOT_RAISE = 558\n    BARRACKSTRAIN_MARINE = 560\n    BARRACKSTRAIN_REAPER = 561\n    BARRACKSTRAIN_GHOST = 562\n    BARRACKSTRAIN_MARAUDER = 563\n    FACTORYTRAIN_SIEGETANK = 591\n    FACTORYTRAIN_THOR = 594\n    FACTORYTRAIN_HELLION = 595\n    TRAIN_HELLBAT = 596\n    TRAIN_CYCLONE = 597\n    FACTORYTRAIN_WIDOWMINE = 614\n    STARPORTTRAIN_MEDIVAC = 620\n    STARPORTTRAIN_BANSHEE = 621\n    STARPORTTRAIN_RAVEN = 622\n    STARPORTTRAIN_BATTLECRUISER = 623\n    STARPORTTRAIN_VIKINGFIGHTER = 624\n    STARPORTTRAIN_LIBERATOR = 626\n    RESEARCH_HISECAUTOTRACKING = 650\n    RESEARCH_TERRANSTRUCTUREARMORUPGRADE = 651\n    ENGINEERINGBAYRESEARCH_TERRANINFANTRYWEAPONSLEVEL1 = 652\n    ENGINEERINGBAYRESEARCH_TERRANINFANTRYWEAPONSLEVEL2 = 653\n    ENGINEERINGBAYRESEARCH_TERRANINFANTRYWEAPONSLEVEL3 = 654\n    RESEARCH_NEOSTEELFRAME = 655\n    ENGINEERINGBAYRESEARCH_TERRANINFANTRYARMORLEVEL1 = 656\n    ENGINEERINGBAYRESEARCH_TERRANINFANTRYARMORLEVEL2 = 657\n    ENGINEERINGBAYRESEARCH_TERRANINFANTRYARMORLEVEL3 = 658\n    MERCCOMPOUNDRESEARCH_REAPERSPEED = 683\n    BUILD_NUKE = 710\n    BARRACKSTECHLABRESEARCH_STIMPACK = 730\n    RESEARCH_COMBATSHIELD = 731\n    RESEARCH_CONCUSSIVESHELLS = 732\n    RESEARCH_INFERNALPREIGNITER = 761\n    FACTORYTECHLABRESEARCH_RESEARCHTRANSFORMATIONSERVOS = 763\n    RESEARCH_DRILLINGCLAWS = 764\n    FACTORYTECHLABRESEARCH_RESEARCHLOCKONRANGEUPGRADE = 765\n    RESEARCH_SMARTSERVOS = 766\n    FACTORYTECHLABRESEARCH_RESEARCHARMORPIERCINGROCKETS = 767\n    RESEARCH_CYCLONERAPIDFIRELAUNCHERS = 768\n    RESEARCH_CYCLONELOCKONDAMAGE = 769\n    RESEARCH_BANSHEECLOAKINGFIELD = 790\n    STARPORTTECHLABRESEARCH_RESEARCHMEDIVACENERGYUPGRADE = 792\n    RESEARCH_RAVENCORVIDREACTOR = 793\n    STARPORTTECHLABRESEARCH_RESEARCHSEEKERMISSILE = 796\n    STARPORTTECHLABRESEARCH_RESEARCHDURABLEMATERIALS = 797\n    RESEARCH_BANSHEEHYPERFLIGHTROTORS = 799\n    STARPORTTECHLABRESEARCH_RESEARCHLIBERATORAGMODE = 800\n    STARPORTTECHLABRESEARCH_RESEARCHRAPIDDEPLOYMENT = 802\n    RESEARCH_RAVENRECALIBRATEDEXPLOSIVES = 803\n    RESEARCH_HIGHCAPACITYFUELTANKS = 804\n    RESEARCH_ADVANCEDBALLISTICS = 805\n    STARPORTTECHLABRESEARCH_RAVENRESEARCHENHANCEDMUNITIONS = 806\n    RESEARCH_PERSONALCLOAKING = 820\n    GHOSTACADEMYRESEARCH_RESEARCHGHOSTENERGYUPGRADE = 821\n    GHOSTACADEMYRESEARCH_RESEARCHENHANCEDSHOCKWAVES = 822\n    ARMORYRESEARCH_TERRANVEHICLEPLATINGLEVEL1 = 852\n    ARMORYRESEARCH_TERRANVEHICLEPLATINGLEVEL2 = 853\n    ARMORYRESEARCH_TERRANVEHICLEPLATINGLEVEL3 = 854\n    ARMORYRESEARCH_TERRANVEHICLEWEAPONSLEVEL1 = 855\n    ARMORYRESEARCH_TERRANVEHICLEWEAPONSLEVEL2 = 856\n    ARMORYRESEARCH_TERRANVEHICLEWEAPONSLEVEL3 = 857\n    ARMORYRESEARCH_TERRANSHIPPLATINGLEVEL1 = 858\n    ARMORYRESEARCH_TERRANSHIPPLATINGLEVEL2 = 859\n    ARMORYRESEARCH_TERRANSHIPPLATINGLEVEL3 = 860\n    ARMORYRESEARCH_TERRANSHIPWEAPONSLEVEL1 = 861\n    ARMORYRESEARCH_TERRANSHIPWEAPONSLEVEL2 = 862\n    ARMORYRESEARCH_TERRANSHIPWEAPONSLEVEL3 = 863\n    ARMORYRESEARCH_TERRANVEHICLEANDSHIPPLATINGLEVEL1 = 864\n    ARMORYRESEARCH_TERRANVEHICLEANDSHIPPLATINGLEVEL2 = 865\n    ARMORYRESEARCH_TERRANVEHICLEANDSHIPPLATINGLEVEL3 = 866\n    PROTOSSBUILD_NEXUS = 880\n    PROTOSSBUILD_PYLON = 881\n    PROTOSSBUILD_ASSIMILATOR = 882\n    PROTOSSBUILD_GATEWAY = 883\n    PROTOSSBUILD_FORGE = 884\n    PROTOSSBUILD_FLEETBEACON = 885\n    PROTOSSBUILD_TWILIGHTCOUNCIL = 886\n    PROTOSSBUILD_PHOTONCANNON = 887\n    PROTOSSBUILD_STARGATE = 889\n    PROTOSSBUILD_TEMPLARARCHIVE = 890\n    PROTOSSBUILD_DARKSHRINE = 891\n    PROTOSSBUILD_ROBOTICSBAY = 892\n    PROTOSSBUILD_ROBOTICSFACILITY = 893\n    PROTOSSBUILD_CYBERNETICSCORE = 894\n    BUILD_SHIELDBATTERY = 895\n    PROTOSSBUILD_CANCEL = 910\n    LOAD_WARPPRISM = 911\n    UNLOADALL_WARPPRISM = 912\n    UNLOADALLAT_WARPPRISM = 913\n    UNLOADUNIT_WARPPRISM = 914\n    GATEWAYTRAIN_ZEALOT = 916\n    GATEWAYTRAIN_STALKER = 917\n    GATEWAYTRAIN_HIGHTEMPLAR = 919\n    GATEWAYTRAIN_DARKTEMPLAR = 920\n    GATEWAYTRAIN_SENTRY = 921\n    TRAIN_ADEPT = 922\n    STARGATETRAIN_PHOENIX = 946\n    STARGATETRAIN_CARRIER = 948\n    STARGATETRAIN_VOIDRAY = 950\n    STARGATETRAIN_ORACLE = 954\n    STARGATETRAIN_TEMPEST = 955\n    ROBOTICSFACILITYTRAIN_WARPPRISM = 976\n    ROBOTICSFACILITYTRAIN_OBSERVER = 977\n    ROBOTICSFACILITYTRAIN_COLOSSUS = 978\n    ROBOTICSFACILITYTRAIN_IMMORTAL = 979\n    TRAIN_DISRUPTOR = 994\n    NEXUSTRAIN_PROBE = 1006\n    PSISTORM_PSISTORM = 1036\n    CANCEL_HANGARQUEUE5 = 1038\n    CANCELSLOT_HANGARQUEUE5 = 1039\n    BROODLORDQUEUE2_CANCEL = 1040\n    BROODLORDQUEUE2_CANCELSLOT = 1041\n    BUILD_INTERCEPTORS = 1042\n    FORGERESEARCH_PROTOSSGROUNDWEAPONSLEVEL1 = 1062\n    FORGERESEARCH_PROTOSSGROUNDWEAPONSLEVEL2 = 1063\n    FORGERESEARCH_PROTOSSGROUNDWEAPONSLEVEL3 = 1064\n    FORGERESEARCH_PROTOSSGROUNDARMORLEVEL1 = 1065\n    FORGERESEARCH_PROTOSSGROUNDARMORLEVEL2 = 1066\n    FORGERESEARCH_PROTOSSGROUNDARMORLEVEL3 = 1067\n    FORGERESEARCH_PROTOSSSHIELDSLEVEL1 = 1068\n    FORGERESEARCH_PROTOSSSHIELDSLEVEL2 = 1069\n    FORGERESEARCH_PROTOSSSHIELDSLEVEL3 = 1070\n    RESEARCH_GRAVITICBOOSTER = 1093\n    RESEARCH_GRAVITICDRIVE = 1094\n    RESEARCH_EXTENDEDTHERMALLANCE = 1097\n    ROBOTICSBAYRESEARCH_RESEARCHIMMORTALREVIVE = 1099\n    RESEARCH_PSISTORM = 1126\n    ZERGBUILD_HATCHERY = 1152\n    ZERGBUILD_CREEPTUMOR = 1153\n    ZERGBUILD_EXTRACTOR = 1154\n    ZERGBUILD_SPAWNINGPOOL = 1155\n    ZERGBUILD_EVOLUTIONCHAMBER = 1156\n    ZERGBUILD_HYDRALISKDEN = 1157\n    ZERGBUILD_SPIRE = 1158\n    ZERGBUILD_ULTRALISKCAVERN = 1159\n    ZERGBUILD_INFESTATIONPIT = 1160\n    ZERGBUILD_NYDUSNETWORK = 1161\n    ZERGBUILD_BANELINGNEST = 1162\n    BUILD_LURKERDEN = 1163\n    ZERGBUILD_ROACHWARREN = 1165\n    ZERGBUILD_SPINECRAWLER = 1166\n    ZERGBUILD_SPORECRAWLER = 1167\n    ZERGBUILD_CANCEL = 1182\n    HARVEST_GATHER_DRONE = 1183\n    HARVEST_RETURN_DRONE = 1184\n    RESEARCH_ZERGMELEEWEAPONSLEVEL1 = 1186\n    RESEARCH_ZERGMELEEWEAPONSLEVEL2 = 1187\n    RESEARCH_ZERGMELEEWEAPONSLEVEL3 = 1188\n    RESEARCH_ZERGGROUNDARMORLEVEL1 = 1189\n    RESEARCH_ZERGGROUNDARMORLEVEL2 = 1190\n    RESEARCH_ZERGGROUNDARMORLEVEL3 = 1191\n    RESEARCH_ZERGMISSILEWEAPONSLEVEL1 = 1192\n    RESEARCH_ZERGMISSILEWEAPONSLEVEL2 = 1193\n    RESEARCH_ZERGMISSILEWEAPONSLEVEL3 = 1194\n    EVOLUTIONCHAMBERRESEARCH_EVOLVEPROPULSIVEPERISTALSIS = 1195\n    UPGRADETOLAIR_LAIR = 1216\n    CANCEL_MORPHLAIR = 1217\n    UPGRADETOHIVE_HIVE = 1218\n    CANCEL_MORPHHIVE = 1219\n    UPGRADETOGREATERSPIRE_GREATERSPIRE = 1220\n    CANCEL_MORPHGREATERSPIRE = 1221\n    RESEARCH_PNEUMATIZEDCARAPACE = 1223\n    LAIRRESEARCH_EVOLVEVENTRALSACKS = 1224\n    RESEARCH_BURROW = 1225\n    RESEARCH_ZERGLINGADRENALGLANDS = 1252\n    RESEARCH_ZERGLINGMETABOLICBOOST = 1253\n    RESEARCH_GROOVEDSPINES = 1282\n    RESEARCH_MUSCULARAUGMENTS = 1283\n    HYDRALISKDENRESEARCH_RESEARCHLURKERRANGE = 1286\n    RESEARCH_ZERGFLYERATTACKLEVEL1 = 1312\n    RESEARCH_ZERGFLYERATTACKLEVEL2 = 1313\n    RESEARCH_ZERGFLYERATTACKLEVEL3 = 1314\n    RESEARCH_ZERGFLYERARMORLEVEL1 = 1315\n    RESEARCH_ZERGFLYERARMORLEVEL2 = 1316\n    RESEARCH_ZERGFLYERARMORLEVEL3 = 1317\n    LARVATRAIN_DRONE = 1342\n    LARVATRAIN_ZERGLING = 1343\n    LARVATRAIN_OVERLORD = 1344\n    LARVATRAIN_HYDRALISK = 1345\n    LARVATRAIN_MUTALISK = 1346\n    LARVATRAIN_ULTRALISK = 1348\n    LARVATRAIN_ROACH = 1351\n    LARVATRAIN_INFESTOR = 1352\n    LARVATRAIN_CORRUPTOR = 1353\n    LARVATRAIN_VIPER = 1354\n    TRAIN_SWARMHOST = 1356\n    MORPHTOBROODLORD_BROODLORD = 1372\n    CANCEL_MORPHBROODLORD = 1373\n    BURROWDOWN_BANELING = 1374\n    BURROWBANELINGDOWN_CANCEL = 1375\n    BURROWUP_BANELING = 1376\n    BURROWDOWN_DRONE = 1378\n    BURROWDRONEDOWN_CANCEL = 1379\n    BURROWUP_DRONE = 1380\n    BURROWDOWN_HYDRALISK = 1382\n    BURROWHYDRALISKDOWN_CANCEL = 1383\n    BURROWUP_HYDRALISK = 1384\n    BURROWDOWN_ROACH = 1386\n    BURROWROACHDOWN_CANCEL = 1387\n    BURROWUP_ROACH = 1388\n    BURROWDOWN_ZERGLING = 1390\n    BURROWZERGLINGDOWN_CANCEL = 1391\n    BURROWUP_ZERGLING = 1392\n    BURROWDOWN_INFESTORTERRAN = 1394\n    BURROWUP_INFESTORTERRAN = 1396\n    REDSTONELAVACRITTERBURROW_BURROWDOWN = 1398\n    REDSTONELAVACRITTERINJUREDBURROW_BURROWDOWN = 1400\n    REDSTONELAVACRITTERUNBURROW_BURROWUP = 1402\n    REDSTONELAVACRITTERINJUREDUNBURROW_BURROWUP = 1404\n    LOAD_OVERLORD = 1406\n    UNLOADALLAT_OVERLORD = 1408\n    UNLOADUNIT_OVERLORD = 1409\n    MERGEABLE_CANCEL = 1411\n    WARPABLE_CANCEL = 1412\n    WARPGATETRAIN_ZEALOT = 1413\n    WARPGATETRAIN_STALKER = 1414\n    WARPGATETRAIN_HIGHTEMPLAR = 1416\n    WARPGATETRAIN_DARKTEMPLAR = 1417\n    WARPGATETRAIN_SENTRY = 1418\n    TRAINWARP_ADEPT = 1419\n    BURROWDOWN_QUEEN = 1433\n    BURROWQUEENDOWN_CANCEL = 1434\n    BURROWUP_QUEEN = 1435\n    LOAD_NYDUSNETWORK = 1437\n    UNLOADALL_NYDASNETWORK = 1438\n    UNLOADUNIT_NYDASNETWORK = 1440\n    EFFECT_BLINK_STALKER = 1442\n    BURROWDOWN_INFESTOR = 1444\n    BURROWINFESTORDOWN_CANCEL = 1445\n    BURROWUP_INFESTOR = 1446\n    MORPH_OVERSEER = 1448\n    CANCEL_MORPHOVERSEER = 1449\n    UPGRADETOPLANETARYFORTRESS_PLANETARYFORTRESS = 1450\n    CANCEL_MORPHPLANETARYFORTRESS = 1451\n    RESEARCH_PATHOGENGLANDS = 1454\n    RESEARCH_NEURALPARASITE = 1455\n    INFESTATIONPITRESEARCH_RESEARCHLOCUSTLIFETIMEINCREASE = 1456\n    INFESTATIONPITRESEARCH_EVOLVEAMORPHOUSARMORCLOUD = 1457\n    RESEARCH_CENTRIFUGALHOOKS = 1482\n    BURROWDOWN_ULTRALISK = 1512\n    BURROWUP_ULTRALISK = 1514\n    UPGRADETOORBITAL_ORBITALCOMMAND = 1516\n    CANCEL_MORPHORBITAL = 1517\n    MORPH_WARPGATE = 1518\n    UPGRADETOWARPGATE_CANCEL = 1519\n    MORPH_GATEWAY = 1520\n    MORPHBACKTOGATEWAY_CANCEL = 1521\n    LIFT_ORBITALCOMMAND = 1522\n    LAND_ORBITALCOMMAND = 1524\n    FORCEFIELD_FORCEFIELD = 1526\n    FORCEFIELD_CANCEL = 1527\n    MORPH_WARPPRISMPHASINGMODE = 1528\n    PHASINGMODE_CANCEL = 1529\n    MORPH_WARPPRISMTRANSPORTMODE = 1530\n    TRANSPORTMODE_CANCEL = 1531\n    RESEARCH_BATTLECRUISERWEAPONREFIT = 1532\n    FUSIONCORERESEARCH_RESEARCHBALLISTICRANGE = 1533\n    FUSIONCORERESEARCH_RESEARCHRAPIDREIGNITIONSYSTEM = 1534\n    CYBERNETICSCORERESEARCH_PROTOSSAIRWEAPONSLEVEL1 = 1562\n    CYBERNETICSCORERESEARCH_PROTOSSAIRWEAPONSLEVEL2 = 1563\n    CYBERNETICSCORERESEARCH_PROTOSSAIRWEAPONSLEVEL3 = 1564\n    CYBERNETICSCORERESEARCH_PROTOSSAIRARMORLEVEL1 = 1565\n    CYBERNETICSCORERESEARCH_PROTOSSAIRARMORLEVEL2 = 1566\n    CYBERNETICSCORERESEARCH_PROTOSSAIRARMORLEVEL3 = 1567\n    RESEARCH_WARPGATE = 1568\n    CYBERNETICSCORERESEARCH_RESEARCHHALLUCINATION = 1571\n    RESEARCH_CHARGE = 1592\n    RESEARCH_BLINK = 1593\n    RESEARCH_ADEPTRESONATINGGLAIVES = 1594\n    TWILIGHTCOUNCILRESEARCH_RESEARCHPSIONICSURGE = 1595\n    TWILIGHTCOUNCILRESEARCH_RESEARCHAMPLIFIEDSHIELDING = 1596\n    TWILIGHTCOUNCILRESEARCH_RESEARCHPSIONICAMPLIFIERS = 1597\n    TACNUKESTRIKE_NUKECALLDOWN = 1622\n    CANCEL_NUKE = 1623\n    SALVAGEBUNKERREFUND_SALVAGE = 1624\n    SALVAGEBUNKER_SALVAGE = 1626\n    EMP_EMP = 1628\n    VORTEX_VORTEX = 1630\n    TRAINQUEEN_QUEEN = 1632\n    BURROWCREEPTUMORDOWN_BURROWDOWN = 1662\n    TRANSFUSION_TRANSFUSION = 1664\n    BARRACKSTECHLABMORPH_TECHLABBARRACKS = 1668\n    FACTORYTECHLABMORPH_TECHLABFACTORY = 1670\n    STARPORTTECHLABMORPH_TECHLABSTARPORT = 1672\n    BARRACKSREACTORMORPH_REACTOR = 1676\n    FACTORYREACTORMORPH_REACTOR = 1678\n    STARPORTREACTORMORPH_REACTOR = 1680\n    ATTACK_REDIRECT = 1682\n    EFFECT_STIM_MARINE_REDIRECT = 1683\n    EFFECT_STIM_MARAUDER_REDIRECT = 1684\n    BURROWEDSTOP_STOPROACHBURROWED = 1685\n    BURROWEDSTOP_HOLDFIRESPECIAL = 1686\n    STOP_REDIRECT = 1691\n    BEHAVIOR_GENERATECREEPON = 1692\n    BEHAVIOR_GENERATECREEPOFF = 1693\n    BUILD_CREEPTUMOR_QUEEN = 1694\n    QUEENBUILD_CANCEL = 1724\n    SPINECRAWLERUPROOT_SPINECRAWLERUPROOT = 1725\n    SPINECRAWLERUPROOT_CANCEL = 1726\n    SPORECRAWLERUPROOT_SPORECRAWLERUPROOT = 1727\n    SPORECRAWLERUPROOT_CANCEL = 1728\n    SPINECRAWLERROOT_SPINECRAWLERROOT = 1729\n    CANCEL_SPINECRAWLERROOT = 1730\n    SPORECRAWLERROOT_SPORECRAWLERROOT = 1731\n    CANCEL_SPORECRAWLERROOT = 1732\n    BUILD_CREEPTUMOR_TUMOR = 1733\n    CANCEL_CREEPTUMOR = 1763\n    BUILDAUTOTURRET_AUTOTURRET = 1764\n    MORPH_ARCHON = 1766\n    ARCHON_WARP_TARGET = 1767\n    BUILD_NYDUSWORM = 1768\n    BUILDNYDUSCANAL_SUMMONNYDUSCANALATTACKER = 1769\n    BUILDNYDUSCANAL_CANCEL = 1798\n    EFFECT_CHARGE = 1819\n    HERDINTERACT_HERD = 1821\n    FRENZY_FRENZY = 1823\n    CONTAMINATE_CONTAMINATE = 1825\n    INFESTEDTERRANSLAYEGG_INFESTEDTERRANS = 1829\n    CANCEL_QUEUEPASIVE = 1831\n    CANCELSLOT_QUEUEPASSIVE = 1832\n    CANCEL_QUEUEPASSIVECANCELTOSELECTION = 1833\n    CANCELSLOT_QUEUEPASSIVECANCELTOSELECTION = 1834\n    MORPHTOGHOSTALTERNATE_MOVE = 1835\n    MORPHTOGHOSTNOVA_MOVE = 1837\n    DIGESTERCREEPSPRAY_DIGESTERCREEPSPRAY = 1839\n    MORPHTOCOLLAPSIBLETERRANTOWERDEBRIS_CANCEL = 1842\n    MORPHTOCOLLAPSIBLETERRANTOWERDEBRISRAMPLEFT_CANCEL = 1844\n    MORPHTOCOLLAPSIBLETERRANTOWERDEBRISRAMPRIGHT_CANCEL = 1846\n    MORPH_MOTHERSHIP = 1847\n    CANCEL_MORPHMOTHERSHIP = 1848\n    MOTHERSHIPSTASIS_MOTHERSHIPSTASIS = 1849\n    CANCEL_MOTHERSHIPSTASIS = 1850\n    MOTHERSHIPCOREWEAPON_MOTHERSHIPSTASIS = 1851\n    NEXUSTRAINMOTHERSHIPCORE_MOTHERSHIPCORE = 1853\n    MOTHERSHIPCORETELEPORT_MOTHERSHIPCORETELEPORT = 1883\n    SALVAGEDRONEREFUND_SALVAGE = 1885\n    SALVAGEDRONE_SALVAGE = 1887\n    SALVAGEZERGLINGREFUND_SALVAGE = 1889\n    SALVAGEZERGLING_SALVAGE = 1891\n    SALVAGEQUEENREFUND_SALVAGE = 1893\n    SALVAGEQUEEN_SALVAGE = 1895\n    SALVAGEROACHREFUND_SALVAGE = 1897\n    SALVAGEROACH_SALVAGE = 1899\n    SALVAGEBANELINGREFUND_SALVAGE = 1901\n    SALVAGEBANELING_SALVAGE = 1903\n    SALVAGEHYDRALISKREFUND_SALVAGE = 1905\n    SALVAGEHYDRALISK_SALVAGE = 1907\n    SALVAGEINFESTORREFUND_SALVAGE = 1909\n    SALVAGEINFESTOR_SALVAGE = 1911\n    SALVAGESWARMHOSTREFUND_SALVAGE = 1913\n    SALVAGESWARMHOST_SALVAGE = 1915\n    SALVAGEULTRALISKREFUND_SALVAGE = 1917\n    SALVAGEULTRALISK_SALVAGE = 1919\n    DIGESTERTRANSPORT_LOADDIGESTER = 1921\n    SPECTRESHIELD_SPECTRESHIELD = 1926\n    XELNAGAHEALINGSHRINE_XELNAGAHEALINGSHRINE = 1928\n    NEXUSINVULNERABILITY_NEXUSINVULNERABILITY = 1930\n    NEXUSPHASESHIFT_NEXUSPHASESHIFT = 1932\n    SPAWNCHANGELINGTARGET_SPAWNCHANGELING = 1934\n    QUEENLAND_QUEENLAND = 1936\n    QUEENFLY_QUEENFLY = 1938\n    ORACLECLOAKFIELD_ORACLECLOAKFIELD = 1940\n    FLYERSHIELD_FLYERSHIELD = 1942\n    LOCUSTTRAIN_SWARMHOST = 1944\n    EFFECT_MASSRECALL_MOTHERSHIPCORE = 1974\n    SINGLERECALL_SINGLERECALL = 1976\n    MORPH_HELLION = 1978\n    RESTORESHIELDS_RESTORESHIELDS = 1980\n    SCRYER_SCRYER = 1982\n    LEECHRESOURCES_CANCEL = 1987\n    SNIPEDOT_SNIPEDOT = 1988\n    SWARMHOSTSPAWNLOCUSTS_LOCUSTMP = 1990\n    CLONE_CLONE = 1992\n    BUILDINGSHIELD_BUILDINGSHIELD = 1994\n    MORPHTOCOLLAPSIBLEROCKTOWERDEBRIS_CANCEL = 1997\n    MORPH_HELLBAT = 1998\n    BUILDINGSTASIS_BUILDINGSTASIS = 2000\n    MAXIUMTHRUST_MAXIMUMTHRUST = 2006\n    BURROWDOWN_SWARMHOST = 2014\n    MORPHTOSWARMHOSTBURROWEDMP_CANCEL = 2015\n    BURROWUP_SWARMHOST = 2016\n    SPAWNINFESTEDTERRAN_LOCUSTMP = 2018\n    ATTACKPROTOSSBUILDING_ATTACKBUILDING = 2048\n    ATTACKPROTOSSBUILDING_ATTACKTOWARDS = 2049\n    ATTACKPROTOSSBUILDING_ATTACKBARRAGE = 2050\n    BURROWEDBANELINGSTOP_STOPROACHBURROWED = 2051\n    BURROWEDBANELINGSTOP_HOLDFIRESPECIAL = 2052\n    STOP_BUILDING = 2057\n    STOPPROTOSSBUILDING_HOLDFIRE = 2058\n    STOPPROTOSSBUILDING_CHEER = 2059\n    STOPPROTOSSBUILDING_DANCE = 2060\n    BLINDINGCLOUD_BLINDINGCLOUD = 2063\n    EYESTALK_EYESTALK = 2065\n    EYESTALK_CANCEL = 2066\n    EFFECT_ABDUCT = 2067\n    VIPERCONSUME_VIPERCONSUME = 2069\n    VIPERCONSUMEMINERALS_VIPERCONSUME = 2071\n    VIPERCONSUMESTRUCTURE_VIPERCONSUME = 2073\n    CANCEL_PROTOSSBUILDINGQUEUE = 2075\n    PROTOSSBUILDINGQUEUE_CANCELSLOT = 2076\n    QUE8_CANCEL = 2077\n    QUE8_CANCELSLOT = 2078\n    TESTZERG_CANCEL = 2080\n    BEHAVIOR_BUILDINGATTACKON = 2081\n    BEHAVIOR_BUILDINGATTACKOFF = 2082\n    PICKUPSCRAPSMALL_PICKUPSCRAPSMALL = 2083\n    PICKUPSCRAPMEDIUM_PICKUPSCRAPMEDIUM = 2085\n    PICKUPSCRAPLARGE_PICKUPSCRAPLARGE = 2087\n    PICKUPPALLETGAS_PICKUPPALLETGAS = 2089\n    PICKUPPALLETMINERALS_PICKUPPALLETMINERALS = 2091\n    MASSIVEKNOCKOVER_MASSIVEKNOCKOVER = 2093\n    BURROWDOWN_WIDOWMINE = 2095\n    WIDOWMINEBURROW_CANCEL = 2096\n    BURROWUP_WIDOWMINE = 2097\n    WIDOWMINEATTACK_WIDOWMINEATTACK = 2099\n    TORNADOMISSILE_TORNADOMISSILE = 2101\n    MOTHERSHIPCOREENERGIZE_MOTHERSHIPCOREENERGIZE = 2102\n    MOTHERSHIPCOREENERGIZE_CANCEL = 2103\n    LURKERASPECTMPFROMHYDRALISKBURROWED_LURKERMPFROMHYDRALISKBURROWED = 2104\n    LURKERASPECTMPFROMHYDRALISKBURROWED_CANCEL = 2105\n    LURKERASPECTMP_LURKERMP = 2106\n    LURKERASPECTMP_CANCEL = 2107\n    BURROWDOWN_LURKER = 2108\n    BURROWLURKERMPDOWN_CANCEL = 2109\n    BURROWUP_LURKER = 2110\n    MORPH_LURKERDEN = 2112\n    CANCEL_MORPHLURKERDEN = 2113\n    HALLUCINATION_ORACLE = 2114\n    EFFECT_MEDIVACIGNITEAFTERBURNERS = 2116\n    EXTENDINGBRIDGENEWIDE8OUT_BRIDGEEXTEND = 2118\n    EXTENDINGBRIDGENEWIDE8_BRIDGERETRACT = 2120\n    EXTENDINGBRIDGENWWIDE8OUT_BRIDGEEXTEND = 2122\n    EXTENDINGBRIDGENWWIDE8_BRIDGERETRACT = 2124\n    EXTENDINGBRIDGENEWIDE10OUT_BRIDGEEXTEND = 2126\n    EXTENDINGBRIDGENEWIDE10_BRIDGERETRACT = 2128\n    EXTENDINGBRIDGENWWIDE10OUT_BRIDGEEXTEND = 2130\n    EXTENDINGBRIDGENWWIDE10_BRIDGERETRACT = 2132\n    EXTENDINGBRIDGENEWIDE12OUT_BRIDGEEXTEND = 2134\n    EXTENDINGBRIDGENEWIDE12_BRIDGERETRACT = 2136\n    EXTENDINGBRIDGENWWIDE12OUT_BRIDGEEXTEND = 2138\n    EXTENDINGBRIDGENWWIDE12_BRIDGERETRACT = 2140\n    INVULNERABILITYSHIELD_INVULNERABILITYSHIELD = 2142\n    CRITTERFLEE_CRITTERFLEE = 2144\n    ORACLEREVELATION_ORACLEREVELATION = 2146\n    ORACLEREVELATIONMODE_ORACLEREVELATIONMODE = 2148\n    ORACLEREVELATIONMODE_CANCEL = 2149\n    ORACLENORMALMODE_ORACLENORMALMODE = 2150\n    ORACLENORMALMODE_CANCEL = 2151\n    MORPHTOCOLLAPSIBLEROCKTOWERDEBRISRAMPRIGHT_CANCEL = 2153\n    MORPHTOCOLLAPSIBLEROCKTOWERDEBRISRAMPLEFT_CANCEL = 2155\n    VOIDSIPHON_VOIDSIPHON = 2156\n    ULTRALISKWEAPONCOOLDOWN_ULTRALISKWEAPONCOOLDOWN = 2158\n    MOTHERSHIPCOREPURIFYNEXUSCANCEL_CANCEL = 2160\n    EFFECT_PHOTONOVERCHARGE = 2162\n    XELNAGA_CAVERNS_DOORE_XELNAGA_CAVERNS_DOORDEFAULTCLOSE = 2164\n    XELNAGA_CAVERNS_DOOREOPENED_XELNAGA_CAVERNS_DOORDEFAULTCLOSE = 2166\n    XELNAGA_CAVERNS_DOORN_XELNAGA_CAVERNS_DOORDEFAULTCLOSE = 2168\n    XELNAGA_CAVERNS_DOORNE_XELNAGA_CAVERNS_DOORDEFAULTCLOSE = 2170\n    XELNAGA_CAVERNS_DOORNEOPENED_XELNAGA_CAVERNS_DOORDEFAULTOPEN = 2172\n    XELNAGA_CAVERNS_DOORNOPENED_XELNAGA_CAVERNS_DOORDEFAULTOPEN = 2174\n    XELNAGA_CAVERNS_DOORNW_XELNAGA_CAVERNS_DOORDEFAULTCLOSE = 2176\n    XELNAGA_CAVERNS_DOORNWOPENED_XELNAGA_CAVERNS_DOORDEFAULTOPEN = 2178\n    XELNAGA_CAVERNS_DOORS_XELNAGA_CAVERNS_DOORDEFAULTCLOSE = 2180\n    XELNAGA_CAVERNS_DOORSE_XELNAGA_CAVERNS_DOORDEFAULTCLOSE = 2182\n    XELNAGA_CAVERNS_DOORSEOPENED_XELNAGA_CAVERNS_DOORDEFAULTOPEN = 2184\n    XELNAGA_CAVERNS_DOORSOPENED_XELNAGA_CAVERNS_DOORDEFAULTOPEN = 2186\n    XELNAGA_CAVERNS_DOORSW_XELNAGA_CAVERNS_DOORDEFAULTCLOSE = 2188\n    XELNAGA_CAVERNS_DOORSWOPENED_XELNAGA_CAVERNS_DOORDEFAULTOPEN = 2190\n    XELNAGA_CAVERNS_DOORW_XELNAGA_CAVERNS_DOORDEFAULTCLOSE = 2192\n    XELNAGA_CAVERNS_DOORWOPENED_XELNAGA_CAVERNS_DOORDEFAULTOPEN = 2194\n    XELNAGA_CAVERNS_FLOATING_BRIDGENE8OUT_BRIDGEEXTEND = 2196\n    XELNAGA_CAVERNS_FLOATING_BRIDGENE8_BRIDGERETRACT = 2198\n    XELNAGA_CAVERNS_FLOATING_BRIDGENW8OUT_BRIDGEEXTEND = 2200\n    XELNAGA_CAVERNS_FLOATING_BRIDGENW8_BRIDGERETRACT = 2202\n    XELNAGA_CAVERNS_FLOATING_BRIDGENE10OUT_BRIDGEEXTEND = 2204\n    XELNAGA_CAVERNS_FLOATING_BRIDGENE10_BRIDGERETRACT = 2206\n    XELNAGA_CAVERNS_FLOATING_BRIDGENW10OUT_BRIDGEEXTEND = 2208\n    XELNAGA_CAVERNS_FLOATING_BRIDGENW10_BRIDGERETRACT = 2210\n    XELNAGA_CAVERNS_FLOATING_BRIDGENE12OUT_BRIDGEEXTEND = 2212\n    XELNAGA_CAVERNS_FLOATING_BRIDGENE12_BRIDGERETRACT = 2214\n    XELNAGA_CAVERNS_FLOATING_BRIDGENW12OUT_BRIDGEEXTEND = 2216\n    XELNAGA_CAVERNS_FLOATING_BRIDGENW12_BRIDGERETRACT = 2218\n    XELNAGA_CAVERNS_FLOATING_BRIDGEH8OUT_BRIDGEEXTEND = 2220\n    XELNAGA_CAVERNS_FLOATING_BRIDGEH8_BRIDGERETRACT = 2222\n    XELNAGA_CAVERNS_FLOATING_BRIDGEV8OUT_BRIDGEEXTEND = 2224\n    XELNAGA_CAVERNS_FLOATING_BRIDGEV8_BRIDGERETRACT = 2226\n    XELNAGA_CAVERNS_FLOATING_BRIDGEH10OUT_BRIDGEEXTEND = 2228\n    XELNAGA_CAVERNS_FLOATING_BRIDGEH10_BRIDGERETRACT = 2230\n    XELNAGA_CAVERNS_FLOATING_BRIDGEV10OUT_BRIDGEEXTEND = 2232\n    XELNAGA_CAVERNS_FLOATING_BRIDGEV10_BRIDGERETRACT = 2234\n    XELNAGA_CAVERNS_FLOATING_BRIDGEH12OUT_BRIDGEEXTEND = 2236\n    XELNAGA_CAVERNS_FLOATING_BRIDGEH12_BRIDGERETRACT = 2238\n    XELNAGA_CAVERNS_FLOATING_BRIDGEV12OUT_BRIDGEEXTEND = 2240\n    XELNAGA_CAVERNS_FLOATING_BRIDGEV12_BRIDGERETRACT = 2242\n    EFFECT_TIMEWARP = 2244\n    SNOWREFINERY_TERRAN_EXTENDINGBRIDGENESHORT8OUT_BRIDGEEXTEND = 2246\n    SNOWREFINERY_TERRAN_EXTENDINGBRIDGENESHORT8_BRIDGERETRACT = 2248\n    SNOWREFINERY_TERRAN_EXTENDINGBRIDGENWSHORT8OUT_BRIDGEEXTEND = 2250\n    SNOWREFINERY_TERRAN_EXTENDINGBRIDGENWSHORT8_BRIDGERETRACT = 2252\n    SNOWREFINERY_TERRAN_EXTENDINGBRIDGENESHORT10OUT_BRIDGEEXTEND = 2254\n    SNOWREFINERY_TERRAN_EXTENDINGBRIDGENESHORT10_BRIDGERETRACT = 2256\n    SNOWREFINERY_TERRAN_EXTENDINGBRIDGENWSHORT10OUT_BRIDGEEXTEND = 2258\n    SNOWREFINERY_TERRAN_EXTENDINGBRIDGENWSHORT10_BRIDGERETRACT = 2260\n    ARMORYRESEARCHSWARM_TERRANVEHICLEANDSHIPWEAPONSLEVEL1 = 2294\n    ARMORYRESEARCHSWARM_TERRANVEHICLEANDSHIPWEAPONSLEVEL2 = 2295\n    ARMORYRESEARCHSWARM_TERRANVEHICLEANDSHIPWEAPONSLEVEL3 = 2296\n    ARMORYRESEARCHSWARM_TERRANVEHICLEANDSHIPPLATINGLEVEL1 = 2297\n    ARMORYRESEARCHSWARM_TERRANVEHICLEANDSHIPPLATINGLEVEL2 = 2298\n    ARMORYRESEARCHSWARM_TERRANVEHICLEANDSHIPPLATINGLEVEL3 = 2299\n    CAUSTICSPRAY_CAUSTICSPRAY = 2324\n    ORACLECLOAKINGFIELDTARGETED_ORACLECLOAKINGFIELDTARGETED = 2326\n    EFFECT_IMMORTALBARRIER = 2328\n    MORPHTORAVAGER_RAVAGER = 2330\n    CANCEL_MORPHRAVAGER = 2331\n    MORPH_LURKER = 2332\n    CANCEL_MORPHLURKER = 2333\n    ORACLEPHASESHIFT_ORACLEPHASESHIFT = 2334\n    RELEASEINTERCEPTORS_RELEASEINTERCEPTORS = 2336\n    EFFECT_CORROSIVEBILE = 2338\n    BURROWDOWN_RAVAGER = 2340\n    BURROWRAVAGERDOWN_CANCEL = 2341\n    BURROWUP_RAVAGER = 2342\n    PURIFICATIONNOVA_PURIFICATIONNOVA = 2344\n    EFFECT_PURIFICATIONNOVA = 2346\n    IMPALE_IMPALE = 2348\n    LOCKON_LOCKON = 2350\n    LOCKONAIR_LOCKONAIR = 2352\n    CANCEL_LOCKON = 2354\n    CORRUPTIONBOMB_CORRUPTIONBOMB = 2356\n    CORRUPTIONBOMB_CANCEL = 2357\n    EFFECT_TACTICALJUMP = 2358\n    OVERCHARGE_OVERCHARGE = 2360\n    MORPH_THORHIGHIMPACTMODE = 2362\n    THORAPMODE_CANCEL = 2363\n    MORPH_THOREXPLOSIVEMODE = 2364\n    CANCEL_MORPHTHOREXPLOSIVEMODE = 2365\n    LIGHTOFAIUR_LIGHTOFAIUR = 2366\n    EFFECT_MASSRECALL_MOTHERSHIP = 2368\n    LOAD_NYDUSWORM = 2370\n    UNLOADALL_NYDUSWORM = 2371\n    BEHAVIOR_PULSARBEAMON = 2375\n    BEHAVIOR_PULSARBEAMOFF = 2376\n    PULSARBEAM_RIPFIELD = 2377\n    PULSARCANNON_PULSARCANNON = 2379\n    VOIDSWARMHOSTSPAWNLOCUST_VOIDSWARMHOSTSPAWNLOCUST = 2381\n    LOCUSTMPFLYINGMORPHTOGROUND_LOCUSTMPFLYINGSWOOP = 2383\n    LOCUSTMPMORPHTOAIR_LOCUSTMPFLYINGSWOOP = 2385\n    EFFECT_LOCUSTSWOOP = 2387\n    HALLUCINATION_DISRUPTOR = 2389\n    HALLUCINATION_ADEPT = 2391\n    EFFECT_VOIDRAYPRISMATICALIGNMENT = 2393\n    AIURLIGHTBRIDGENE8OUT_BRIDGEEXTEND = 2397\n    AIURLIGHTBRIDGENE8_BRIDGERETRACT = 2399\n    AIURLIGHTBRIDGENE10OUT_BRIDGEEXTEND = 2401\n    AIURLIGHTBRIDGENE10_BRIDGERETRACT = 2403\n    AIURLIGHTBRIDGENE12OUT_BRIDGEEXTEND = 2405\n    AIURLIGHTBRIDGENE12_BRIDGERETRACT = 2407\n    AIURLIGHTBRIDGENW8OUT_BRIDGEEXTEND = 2409\n    AIURLIGHTBRIDGENW8_BRIDGERETRACT = 2411\n    AIURLIGHTBRIDGENW10OUT_BRIDGEEXTEND = 2413\n    AIURLIGHTBRIDGENW10_BRIDGERETRACT = 2415\n    AIURLIGHTBRIDGENW12OUT_BRIDGEEXTEND = 2417\n    AIURLIGHTBRIDGENW12_BRIDGERETRACT = 2419\n    AIURTEMPLEBRIDGENE8OUT_BRIDGEEXTEND = 2421\n    AIURTEMPLEBRIDGENE8_BRIDGERETRACT = 2423\n    AIURTEMPLEBRIDGENE10OUT_BRIDGEEXTEND = 2425\n    AIURTEMPLEBRIDGENE10_BRIDGERETRACT = 2427\n    AIURTEMPLEBRIDGENE12OUT_BRIDGEEXTEND = 2429\n    AIURTEMPLEBRIDGENE12_BRIDGERETRACT = 2431\n    AIURTEMPLEBRIDGENW8OUT_BRIDGEEXTEND = 2433\n    AIURTEMPLEBRIDGENW8_BRIDGERETRACT = 2435\n    AIURTEMPLEBRIDGENW10OUT_BRIDGEEXTEND = 2437\n    AIURTEMPLEBRIDGENW10_BRIDGERETRACT = 2439\n    AIURTEMPLEBRIDGENW12OUT_BRIDGEEXTEND = 2441\n    AIURTEMPLEBRIDGENW12_BRIDGERETRACT = 2443\n    SHAKURASLIGHTBRIDGENE8OUT_BRIDGEEXTEND = 2445\n    SHAKURASLIGHTBRIDGENE8_BRIDGERETRACT = 2447\n    SHAKURASLIGHTBRIDGENE10OUT_BRIDGEEXTEND = 2449\n    SHAKURASLIGHTBRIDGENE10_BRIDGERETRACT = 2451\n    SHAKURASLIGHTBRIDGENE12OUT_BRIDGEEXTEND = 2453\n    SHAKURASLIGHTBRIDGENE12_BRIDGERETRACT = 2455\n    SHAKURASLIGHTBRIDGENW8OUT_BRIDGEEXTEND = 2457\n    SHAKURASLIGHTBRIDGENW8_BRIDGERETRACT = 2459\n    SHAKURASLIGHTBRIDGENW10OUT_BRIDGEEXTEND = 2461\n    SHAKURASLIGHTBRIDGENW10_BRIDGERETRACT = 2463\n    SHAKURASLIGHTBRIDGENW12OUT_BRIDGEEXTEND = 2465\n    SHAKURASLIGHTBRIDGENW12_BRIDGERETRACT = 2467\n    VOIDMPIMMORTALREVIVEREBUILD_IMMORTAL = 2469\n    VOIDMPIMMORTALREVIVEDEATH_IMMORTAL = 2471\n    ARBITERMPSTASISFIELD_ARBITERMPSTASISFIELD = 2473\n    ARBITERMPRECALL_ARBITERMPRECALL = 2475\n    CORSAIRMPDISRUPTIONWEB_CORSAIRMPDISRUPTIONWEB = 2477\n    MORPHTOGUARDIANMP_MORPHTOGUARDIANMP = 2479\n    MORPHTOGUARDIANMP_CANCEL = 2480\n    MORPHTODEVOURERMP_MORPHTODEVOURERMP = 2481\n    MORPHTODEVOURERMP_CANCEL = 2482\n    DEFILERMPCONSUME_DEFILERMPCONSUME = 2483\n    DEFILERMPDARKSWARM_DEFILERMPDARKSWARM = 2485\n    DEFILERMPPLAGUE_DEFILERMPPLAGUE = 2487\n    DEFILERMPBURROW_BURROWDOWN = 2489\n    DEFILERMPBURROW_CANCEL = 2490\n    DEFILERMPUNBURROW_BURROWUP = 2491\n    QUEENMPENSNARE_QUEENMPENSNARE = 2493\n    QUEENMPSPAWNBROODLINGS_QUEENMPSPAWNBROODLINGS = 2495\n    QUEENMPINFESTCOMMANDCENTER_QUEENMPINFESTCOMMANDCENTER = 2497\n    LIGHTNINGBOMB_LIGHTNINGBOMB = 2499\n    GRAPPLE_GRAPPLE = 2501\n    ORACLESTASISTRAP_ORACLEBUILDSTASISTRAP = 2503\n    BUILD_STASISTRAP = 2505\n    CANCEL_STASISTRAP = 2535\n    ORACLESTASISTRAPACTIVATE_ACTIVATESTASISWARD = 2536\n    SELFREPAIR_SELFREPAIR = 2538\n    SELFREPAIR_CANCEL = 2539\n    AGGRESSIVEMUTATION_AGGRESSIVEMUTATION = 2540\n    PARASITICBOMB_PARASITICBOMB = 2542\n    ADEPTPHASESHIFT_ADEPTPHASESHIFT = 2544\n    PURIFICATIONNOVAMORPH_PURIFICATIONNOVA = 2546\n    PURIFICATIONNOVAMORPHBACK_PURIFICATIONNOVA = 2548\n    BEHAVIOR_HOLDFIREON_LURKER = 2550\n    BEHAVIOR_HOLDFIREOFF_LURKER = 2552\n    LIBERATORMORPHTOAG_LIBERATORAGMODE = 2554\n    LIBERATORMORPHTOAA_LIBERATORAAMODE = 2556\n    MORPH_LIBERATORAGMODE = 2558\n    MORPH_LIBERATORAAMODE = 2560\n    TIMESTOP_TIMESTOP = 2562\n    TIMESTOP_CANCEL = 2563\n    AIURLIGHTBRIDGEABANDONEDNE8OUT_BRIDGEEXTEND = 2564\n    AIURLIGHTBRIDGEABANDONEDNE8_BRIDGERETRACT = 2566\n    AIURLIGHTBRIDGEABANDONEDNE10OUT_BRIDGEEXTEND = 2568\n    AIURLIGHTBRIDGEABANDONEDNE10_BRIDGERETRACT = 2570\n    AIURLIGHTBRIDGEABANDONEDNE12OUT_BRIDGEEXTEND = 2572\n    AIURLIGHTBRIDGEABANDONEDNE12_BRIDGERETRACT = 2574\n    AIURLIGHTBRIDGEABANDONEDNW8OUT_BRIDGEEXTEND = 2576\n    AIURLIGHTBRIDGEABANDONEDNW8_BRIDGERETRACT = 2578\n    AIURLIGHTBRIDGEABANDONEDNW10OUT_BRIDGEEXTEND = 2580\n    AIURLIGHTBRIDGEABANDONEDNW10_BRIDGERETRACT = 2582\n    AIURLIGHTBRIDGEABANDONEDNW12OUT_BRIDGEEXTEND = 2584\n    AIURLIGHTBRIDGEABANDONEDNW12_BRIDGERETRACT = 2586\n    KD8CHARGE_KD8CHARGE = 2588\n    PENETRATINGSHOT_PENETRATINGSHOT = 2590\n    CLOAKINGDRONE_CLOAKINGDRONE = 2592\n    CANCEL_ADEPTPHASESHIFT = 2594\n    CANCEL_ADEPTSHADEPHASESHIFT = 2596\n    SLAYNELEMENTALGRAB_SLAYNELEMENTALGRAB = 2598\n    MORPHTOCOLLAPSIBLEPURIFIERTOWERDEBRIS_CANCEL = 2601\n    PORTCITY_BRIDGE_UNITNE8OUT_BRIDGEEXTEND = 2602\n    PORTCITY_BRIDGE_UNITNE8_BRIDGERETRACT = 2604\n    PORTCITY_BRIDGE_UNITSE8OUT_BRIDGEEXTEND = 2606\n    PORTCITY_BRIDGE_UNITSE8_BRIDGERETRACT = 2608\n    PORTCITY_BRIDGE_UNITNW8OUT_BRIDGEEXTEND = 2610\n    PORTCITY_BRIDGE_UNITNW8_BRIDGERETRACT = 2612\n    PORTCITY_BRIDGE_UNITSW8OUT_BRIDGEEXTEND = 2614\n    PORTCITY_BRIDGE_UNITSW8_BRIDGERETRACT = 2616\n    PORTCITY_BRIDGE_UNITNE10OUT_BRIDGEEXTEND = 2618\n    PORTCITY_BRIDGE_UNITNE10_BRIDGERETRACT = 2620\n    PORTCITY_BRIDGE_UNITSE10OUT_BRIDGEEXTEND = 2622\n    PORTCITY_BRIDGE_UNITSE10_BRIDGERETRACT = 2624\n    PORTCITY_BRIDGE_UNITNW10OUT_BRIDGEEXTEND = 2626\n    PORTCITY_BRIDGE_UNITNW10_BRIDGERETRACT = 2628\n    PORTCITY_BRIDGE_UNITSW10OUT_BRIDGEEXTEND = 2630\n    PORTCITY_BRIDGE_UNITSW10_BRIDGERETRACT = 2632\n    PORTCITY_BRIDGE_UNITNE12OUT_BRIDGEEXTEND = 2634\n    PORTCITY_BRIDGE_UNITNE12_BRIDGERETRACT = 2636\n    PORTCITY_BRIDGE_UNITSE12OUT_BRIDGEEXTEND = 2638\n    PORTCITY_BRIDGE_UNITSE12_BRIDGERETRACT = 2640\n    PORTCITY_BRIDGE_UNITNW12OUT_BRIDGEEXTEND = 2642\n    PORTCITY_BRIDGE_UNITNW12_BRIDGERETRACT = 2644\n    PORTCITY_BRIDGE_UNITSW12OUT_BRIDGEEXTEND = 2646\n    PORTCITY_BRIDGE_UNITSW12_BRIDGERETRACT = 2648\n    PORTCITY_BRIDGE_UNITN8OUT_BRIDGEEXTEND = 2650\n    PORTCITY_BRIDGE_UNITN8_BRIDGERETRACT = 2652\n    PORTCITY_BRIDGE_UNITS8OUT_BRIDGEEXTEND = 2654\n    PORTCITY_BRIDGE_UNITS8_BRIDGERETRACT = 2656\n    PORTCITY_BRIDGE_UNITE8OUT_BRIDGEEXTEND = 2658\n    PORTCITY_BRIDGE_UNITE8_BRIDGERETRACT = 2660\n    PORTCITY_BRIDGE_UNITW8OUT_BRIDGEEXTEND = 2662\n    PORTCITY_BRIDGE_UNITW8_BRIDGERETRACT = 2664\n    PORTCITY_BRIDGE_UNITN10OUT_BRIDGEEXTEND = 2666\n    PORTCITY_BRIDGE_UNITN10_BRIDGERETRACT = 2668\n    PORTCITY_BRIDGE_UNITS10OUT_BRIDGEEXTEND = 2670\n    PORTCITY_BRIDGE_UNITS10_BRIDGERETRACT = 2672\n    PORTCITY_BRIDGE_UNITE10OUT_BRIDGEEXTEND = 2674\n    PORTCITY_BRIDGE_UNITE10_BRIDGERETRACT = 2676\n    PORTCITY_BRIDGE_UNITW10OUT_BRIDGEEXTEND = 2678\n    PORTCITY_BRIDGE_UNITW10_BRIDGERETRACT = 2680\n    PORTCITY_BRIDGE_UNITN12OUT_BRIDGEEXTEND = 2682\n    PORTCITY_BRIDGE_UNITN12_BRIDGERETRACT = 2684\n    PORTCITY_BRIDGE_UNITS12OUT_BRIDGEEXTEND = 2686\n    PORTCITY_BRIDGE_UNITS12_BRIDGERETRACT = 2688\n    PORTCITY_BRIDGE_UNITE12OUT_BRIDGEEXTEND = 2690\n    PORTCITY_BRIDGE_UNITE12_BRIDGERETRACT = 2692\n    PORTCITY_BRIDGE_UNITW12OUT_BRIDGEEXTEND = 2694\n    PORTCITY_BRIDGE_UNITW12_BRIDGERETRACT = 2696\n    TEMPESTDISRUPTIONBLAST_TEMPESTDISRUPTIONBLAST = 2698\n    CANCEL_TEMPESTDISRUPTIONBLAST = 2699\n    EFFECT_SHADOWSTRIDE = 2700\n    EFFECT_SPAWNLOCUSTS = 2704\n    LOCUSTMPFLYINGSWOOPATTACK_LOCUSTMPFLYINGSWOOP = 2706\n    MORPH_OVERLORDTRANSPORT = 2708\n    CANCEL_MORPHOVERLORDTRANSPORT = 2709\n    EFFECT_GHOSTSNIPE = 2714\n    PURIFYMORPHPYLON_MOTHERSHIPCOREWEAPON = 2716\n    PURIFYMORPHPYLONBACK_MOTHERSHIPCOREWEAPON = 2718\n    RESEARCH_SHADOWSTRIKE = 2720\n    HEAL_MEDICHEAL = 2750\n    LURKERASPECT_LURKER = 2752\n    LURKERASPECT_CANCEL = 2753\n    BURROWLURKERDOWN_BURROWDOWN = 2754\n    BURROWLURKERDOWN_CANCEL = 2755\n    BURROWLURKERUP_BURROWUP = 2756\n    D8CHARGE_D8CHARGE = 2758\n    DEFENSIVEMATRIX_DEFENSIVEMATRIX = 2760\n    MISSILEPODS_MISSILEPODS = 2762\n    LOKIMISSILEPODS_MISSILEPODS = 2764\n    HUTTRANSPORT_HUTLOAD = 2766\n    HUTTRANSPORT_HUTUNLOADALL = 2767\n    LEVIATHANSPAWNBROODLORD_SPAWNBROODLORD = 2773\n    SS_CARRIERBOSSATTACKLAUNCH_SS_SHOOTING = 2775\n    SS_CARRIERSPAWNINTERCEPTOR_SS_CARRIERSPAWNINTERCEPTOR = 2777\n    SS_CARRIERBOSSATTACKTARGET_SS_SHOOTING = 2779\n    SS_FIGHTERBOMB_SS_FIGHTERBOMB = 2781\n    SS_PHOENIXSHOOTING_SS_SHOOTING = 2785\n    SS_BATTLECRUISERMISSILEATTACK_SS_SHOOTING = 2789\n    SS_LEVIATHANSPAWNBOMBS_SS_LEVIATHANSPAWNBOMBS = 2791\n    SS_BATTLECRUISERHUNTERSEEKERATTACK_SS_SHOOTING = 2793\n    SS_LEVIATHANTENTACLEATTACKL1NODELAY_SS_LEVIATHANTENTACLEATTACKL1NODELAY = 2797\n    SS_LEVIATHANTENTACLEATTACKL2NODELAY_SS_LEVIATHANTENTACLEATTACKL2NODELAY = 2799\n    SS_LEVIATHANTENTACLEATTACKR1NODELAY_SS_LEVIATHANTENTACLEATTACKR1NODELAY = 2801\n    SS_LEVIATHANTENTACLEATTACKR2NODELAY_SS_LEVIATHANTENTACLEATTACKR2NODELAY = 2803\n    SS_SCIENCEVESSELTELEPORT_ZERATULBLINK = 2805\n    SS_TERRATRONBEAMATTACK_SS_TERRATRONBEAMATTACK = 2807\n    SS_TERRATRONSAWATTACK_SS_TERRATRONSAWATTACK = 2809\n    SS_WRAITHATTACK_SS_SHOOTING = 2811\n    SS_SWARMGUARDIANATTACK_SS_SHOOTING = 2813\n    SS_SCOUTATTACK_SS_SHOOTING = 2819\n    SS_INTERCEPTORATTACK_SS_SHOOTING = 2821\n    SS_CORRUPTORATTACK_SS_SHOOTING = 2823\n    SS_LEVIATHANTENTACLEATTACKL2_SS_LEVIATHANTENTACLEATTACKL2 = 2825\n    SS_LEVIATHANTENTACLEATTACKR1_SS_LEVIATHANTENTACLEATTACKR1 = 2827\n    SS_LEVIATHANTENTACLEATTACKL1_SS_LEVIATHANTENTACLEATTACKL1 = 2829\n    SS_LEVIATHANTENTACLEATTACKR2_SS_LEVIATHANTENTACLEATTACKR2 = 2831\n    SS_SCIENCEVESSELATTACK_SS_SHOOTING = 2833\n    LURKERASPECTFROMHYDRALISKBURROWED_LURKERFROMHYDRALISKBURROWED = 2836\n    LURKERASPECTFROMHYDRALISKBURROWED_CANCEL = 2837\n    UPGRADETOLURKERDEN_LURKERDEN = 2838\n    UPGRADETOLURKERDEN_CANCEL = 2839\n    ADVANCEDCONSTRUCTION_CANCEL = 2840\n    BUILDINPROGRESSNONCANCELLABLE_CANCEL = 2842\n    INFESTEDVENTSPAWNCORRUPTOR_SPAWNCORRUPTOR = 2844\n    INFESTEDVENTSPAWNBROODLORD_SPAWNBROODLORD = 2846\n    IRRADIATE_IRRADIATE = 2848\n    IRRADIATE_CANCEL = 2849\n    INFESTEDVENTSPAWNMUTALISK_LEVIATHANSPAWNMUTALISK = 2850\n    MAKEVULTURESPIDERMINES_SPIDERMINEREPLENISH = 2852\n    MEDIVACDOUBLEBEAMHEAL_HEAL = 2872\n    MINDCONTROL_MINDCONTROL = 2874\n    OBLITERATE_OBLITERATE = 2876\n    VOODOOSHIELD_VOODOOSHIELD = 2878\n    RELEASEMINION_RELEASEMINION = 2880\n    ULTRASONICPULSE_ULTRASONICPULSE = 2882\n    ARCHIVESEAL_ARCHIVESEAL = 2884\n    ARTANISVORTEX_VORTEX = 2886\n    ARTANISWORMHOLETRANSIT_WORMHOLETRANSIT = 2888\n    BUNKERATTACK_BUNKERATTACK = 2890\n    BUNKERATTACK_ATTACKTOWARDS = 2891\n    BUNKERATTACK_ATTACKBARRAGE = 2892\n    BUNKERSTOP_STOPBUNKER = 2893\n    BUNKERSTOP_HOLDFIRESPECIAL = 2894\n    CANCELTERRAZINEHARVEST_CANCEL = 2899\n    LEVIATHANSPAWNMUTALISK_LEVIATHANSPAWNMUTALISK = 2901\n    PARKCOLONISTVEHICLE_PARKCOLONISTVEHICLE = 2903\n    STARTCOLONISTVEHICLE_STARTCOLONISTVEHICLE = 2905\n    CONSUMPTION_CONSUMPTION = 2907\n    CONSUMEDNA_CONSUMEDNA = 2909\n    EGGPOP_EGGPOP = 2911\n    EXPERIMENTALPLASMAGUN_EXPERIMENTALPLASMAGUN = 2913\n    GATHERSPECIALOBJECT_GATHERSPECIALOBJECT = 2915\n    LOKIUNDOCK_LIFT = 2919\n    MINDBLAST_MINDBLAST = 2921\n    MORPHTOINFESTEDCIVILIAN_MORPHTOINFESTEDCIVILIAN = 2923\n    QUEENSHOCKWAVE_QUEENSHOCKWAVE = 2925\n    TAURENOUTHOUSELIFTOFF_TAURENOUTHOUSEFLY = 2927\n    TAURENOUTHOUSETRANSPORT_LOADTAURENOUTHOUSE = 2929\n    TAURENOUTHOUSETRANSPORT_UNLOADTAURENOUTHOUSE = 2930\n    TYCHUS03OMEGASTORM_OMEGASTORM = 2934\n    RAYNORSNIPE_RAYNORSNIPE = 2936\n    BONESHEAL_BONESHEAL = 2938\n    BONESTOSSGRENADE_TOSSGRENADETYCHUS = 2940\n    HERCULESTRANSPORT_MEDIVACLOAD = 2942\n    HERCULESTRANSPORT_MEDIVACUNLOADALL = 2944\n    SPECOPSDROPSHIPTRANSPORT_MEDIVACLOAD = 2947\n    SPECOPSDROPSHIPTRANSPORT_MEDIVACUNLOADALL = 2949\n    DUSKWINGBANSHEECLOAKINGFIELD_CLOAKONBANSHEE = 2952\n    DUSKWINGBANSHEECLOAKINGFIELD_CLOAKOFF = 2953\n    HYPERIONYAMATOSPECIAL_HYPERIONYAMATOGUN = 2954\n    INFESTABLEHUTTRANSPORT_HUTLOAD = 2956\n    INFESTABLEHUTTRANSPORT_HUTUNLOADALL = 2957\n    DUTCHPLACETURRET_DUTCHPLACETURRET = 2961\n    BURROWINFESTEDCIVILIANDOWN_BURROWDOWN = 2963\n    BURROWINFESTEDCIVILIANUP_BURROWUP = 2965\n    SELENDISHANGAR_INTERCEPTOR = 2967\n    SIEGEBREAKERSIEGE_SIEGEMODE = 2989\n    SIEGEBREAKERUNSIEGE_UNSIEGE = 2991\n    SOULCHANNEL_CANCEL = 2994\n    SENTRYGUNBURROW_BURROWTURRET = 2999\n    SENTRYGUNUNBURROW_UNBURROWTURRET = 3001\n    GRAVITONPRISON_GRAVITONPRISON = 3005\n    IMPLOSION_IMPLOSION = 3007\n    OMEGASTORM_OMEGASTORM = 3009\n    PSIONICSHOCKWAVE_PSIONICSHOCKWAVE = 3011\n    HYBRIDFAOESTUN_HYBRIDFAOESTUN = 3013\n    SUMMONMERCENARIES_HIREKELMORIANMINERS = 3015\n    SUMMONMERCENARIES_HIREDEVILDOGS = 3016\n    SUMMONMERCENARIES_HIRESPARTANCOMPANY = 3017\n    SUMMONMERCENARIES_HIREHAMMERSECURITIES = 3018\n    SUMMONMERCENARIES_HIRESIEGEBREAKERS = 3019\n    SUMMONMERCENARIES_HIREHELSANGELS = 3020\n    SUMMONMERCENARIES_HIREDUSKWING = 3021\n    SUMMONMERCENARIES_HIREDUKESREVENGE = 3022\n    SUMMONMERCENARIESPH_HIREKELMORIANMINERSPH = 3045\n    ENERGYNOVA_ENERGYNOVA = 3075\n    THEMOROSDEVICE_THEMOROSDEVICE = 3077\n    TOSSGRENADE_TOSSGRENADE = 3079\n    VOIDSEEKERTRANSPORT_MEDIVACLOAD = 3081\n    VOIDSEEKERTRANSPORT_MEDIVACUNLOADALL = 3083\n    TERRANBUILDDROP_SUPPLYDEPOTDROP = 3086\n    TERRANBUILDDROP_CANCEL = 3116\n    ODINNUCLEARSTRIKE_ODINNUKECALLDOWN = 3117\n    ODINNUCLEARSTRIKE_CANCEL = 3118\n    ODINWRECKAGE_ODIN = 3119\n    RESEARCHLABTRANSPORT_HUTLOAD = 3121\n    RESEARCHLABTRANSPORT_HUTUNLOADALL = 3122\n    COLONYSHIPTRANSPORT_MEDIVACLOAD = 3126\n    COLONYSHIPTRANSPORT_MEDIVACUNLOADALL = 3128\n    COLONYINFESTATION_COLONYINFESTATION = 3131\n    DOMINATION_DOMINATION = 3133\n    DOMINATION_CANCEL = 3134\n    KARASSPLASMASURGE_KARASSPLASMASURGE = 3135\n    KARASSPSISTORM_PSISTORM = 3137\n    HYBRIDBLINK_ZERATULBLINK = 3139\n    HYBRIDCPLASMABLAST_HYBRIDCPLASMABLAST = 3141\n    HEROARMNUKE_NUKEARM = 3143\n    HERONUCLEARSTRIKE_NUKECALLDOWN = 3163\n    HERONUCLEARSTRIKE_CANCEL = 3164\n    ODINBARRAGE_ODINBARRAGE = 3165\n    ODINBARRAGE_CANCEL = 3166\n    PURIFIERTOGGLEPOWER_PURIFIERPOWERDOWN = 3167\n    PURIFIERTOGGLEPOWER_PURIFIERPOWERUP = 3168\n    PHASEMINEBLAST_PHASEMINEBLAST = 3169\n    VOIDSEEKERPHASEMINEBLAST_PHASEMINEBLAST = 3171\n    TRANSPORTTRUCKTRANSPORT_TRANSPORTTRUCKLOAD = 3173\n    TRANSPORTTRUCKTRANSPORT_TRANSPORTTRUCKUNLOADALL = 3174\n    VAL03QUEENOFBLADESBURROW_BURROWDOWN = 3178\n    VAL03QUEENOFBLADESDEEPTUNNEL_DEEPTUNNEL = 3180\n    VAL03QUEENOFBLADESUNBURROW_BURROWUP = 3182\n    LOKIYAMATO_LOKIYAMATOGUN = 3188\n    DUKESREVENGEYAMATO_YAMATOGUN = 3190\n    ZERATULBLINK_ZERATULBLINK = 3192\n    ROGUEGHOSTCLOAK_CLOAKONSPECTRE = 3194\n    ROGUEGHOSTCLOAK_CLOAKOFF = 3195\n    VULTURESPIDERMINES_SPIDERMINE = 3196\n    VULTUREQUEUE3_CANCEL = 3198\n    VULTUREQUEUE3_CANCELSLOT = 3199\n    SUPERWARPGATETRAIN_ZEALOT = 3200\n    SUPERWARPGATETRAIN_STALKER = 3201\n    SUPERWARPGATETRAIN_IMMORTAL = 3202\n    SUPERWARPGATETRAIN_HIGHTEMPLAR = 3203\n    SUPERWARPGATETRAIN_DARKTEMPLAR = 3204\n    SUPERWARPGATETRAIN_SENTRY = 3205\n    SUPERWARPGATETRAIN_CARRIER = 3206\n    SUPERWARPGATETRAIN_PHOENIX = 3207\n    SUPERWARPGATETRAIN_VOIDRAY = 3208\n    SUPERWARPGATETRAIN_ARCHON = 3209\n    SUPERWARPGATETRAIN_WARPINZERATUL = 3210\n    SUPERWARPGATETRAIN_WARPINURUN = 3211\n    SUPERWARPGATETRAIN_WARPINMOHANDAR = 3212\n    SUPERWARPGATETRAIN_WARPINSELENDIS = 3213\n    SUPERWARPGATETRAIN_WARPINSCOUT = 3214\n    SUPERWARPGATETRAIN_COLOSSUS = 3215\n    SUPERWARPGATETRAIN_WARPPRISM = 3216\n    BURROWOMEGALISKDOWN_BURROWDOWN = 3220\n    BURROWOMEGALISKUP_BURROWUP = 3222\n    BURROWINFESTEDABOMINATIONDOWN_BURROWDOWN = 3224\n    BURROWINFESTEDABOMINATIONUP_BURROWUP = 3226\n    BURROWHUNTERKILLERDOWN_BURROWDOWN = 3228\n    BURROWHUNTERKILLERDOWN_CANCEL = 3229\n    BURROWHUNTERKILLERUP_BURROWUP = 3230\n    NOVASNIPE_NOVASNIPE = 3232\n    VORTEXPURIFIER_VORTEX = 3234\n    TALDARIMVORTEX_VORTEX = 3236\n    PURIFIERPLANETCRACKER_PLANETCRACKER = 3238\n    BURROWINFESTEDTERRANCAMPAIGNDOWN_BURROWDOWN = 3240\n    BURROWINFESTEDTERRANCAMPAIGNUP_BURROWUP = 3242\n    INFESTEDMONSTERTRAIN_INFESTEDCIVILIAN = 3244\n    INFESTEDMONSTERTRAIN_INFESTEDTERRANCAMPAIGN = 3245\n    INFESTEDMONSTERTRAIN_INFESTEDABOMINATION = 3246\n    BIODOMETRANSPORT_BIODOMELOAD = 3274\n    BIODOMETRANSPORT_BIODOMEUNLOADALL = 3275\n    ATTACKALLOWSINVULNERABLE_ATTACKALLOWSINVULNERABLE = 3295\n    ATTACKALLOWSINVULNERABLE_ATTACKTOWARDS = 3296\n    ATTACKALLOWSINVULNERABLE_ATTACKBARRAGE = 3297\n    ZERATULSTUN_ZERATULSTUN = 3298\n    WRAITHCLOAK_CLOAKOFF = 3301\n    BARRACKSTECHREACTORMORPH_TECHLABBARRACKS = 3304\n    FACTORYTECHREACTORMORPH_TECHLABFACTORY = 3306\n    STARPORTTECHREACTORMORPH_TECHLABSTARPORT = 3308\n    SS_FIGHTERSHOOTING_SS_SHOOTING = 3310\n    RAYNORC4_PLANTC4CHARGE = 3312\n    DUKESREVENGEDEFENSIVEMATRIX_DEFENSIVEMATRIX = 3314\n    DUKESREVENGEMISSILEPODS_MISSILEPODS = 3316\n    THORWRECKAGE_THOR = 3318\n    _330MMBARRAGECANNONS_330MMBARRAGECANNONS = 3320\n    _330MMBARRAGECANNONS_CANCEL = 3321\n    THORREBORN_THOR = 3322\n    THORREBORN_CANCEL = 3323\n    SPECTRENUKE_SPECTRENUKECALLDOWN = 3324\n    SPECTRENUKE_CANCEL = 3325\n    SPECTRENUKESILOARMMAGAZINE_SPECTRENUKEARM = 3327\n    COLONISTSHIPLIFTOFF_LIFT = 3346\n    COLONISTSHIPLAND_LAND = 3348\n    BIODOMECOMMANDLIFTOFF_LIFT = 3350\n    BIODOMECOMMANDLAND_LAND = 3352\n    HERCULESLIFTOFF_LIFT = 3354\n    HERCULESLAND_HERCULESLAND = 3356\n    LIGHTBRIDGEOFF_LIGHTBRIDGEOFF = 3358\n    LIGHTBRIDGEON_LIGHTBRIDGEON = 3360\n    LIBRARYDOWN_LIBRARYDOWN = 3362\n    LIBRARYUP_LIBRARYUP = 3364\n    TEMPLEDOORDOWN_TEMPLEDOORDOWN = 3366\n    TEMPLEDOORUP_TEMPLEDOORUP = 3368\n    TEMPLEDOORDOWNURDL_TEMPLEDOORDOWNURDL = 3370\n    TEMPLEDOORUPURDL_TEMPLEDOORUPURDL = 3372\n    PSYTROUSOXIDE_PSYTROUSOXIDEON = 3374\n    PSYTROUSOXIDE_PSYTROUSOXIDEOFF = 3375\n    BIOPLASMIDDISCHARGE_BIOPLASMIDDISCHARGE = 3378\n    WRECKINGCREWASSAULTMODE_ASSAULTMODE = 3380\n    WRECKINGCREWFIGHTERMODE_FIGHTERMODE = 3382\n    BIOSTASIS_BIOSTASIS = 3384\n    COLONISTTRANSPORTTRANSPORT_COLONISTTRANSPORTLOAD = 3386\n    COLONISTTRANSPORTTRANSPORT_COLONISTTRANSPORTUNLOADALL = 3387\n    DROPTOSUPPLYDEPOT_RAISE = 3391\n    REFINERYTOAUTOMATEDREFINERY_RAISE = 3393\n    HELIOSCRASHMORPH_CRASHMORPH = 3395\n    NANOREPAIR_HEAL = 3397\n    PICKUP_PICKUP = 3399\n    PICKUPARCADE_PICKUP = 3401\n    PICKUPGAS100_PICKUPGAS100 = 3403\n    PICKUPMINERALS100_PICKUPMINERALS100 = 3405\n    TAURENSTIMPACK_STIM = 3423\n    TESTREVIVE_SCV = 3454\n    TESTINTERACT_DESIGNATE = 3514\n    CLIFFDOOROPEN0_SPACEPLATFORMDOOROPEN = 3515\n    CLIFFDOORCLOSE0_SPACEPLATFORMDOORCLOSE = 3517\n    CLIFFDOOROPEN1_SPACEPLATFORMDOOROPEN = 3519\n    CLIFFDOORCLOSE1_SPACEPLATFORMDOORCLOSE = 3521\n    DESTRUCTIBLEGATEDIAGONALBLURLOWERED_GATEOPEN = 3523\n    DESTRUCTIBLEGATEDIAGONALULBRLOWERED_GATEOPEN = 3525\n    DESTRUCTIBLEGATESTRAIGHTHORIZONTALBFLOWERED_GATEOPEN = 3527\n    DESTRUCTIBLEGATESTRAIGHTHORIZONTALLOWERED_GATEOPEN = 3529\n    DESTRUCTIBLEGATESTRAIGHTVERTICALLFLOWERED_GATEOPEN = 3531\n    DESTRUCTIBLEGATESTRAIGHTVERTICALLOWERED_GATEOPEN = 3533\n    DESTRUCTIBLEGATEDIAGONALBLUR_GATECLOSE = 3535\n    DESTRUCTIBLEGATEDIAGONALULBR_GATECLOSE = 3537\n    DESTRUCTIBLEGATESTRAIGHTHORIZONTALBF_GATECLOSE = 3539\n    DESTRUCTIBLEGATESTRAIGHTHORIZONTAL_GATECLOSE = 3541\n    DESTRUCTIBLEGATESTRAIGHTVERTICALLF_GATECLOSE = 3543\n    DESTRUCTIBLEGATESTRAIGHTVERTICAL_GATECLOSE = 3545\n    TESTLEARN_TESTLEARN = 3547\n    TESTLEVELEDSPELL_YAMATOGUN = 3567\n    METALGATEDIAGONALBLURLOWERED_GATEOPEN = 3569\n    METALGATEDIAGONALULBRLOWERED_GATEOPEN = 3571\n    METALGATESTRAIGHTHORIZONTALBFLOWERED_GATEOPEN = 3573\n    METALGATESTRAIGHTHORIZONTALLOWERED_GATEOPEN = 3575\n    METALGATESTRAIGHTVERTICALLFLOWERED_GATEOPEN = 3577\n    METALGATESTRAIGHTVERTICALLOWERED_GATEOPEN = 3579\n    METALGATEDIAGONALBLUR_GATECLOSE = 3581\n    METALGATEDIAGONALULBR_GATECLOSE = 3583\n    METALGATESTRAIGHTHORIZONTALBF_GATECLOSE = 3585\n    METALGATESTRAIGHTHORIZONTAL_GATECLOSE = 3587\n    METALGATESTRAIGHTVERTICALLF_GATECLOSE = 3589\n    METALGATESTRAIGHTVERTICAL_GATECLOSE = 3591\n    SECURITYGATEDIAGONALBLURLOWERED_GATEOPEN = 3593\n    SECURITYGATEDIAGONALULBRLOWERED_GATEOPEN = 3595\n    SECURITYGATESTRAIGHTHORIZONTALBFLOWERED_GATEOPEN = 3597\n    SECURITYGATESTRAIGHTHORIZONTALLOWERED_GATEOPEN = 3599\n    SECURITYGATESTRAIGHTVERTICALLFLOWERED_GATEOPEN = 3601\n    SECURITYGATESTRAIGHTVERTICALLOWERED_GATEOPEN = 3603\n    SECURITYGATEDIAGONALBLUR_GATECLOSE = 3605\n    SECURITYGATEDIAGONALULBR_GATECLOSE = 3607\n    SECURITYGATESTRAIGHTHORIZONTALBF_GATECLOSE = 3609\n    SECURITYGATESTRAIGHTHORIZONTAL_GATECLOSE = 3611\n    SECURITYGATESTRAIGHTVERTICALLF_GATECLOSE = 3613\n    SECURITYGATESTRAIGHTVERTICAL_GATECLOSE = 3615\n    CHANGESHRINETERRAN_CHANGESHRINETERRAN = 3617\n    CHANGESHRINEPROTOSS_CHANGESHRINEPROTOSS = 3619\n    SPECTREHOLDFIRE_SPECTREHOLDFIRE = 3621\n    SPECTREWEAPONSFREE_WEAPONSFREE = 3623\n    GWALEARN_TESTLEARN = 3625\n    LIGHTBRIDGEOFFTOPRIGHT_LIGHTBRIDGEOFF = 3647\n    LIGHTBRIDGEONTOPRIGHT_LIGHTBRIDGEON = 3649\n    TESTHEROGRAB_GRABZERGLING = 3651\n    TESTHEROTHROW_THROWZERGLING = 3653\n    TESTHERODEBUGMISSILEABILITY_TESTHERODEBUGMISSILEABILITY = 3655\n    TESTHERODEBUGTRACKINGABILITY_TESTHERODEBUGTRACKINGABILITY = 3657\n    TESTHERODEBUGTRACKINGABILITY_CANCEL = 3658\n    CANCEL = 3659\n    HALT = 3660\n    BURROWDOWN = 3661\n    BURROWUP = 3662\n    LOADALL = 3663\n    UNLOADALL = 3664\n    STOP = 3665\n    HARVEST_GATHER = 3666\n    HARVEST_RETURN = 3667\n    LOAD = 3668\n    UNLOADALLAT = 3669\n    CANCEL_LAST = 3671\n    CANCEL_SLOT = 3672\n    RALLY_UNITS = 3673\n    ATTACK = 3674\n    EFFECT_STIM = 3675\n    BEHAVIOR_CLOAKON = 3676\n    BEHAVIOR_CLOAKOFF = 3677\n    LAND = 3678\n    LIFT = 3679\n    MORPH_ROOT = 3680\n    MORPH_UPROOT = 3681\n    BUILD_TECHLAB = 3682\n    BUILD_REACTOR = 3683\n    EFFECT_SPRAY = 3684\n    EFFECT_REPAIR = 3685\n    EFFECT_MASSRECALL = 3686\n    EFFECT_BLINK = 3687\n    BEHAVIOR_HOLDFIREON = 3688\n    BEHAVIOR_HOLDFIREOFF = 3689\n    RALLY_WORKERS = 3690\n    BUILD_CREEPTUMOR = 3691\n    RESEARCH_PROTOSSAIRARMOR = 3692\n    RESEARCH_PROTOSSAIRWEAPONS = 3693\n    RESEARCH_PROTOSSGROUNDARMOR = 3694\n    RESEARCH_PROTOSSGROUNDWEAPONS = 3695\n    RESEARCH_PROTOSSSHIELDS = 3696\n    RESEARCH_TERRANINFANTRYARMOR = 3697\n    RESEARCH_TERRANINFANTRYWEAPONS = 3698\n    RESEARCH_TERRANSHIPWEAPONS = 3699\n    RESEARCH_TERRANVEHICLEANDSHIPPLATING = 3700\n    RESEARCH_TERRANVEHICLEWEAPONS = 3701\n    RESEARCH_ZERGFLYERARMOR = 3702\n    RESEARCH_ZERGFLYERATTACK = 3703\n    RESEARCH_ZERGGROUNDARMOR = 3704\n    RESEARCH_ZERGMELEEWEAPONS = 3705\n    RESEARCH_ZERGMISSILEWEAPONS = 3706\n    CANCEL_VOIDRAYPRISMATICALIGNMENT = 3707\n    RESEARCH_ADAPTIVETALONS = 3709\n    LURKERDENRESEARCH_RESEARCHLURKERRANGE = 3710\n    MORPH_OBSERVERMODE = 3739\n    MORPH_SURVEILLANCEMODE = 3741\n    MORPH_OVERSIGHTMODE = 3743\n    MORPH_OVERSEERMODE = 3745\n    EFFECT_INTERFERENCEMATRIX = 3747\n    EFFECT_REPAIRDRONE = 3749\n    EFFECT_REPAIR_REPAIRDRONE = 3751\n    EFFECT_ANTIARMORMISSILE = 3753\n    EFFECT_CHRONOBOOSTENERGYCOST = 3755\n    EFFECT_MASSRECALL_NEXUS = 3757\n    NEXUSSHIELDRECHARGE_NEXUSSHIELDRECHARGE = 3759\n    NEXUSSHIELDRECHARGEONPYLON_NEXUSSHIELDRECHARGEONPYLON = 3761\n    INFESTORENSNARE_INFESTORENSNARE = 3763\n    EFFECT_RESTORE = 3765\n    NEXUSSHIELDOVERCHARGE_NEXUSSHIELDOVERCHARGE = 3767\n    NEXUSSHIELDOVERCHARGEOFF_NEXUSSHIELDOVERCHARGEOFF = 3769\n    ATTACK_BATTLECRUISER = 3771\n    BATTLECRUISERATTACK_ATTACKTOWARDS = 3772\n    BATTLECRUISERATTACK_ATTACKBARRAGE = 3773\n    BATTLECRUISERATTACKEVALUATOR_MOTHERSHIPCOREATTACK = 3774\n    MOVE_BATTLECRUISER = 3776\n    PATROL_BATTLECRUISER = 3777\n    HOLDPOSITION_BATTLECRUISER = 3778\n    BATTLECRUISERMOVE_ACQUIREMOVE = 3779\n    BATTLECRUISERMOVE_TURN = 3780\n    BATTLECRUISERSTOPEVALUATOR_STOP = 3781\n    STOP_BATTLECRUISER = 3783\n    BATTLECRUISERSTOP_HOLDFIRE = 3784\n    BATTLECRUISERSTOP_CHEER = 3785\n    BATTLECRUISERSTOP_DANCE = 3786\n    VIPERPARASITICBOMBRELAY_PARASITICBOMB = 3789\n    PARASITICBOMBRELAYDODGE_PARASITICBOMB = 3791\n    HOLDPOSITION = 3793\n    MOVE = 3794\n    PATROL = 3795\n    UNLOADUNIT = 3796\n    LOADOUTSPRAY_LOADOUTSPRAY1 = 3797\n    LOADOUTSPRAY_LOADOUTSPRAY2 = 3798\n    LOADOUTSPRAY_LOADOUTSPRAY3 = 3799\n    LOADOUTSPRAY_LOADOUTSPRAY4 = 3800\n    LOADOUTSPRAY_LOADOUTSPRAY5 = 3801\n    LOADOUTSPRAY_LOADOUTSPRAY6 = 3802\n    LOADOUTSPRAY_LOADOUTSPRAY7 = 3803\n    LOADOUTSPRAY_LOADOUTSPRAY8 = 3804\n    LOADOUTSPRAY_LOADOUTSPRAY9 = 3805\n    LOADOUTSPRAY_LOADOUTSPRAY10 = 3806\n    LOADOUTSPRAY_LOADOUTSPRAY11 = 3807\n    LOADOUTSPRAY_LOADOUTSPRAY12 = 3808\n    LOADOUTSPRAY_LOADOUTSPRAY13 = 3809\n    LOADOUTSPRAY_LOADOUTSPRAY14 = 3810\n    MORPHTOCOLLAPSIBLEROCKTOWERDEBRISRAMPLEFTGREEN_CANCEL = 3967\n    MORPHTOCOLLAPSIBLEROCKTOWERDEBRISRAMPRIGHTGREEN_CANCEL = 3970\n    BATTERYOVERCHARGE_BATTERYOVERCHARGE = 4107\n    AMORPHOUSARMORCLOUD_AMORPHOUSARMORCLOUD = 4109\n    SHIELDBATTERYRECHARGEEX5_SHIELDBATTERYRECHARGE = 4111\n    SHIELDBATTERYRECHARGEEX5_STOP = 4112\n\n    def __repr__(self):\n        return f\"AbilityId.{self.name}\"",
  "def __repr__(self):\n        return f\"AbilityId.{self.name}\"",
  "class UpgradeId(enum.Enum):\n    NULL = 0\n    CARRIERLAUNCHSPEEDUPGRADE = 1\n    GLIALRECONSTITUTION = 2\n    TUNNELINGCLAWS = 3\n    CHITINOUSPLATING = 4\n    HISECAUTOTRACKING = 5\n    TERRANBUILDINGARMOR = 6\n    TERRANINFANTRYWEAPONSLEVEL1 = 7\n    TERRANINFANTRYWEAPONSLEVEL2 = 8\n    TERRANINFANTRYWEAPONSLEVEL3 = 9\n    NEOSTEELFRAME = 10\n    TERRANINFANTRYARMORSLEVEL1 = 11\n    TERRANINFANTRYARMORSLEVEL2 = 12\n    TERRANINFANTRYARMORSLEVEL3 = 13\n    REAPERSPEED = 14\n    STIMPACK = 15\n    SHIELDWALL = 16\n    PUNISHERGRENADES = 17\n    SIEGETECH = 18\n    HIGHCAPACITYBARRELS = 19\n    BANSHEECLOAK = 20\n    MEDIVACCADUCEUSREACTOR = 21\n    RAVENCORVIDREACTOR = 22\n    HUNTERSEEKER = 23\n    DURABLEMATERIALS = 24\n    PERSONALCLOAKING = 25\n    GHOSTMOEBIUSREACTOR = 26\n    TERRANVEHICLEARMORSLEVEL1 = 27\n    TERRANVEHICLEARMORSLEVEL2 = 28\n    TERRANVEHICLEARMORSLEVEL3 = 29\n    TERRANVEHICLEWEAPONSLEVEL1 = 30\n    TERRANVEHICLEWEAPONSLEVEL2 = 31\n    TERRANVEHICLEWEAPONSLEVEL3 = 32\n    TERRANSHIPARMORSLEVEL1 = 33\n    TERRANSHIPARMORSLEVEL2 = 34\n    TERRANSHIPARMORSLEVEL3 = 35\n    TERRANSHIPWEAPONSLEVEL1 = 36\n    TERRANSHIPWEAPONSLEVEL2 = 37\n    TERRANSHIPWEAPONSLEVEL3 = 38\n    PROTOSSGROUNDWEAPONSLEVEL1 = 39\n    PROTOSSGROUNDWEAPONSLEVEL2 = 40\n    PROTOSSGROUNDWEAPONSLEVEL3 = 41\n    PROTOSSGROUNDARMORSLEVEL1 = 42\n    PROTOSSGROUNDARMORSLEVEL2 = 43\n    PROTOSSGROUNDARMORSLEVEL3 = 44\n    PROTOSSSHIELDSLEVEL1 = 45\n    PROTOSSSHIELDSLEVEL2 = 46\n    PROTOSSSHIELDSLEVEL3 = 47\n    OBSERVERGRAVITICBOOSTER = 48\n    GRAVITICDRIVE = 49\n    EXTENDEDTHERMALLANCE = 50\n    HIGHTEMPLARKHAYDARINAMULET = 51\n    PSISTORMTECH = 52\n    ZERGMELEEWEAPONSLEVEL1 = 53\n    ZERGMELEEWEAPONSLEVEL2 = 54\n    ZERGMELEEWEAPONSLEVEL3 = 55\n    ZERGGROUNDARMORSLEVEL1 = 56\n    ZERGGROUNDARMORSLEVEL2 = 57\n    ZERGGROUNDARMORSLEVEL3 = 58\n    ZERGMISSILEWEAPONSLEVEL1 = 59\n    ZERGMISSILEWEAPONSLEVEL2 = 60\n    ZERGMISSILEWEAPONSLEVEL3 = 61\n    OVERLORDSPEED = 62\n    OVERLORDTRANSPORT = 63\n    BURROW = 64\n    ZERGLINGATTACKSPEED = 65\n    ZERGLINGMOVEMENTSPEED = 66\n    HYDRALISKSPEED = 67\n    ZERGFLYERWEAPONSLEVEL1 = 68\n    ZERGFLYERWEAPONSLEVEL2 = 69\n    ZERGFLYERWEAPONSLEVEL3 = 70\n    ZERGFLYERARMORSLEVEL1 = 71\n    ZERGFLYERARMORSLEVEL2 = 72\n    ZERGFLYERARMORSLEVEL3 = 73\n    INFESTORENERGYUPGRADE = 74\n    CENTRIFICALHOOKS = 75\n    BATTLECRUISERENABLESPECIALIZATIONS = 76\n    BATTLECRUISERBEHEMOTHREACTOR = 77\n    PROTOSSAIRWEAPONSLEVEL1 = 78\n    PROTOSSAIRWEAPONSLEVEL2 = 79\n    PROTOSSAIRWEAPONSLEVEL3 = 80\n    PROTOSSAIRARMORSLEVEL1 = 81\n    PROTOSSAIRARMORSLEVEL2 = 82\n    PROTOSSAIRARMORSLEVEL3 = 83\n    WARPGATERESEARCH = 84\n    HALTECH = 85\n    CHARGE = 86\n    BLINKTECH = 87\n    ANABOLICSYNTHESIS = 88\n    OBVERSEINCUBATION = 89\n    VIKINGJOTUNBOOSTERS = 90\n    ORGANICCARAPACE = 91\n    INFESTORPERISTALSIS = 92\n    ABDOMINALFORTITUDE = 93\n    HYDRALISKSPEEDUPGRADE = 94\n    BANELINGBURROWMOVE = 95\n    COMBATDRUGS = 96\n    STRIKECANNONS = 97\n    TRANSFORMATIONSERVOS = 98\n    PHOENIXRANGEUPGRADE = 99\n    TEMPESTRANGEUPGRADE = 100\n    NEURALPARASITE = 101\n    LOCUSTLIFETIMEINCREASE = 102\n    ULTRALISKBURROWCHARGEUPGRADE = 103\n    ORACLEENERGYUPGRADE = 104\n    RESTORESHIELDS = 105\n    PROTOSSHEROSHIPWEAPON = 106\n    PROTOSSHEROSHIPDETECTOR = 107\n    PROTOSSHEROSHIPSPELL = 108\n    REAPERJUMP = 109\n    INCREASEDRANGE = 110\n    ZERGBURROWMOVE = 111\n    ANIONPULSECRYSTALS = 112\n    TERRANVEHICLEANDSHIPWEAPONSLEVEL1 = 113\n    TERRANVEHICLEANDSHIPWEAPONSLEVEL2 = 114\n    TERRANVEHICLEANDSHIPWEAPONSLEVEL3 = 115\n    TERRANVEHICLEANDSHIPARMORSLEVEL1 = 116\n    TERRANVEHICLEANDSHIPARMORSLEVEL2 = 117\n    TERRANVEHICLEANDSHIPARMORSLEVEL3 = 118\n    FLYINGLOCUSTS = 119\n    ROACHSUPPLY = 120\n    IMMORTALREVIVE = 121\n    DRILLCLAWS = 122\n    CYCLONELOCKONRANGEUPGRADE = 123\n    CYCLONEAIRUPGRADE = 124\n    LIBERATORMORPH = 125\n    ADEPTSHIELDUPGRADE = 126\n    LURKERRANGE = 127\n    IMMORTALBARRIER = 128\n    ADEPTKILLBOUNCE = 129\n    ADEPTPIERCINGATTACK = 130\n    CINEMATICMODE = 131\n    CURSORDEBUG = 132\n    MAGFIELDLAUNCHERS = 133\n    EVOLVEGROOVEDSPINES = 134\n    EVOLVEMUSCULARAUGMENTS = 135\n    BANSHEESPEED = 136\n    MEDIVACRAPIDDEPLOYMENT = 137\n    RAVENRECALIBRATEDEXPLOSIVES = 138\n    MEDIVACINCREASESPEEDBOOST = 139\n    LIBERATORAGRANGEUPGRADE = 140\n    DARKTEMPLARBLINKUPGRADE = 141\n    RAVAGERRANGE = 142\n    RAVENDAMAGEUPGRADE = 143\n    CYCLONELOCKONDAMAGEUPGRADE = 144\n    ARESCLASSWEAPONSSYSTEMVIKING = 145\n    AUTOHARVESTER = 146\n    HYBRIDCPLASMAUPGRADEHARD = 147\n    HYBRIDCPLASMAUPGRADEINSANE = 148\n    INTERCEPTORLIMIT4 = 149\n    INTERCEPTORLIMIT6 = 150\n    _330MMBARRAGECANNONS = 151\n    NOTPOSSIBLESIEGEMODE = 152\n    NEOSTEELFRAME_2 = 153\n    NEOSTEELANDSHRIKETURRETICONUPGRADE = 154\n    OCULARIMPLANTS = 155\n    CROSSSPECTRUMDAMPENERS = 156\n    ORBITALSTRIKE = 157\n    CLUSTERBOMB = 158\n    SHAPEDHULL = 159\n    SPECTRETOOLTIPUPGRADE = 160\n    ULTRACAPACITORS = 161\n    VANADIUMPLATING = 162\n    COMMANDCENTERREACTOR = 163\n    REGENERATIVEBIOSTEEL = 164\n    CELLULARREACTORS = 165\n    BANSHEECLOAKEDDAMAGE = 166\n    DISTORTIONBLASTERS = 167\n    EMPTOWER = 168\n    SUPPLYDEPOTDROP = 169\n    HIVEMINDEMULATOR = 170\n    FORTIFIEDBUNKERCARAPACE = 171\n    PREDATOR = 172\n    SCIENCEVESSEL = 173\n    DUALFUSIONWELDERS = 174\n    ADVANCEDCONSTRUCTION = 175\n    ADVANCEDMEDICTRAINING = 176\n    PROJECTILEACCELERATORS = 177\n    REINFORCEDSUPERSTRUCTURE = 178\n    MULE = 179\n    ORBITALRELAY = 180\n    RAZORWIRE = 181\n    ADVANCEDHEALINGAI = 182\n    TWINLINKEDFLAMETHROWERS = 183\n    NANOCONSTRUCTOR = 184\n    CERBERUSMINES = 185\n    HYPERFLUXOR = 186\n    TRILITHIUMPOWERCELLS = 187\n    PERMANENTCLOAKGHOST = 188\n    PERMANENTCLOAKSPECTRE = 189\n    ULTRASONICPULSE = 190\n    SURVIVALPODS = 191\n    ENERGYSTORAGE = 192\n    FULLBORECANISTERAMMO = 193\n    CAMPAIGNJOTUNBOOSTERS = 194\n    MICROFILTERING = 195\n    PARTICLECANNONAIR = 196\n    VULTUREAUTOREPAIR = 197\n    PSIDISRUPTOR = 198\n    SCIENCEVESSELENERGYMANIPULATION = 199\n    SCIENCEVESSELPLASMAWEAPONRY = 200\n    SHOWGATLINGGUN = 201\n    TECHREACTOR = 202\n    TECHREACTORAI = 203\n    TERRANDEFENSERANGEBONUS = 204\n    X88TNAPALMUPGRADE = 205\n    HURRICANEMISSILES = 206\n    MECHANICALREBIRTH = 207\n    MARINESTIMPACK = 208\n    DARKTEMPLARTACTICS = 209\n    CLUSTERWARHEADS = 210\n    CLOAKDISTORTIONFIELD = 211\n    DEVASTATORMISSILES = 212\n    DISTORTIONTHRUSTERS = 213\n    DYNAMICPOWERROUTING = 214\n    IMPALERROUNDS = 215\n    KINETICFIELDS = 216\n    BURSTCAPACITORS = 217\n    HAILSTORMMISSILEPODS = 218\n    RAPIDDEPLOYMENT = 219\n    REAPERSTIMPACK = 220\n    REAPERD8CHARGE = 221\n    TYCHUS05BATTLECRUISERPENETRATION = 222\n    VIRALPLASMA = 223\n    FIREBATJUGGERNAUTPLATING = 224\n    MULTILOCKTARGETINGSYSTEMS = 225\n    TURBOCHARGEDENGINES = 226\n    DISTORTIONSENSORS = 227\n    INFERNALPREIGNITERS = 228\n    HELLIONCAMPAIGNINFERNALPREIGNITER = 229\n    NAPALMFUELTANKS = 230\n    AUXILIARYMEDBOTS = 231\n    JUGGERNAUTPLATING = 232\n    MARAUDERLIFEBOOST = 233\n    COMBATSHIELD = 234\n    REAPERU238ROUNDS = 235\n    MAELSTROMROUNDS = 236\n    SIEGETANKSHAPEDBLAST = 237\n    TUNGSTENSPIKES = 238\n    BEARCLAWNOZZLES = 239\n    NANOBOTINJECTORS = 240\n    STABILIZERMEDPACKS = 241\n    HALOROCKETS = 242\n    SCAVENGINGSYSTEMS = 243\n    EXTRAMINES = 244\n    ARESCLASSWEAPONSSYSTEM = 245\n    WHITENAPALM = 246\n    VIRALMUNITIONS = 247\n    JACKHAMMERCONCUSSIONGRENADES = 248\n    FIRESUPPRESSIONSYSTEMS = 249\n    FLARERESEARCH = 250\n    MODULARCONSTRUCTION = 251\n    EXPANDEDHULL = 252\n    SHRIKETURRET = 253\n    MICROFUSIONREACTORS = 254\n    WRAITHCLOAK = 255\n    SINGULARITYCHARGE = 256\n    GRAVITICTHRUSTERS = 257\n    YAMATOCANNON = 258\n    DEFENSIVEMATRIX = 259\n    DARKPROTOSS = 260\n    TERRANINFANTRYWEAPONSULTRACAPACITORSLEVEL1 = 261\n    TERRANINFANTRYWEAPONSULTRACAPACITORSLEVEL2 = 262\n    TERRANINFANTRYWEAPONSULTRACAPACITORSLEVEL3 = 263\n    TERRANINFANTRYARMORSVANADIUMPLATINGLEVEL1 = 264\n    TERRANINFANTRYARMORSVANADIUMPLATINGLEVEL2 = 265\n    TERRANINFANTRYARMORSVANADIUMPLATINGLEVEL3 = 266\n    TERRANVEHICLEWEAPONSULTRACAPACITORSLEVEL1 = 267\n    TERRANVEHICLEWEAPONSULTRACAPACITORSLEVEL2 = 268\n    TERRANVEHICLEWEAPONSULTRACAPACITORSLEVEL3 = 269\n    TERRANVEHICLEARMORSVANADIUMPLATINGLEVEL1 = 270\n    TERRANVEHICLEARMORSVANADIUMPLATINGLEVEL2 = 271\n    TERRANVEHICLEARMORSVANADIUMPLATINGLEVEL3 = 272\n    TERRANSHIPWEAPONSULTRACAPACITORSLEVEL1 = 273\n    TERRANSHIPWEAPONSULTRACAPACITORSLEVEL2 = 274\n    TERRANSHIPWEAPONSULTRACAPACITORSLEVEL3 = 275\n    TERRANSHIPARMORSVANADIUMPLATINGLEVEL1 = 276\n    TERRANSHIPARMORSVANADIUMPLATINGLEVEL2 = 277\n    TERRANSHIPARMORSVANADIUMPLATINGLEVEL3 = 278\n    HIREKELMORIANMINERSPH = 279\n    HIREDEVILDOGSPH = 280\n    HIRESPARTANCOMPANYPH = 281\n    HIREHAMMERSECURITIESPH = 282\n    HIRESIEGEBREAKERSPH = 283\n    HIREHELSANGELSPH = 284\n    HIREDUSKWINGPH = 285\n    HIREDUKESREVENGE = 286\n    TOSHEASYMODE = 287\n    VOIDRAYSPEEDUPGRADE = 288\n    SMARTSERVOS = 289\n    ARMORPIERCINGROCKETS = 290\n    CYCLONERAPIDFIRELAUNCHERS = 291\n    RAVENENHANCEDMUNITIONS = 292\n    DIGGINGCLAWS = 293\n    CARRIERCARRIERCAPACITY = 294\n    CARRIERLEASHRANGEUPGRADE = 295\n    TEMPESTGROUNDATTACKUPGRADE = 296\n    ENHANCEDSHOCKWAVES = 297\n    MICROBIALSHROUD = 298\n    SUNDERINGIMPACT = 299\n    AMPLIFIEDSHIELDING = 300\n    PSIONICAMPLIFIERS = 301\n    SECRETEDCOATING = 302\n\n    def __repr__(self):\n        return f\"UpgradeId.{self.name}\"",
  "def __repr__(self):\n        return f\"UpgradeId.{self.name}\"",
  "class EffectId(enum.Enum):\n    NULL = 0\n    PSISTORMPERSISTENT = 1\n    GUARDIANSHIELDPERSISTENT = 2\n    TEMPORALFIELDGROWINGBUBBLECREATEPERSISTENT = 3\n    TEMPORALFIELDAFTERBUBBLECREATEPERSISTENT = 4\n    THERMALLANCESFORWARD = 5\n    SCANNERSWEEP = 6\n    NUKEPERSISTENT = 7\n    LIBERATORTARGETMORPHDELAYPERSISTENT = 8\n    LIBERATORTARGETMORPHPERSISTENT = 9\n    BLINDINGCLOUDCP = 10\n    RAVAGERCORROSIVEBILECP = 11\n    LURKERMP = 12\n\n    def __repr__(self):\n        return f\"EffectId.{self.name}\"",
  "def __repr__(self):\n        return f\"EffectId.{self.name}\"",
  "class BuffId(enum.Enum):\n    NULL = 0\n    RADAR25 = 1\n    TAUNTB = 2\n    DISABLEABILS = 3\n    TRANSIENTMORPH = 4\n    GRAVITONBEAM = 5\n    GHOSTCLOAK = 6\n    BANSHEECLOAK = 7\n    POWERUSERWARPABLE = 8\n    VORTEXBEHAVIORENEMY = 9\n    CORRUPTION = 10\n    QUEENSPAWNLARVATIMER = 11\n    GHOSTHOLDFIRE = 12\n    GHOSTHOLDFIREB = 13\n    LEECH = 14\n    LEECHDISABLEABILITIES = 15\n    EMPDECLOAK = 16\n    FUNGALGROWTH = 17\n    GUARDIANSHIELD = 18\n    SEEKERMISSILETIMEOUT = 19\n    TIMEWARPPRODUCTION = 20\n    ETHEREAL = 21\n    NEURALPARASITE = 22\n    NEURALPARASITEWAIT = 23\n    STIMPACKMARAUDER = 24\n    SUPPLYDROP = 25\n    _250MMSTRIKECANNONS = 26\n    STIMPACK = 27\n    PSISTORM = 28\n    CLOAKFIELDEFFECT = 29\n    CHARGING = 30\n    AIDANGERBUFF = 31\n    VORTEXBEHAVIOR = 32\n    SLOW = 33\n    TEMPORALRIFTUNIT = 34\n    SHEEPBUSY = 35\n    CONTAMINATED = 36\n    TIMESCALECONVERSIONBEHAVIOR = 37\n    BLINDINGCLOUDSTRUCTURE = 38\n    COLLAPSIBLEROCKTOWERCONJOINEDSEARCH = 39\n    COLLAPSIBLEROCKTOWERRAMPDIAGONALCONJOINEDSEARCH = 40\n    COLLAPSIBLETERRANTOWERCONJOINEDSEARCH = 41\n    COLLAPSIBLETERRANTOWERRAMPDIAGONALCONJOINEDSEARCH = 42\n    DIGESTERCREEPSPRAYVISION = 43\n    INVULNERABILITYSHIELD = 44\n    MINEDRONECOUNTDOWN = 45\n    MOTHERSHIPSTASIS = 46\n    MOTHERSHIPSTASISCASTER = 47\n    MOTHERSHIPCOREENERGIZEVISUAL = 48\n    ORACLEREVELATION = 49\n    GHOSTSNIPEDOT = 50\n    NEXUSPHASESHIFT = 51\n    NEXUSINVULNERABILITY = 52\n    ROUGHTERRAINSEARCH = 53\n    ROUGHTERRAINSLOW = 54\n    ORACLECLOAKFIELD = 55\n    ORACLECLOAKFIELDEFFECT = 56\n    SCRYERFRIENDLY = 57\n    SPECTRESHIELD = 58\n    VIPERCONSUMESTRUCTURE = 59\n    RESTORESHIELDS = 60\n    MERCENARYCYCLONEMISSILES = 61\n    MERCENARYSENSORDISH = 62\n    MERCENARYSHIELD = 63\n    SCRYER = 64\n    STUNROUNDINITIALBEHAVIOR = 65\n    BUILDINGSHIELD = 66\n    LASERSIGHT = 67\n    PROTECTIVEBARRIER = 68\n    CORRUPTORGROUNDATTACKDEBUFF = 69\n    BATTLECRUISERANTIAIRDISABLE = 70\n    BUILDINGSTASIS = 71\n    STASIS = 72\n    RESOURCESTUN = 73\n    MAXIMUMTHRUST = 74\n    CHARGEUP = 75\n    CLOAKUNIT = 76\n    NULLFIELD = 77\n    RESCUE = 78\n    BENIGN = 79\n    LASERTARGETING = 80\n    ENGAGE = 81\n    CAPRESOURCE = 82\n    BLINDINGCLOUD = 83\n    DOOMDAMAGEDELAY = 84\n    EYESTALK = 85\n    BURROWCHARGE = 86\n    HIDDEN = 87\n    MINEDRONEDOT = 88\n    MEDIVACSPEEDBOOST = 89\n    EXTENDBRIDGEEXTENDINGBRIDGENEWIDE8OUT = 90\n    EXTENDBRIDGEEXTENDINGBRIDGENWWIDE8OUT = 91\n    EXTENDBRIDGEEXTENDINGBRIDGENEWIDE10OUT = 92\n    EXTENDBRIDGEEXTENDINGBRIDGENWWIDE10OUT = 93\n    EXTENDBRIDGEEXTENDINGBRIDGENEWIDE12OUT = 94\n    EXTENDBRIDGEEXTENDINGBRIDGENWWIDE12OUT = 95\n    PHASESHIELD = 96\n    PURIFY = 97\n    VOIDSIPHON = 98\n    ORACLEWEAPON = 99\n    ANTIAIRWEAPONSWITCHCOOLDOWN = 100\n    ARBITERMPSTASISFIELD = 101\n    IMMORTALOVERLOAD = 102\n    CLOAKINGFIELDTARGETED = 103\n    LIGHTNINGBOMB = 104\n    ORACLEPHASESHIFT = 105\n    RELEASEINTERCEPTORSCOOLDOWN = 106\n    RELEASEINTERCEPTORSTIMEDLIFEWARNING = 107\n    RELEASEINTERCEPTORSWANDERDELAY = 108\n    RELEASEINTERCEPTORSBEACON = 109\n    ARBITERMPCLOAKFIELDEFFECT = 110\n    PURIFICATIONNOVA = 111\n    CORRUPTIONBOMBDAMAGE = 112\n    CORSAIRMPDISRUPTIONWEB = 113\n    DISRUPTORPUSH = 114\n    LIGHTOFAIUR = 115\n    LOCKON = 116\n    OVERCHARGE = 117\n    OVERCHARGEDAMAGE = 118\n    OVERCHARGESPEEDBOOST = 119\n    SEEKERMISSILE = 120\n    TEMPORALFIELD = 121\n    VOIDRAYSWARMDAMAGEBOOST = 122\n    VOIDMPIMMORTALREVIVESUPRESSED = 123\n    DEVOURERMPACIDSPORES = 124\n    DEFILERMPCONSUME = 125\n    DEFILERMPDARKSWARM = 126\n    DEFILERMPPLAGUE = 127\n    QUEENMPENSNARE = 128\n    ORACLESTASISTRAPTARGET = 129\n    SELFREPAIR = 130\n    AGGRESSIVEMUTATION = 131\n    PARASITICBOMB = 132\n    PARASITICBOMBUNITKU = 133\n    PARASITICBOMBSECONDARYUNITSEARCH = 134\n    ADEPTDEATHCHECK = 135\n    LURKERHOLDFIRE = 136\n    LURKERHOLDFIREB = 137\n    TIMESTOPSTUN = 138\n    SLAYNELEMENTALGRABSTUN = 139\n    PURIFICATIONNOVAPOST = 140\n    DISABLEINTERCEPTORS = 141\n    BYPASSARMORDEBUFFONE = 142\n    BYPASSARMORDEBUFFTWO = 143\n    BYPASSARMORDEBUFFTHREE = 144\n    CHANNELSNIPECOMBAT = 145\n    TEMPESTDISRUPTIONBLASTSTUNBEHAVIOR = 146\n    GRAVITONPRISON = 147\n    INFESTORDISEASE = 148\n    SS_LIGHTNINGPROJECTOR = 149\n    PURIFIERPLANETCRACKERCHARGE = 150\n    SPECTRECLOAKING = 151\n    WRAITHCLOAK = 152\n    PSYTROUSOXIDE = 153\n    BANSHEECLOAKCROSSSPECTRUMDAMPENERS = 154\n    SS_BATTLECRUISERHUNTERSEEKERTIMEOUT = 155\n    SS_STRONGERENEMYBUFF = 156\n    SS_TERRATRONARMMISSILETARGETCHECK = 157\n    SS_MISSILETIMEOUT = 158\n    SS_LEVIATHANBOMBCOLLISIONCHECK = 159\n    SS_LEVIATHANBOMBEXPLODETIMER = 160\n    SS_LEVIATHANBOMBMISSILETARGETCHECK = 161\n    SS_TERRATRONCOLLISIONCHECK = 162\n    SS_CARRIERBOSSCOLLISIONCHECK = 163\n    SS_CORRUPTORMISSILETARGETCHECK = 164\n    SS_INVULNERABLE = 165\n    SS_LEVIATHANTENTACLEMISSILETARGETCHECK = 166\n    SS_LEVIATHANTENTACLEMISSILETARGETCHECKINVERTED = 167\n    SS_LEVIATHANTENTACLETARGETDEATHDELAY = 168\n    SS_LEVIATHANTENTACLEMISSILESCANSWAPDELAY = 169\n    SS_POWERUPDIAGONAL2 = 170\n    SS_BATTLECRUISERCOLLISIONCHECK = 171\n    SS_TERRATRONMISSILESPINNERMISSILELAUNCHER = 172\n    SS_TERRATRONMISSILESPINNERCOLLISIONCHECK = 173\n    SS_TERRATRONMISSILELAUNCHER = 174\n    SS_BATTLECRUISERMISSILELAUNCHER = 175\n    SS_TERRATRONSTUN = 176\n    SS_VIKINGRESPAWN = 177\n    SS_WRAITHCOLLISIONCHECK = 178\n    SS_SCOURGEMISSILETARGETCHECK = 179\n    SS_SCOURGEDEATH = 180\n    SS_SWARMGUARDIANCOLLISIONCHECK = 181\n    SS_FIGHTERBOMBMISSILEDEATH = 182\n    SS_FIGHTERDRONEDAMAGERESPONSE = 183\n    SS_INTERCEPTORCOLLISIONCHECK = 184\n    SS_CARRIERCOLLISIONCHECK = 185\n    SS_MISSILETARGETCHECKVIKINGDRONE = 186\n    SS_MISSILETARGETCHECKVIKINGSTRONG1 = 187\n    SS_MISSILETARGETCHECKVIKINGSTRONG2 = 188\n    SS_POWERUPHEALTH1 = 189\n    SS_POWERUPHEALTH2 = 190\n    SS_POWERUPSTRONG = 191\n    SS_POWERUPMORPHTOBOMB = 192\n    SS_POWERUPMORPHTOHEALTH = 193\n    SS_POWERUPMORPHTOSIDEMISSILES = 194\n    SS_POWERUPMORPHTOSTRONGERMISSILES = 195\n    SS_CORRUPTORCOLLISIONCHECK = 196\n    SS_SCOUTCOLLISIONCHECK = 197\n    SS_PHOENIXCOLLISIONCHECK = 198\n    SS_SCOURGECOLLISIONCHECK = 199\n    SS_LEVIATHANCOLLISIONCHECK = 200\n    SS_SCIENCEVESSELCOLLISIONCHECK = 201\n    SS_TERRATRONSAWCOLLISIONCHECK = 202\n    SS_LIGHTNINGPROJECTORCOLLISIONCHECK = 203\n    SHIFTDELAY = 204\n    BIOSTASIS = 205\n    PERSONALCLOAKINGFREE = 206\n    EMPDRAIN = 207\n    MINDBLASTSTUN = 208\n    _330MMBARRAGECANNONS = 209\n    VOODOOSHIELD = 210\n    SPECTRECLOAKINGFREE = 211\n    ULTRASONICPULSESTUN = 212\n    IRRADIATE = 213\n    NYDUSWORMLAVAINSTANTDEATH = 214\n    PREDATORCLOAKING = 215\n    PSIDISRUPTION = 216\n    MINDCONTROL = 217\n    QUEENKNOCKDOWN = 218\n    SCIENCEVESSELCLOAKFIELD = 219\n    SPORECANNONMISSILE = 220\n    ARTANISTEMPORALRIFTUNIT = 221\n    ARTANISCLOAKINGFIELDEFFECT = 222\n    ARTANISVORTEXBEHAVIOR = 223\n    INCAPACITATED = 224\n    KARASSPSISTORM = 225\n    DUTCHMARAUDERSLOW = 226\n    JUMPSTOMPSTUN = 227\n    JUMPSTOMPFSTUN = 228\n    RAYNORMISSILETIMEDLIFE = 229\n    PSIONICSHOCKWAVEHEIGHTANDSTUN = 230\n    SHADOWCLONE = 231\n    AUTOMATEDREPAIR = 232\n    SLIMED = 233\n    RAYNORTIMEBOMBMISSILE = 234\n    RAYNORTIMEBOMBUNIT = 235\n    TYCHUSCOMMANDOSTIMPACK = 236\n    VIRALPLASMA = 237\n    NAPALM = 238\n    BURSTCAPACITORSDAMAGEBUFF = 239\n    COLONYINFESTATION = 240\n    DOMINATION = 241\n    EMPBURST = 242\n    HYBRIDCZERGYROOTS = 243\n    HYBRIDFZERGYROOTS = 244\n    LOCKDOWNB = 245\n    SPECTRELOCKDOWNB = 246\n    VOODOOLOCKDOWN = 247\n    ZERATULSTUN = 248\n    BUILDINGSCARAB = 249\n    VORTEXBEHAVIORERADICATOR = 250\n    GHOSTBLAST = 251\n    HEROICBUFF03 = 252\n    CANNONRADAR = 253\n    SS_MISSILETARGETCHECKVIKING = 254\n    SS_MISSILETARGETCHECK = 255\n    SS_MAXSPEED = 256\n    SS_MAXACCELERATION = 257\n    SS_POWERUPDIAGONAL1 = 258\n    WATER = 259\n    DEFENSIVEMATRIX = 260\n    TESTATTRIBUTE = 261\n    TESTVETERANCY = 262\n    SHREDDERSWARMDAMAGEAPPLY = 263\n    CORRUPTORINFESTING = 264\n    MERCGROUNDDROPDELAY = 265\n    MERCGROUNDDROP = 266\n    MERCAIRDROPDELAY = 267\n    SPECTREHOLDFIRE = 268\n    SPECTREHOLDFIREB = 269\n    ITEMGRAVITYBOMBS = 270\n    CARRYMINERALFIELDMINERALS = 271\n    CARRYHIGHYIELDMINERALFIELDMINERALS = 272\n    CARRYHARVESTABLEVESPENEGEYSERGAS = 273\n    CARRYHARVESTABLEVESPENEGEYSERGASPROTOSS = 274\n    CARRYHARVESTABLEVESPENEGEYSERGASZERG = 275\n    PERMANENTLYCLOAKED = 276\n    RAVENSCRAMBLERMISSILE = 277\n    RAVENSHREDDERMISSILETIMEOUT = 278\n    RAVENSHREDDERMISSILETINT = 279\n    RAVENSHREDDERMISSILEARMORREDUCTION = 280\n    CHRONOBOOSTENERGYCOST = 281\n    NEXUSSHIELDRECHARGEONPYLONBEHAVIOR = 282\n    NEXUSSHIELDRECHARGEONPYLONBEHAVIORSECONDARYONTARGET = 283\n    INFESTORENSNARE = 284\n    INFESTORENSNAREMAKEPRECURSORREHEIGHTSOURCE = 285\n    NEXUSSHIELDOVERCHARGE = 286\n    PARASITICBOMBDELAYTIMEDLIFE = 287\n    TRANSFUSION = 288\n    ACCELERATIONZONETEMPORALFIELD = 289\n    ACCELERATIONZONEFLYINGTEMPORALFIELD = 290\n    INHIBITORZONEFLYINGTEMPORALFIELD = 291\n    LOADOUTSPRAYTRACKER = 292\n    INHIBITORZONETEMPORALFIELD = 293\n    RESONATINGGLAIVESPHASESHIFT = 294\n    NEURALPARASITECHILDREN = 295\n    AMORPHOUSARMORCLOUD = 296\n    RAVENSHREDDERMISSILEARMORREDUCTIONUISUBTRUCT = 297\n    BATTERYOVERCHARGE = 298\n\n    def __repr__(self):\n        return f\"BuffId.{self.name}\"",
  "def __repr__(self):\n        return f\"BuffId.{self.name}\""
]